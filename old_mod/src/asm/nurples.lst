PC     Output      Line
040000             0001   ; macro files generally want to go here, before any of the other includes
040000             0002   ; which call the macro, otherwise the assembler won't have the macro
040000             0003   ; available to run when it is called, and will fail with something
040000             0004   ; along the lines of 'invalid label' at such and such a line
040000             0005       include "macros.inc"
040000             0001*  
040000             0002*  ; https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
040000             0003*  ; Macro for loading bitmaps to VDP buffers
040000             0004*  	macro LOADBMP n,width,height,file
040000             0005*  	db 23,27,0  ; VDU 23, 27, 0 select bitmap
040000             0006*  	db n      ; specify target bitmap number (8-bits)
040000             0007*  	db 23,27,1  ; load bitmap data
040000             0008*      dw width    ; in pixels
040000             0009*      dw height   ; in pixels
040000             0010*  	incbin file ; path to file containing binary bitmap data
040000             0011*  	endmacro
040000             0012*  
040000             0013*  ; https://discord.com/channels/1158535358624039014/1158536809916149831/1208492884861653145
040000             0014*  	; load an rgba2222 bitmap to a 16-bit bufferId
040000             0015*  	macro LOADBMPBUFFER2 bufferId,width,height,file
040000             0016*  
040000             0017*      ; Clear buffer
040000             0018*      db 23,0,0xA0
040000             0019*      dw bufferId
040000             0020*      db 2
040000             0021*  
040000             0022*      db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040000             0023*      dw bufferId
040000             0024*  
040000             0025*      ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040000             0026*      db 23,0,0xA0
040000             0027*      dw bufferId
040000             0028*      db 0
040000             0029*  	dw width * height ; length of data in bytes
040000             0030*      incbin file ; bitmap data
040000             0031*  
040000             0032*      ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040000             0033*      db 23,27,0x21
040000             0034*      dw width ; in pixels
040000             0035*      dw height ; in pixels
040000             0036*      db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
040000             0037*      endmacro
040000             0038*  
040000             0039*  	; load an rgba8888 bitmap to a 16-bit bufferId
040000             0040*  	macro LOADBMPBUFFER8 bufferId,width,height,file
040000             0041*  
040000             0042*      ; Clear buffer
040000             0043*      db 23,0,0xA0
040000             0044*      dw bufferId
040000             0045*      db 2
040000             0046*  
040000             0047*      db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040000             0048*      dw bufferId
040000             0049*  
040000             0050*      ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040000             0051*      db 23,0,0xA0
040000             0052*      dw bufferId
040000             0053*      db 0
040000             0054*  	dw width * height * 4 ; length of data in bytes
040000             0055*      incbin file ; bitmap data
040000             0056*  
040000             0057*      ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040000             0058*      db 23,27,0x21
040000             0059*      dw width ; in pixels
040000             0060*      dw height ; in pixels
040000             0061*      db 0 ; bitmap format: 0 = RGBA8888 (4-bytes per pixel)
040000             0062*      endmacro
040000             0006   
040000             0007   ;MOS INITIALIATION MUST GO HERE BEFORE ANY OTHER CODE
040000             0008       .assume adl=1
040000             0009       .org 0x040000
040000             0010   
040000 C3 45 00 04 0011       jp start
040004             0012   
040004 FF FF FF FF 0013       .align 64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040040 4D 4F 53    0014       .db "MOS"
040043 00          0015       .db 00h
040044 01          0016       .db 01h
040045             0017   
040045             0018   start:
040045 F5          0019       push af
040046 C5          0020       push bc
040047 D5          0021       push de
040048 DD E5       0022       push ix
04004A FD E5       0023       push iy
04004C             0024   
04004C             0025   ; ###############################################
04004C             0026   ; ez80asmLinker.py loader code goes here if used.
04004C             0027   ; ###############################################
04004C             0028   
04004C             0029   ; ###############################################
04004C CD C0 42 04 0030   	call	init			; Initialization code
040050 CD 70 43 04 0031   	call 	main			; Call the main function
040054             0032   ; ###############################################
040054             0033   
040054             0034   exit:
040054             0035   
040054 FD E1       0036       pop iy                              ; Pop all registers back from the stack
040056 DD E1       0037       pop ix
040058 D1          0038       pop de
040059 C1          0039       pop bc
04005A F1          0040       pop af
04005B 21 00 00 00 0041       ld hl,0                             ; Load the MOS API return code (0) for no errors.
04005F             0042   
04005F C9          0043       ret                                 ; Return MOS
040060             0044   
040060             0045   ; after this we can put includes in any order we wish, even in between
040060             0046   ; code blocks if there is any program-dependent or asethetic reason to do so
040060             0047   	include "fonts.inc"
040060             0001*  font_nurples:
040060 00 00 00 00 0002*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ;   #20 32
       00 00 00 00 
040068 20 20 20 20 0003*      db 0x20,0x20,0x20,0x20,0x00,0x00,0x20,0x00 ; ! #21 33
       00 00 20 00 
040070 50 50 00 00 0004*      db 0x50,0x50,0x00,0x00,0x00,0x00,0x00,0x00 ; " #22 34
       00 00 00 00 
040078 00 50 F8 50 0005*      db 0x00,0x50,0xF8,0x50,0x50,0xF8,0x50,0x00 ; # #23 35
       50 F8 50 00 
040080 20 70 A0 70 0006*      db 0x20,0x70,0xA0,0x70,0x28,0x70,0x20,0x00 ; $ #24 36
       28 70 20 00 
040088 00 88 10 20 0007*      db 0x00,0x88,0x10,0x20,0x40,0x88,0x00,0x00 ; % #25 37
       40 88 00 00 
040090 60 90 80 40 0008*      db 0x60,0x90,0x80,0x40,0xA8,0x90,0x68,0x00 ; & #26 38
       A8 90 68 00 
040098 20 20 00 00 0009*      db 0x20,0x20,0x00,0x00,0x00,0x00,0x00,0x00 ; ' #27 39
       00 00 00 00 
0400A0 10 20 40 40 0010*      db 0x10,0x20,0x40,0x40,0x40,0x20,0x10,0x00 ; ( #28 40
       40 20 10 00 
0400A8 40 20 10 10 0011*      db 0x40,0x20,0x10,0x10,0x10,0x20,0x40,0x00 ; ) #29 41
       10 20 40 00 
0400B0 20 A8 70 20 0012*      db 0x20,0xA8,0x70,0x20,0x70,0xA8,0x20,0x00 ; * #2A 42
       70 A8 20 00 
0400B8 00 20 20 70 0013*      db 0x00,0x20,0x20,0x70,0x20,0x20,0x00,0x00 ; + #2B 43
       20 20 00 00 
0400C0 00 00 00 00 0014*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x40 ; ,0x2C 44
       00 00 20 40 
0400C8 00 00 00 70 0015*      db 0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x00 ; - #2D 45
       00 00 00 00 
0400D0 00 00 00 00 0016*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00 ; . #2E 46
       00 00 20 00 
0400D8 10 10 20 20 0017*      db 0x10,0x10,0x20,0x20,0x40,0x40,0x80,0x80 ; / #2F 47
       40 40 80 80 
0400E0 70 88 C8 A8 0018*      db 0x70,0x88,0xC8,0xA8,0x98,0x88,0x70,0x00 ; 0 #30 48
       98 88 70 00 
0400E8 20 60 20 20 0019*      db 0x20,0x60,0x20,0x20,0x20,0x20,0x70,0x00 ; 1 #31 49
       20 20 70 00 
0400F0 60 90 10 20 0020*      db 0x60,0x90,0x10,0x20,0x40,0x80,0xF0,0x00 ; 2 #32 50
       40 80 F0 00 
0400F8 60 90 10 60 0021*      db 0x60,0x90,0x10,0x60,0x10,0x90,0x60,0x00 ; 3 #33 51
       10 90 60 00 
040100 10 30 50 90 0022*      db 0x10,0x30,0x50,0x90,0xF8,0x10,0x10,0x00 ; 4 #34 52
       F8 10 10 00 
040108 F0 80 E0 10 0023*      db 0xF0,0x80,0xE0,0x10,0x10,0x90,0x60,0x00 ; 5 #35 53
       10 90 60 00 
040110 60 90 80 E0 0024*      db 0x60,0x90,0x80,0xE0,0x90,0x90,0x60,0x00 ; 6 #36 54
       90 90 60 00 
040118 F0 10 20 20 0025*      db 0xF0,0x10,0x20,0x20,0x40,0x40,0x40,0x00 ; 7 #37 55
       40 40 40 00 
040120 60 90 90 60 0026*      db 0x60,0x90,0x90,0x60,0x90,0x90,0x60,0x00 ; 8 #38 56
       90 90 60 00 
040128 60 90 90 70 0027*      db 0x60,0x90,0x90,0x70,0x10,0x10,0x60,0x00 ; 9 #39 57
       10 10 60 00 
040130 00 00 00 20 0028*      db 0x00,0x00,0x00,0x20,0x00,0x00,0x20,0x00 ; : #3A 58
       00 00 20 00 
040138 00 00 00 20 0029*      db 0x00,0x00,0x00,0x20,0x00,0x00,0x20,0x40 ; ; #3B 59
       00 00 20 40 
040140 08 10 20 40 0030*      db 0x08,0x10,0x20,0x40,0x20,0x10,0x08,0x00 ; < #3C 60
       20 10 08 00 
040148 00 00 70 00 0031*      db 0x00,0x00,0x70,0x00,0x70,0x00,0x00,0x00 ; = #3D 61
       70 00 00 00 
040150 80 40 20 10 0032*      db 0x80,0x40,0x20,0x10,0x20,0x40,0x80,0x00 ; > #3E 62
       20 40 80 00 
040158 70 88 08 10 0033*      db 0x70,0x88,0x08,0x10,0x20,0x00,0x20,0x00 ; ? #3F 63
       20 00 20 00 
040160 30 48 98 A8 0034*      db 0x30,0x48,0x98,0xA8,0xA8,0x90,0x40,0x30 ; @ #40 64
       A8 90 40 30 
040168 70 88 88 F8 0035*      db 0x70,0x88,0x88,0xF8,0x88,0x88,0x88,0x00 ; A #41 65
       88 88 88 00 
040170 F0 88 88 F0 0036*      db 0xF0,0x88,0x88,0xF0,0x88,0x88,0xF0,0x00 ; B #42 66
       88 88 F0 00 
040178 70 88 80 80 0037*      db 0x70,0x88,0x80,0x80,0x80,0x88,0x70,0x00 ; C #43 67
       80 88 70 00 
040180 E0 90 88 88 0038*      db 0xE0,0x90,0x88,0x88,0x88,0x90,0xE0,0x00 ; D #44 68
       88 90 E0 00 
040188 F8 80 80 E0 0039*      db 0xF8,0x80,0x80,0xE0,0x80,0x80,0xF8,0x00 ; E #45 69
       80 80 F8 00 
040190 F8 80 80 E0 0040*      db 0xF8,0x80,0x80,0xE0,0x80,0x80,0x80,0x00 ; F #46 70
       80 80 80 00 
040198 70 88 80 B8 0041*      db 0x70,0x88,0x80,0xB8,0x88,0x88,0x70,0x00 ; G #47 71
       88 88 70 00 
0401A0 88 88 88 F8 0042*      db 0x88,0x88,0x88,0xF8,0x88,0x88,0x88,0x00 ; H #48 72
       88 88 88 00 
0401A8 70 20 20 20 0043*      db 0x70,0x20,0x20,0x20,0x20,0x20,0x70,0x00 ; I #49 73
       20 20 70 00 
0401B0 78 10 10 10 0044*      db 0x78,0x10,0x10,0x10,0x10,0x50,0x20,0x00 ; J #4A 74
       10 50 20 00 
0401B8 88 90 A0 D0 0045*      db 0x88,0x90,0xA0,0xD0,0x88,0x88,0x88,0x00 ; K #4B 75
       88 88 88 00 
0401C0 40 40 40 40 0046*      db 0x40,0x40,0x40,0x40,0x40,0x40,0x78,0x00 ; L #4C 76
       40 40 78 00 
0401C8 88 88 D8 A8 0047*      db 0x88,0x88,0xD8,0xA8,0x88,0x88,0x88,0x00 ; M #4D 77
       88 88 88 00 
0401D0 88 88 C8 A8 0048*      db 0x88,0x88,0xC8,0xA8,0x98,0x88,0x88,0x00 ; N #4E 78
       98 88 88 00 
0401D8 70 88 88 88 0049*      db 0x70,0x88,0x88,0x88,0x88,0x88,0x70,0x00 ; O #4F 79
       88 88 70 00 
0401E0 F0 88 88 F0 0050*      db 0xF0,0x88,0x88,0xF0,0x80,0x80,0x80,0x00 ; P #50 80
       80 80 80 00 
0401E8 70 88 88 88 0051*      db 0x70,0x88,0x88,0x88,0xA8,0x90,0x68,0x00 ; Q #51 81
       A8 90 68 00 
0401F0 F0 88 88 F0 0052*      db 0xF0,0x88,0x88,0xF0,0xA0,0x90,0x88,0x00 ; R #52 82
       A0 90 88 00 
0401F8 70 88 80 70 0053*      db 0x70,0x88,0x80,0x70,0x08,0x88,0x70,0x00 ; S #53 83
       08 88 70 00 
040200 F8 20 20 20 0054*      db 0xF8,0x20,0x20,0x20,0x20,0x20,0x20,0x00 ; T #54 84
       20 20 20 00 
040208 88 88 88 88 0055*      db 0x88,0x88,0x88,0x88,0x88,0x88,0x70,0x00 ; U #55 85
       88 88 70 00 
040210 88 88 88 88 0056*      db 0x88,0x88,0x88,0x88,0x88,0x50,0x20,0x00 ; V #56 86
       88 50 20 00 
040218 88 88 88 88 0057*      db 0x88,0x88,0x88,0x88,0xA8,0xA8,0x50,0x00 ; W #57 87
       A8 A8 50 00 
040220 88 88 50 20 0058*      db 0x88,0x88,0x50,0x20,0x50,0x88,0x88,0x00 ; X #58 88
       50 88 88 00 
040228 88 88 50 20 0059*      db 0x88,0x88,0x50,0x20,0x20,0x20,0x20,0x00 ; Y #59 89
       20 20 20 00 
040230 F8 08 10 20 0060*      db 0xF8,0x08,0x10,0x20,0x40,0x80,0xF8,0x00 ; Z #5A 90
       40 80 F8 00 
040238 38 20 20 20 0061*      db 0x38,0x20,0x20,0x20,0x20,0x20,0x38,0x00 ; [ #5B 91
       20 20 38 00 
040240 80 80 40 40 0062*      db 0x80,0x80,0x40,0x40,0x20,0x20,0x10,0x10 ; \ #5C 92
       20 20 10 10 
040248 E0 20 20 20 0063*      db 0xE0,0x20,0x20,0x20,0x20,0x20,0xE0,0x00 ; ] #5D 93
       20 20 E0 00 
040250 20 50 88 00 0064*      db 0x20,0x50,0x88,0x00,0x00,0x00,0x00,0x00 ; ^ #5E 94
       00 00 00 00 
040258 00 00 00 00 0065*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF8 ; _ #5F 95
       00 00 00 F8 
040260 40 20 00 00 0066*      db 0x40,0x20,0x00,0x00,0x00,0x00,0x00,0x00 ; ` #60 96
       00 00 00 00 
040268 00 00 60 10 0067*      db 0x00,0x00,0x60,0x10,0x70,0x90,0x70,0x00 ; a #61 97
       70 90 70 00 
040270 80 80 E0 90 0068*      db 0x80,0x80,0xE0,0x90,0x90,0x90,0xE0,0x00 ; b #62 98
       90 90 E0 00 
040278 00 00 60 90 0069*      db 0x00,0x00,0x60,0x90,0x80,0x90,0x60,0x00 ; c #63 99
       80 90 60 00 
040280 10 10 70 90 0070*      db 0x10,0x10,0x70,0x90,0x90,0x90,0x70,0x00 ; d #64 100
       90 90 70 00 
040288 00 00 60 90 0071*      db 0x00,0x00,0x60,0x90,0xF0,0x80,0x70,0x00 ; e #65 101
       F0 80 70 00 
040290 60 90 80 C0 0072*      db 0x60,0x90,0x80,0xC0,0x80,0x80,0x80,0x00 ; f #66 102
       80 80 80 00 
040298 00 00 70 90 0073*      db 0x00,0x00,0x70,0x90,0x90,0x70,0x10,0x60 ; g #67 103
       90 70 10 60 
0402A0 80 80 E0 90 0074*      db 0x80,0x80,0xE0,0x90,0x90,0x90,0x90,0x00 ; h #68 104
       90 90 90 00 
0402A8 00 20 00 20 0075*      db 0x00,0x20,0x00,0x20,0x20,0x20,0x20,0x00 ; i #69 105
       20 20 20 00 
0402B0 00 10 00 10 0076*      db 0x00,0x10,0x00,0x10,0x10,0x10,0x50,0x20 ; j #6A 106
       10 10 50 20 
0402B8 80 80 90 A0 0077*      db 0x80,0x80,0x90,0xA0,0xC0,0xA0,0x90,0x00 ; k #6B 107
       C0 A0 90 00 
0402C0 20 20 20 20 0078*      db 0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x00 ; l #6C 108
       20 20 20 00 
0402C8 00 00 D0 A8 0079*      db 0x00,0x00,0xD0,0xA8,0xA8,0x88,0x88,0x00 ; m #6D 109
       A8 88 88 00 
0402D0 00 00 B0 C8 0080*      db 0x00,0x00,0xB0,0xC8,0x88,0x88,0x88,0x00 ; n #6E 110
       88 88 88 00 
0402D8 00 00 70 88 0081*      db 0x00,0x00,0x70,0x88,0x88,0x88,0x70,0x00 ; o #6F 111
       88 88 70 00 
0402E0 00 00 F0 88 0082*      db 0x00,0x00,0xF0,0x88,0x88,0xF0,0x80,0x80 ; p #70 112
       88 F0 80 80 
0402E8 00 00 78 88 0083*      db 0x00,0x00,0x78,0x88,0x88,0x78,0x08,0x08 ; q #71 113
       88 78 08 08 
0402F0 00 00 B0 C8 0084*      db 0x00,0x00,0xB0,0xC8,0x80,0x80,0x80,0x00 ; r 114 #72
       80 80 80 00 
0402F8 00 00 70 80 0085*      db 0x00,0x00,0x70,0x80,0x60,0x10,0xE0,0x00 ; s #73 115
       60 10 E0 00 
040300 40 40 F0 40 0086*      db 0x40,0x40,0xF0,0x40,0x40,0x40,0x30,0x00 ; t #74 116
       40 40 30 00 
040308 00 00 88 88 0087*      db 0x00,0x00,0x88,0x88,0x88,0x98,0x68,0x00 ; u #75 117
       88 98 68 00 
040310 00 00 88 88 0088*      db 0x00,0x00,0x88,0x88,0x88,0x50,0x20,0x00 ; v #76 118
       88 50 20 00 
040318 00 00 88 88 0089*      db 0x00,0x00,0x88,0x88,0xA8,0xA8,0x50,0x00 ; w #77 119
       A8 A8 50 00 
040320 00 00 88 50 0090*      db 0x00,0x00,0x88,0x50,0x20,0x50,0x88,0x00 ; x #78 120
       20 50 88 00 
040328 00 00 88 88 0091*      db 0x00,0x00,0x88,0x88,0x50,0x50,0x20,0xC0 ; y #79 121
       50 50 20 C0 
040330 00 00 F8 10 0092*      db 0x00,0x00,0xF8,0x10,0x20,0x40,0xF8,0x00 ; z #7A 122
       20 40 F8 00 
040338 30 40 40 80 0093*      db 0x30,0x40,0x40,0x80,0x40,0x40,0x30,0x00 ; { #7B 123
       40 40 30 00 
040340 20 20 20 20 0094*      db 0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20 ; | #7C 124
       20 20 20 20 
040348 60 10 10 08 0095*      db 0x60,0x10,0x10,0x08,0x10,0x10,0x60,0x00 ; } #7D 125
       10 10 60 00 
040350 68 B0 00 00 0096*      db 0x68,0xB0,0x00,0x00,0x00,0x00,0x00,0x00 ; ~ #7E 126
       00 00 00 00 
040358 A8 50 A8 50 0097*      db 0xA8,0x50,0xA8,0x50,0xA8,0x50,0xA8,0x00 ;  #7F 127
       A8 50 A8 00 
040360 00 00 00 FC 0098*      db 0x00,0x00,0x00,0xFC,0x00,0x00,0x00,0x00 ; ─ #80 128
       00 00 00 00 
040368 20 20 20 20 0099*      db 0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20 ; │ #81 129
       20 20 20 20 
040370 00 00 00 3C 0100*      db 0x00,0x00,0x00,0x3C,0x20,0x20,0x20,0x20 ; ┌ #82 130
       20 20 20 20 
040378 00 00 00 E0 0101*      db 0x00,0x00,0x00,0xE0,0x20,0x20,0x20,0x20 ; ┐ #83 131
       20 20 20 20 
040380 20 20 20 3C 0102*      db 0x20,0x20,0x20,0x3C,0x00,0x00,0x00,0x00 ; └ #84 132
       00 00 00 00 
040388 20 20 20 E0 0103*      db 0x20,0x20,0x20,0xE0,0x00,0x00,0x00,0x00 ; ┘ #85 133
       00 00 00 00 
040390 20 20 20 3C 0104*      db 0x20,0x20,0x20,0x3C,0x20,0x20,0x20,0x20 ; ├ #86 134
       20 20 20 20 
040398 20 20 20 E0 0105*      db 0x20,0x20,0x20,0xE0,0x20,0x20,0x20,0x20 ; ┤ #87 135
       20 20 20 20 
0403A0 00 00 00 FC 0106*      db 0x00,0x00,0x00,0xFC,0x20,0x20,0x20,0x20 ; ┬ #88 136
       20 20 20 20 
0403A8 20 20 20 FC 0107*      db 0x20,0x20,0x20,0xFC,0x00,0x00,0x00,0x00 ; ┴ #89 137
       00 00 00 00 
0403B0 20 20 20 FC 0108*      db 0x20,0x20,0x20,0xFC,0x20,0x20,0x20,0x20 ; ┼ #8A 138
       20 20 20 20 
0403B8 00 00 FC 00 0109*      db 0x00,0x00,0xFC,0x00,0xFC,0x00,0x00,0x00 ; ═ #8B 139
       FC 00 00 00 
0403C0 50 50 50 50 0110*      db 0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50 ; ║ #8C 140
       50 50 50 50 
0403C8 00 00 3C 20 0111*      db 0x00,0x00,0x3C,0x20,0x3C,0x20,0x20,0x20 ; ╒ #8D 141
       3C 20 20 20 
0403D0 00 00 00 7C 0112*      db 0x00,0x00,0x00,0x7C,0x50,0x50,0x50,0x50 ; ╓ #8E 142
       50 50 50 50 
0403D8 00 00 7C 40 0113*      db 0x00,0x00,0x7C,0x40,0x5C,0x50,0x50,0x50 ; ╔ #8F 143
       5C 50 50 50 
0403E0 00 00 E0 20 0114*      db 0x00,0x00,0xE0,0x20,0xE0,0x20,0x20,0x20 ; ╕ #90 144
       E0 20 20 20 
0403E8 00 00 00 F0 0115*      db 0x00,0x00,0x00,0xF0,0x50,0x50,0x50,0x50 ; ╖ #91 145
       50 50 50 50 
0403F0 00 00 F0 10 0116*      db 0x00,0x00,0xF0,0x10,0xD0,0x50,0x50,0x50 ; ╗ #92 146
       D0 50 50 50 
0403F8 20 20 3C 20 0117*      db 0x20,0x20,0x3C,0x20,0x3C,0x00,0x00,0x00 ; ╘ #93 147
       3C 00 00 00 
040400 50 50 50 7C 0118*      db 0x50,0x50,0x50,0x7C,0x00,0x00,0x00,0x00 ; ╙ #94 148
       00 00 00 00 
040408 50 50 5C 40 0119*      db 0x50,0x50,0x5C,0x40,0x7C,0x00,0x00,0x00 ; ╚ #95 149
       7C 00 00 00 
040410 20 20 E0 20 0120*      db 0x20,0x20,0xE0,0x20,0xE0,0x00,0x00,0x00 ; ╛ #96 150
       E0 00 00 00 
040418 50 50 50 F0 0121*      db 0x50,0x50,0x50,0xF0,0x00,0x00,0x00,0x00 ; ╜ #97 151
       00 00 00 00 
040420 50 50 D0 10 0122*      db 0x50,0x50,0xD0,0x10,0xF0,0x00,0x00,0x00 ; ╝ #98 152
       F0 00 00 00 
040428 20 20 3C 20 0123*      db 0x20,0x20,0x3C,0x20,0x3C,0x20,0x20,0x20 ; ╞ #99 153
       3C 20 20 20 
040430 50 50 50 5C 0124*      db 0x50,0x50,0x50,0x5C,0x50,0x50,0x50,0x50 ; ╟ #9A 154
       50 50 50 50 
040438 50 50 5C 40 0125*      db 0x50,0x50,0x5C,0x40,0x5C,0x50,0x50,0x50 ; ╠ #9B 155
       5C 50 50 50 
040440 20 20 E0 20 0126*      db 0x20,0x20,0xE0,0x20,0xE0,0x20,0x20,0x20 ; ╡ #9C 156
       E0 20 20 20 
040448 50 50 50 D0 0127*      db 0x50,0x50,0x50,0xD0,0x50,0x50,0x50,0x50 ; ╢ #9D 157
       50 50 50 50 
040450 50 50 D0 10 0128*      db 0x50,0x50,0xD0,0x10,0xD0,0x50,0x50,0x50 ; ╣ #9E 158
       D0 50 50 50 
040458 00 00 FC 00 0129*      db 0x00,0x00,0xFC,0x00,0xFC,0x20,0x20,0x20 ; ╤ #9F 159
       FC 20 20 20 
040460 00 00 00 FC 0130*      db 0x00,0x00,0x00,0xFC,0x50,0x50,0x50,0x50 ; ╥ #A0 160
       50 50 50 50 
040468 00 00 FC 00 0131*      db 0x00,0x00,0xFC,0x00,0xDC,0x50,0x50,0x50 ; ╦ #A1 161
       DC 50 50 50 
040470 20 20 FC 00 0132*      db 0x20,0x20,0xFC,0x00,0xFC,0x00,0x00,0x00 ; ╧ #A2 162
       FC 00 00 00 
040478 50 50 50 FC 0133*      db 0x50,0x50,0x50,0xFC,0x00,0x00,0x00,0x00 ; ╨ #A3 163
       00 00 00 00 
040480 50 50 DC 00 0134*      db 0x50,0x50,0xDC,0x00,0xFC,0x00,0x00,0x00 ; ╩ #A4 164
       FC 00 00 00 
040488 20 20 FC 20 0135*      db 0x20,0x20,0xFC,0x20,0xFC,0x20,0x20,0x20 ; ╪ #A5 165
       FC 20 20 20 
040490 50 50 50 FC 0136*      db 0x50,0x50,0x50,0xFC,0x50,0x50,0x50,0x50 ; ╫ #A6 166
       50 50 50 50 
040498 50 50 DC 00 0137*      db 0x50,0x50,0xDC,0x00,0xDC,0x50,0x50,0x50 ; ╬ #A7 167
       DC 50 50 50 
0404A0 FC FC 00 00 0138*      db 0xFC,0xFC,0x00,0x00,0x00,0x00,0x00,0x00 ; ▀ #A8 168
       00 00 00 00 
0404A8 00 00 00 00 0139*      db 0x00,0x00,0x00,0x00,0x00,0x00,0xFC,0xFC ; ▄ #A9 169
       00 00 FC FC 
0404B0 FC FC FC FC 0140*      db 0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC ; █ #AA 170
       FC FC FC FC 
0404B8 C0 C0 C0 C0 0141*      db 0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0 ; ▌ #AB 171
       C0 C0 C0 C0 
0404C0 0C 0C 0C 0C 0142*      db 0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C ; ▐ #AC 172
       0C 0C 0C 0C 
0404C8 A8 00 A8 00 0143*      db 0xA8,0x00,0xA8,0x00,0xA8,0x00,0xA8,0x00 ; ░ #AD 173
       A8 00 A8 00 
0404D0 A8 54 A8 54 0144*      db 0xA8,0x54,0xA8,0x54,0xA8,0x54,0xA8,0x54 ; ▒ #AE 174
       A8 54 A8 54 
0404D8 54 FC 54 FC 0145*      db 0x54,0xFC,0x54,0xFC,0x54,0xFC,0x54,0xFC ; ▓ #AF 175
       54 FC 54 FC 
0404E0             0048   	include "levels.inc"
0404E0 00          0001*  tiles_level_00: db  0 ; number of rows, 0 is max of 256
0404E1 00 00 00 00 0002*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 0
       00 00 00 00 
       00 01 02 02 
       01 02 02 01 
0404F1 00 00 00 00 0003*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x05,0x00,0x03 ; row 1
       00 00 00 00 
       00 03 00 05 
       03 05 00 03 
040501 00 00 00 00 0004*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 2
       00 00 00 00 
       00 03 00 00 
       03 00 00 03 
040511 00 00 00 07 0005*  	db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 3
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
040521 00 00 00 03 0006*  	db 0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x05,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x03 ; row 4
       00 05 03 05 
       00 03 05 00 
       03 00 00 03 
040531 00 00 00 03 0007*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 5
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
040541 00 00 00 01 0008*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 6
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
040551 00 00 00 03 0009*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 7
       00 00 03 05 
       04 03 00 00 
       03 00 00 03 
040561 00 00 00 03 0010*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 8
       00 00 03 04 
       05 03 00 00 
       03 00 00 03 
040571 01 02 02 01 0011*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 9
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
040581 03 04 05 03 0012*  	db 0x03,0x04,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03 ; row 10
       00 00 03 00 
       00 03 00 00 
       03 05 05 03 
040591 03 05 04 03 0013*  	db 0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03 ; row 11
       00 00 03 00 
       00 03 00 00 
       03 04 04 03 
0405A1 01 02 02 01 0014*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x01 ; row 12
       02 02 01 02 
       02 06 02 02 
       01 02 02 01 
0405B1 00 00 00 00 0015*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x03 ; row 13
       00 00 03 04 
       00 03 05 00 
       03 00 00 03 
0405C1 00 00 00 00 0016*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 14
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
0405D1 00 00 00 00 0017*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 15
       00 00 01 02 
       02 07 02 02 
       01 02 02 01 
0405E1 00 00 00 00 0018*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x05,0x03,0x00,0x00,0x00 ; row 16
       00 00 03 05 
       05 03 00 05 
       03 00 00 00 
0405F1 00 00 00 00 0019*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 17
       00 00 03 05 
       04 03 00 00 
       03 00 00 00 
040601 00 00 00 00 0020*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 18
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040611 00 00 00 00 0021*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x00,0x03,0x00,0x00,0x00 ; row 19
       00 00 03 00 
       00 03 04 00 
       03 00 00 00 
040621 00 00 00 00 0022*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 20
       00 00 03 00 
       05 03 00 00 
       03 00 00 00 
040631 00 00 00 00 0023*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00 ; row 21
       00 00 03 00 
       00 03 05 00 
       03 00 00 00 
040641 00 00 00 00 0024*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 22
       00 00 03 04 
       00 03 00 00 
       03 00 00 00 
040651 00 00 00 00 0025*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 23
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040661 00 00 00 00 0026*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 24
       00 00 03 00 
       04 03 00 00 
       00 00 00 00 
040671 00 00 00 00 0027*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 25
       00 00 03 05 
       00 03 00 00 
       00 00 00 00 
040681 00 00 00 01 0028*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00 ; row 26
       02 02 01 02 
       02 07 00 00 
       00 00 00 00 
040691 00 00 00 03 0029*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 27
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0406A1 00 00 00 03 0030*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 28
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
0406B1 00 00 00 01 0031*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 29
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
0406C1 00 00 00 03 0032*  	db 0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 30
       04 05 03 00 
       00 03 00 00 
       00 00 00 00 
0406D1 00 00 00 03 0033*  	db 0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 31
       05 05 03 00 
       00 03 00 00 
       00 00 00 00 
0406E1 00 00 00 01 0034*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 32
       02 02 06 02 
       02 01 00 00 
       00 00 00 00 
0406F1 00 00 00 00 0035*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 33
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
040701 00 00 00 00 0036*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 34
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
040711 00 00 00 00 0037*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 35
       00 00 01 02 
       02 01 02 02 
       07 00 00 00 
040721 00 00 00 00 0038*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 36
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
040731 00 00 00 00 0039*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 37
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
040741 00 00 00 00 0040*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 38
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040751 00 00 00 00 0041*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 39
       00 00 03 04 
       04 03 00 00 
       00 00 00 00 
040761 00 00 00 00 0042*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 40
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
040771 00 00 00 01 0043*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 41
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
040781 00 00 00 03 0044*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 42
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
040791 00 00 00 03 0045*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 43
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0407A1 07 02 02 01 0046*  	db 0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 44
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
0407B1 03 00 00 03 0047*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 45
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0407C1 03 00 00 03 0048*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 46
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0407D1 01 02 02 01 0049*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 47
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
0407E1 00 00 00 03 0050*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 48
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0407F1 00 00 00 03 0051*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 49
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
040801 00 00 00 06 0052*  	db 0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00 ; row 50
       02 02 01 02 
       02 07 00 00 
       00 00 00 00 
040811 00 00 00 00 0053*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 51
       00 00 03 05 
       04 03 00 00 
       00 00 00 00 
040821 00 00 00 00 0054*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 52
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
040831 00 00 00 00 0055*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 53
       00 00 01 02 
       02 01 00 00 
       00 00 00 00 
040841 00 00 00 00 0056*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 54
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
040851 00 00 00 00 0057*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 55
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
040861 00 00 00 01 0058*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 56
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
040871 00 00 00 03 0059*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 57
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
040881 00 00 00 03 0060*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 58
       00 00 03 04 
       04 03 00 00 
       00 00 00 00 
040891 00 00 00 01 0061*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 59
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
0408A1 00 00 00 03 0062*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 60
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0408B1 00 00 00 03 0063*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 61
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0408C1 00 00 00 07 0064*  	db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00 ; row 62
       02 02 01 02 
       02 06 00 00 
       00 00 00 00 
0408D1 00 00 00 00 0065*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 63
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0408E1 00 00 00 00 0066*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 64
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0408F1 00 00 00 00 0067*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 65
       00 00 01 02 
       02 01 00 00 
       00 00 00 00 
040901 00 00 00 00 0068*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 66
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
040911 00 00 00 00 0069*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 67
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
040921 00 00 00 00 0070*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 68
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040931 00 00 00 00 0071*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00 ; row 69
       00 00 00 00 
       00 03 04 04 
       03 00 00 00 
040941 00 00 00 00 0072*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00 ; row 70
       00 00 00 00 
       00 03 05 04 
       03 00 00 00 
040951 00 00 00 00 0073*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 71
       00 00 00 00 
       00 01 02 02 
       01 00 00 00 
040961 00 00 00 00 0074*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 72
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
040971 00 00 00 00 0075*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 73
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
040981 00 00 00 00 0076*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 74
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040991 00 00 00 00 0077*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 75
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0409A1 00 00 00 00 0078*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 76
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0409B1 00 00 00 07 0079*  	db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 77
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
0409C1 00 00 00 03 0080*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 78
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0409D1 00 00 00 03 0081*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 79
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0409E1 00 00 00 01 0082*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00 ; row 80
       02 02 01 02 
       02 06 00 00 
       00 00 00 00 
0409F1 00 00 00 03 0083*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 81
       00 00 03 05 
       04 03 00 00 
       00 00 00 00 
040A01 00 00 00 03 0084*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 82
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
040A11 00 00 00 01 0085*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 83
       02 02 01 02 
       02 01 02 02 
       07 00 00 00 
040A21 00 00 00 00 0086*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 84
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
040A31 00 00 00 00 0087*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 85
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
040A41 00 00 00 00 0088*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 86
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040A51 00 00 00 00 0089*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 87
       00 00 03 05 
       05 03 00 00 
       03 00 00 00 
040A61 00 00 00 00 0090*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 88
       00 00 03 04 
       04 03 00 00 
       03 00 00 00 
040A71 00 00 00 00 0091*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 89
       00 00 01 02 
       02 01 02 02 
       01 02 02 01 
040A81 00 00 00 00 0092*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 90
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
040A91 00 00 00 00 0093*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 91
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
040AA1 00 00 00 00 0094*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 92
       00 00 06 02 
       02 01 02 02 
       01 02 02 01 
040AB1 00 00 00 00 0095*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x04,0x03 ; row 93
       00 00 00 00 
       00 03 00 00 
       03 05 04 03 
040AC1 00 00 00 00 0096*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x05,0x03 ; row 94
       00 00 00 00 
       00 03 00 00 
       03 04 05 03 
040AD1 00 00 00 01 0097*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 95
       02 02 02 02 
       02 07 02 02 
       01 02 02 01 
040AE1 00 00 00 03 0098*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 96
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
040AF1 00 00 00 03 0099*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 97
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
040B01 00 00 00 01 0100*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01,0x02,0x02,0x01 ; row 98
       02 02 02 02 
       02 02 02 02 
       01 02 02 01 
040B11 01 02 02 01 0101*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 99
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040B21 03 00 00 03 0102*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 100
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040B31 03 00 00 03 0103*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 101
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040B41 01 02 02 07 0104*  	db 0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 102
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040B51 03 00 00 03 0105*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 103
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040B61 03 00 00 03 0106*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 104
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040B71 01 02 02 01 0107*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 105
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
040B81 03 00 04 03 0108*  	db 0x03,0x00,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 106
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
040B91 03 04 00 03 0109*  	db 0x03,0x04,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 107
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
040BA1 01 02 02 01 0110*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 108
       02 02 06 02 
       02 01 00 00 
       00 00 00 00 
040BB1 03 00 00 03 0111*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 109
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
040BC1 03 00 04 03 0112*  	db 0x03,0x00,0x04,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 110
       00 00 03 04 
       04 03 00 00 
       00 00 00 00 
040BD1 01 02 02 01 0113*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 111
       02 02 07 02 
       02 01 00 00 
       00 00 00 00 
040BE1 00 00 00 03 0114*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 112
       00 00 03 05 
       00 03 00 00 
       00 00 00 00 
040BF1 00 00 00 03 0115*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 113
       00 00 03 05 
       00 03 00 00 
       00 00 00 00 
040C01 00 00 00 01 0116*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 114
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
040C11 00 00 00 00 0117*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00 ; row 115
       00 00 03 00 
       00 03 04 04 
       03 00 00 00 
040C21 00 00 00 00 0118*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00 ; row 116
       00 00 03 00 
       00 03 05 05 
       03 00 00 00 
040C31 00 00 00 00 0119*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 117
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040C41 00 00 00 00 0120*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 118
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
040C51 00 00 00 00 0121*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 119
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
040C61 00 00 00 00 0122*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x01 ; row 120
       00 00 00 00 
       00 06 02 02 
       01 02 02 01 
040C71 00 00 00 00 0123*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x00,0x05,0x03 ; row 121
       00 00 00 00 
       00 03 00 05 
       03 00 05 03 
040C81 00 00 00 00 0124*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x04,0x03,0x05,0x00,0x03 ; row 122
       00 00 00 00 
       00 03 00 04 
       03 05 00 03 
040C91 00 00 00 00 0125*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 123
       00 00 00 00 
       00 07 02 02 
       01 02 02 01 
040CA1 00 00 00 00 0126*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 124
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
040CB1 00 00 00 00 0127*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 125
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
040CC1 00 00 00 00 0128*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 126
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
040CD1 00 00 00 00 0129*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 127
       00 00 03 05 
       04 03 00 00 
       00 00 00 00 
040CE1 00 00 00 00 0130*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 128
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
040CF1 00 00 00 01 0131*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00 ; row 129
       02 02 01 02 
       02 06 00 00 
       00 00 00 00 
040D01 00 00 00 03 0132*  	db 0x00,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 130
       05 00 03 00 
       00 00 00 00 
       00 00 00 00 
040D11 00 00 00 03 0133*  	db 0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 131
       00 05 03 00 
       00 00 00 00 
       00 00 00 00 
040D21 01 02 02 07 0134*  	db 0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 132
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
040D31 03 04 00 03 0135*  	db 0x03,0x04,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 133
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040D41 03 05 04 03 0136*  	db 0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 134
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040D51 01 02 02 01 0137*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 135
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040D61 03 00 00 03 0138*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 136
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040D71 03 00 00 03 0139*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 137
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040D81 01 02 02 01 0140*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 138
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
040D91 03 00 00 03 0141*  	db 0x03,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 139
       04 05 03 00 
       00 00 00 00 
       00 00 00 00 
040DA1 03 00 00 03 0142*  	db 0x03,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 140
       05 04 03 00 
       00 00 00 00 
       00 00 00 00 
040DB1 01 02 02 01 0143*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 141
       02 02 01 02 
       02 01 02 02 
       07 00 00 00 
040DC1 00 00 00 03 0144*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 142
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
040DD1 00 00 00 03 0145*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 143
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
040DE1 00 00 00 06 0146*  	db 0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 144
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
040DF1 00 00 00 00 0147*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x03 ; row 145
       00 00 03 00 
       00 03 04 04 
       03 00 00 03 
040E01 00 00 00 00 0148*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03 ; row 146
       00 00 03 00 
       00 03 05 05 
       03 00 00 03 
040E11 00 00 00 00 0149*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01 ; row 147
       00 00 01 02 
       02 01 02 02 
       06 02 02 01 
040E21 00 00 00 00 0150*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 148
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
040E31 00 00 00 00 0151*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 149
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
040E41 00 00 00 00 0152*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 150
       00 00 01 02 
       02 01 02 02 
       01 02 02 01 
040E51 00 00 00 00 0153*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x03 ; row 151
       00 00 00 00 
       00 03 04 04 
       03 00 00 03 
040E61 00 00 00 00 0154*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03 ; row 152
       00 00 00 00 
       00 03 05 04 
       03 00 00 03 
040E71 00 00 00 00 0155*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 153
       00 00 00 00 
       00 01 02 02 
       01 02 02 01 
040E81 00 00 00 00 0156*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 154
       00 00 00 00 
       00 03 00 00 
       03 00 00 03 
040E91 00 00 00 00 0157*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 155
       00 00 00 00 
       00 03 00 00 
       03 00 00 03 
040EA1 00 00 00 00 0158*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 156
       00 00 00 00 
       00 07 02 02 
       01 02 02 01 
040EB1 00 00 00 00 0159*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 157
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
040EC1 00 00 00 00 0160*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 158
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
040ED1 00 00 00 00 0161*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01 ; row 159
       00 00 00 00 
       00 00 00 00 
       01 02 02 01 
040EE1 00 00 00 00 0162*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03 ; row 160
       00 00 00 00 
       00 00 00 00 
       03 05 05 03 
040EF1 00 00 00 00 0163*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03 ; row 161
       00 00 00 00 
       00 00 00 00 
       03 05 04 03 
040F01 00 00 00 00 0164*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x02,0x02,0x01 ; row 162
       00 00 00 00 
       00 00 00 00 
       06 02 02 01 
040F11 00 00 00 00 0165*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 163
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
040F21 00 00 00 00 0166*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 164
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
040F31 00 00 00 01 0167*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x07,0x02,0x02,0x01 ; row 165
       02 02 02 02 
       02 02 02 02 
       07 02 02 01 
040F41 00 00 00 03 0168*  	db 0x00,0x00,0x00,0x03,0x04,0x04,0x05,0x04,0x05,0x05,0x05,0x04,0x04,0x04,0x05,0x03 ; row 166
       04 04 05 04 
       05 05 05 04 
       04 04 05 03 
040F51 00 00 00 03 0169*  	db 0x00,0x00,0x00,0x03,0x05,0x05,0x04,0x04,0x04,0x04,0x05,0x05,0x04,0x05,0x05,0x03 ; row 167
       05 05 04 04 
       04 04 05 05 
       04 05 05 03 
040F61 00 00 00 01 0170*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01 ; row 168
       02 02 02 02 
       02 02 02 02 
       02 02 02 01 
040F71 01 02 02 07 0171*  	db 0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 169
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040F81 03 00 00 03 0172*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 170
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040F91 03 00 00 03 0173*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 171
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040FA1 01 02 02 01 0174*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 172
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040FB1 03 04 04 03 0175*  	db 0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 173
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040FC1 03 04 04 03 0176*  	db 0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 174
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040FD1 01 02 02 01 0177*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 175
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040FE1 03 00 00 03 0178*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 176
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040FF1 03 00 00 03 0179*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 177
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041001 01 02 02 01 0180*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 178
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041011 03 00 00 03 0181*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 179
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041021 03 00 00 03 0182*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 180
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041031 01 02 02 07 0183*  	db 0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 181
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
041041 03 00 00 03 0184*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 182
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
041051 03 00 00 03 0185*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 183
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
041061 01 02 02 01 0186*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 184
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
041071 00 00 00 03 0187*  	db 0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 185
       05 05 03 00 
       00 03 00 00 
       00 00 00 00 
041081 00 00 00 03 0188*  	db 0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 186
       05 05 03 00 
       00 03 00 00 
       00 00 00 00 
041091 00 00 00 01 0189*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 187
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
0410A1 00 00 00 03 0190*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 188
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0410B1 00 00 00 03 0191*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 189
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0410C1 00 00 00 01 0192*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 190
       02 02 06 02 
       02 01 00 00 
       00 00 00 00 
0410D1 00 00 00 03 0193*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 191
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0410E1 00 00 00 03 0194*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 192
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0410F1 00 00 00 01 0195*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 193
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
041101 00 00 00 03 0196*  	db 0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 194
       04 04 03 00 
       00 00 00 00 
       00 00 00 00 
041111 00 00 00 03 0197*  	db 0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 195
       04 04 03 00 
       00 00 00 00 
       00 00 00 00 
041121 00 00 00 01 0198*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 196
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
041131 00 00 00 03 0199*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 197
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
041141 00 00 00 03 0200*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 198
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
041151 00 00 00 07 0201*  	db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 199
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
041161 00 00 00 03 0202*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 200
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
041171 00 00 00 03 0203*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 201
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
041181 00 00 00 01 0204*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 202
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
041191 00 00 00 00 0205*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 203
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
0411A1 00 00 00 00 0206*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 204
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
0411B1 00 00 00 00 0207*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 205
       00 00 01 02 
       02 01 02 02 
       07 00 00 00 
0411C1 00 00 00 00 0208*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 206
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0411D1 00 00 00 00 0209*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 207
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0411E1 00 00 00 00 0210*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 208
       00 00 01 02 
       02 01 02 02 
       01 02 02 01 
0411F1 00 00 00 00 0211*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03 ; row 209
       00 00 00 00 
       00 03 00 00 
       03 04 04 03 
041201 00 00 00 00 0212*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03 ; row 210
       00 00 00 00 
       00 03 00 00 
       03 04 04 03 
041211 00 00 00 00 0213*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x06,0x02,0x02,0x01,0x02,0x02,0x01 ; row 211
       00 00 00 00 
       01 06 02 02 
       01 02 02 01 
041221 00 00 00 00 0214*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x01,0x00,0x00,0x00,0x00,0x00 ; row 212
       00 00 00 01 
       05 04 01 00 
       00 00 00 00 
041231 00 00 00 00 0215*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00 ; row 213
       00 00 01 05 
       04 05 01 00 
       00 00 00 00 
041241 00 00 00 00 0216*  	db 0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 214
       00 01 05 04 
       05 01 00 00 
       00 00 00 00 
041251 00 00 00 00 0217*  	db 0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 215
       01 05 04 05 
       01 00 00 00 
       00 00 00 00 
041261 00 00 00 01 0218*  	db 0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 216
       05 04 05 01 
       00 00 00 00 
       00 00 00 00 
041271 00 00 01 05 0219*  	db 0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 217
       04 05 01 00 
       00 00 00 00 
       00 00 00 00 
041281 01 02 02 07 0220*  	db 0x01,0x02,0x02,0x07,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 218
       05 01 00 00 
       00 00 00 00 
       00 00 00 00 
041291 03 00 00 03 0221*  	db 0x03,0x00,0x00,0x03,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 219
       01 00 00 00 
       00 00 00 00 
       00 00 00 00 
0412A1 03 00 00 03 0222*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 220
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0412B1 01 02 02 01 0223*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 221
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
0412C1 03 00 00 03 0224*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 222
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0412D1 03 00 00 03 0225*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 223
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0412E1 01 02 02 01 0226*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 224
       02 02 06 00 
       00 00 00 00 
       00 00 00 00 
0412F1 00 00 00 03 0227*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 225
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
041301 00 00 00 03 0228*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 226
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
041311 00 00 00 01 0229*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 227
       02 02 01 02 
       02 01 02 02 
       07 00 00 00 
041321 00 00 00 03 0230*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 228
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041331 00 00 00 03 0231*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 229
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041341 00 00 00 01 0232*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 230
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
041351 00 00 00 03 0233*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 231
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041361 00 00 00 03 0234*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 232
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041371 01 02 02 01 0235*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00 ; row 233
       02 02 01 02 
       02 01 02 02 
       06 00 00 00 
041381 03 00 00 03 0236*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 234
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
041391 03 00 00 03 0237*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 235
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0413A1 07 02 02 01 0238*  	db 0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 236
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
0413B1 00 00 00 03 0239*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 237
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0413C1 00 00 00 03 0240*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 238
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
0413D1 00 00 00 01 0241*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 239
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
0413E1 00 00 00 03 0242*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 240
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0413F1 00 00 00 03 0243*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 241
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041401 00 00 00 01 0244*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 242
       02 02 06 02 
       02 01 02 02 
       01 00 00 00 
041411 00 00 00 00 0245*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 243
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041421 00 00 00 00 0246*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 244
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041431 00 00 00 00 0247*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 245
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
041441 00 00 00 00 0248*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 246
       00 00 03 05 
       04 03 00 00 
       03 00 00 00 
041451 00 00 00 00 0249*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 247
       00 00 03 05 
       04 03 00 00 
       03 00 00 00 
041461 00 00 00 01 0250*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 248
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
041471 00 00 00 03 0251*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 249
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041481 00 00 00 03 0252*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 250
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
041491 01 02 02 07 0253*  	db 0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x02,0x02,0x01 ; row 251
       02 02 01 02 
       02 01 02 02 
       07 02 02 01 
0414A1 03 05 05 03 0254*  	db 0x03,0x05,0x05,0x03,0x04,0x05,0x03,0x05,0x05,0x03,0x00,0x05,0x03,0x05,0x04,0x03 ; row 252
       04 05 03 05 
       05 03 00 05 
       03 05 04 03 
0414B1 03 04 04 03 0255*  	db 0x03,0x04,0x04,0x03,0x05,0x05,0x03,0x04,0x04,0x03,0x05,0x00,0x03,0x04,0x04,0x03 ; row 253
       05 05 03 04 
       04 03 05 00 
       03 04 04 03 
0414C1 01 02 02 06 0256*  	db 0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x06 ; row 254
       02 02 01 02 
       02 06 02 02 
       01 02 02 06 
0414D1 00 00 00 00 0257*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0414E1             0258*  
0414E1             0259*  
0414E1 10          0260*  tiles_level_01: db 16  ; number of rows, 0 is max of 256
0414E2 00 00 00 00 0261*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0414F2 00 00 00 00 0262*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041502 00 00 00 00 0263*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041512 00 00 00 00 0264*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041522 00 00 00 00 0265*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041532 00 00 00 00 0266*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041542 00 00 00 00 0267*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041552 00 00 00 00 0268*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041562 00 00 00 00 0269*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041572 00 00 00 00 0270*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041582 00 00 00 00 0271*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041592 00 00 00 00 0272*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0415A2 00 00 00 00 0273*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0415B2 00 00 00 00 0274*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0415C2 00 00 00 00 0275*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0415D2 00 00 00 00 0276*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0415E2             0277*  
0415E2             0049   	include "sprites.inc"
0415E2             0001*  ; ###### SPRITE TABLE FIELD INDICES ######
0415E2             0002*  table_bytes_per_record: equ 38 ; 38 bytes per sprite record
0415E2             0003*  sprite_id:              equ 00 ; 1 bytes unique spriteId, zero-based
0415E2             0004*  sprite_type:            equ 01 ; 1 bytes type of sprite as defined in enemies.inc
0415E2             0005*  sprite_base_bufferId:   equ 02 ; 3 bytes bitmap bufferId
0415E2             0006*  sprite_move_program:    equ 05 ; 3 bytes address of sprite's behavior subroutine
0415E2             0007*  sprite_collisions:      equ 08 ; 1 bytes low/high nibble: collision details
0415E2             0008*  sprite_dim_x:           equ 09 ; 1 bytes sprite width in pixels
0415E2             0009*  sprite_dim_y:           equ 10 ; 1 bytes sprite height in pixels
0415E2             0010*  sprite_x:               equ 11 ; 3 bytes 16.8 fractional x position in pixels
0415E2             0011*  sprite_y:               equ 14 ; 3 bytes 16.8 fractional y position in pixels
0415E2             0012*  sprite_xvel:            equ 17 ; 3 bytes x-component velocity, 16.8 fixed, pixels
0415E2             0013*  sprite_yvel:            equ 20 ; 3 bytes y-component velocity, 16.8 fixed, pixels
0415E2             0014*  sprite_vel:             equ 23 ; 3 bytes velocity px/frame (16.8 fixed)
0415E2             0015*  sprite_heading:         equ 26 ; 3 bytes sprite movement direction deg256 16.8 fixed
0415E2             0016*  sprite_orientation:     equ 29 ; 3 bytes orientation bits
0415E2             0017*  sprite_animation:       equ 32 ; 1 bytes current animation index, zero-based
0415E2             0018*  sprite_animation_timer: equ 33 ; 1 bytes when hits zero, draw next animation
0415E2             0019*  sprite_move_timer:      equ 34 ; 1 bytes when zero, go to next move program, or step
0415E2             0020*  sprite_move_step:       equ 35 ; 1 bytes stage in a move program sequence, varies
0415E2             0021*  sprite_points:          equ 36 ; 1 bytes points awarded for killing this sprite type, BCD
0415E2             0022*  sprite_shield_damage:   equ 37 ; 1 bytes shield points deducted for collision, binary
0415E2             0023*  
0415E2             0024*  ; ###### SPRITE TABLE VARIABLES ######
0415E2             0025*  ; maximum number of sprites
0415E2             0026*  table_max_records: equ 1 ; it can handle more but this is pushing it
0415E2             0027*  table_total_bytes: equ table_max_records*table_bytes_per_record
0415E2             0028*  
0415E2             0029*  ; #### THIS IS THE SPACE ALLOCATED TO THE SPRITE TABLE ####
0415E2             0030*  table_base:
0415E2 00 00 00 00 0031*  sprite_start_variables:  blkb table_total_bytes, 0 ; fill with zeroes
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00       
041608             0032*  sprite_end_variables: ; in case we want to traverse the table in reverse
041608             0033*  
041608             0034*  ; pointer to top address of current record, initialized to table_base
041608 E2 15 04    0035*  table_pointer: dl table_base
04160B             0036*  ; how many active sprites
04160B 00          0037*  table_active_sprites: db 0x00
04160C             0038*  ; flag indicating collision with screen edge
04160C             0039*  ; uses orientation codes to specify which edge(s)
04160C 00          0040*  sprite_screen_edge: db #00
04160D             0041*  ; next sprite id to use
04160D 00          0042*  sprite_next_id: db 0
04160E             0043*  
04160E             0044*  ; ######### COLLISION SPRITE PARAMETERS ##########
04160E             0045*  ; integer coordinates are all that are needed for collision calculations
04160E 00          0046*  collision_x: db 0x00
04160F 00          0047*  collision_y: db 0x00
041610 00          0048*  collision_dim_x: db 0x00
041611 00          0049*  collision_dim_y: db 0x00
041612             0050*  
041612             0051*  ; scratch variables
041612 00          0052*  x: db 0x00 ; 8-bit signed integer
041613 00          0053*  y: db 0x00 ; 8-bit signed integer
041614 00 00 00    0054*  x0: dl 0x000000 ; 16.8 signed fixed place
041617 00 00 00    0055*  y0: dl 0x000000 ; 16.8 signed fixed place
04161A 00 00 00    0056*  incx1: dl 0x000000 ; 16.8 signed fixed place
04161D 00 00 00    0057*  incy1: dl 0x000000 ; 16.8 signed fixed place
041620 00 00 00    0058*  incx2: dl 0x000000 ; 16.8 signed fixed place
041623 00 00 00    0059*  incy2: dl 0x000000 ; 16.8 signed fixed place
041626             0060*  
041626             0061*  ; sprite_heading: dl 0x000000 ; signed fixed 16.8
041626 00 00 00    0062*  radius: dl 0x000000 ; signed fixed 16.8 (but should always be positive)
041629 00 00 00    0063*  sin_sprite_heading: dl 0x000000 ; signed fixed 16.8
04162C 00 00 00    0064*  cos_sprite_heading: dl 0x000000 ; signed fixed 16.8
04162F             0065*  
04162F             0066*  ; gets the next available sprite id
04162F             0067*  ; inputs; none
04162F             0068*  ; returns: if new sprite available, a = sprite id,
04162F             0069*  ;           ix pointing to new sprite vars, carry set
04162F             0070*  ;      otherwise, a = 0, carry flag reset, ix pointing to highest sprite vars
04162F             0071*  ; destroys: a,b,hl,ix
04162F             0072*  ; affects: bumps table_active_sprites by one
04162F             0073*  table_get_next_id:
04162F DD 21 E2 15 0074*      ld ix,table_base
       04          
041634 11 26 00 00 0075*      ld de,table_bytes_per_record
041638 06 01       0076*      ld b,table_max_records
04163A             0077*  @loop:
04163A DD 7E 01    0078*      ld a,(ix+sprite_type)
04163D A7          0079*      and a
04163E 28 06       0080*      jr z,@found
041640 DD 19       0081*      add ix,de
041642 10 F6       0082*      djnz @loop
041644             0083*  @notfound:
041644 AF          0084*      xor a ; a = 0 and reset carry flag indicating that we didn't find a free sprite
041645 C9          0085*      ret
041646             0086*  @found:
041646             0087*  ; bump number of active sprites
041646 21 0B 16 04 0088*      ld hl,table_active_sprites
04164A 34          0089*      inc (hl)
04164B             0090*  ; return sprite id
04164B 3E 01       0091*      ld a,table_max_records
04164D 90          0092*      sub b
04164E 32 0D 16 04 0093*      ld (sprite_next_id),a
041652 37          0094*      scf ; sets carry flag indicating we found a free sprite
041653 C9          0095*      ret ; done
041654             0096*  
041654             0097*  ; deactivate the sprite with the given id
041654             0098*  ; inputs: a = sprite id
041654             0099*  ; outputs: nothing
041654             0100*  ; destroys: a,ix,de
041654             0101*  ; affects: decrements table_active_sprites by one
041654             0102*  table_deactivate_sprite:
041654 F5          0103*      push af ; save sprite id bc we need it later
041655 CD 57 1F 04 0104*      call vdu_sprite_select
041659 CD DB 1F 04 0105*      call vdu_sprite_hide
04165D F1          0106*      pop af ; restore sprite id
04165E 11 00 00 00 0107*      ld de,0 ; clear deu
041662 57          0108*      ld d,a
041663 1E 26       0109*      ld e,table_bytes_per_record
041665 ED 5C       0110*      mlt de
041667 DD 21 E2 15 0111*      ld ix,table_base
       04          
04166C DD 19       0112*      add ix,de
04166E AF          0113*      xor a
04166F DD 77 01    0114*      ld (ix+sprite_type),a
041672 DD 21 0B 16 0115*      ld ix,table_active_sprites
       04          
041677 DD 35 00    0116*      dec (ix)
04167A C9          0117*      ret
04167B             0118*  
04167B             0119*  sprites_init:
04167B             0120*  ; initialize sprites
04167B CD 83 20 04 0121*  	call vdu_sprite_reset ; out of an abundance of caution (copilot: and paranoia)
04167F AF          0122*  	xor a
041680             0123*  @sprite_loop:
041680 F5          0124*  	push af
041681 CD 57 1F 04 0125*  	call vdu_sprite_select
041685 21 00 01 00 0126*  	ld hl,BUF_0TILE_EMPTY ; can be anything, but why not blank?
041689 CD A4 20 04 0127*  	call vdu_sprite_add_buff
04168D F1          0128*  	pop af
04168E 3C          0129*  	inc a
04168F FE 02       0130*  	cp table_max_records+1 ; tack on sprites for player and laser
041691 20 ED       0131*  	jr nz,@sprite_loop
041693 3C          0132*  	inc a
041694 CD 8B 1F 04 0133*  	call vdu_sprite_activate
041698             0134*  
041698             0135*  ; define player sprite
041698 3A 7E 2C 04 0136*  	ld a,(player_id)
04169C CD 57 1F 04 0137*  	call vdu_sprite_select
0416A0 CD 6A 1F 04 0138*  	call vdu_sprite_clear_frames
0416A4 21 34 01 00 0139*  	ld hl,BUF_SHIP_0L
0416A8 01 03 00 00 0140*  	ld bc,3 ; three bitmaps for player ship
0416AC             0141*  @sprite_player_loop:
0416AC C5          0142*  	push bc
0416AD E5          0143*  	push hl
0416AE CD A4 20 04 0144*  	call vdu_sprite_add_buff
0416B2 E1          0145*  	pop hl
0416B3 23          0146*  	inc hl
0416B4 C1          0147*  	pop bc
0416B5 10 F5       0148*  	djnz @sprite_player_loop
0416B7 CD CD 1F 04 0149*  	call vdu_sprite_show
0416BB             0150*  
0416BB             0151*  ; all done
0416BB C9          0152*      ret
0416BC             0050   ; API includes
0416BC             0051       include "mos_api.inc"
0416BC             0001*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/mos_api.inc
0416BC             0002*  ; Title:	AGON MOS - API for user projects
0416BC             0003*  ; Author:	Dean Belfield
0416BC             0004*  ;			Adapted for agon-ez80asm by Jeroen Venema
0416BC             0005*  ;			Added MOS error codes for return in HL
0416BC             0006*  ; Created:	03/08/2022
0416BC             0007*  ; Last Updated:	10/08/2023
0416BC             0008*  ;
0416BC             0009*  ; Modinfo:
0416BC             0010*  ; 05/08/2022:	Added mos_feof
0416BC             0011*  ; 09/08/2022:	Added system variables: cursorX, cursorY
0416BC             0012*  ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
0416BC             0013*  ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
0416BC             0014*  ; 24/09/2022:	Added mos_getError, mos_mkdir
0416BC             0015*  ; 13/10/2022:	Added mos_oscli
0416BC             0016*  ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
0416BC             0017*  ; 04/03/2023:	Added sysvar_scrpixelIndex
0416BC             0018*  ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
0416BC             0019*  ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
0416BC             0020*  ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
0416BC             0021*  ; 22/03/2023:	The VDP commands are now indexed from 0x80
0416BC             0022*  ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
0416BC             0023*  ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
0416BC             0024*  ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
0416BC             0025*  ; 19/05/2023:	Added sysvar_scrMode
0416BC             0026*  ; 05/06/2023:	Added sysvar_rtcEnable
0416BC             0027*  ; 03/08/2023:	Added mos_setkbvector
0416BC             0028*  ; 10/08/2023:	Added mos_getkbmap
0416BC             0029*  
0416BC             0030*  ; VDP control (VDU 23, 0, n)
0416BC             0031*  ;
0416BC             0032*  vdp_gp:				EQU 80h
0416BC             0033*  vdp_keycode:		EQU 81h
0416BC             0034*  vdp_cursor:			EQU	82h
0416BC             0035*  vdp_scrchar:		EQU	83h
0416BC             0036*  vdp_scrpixel:		EQU	84h
0416BC             0037*  vdp_audio:			EQU	85h
0416BC             0038*  vdp_mode:			EQU	86h
0416BC             0039*  vdp_rtc:			EQU	87h
0416BC             0040*  vdp_keystate:		EQU	88h
0416BC             0041*  vdp_logicalcoords:	EQU	C0h
0416BC             0042*  vdp_terminalmode:	EQU	FFh
0416BC             0043*  
0416BC             0044*  ; MOS high level functions
0416BC             0045*  ;
0416BC             0046*  mos_getkey:			EQU	00h
0416BC             0047*  mos_load:			EQU	01h
0416BC             0048*  mos_save:			EQU	02h
0416BC             0049*  mos_cd:				EQU	03h
0416BC             0050*  mos_dir:			EQU	04h
0416BC             0051*  mos_del:			EQU	05h
0416BC             0052*  mos_ren:			EQU	06h
0416BC             0053*  mos_mkdir:			EQU	07h
0416BC             0054*  mos_sysvars:		EQU	08h
0416BC             0055*  mos_editline:		EQU	09h
0416BC             0056*  mos_fopen:			EQU	0Ah
0416BC             0057*  mos_fclose:			EQU	0Bh
0416BC             0058*  mos_fgetc:			EQU	0Ch
0416BC             0059*  mos_fputc:			EQU	0Dh
0416BC             0060*  mos_feof:			EQU	0Eh
0416BC             0061*  mos_getError:		EQU	0Fh
0416BC             0062*  mos_oscli:			EQU	10h
0416BC             0063*  mos_copy:			EQU	11h
0416BC             0064*  mos_getrtc:			EQU	12h
0416BC             0065*  mos_setrtc:			EQU	13h
0416BC             0066*  mos_setintvector:	EQU	14h
0416BC             0067*  mos_uopen:			EQU	15h
0416BC             0068*  mos_uclose:			EQU	16h
0416BC             0069*  mos_ugetc:			EQU	17h
0416BC             0070*  mos_uputc:			EQU	18h
0416BC             0071*  mos_getfil:			EQU	19h
0416BC             0072*  mos_fread:			EQU	1Ah
0416BC             0073*  mos_fwrite:			EQU	1Bh
0416BC             0074*  mos_flseek:			EQU	1Ch
0416BC             0075*  mos_setkbvector:	EQU	1Dh
0416BC             0076*  mos_getkbmap:		EQU	1Eh
0416BC             0077*  
0416BC             0078*  ; MOS program exit codes
0416BC             0079*  ;
0416BC             0080*  EXIT_OK:				EQU  0;	"OK",
0416BC             0081*  EXIT_ERROR_SD_ACCESS:	EQU	 1;	"Error accessing SD card",
0416BC             0082*  EXIT_ERROR_ASSERTION:	EQU  2;	"Assertion failed",
0416BC             0083*  EXIT_SD_CARDFAILURE:	EQU  3;	"SD card failure",
0416BC             0084*  EXIT_FILENOTFOUND:		EQU  4;	"Could not find file",
0416BC             0085*  EXIT_PATHNOTFOUND:		EQU  5;	"Could not find path",
0416BC             0086*  EXIT_INVALIDPATHNAME:	EQU  6;	"Invalid path name",
0416BC             0087*  EXIT_ACCESSDENIED_FULL:	EQU  7;	"Access denied or directory full",
0416BC             0088*  EXIT_ACCESSDENIED:		EQU  8;	"Access denied",
0416BC             0089*  EXIT_INVALIDOBJECT:		EQU  9;	"Invalid file/directory object",
0416BC             0090*  EXIT_SD_WRITEPROTECTED:	EQU 10;	"SD card is write protected",
0416BC             0091*  EXIT_INVALIDDRIVENUMBER:EQU 11;	"Logical drive number is invalid",
0416BC             0092*  EXIT_NOVOLUMEWORKAREA:	EQU 12;	"Volume has no work area",
0416BC             0093*  EXIT_NOVALIDFATVOLUME:	EQU 13;	"No valid FAT volume",
0416BC             0094*  EXIT_ERRORMKFS:			EQU 14;	"Error occurred during mkfs",
0416BC             0095*  EXIT_VOLUMETIMEOUT:		EQU 15;	"Volume timeout",
0416BC             0096*  EXIT_VOLUMELOCKED:		EQU 16;	"Volume locked",
0416BC             0097*  EXIT_LFNALLOCATION:		EQU 17;	"LFN working buffer could not be allocated",
0416BC             0098*  EXIT_MAXOPENFILES:		EQU 18;	"Too many open files",
0416BC             0099*  EXIT_INVALIDPARAMETER:	EQU 19;	"Invalid parameter",
0416BC             0100*  EXIT_INVALIDCOMMAND:	EQU 20;	"Invalid command",
0416BC             0101*  EXIT_INVALIDEXECUTABLE:	EQU 21;	"Invalid executable",
0416BC             0102*  ; FatFS file access functions
0416BC             0103*  ;
0416BC             0104*  ffs_fopen:			EQU	80h
0416BC             0105*  ffs_fclose:			EQU	81h
0416BC             0106*  ffs_fread:			EQU	82h
0416BC             0107*  ffs_fwrite:			EQU	83h
0416BC             0108*  ffs_flseek:			EQU	84h
0416BC             0109*  ffs_ftruncate:		EQU	85h
0416BC             0110*  ffs_fsync:			EQU	86h
0416BC             0111*  ffs_fforward:		EQU	87h
0416BC             0112*  ffs_fexpand:		EQU	88h
0416BC             0113*  ffs_fgets:			EQU	89h
0416BC             0114*  ffs_fputc:			EQU	8Ah
0416BC             0115*  ffs_fputs:			EQU	8Bh
0416BC             0116*  ffs_fprintf:		EQU	8Ch
0416BC             0117*  ffs_ftell:			EQU	8Dh
0416BC             0118*  ffs_feof:			EQU	8Eh
0416BC             0119*  ffs_fsize:			EQU	8Fh
0416BC             0120*  ffs_ferror:			EQU	90h
0416BC             0121*  
0416BC             0122*  ; FatFS directory access functions
0416BC             0123*  ;
0416BC             0124*  ffs_dopen:			EQU	91h
0416BC             0125*  ffs_dclose:			EQU	92h
0416BC             0126*  ffs_dread:			EQU	93h
0416BC             0127*  ffs_dfindfirst:		EQU	94h
0416BC             0128*  ffs_dfindnext:		EQU	95h
0416BC             0129*  
0416BC             0130*  ; FatFS file and directory management functions
0416BC             0131*  ;
0416BC             0132*  ffs_stat:			EQU	96h
0416BC             0133*  ffs_unlink:			EQU	97h
0416BC             0134*  ffs_rename:			EQU	98h
0416BC             0135*  ffs_chmod:			EQU	99h
0416BC             0136*  ffs_utime:			EQU	9Ah
0416BC             0137*  ffs_mkdir:			EQU	9Bh
0416BC             0138*  ffs_chdir:			EQU	9Ch
0416BC             0139*  ffs_chdrive:		EQU	9Dh
0416BC             0140*  ffs_getcwd:			EQU	9Eh
0416BC             0141*  
0416BC             0142*  ; FatFS volume management and system configuration functions
0416BC             0143*  ;
0416BC             0144*  ffs_mount:			EQU	9Fh
0416BC             0145*  ffs_mkfs:			EQU	A0h
0416BC             0146*  ffs_fdisk:			EQU	A1h
0416BC             0147*  ffs_getfree:		EQU	A2h
0416BC             0148*  ffs_getlabel:		EQU	A3h
0416BC             0149*  ffs_setlabel:		EQU	A4h
0416BC             0150*  ffs_setcp:			EQU	A5h
0416BC             0151*  
0416BC             0152*  ; File access modes
0416BC             0153*  ;
0416BC             0154*  fa_read:			EQU	01h
0416BC             0155*  fa_write:			EQU	02h
0416BC             0156*  fa_open_existing:	EQU	00h
0416BC             0157*  fa_create_new:		EQU	04h
0416BC             0158*  fa_create_always:	EQU	08h
0416BC             0159*  fa_open_always:		EQU	10h
0416BC             0160*  fa_open_append:		EQU	30h
0416BC             0161*  
0416BC             0162*  ; System variable indexes for api_sysvars
0416BC             0163*  ; Index into _sysvars in globals.inc
0416BC             0164*  ;
0416BC             0165*  sysvar_time:			EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
0416BC             0166*  sysvar_vpd_pflags:		EQU	04h	; 1: Flags to indicate completion of VDP commands
0416BC             0167*  sysvar_keyascii:		EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
0416BC             0168*  sysvar_keymods:			EQU	06h	; 1: Keycode modifiers
0416BC             0169*  sysvar_cursorX:			EQU	07h	; 1: Cursor X position
0416BC             0170*  sysvar_cursorY:			EQU	08h	; 1: Cursor Y position
0416BC             0171*  sysvar_scrchar:			EQU	09h	; 1: Character read from screen
0416BC             0172*  sysvar_scrpixel:		EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
0416BC             0173*  sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
0416BC             0174*  sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
0416BC             0175*  sysvar_scrWidth:		EQU	0Fh	; 2: Screen width in pixels
0416BC             0176*  sysvar_scrHeight:		EQU	11h	; 2: Screen height in pixels
0416BC             0177*  sysvar_scrCols:			EQU	13h	; 1: Screen columns in characters
0416BC             0178*  sysvar_scrRows:			EQU	14h	; 1: Screen rows in characters
0416BC             0179*  sysvar_scrColours:		EQU	15h	; 1: Number of colours displayed
0416BC             0180*  sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
0416BC             0181*  sysvar_vkeycode:		EQU	17h	; 1: Virtual key code from FabGL
0416BC             0182*  sysvar_vkeydown:		EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
0416BC             0183*  sysvar_vkeycount:		EQU	19h	; 1: Incremented every time a key packet is received
0416BC             0184*  sysvar_rtc:				EQU	1Ah	; 6: Real time clock data
0416BC             0185*  sysvar_spare:			EQU	20h	; 2: Spare, previously used by rtc
0416BC             0186*  sysvar_keydelay:		EQU	22h	; 2: Keyboard repeat delay
0416BC             0187*  sysvar_keyrate:			EQU	24h	; 2: Keyboard repeat reat
0416BC             0188*  sysvar_keyled:			EQU	26h	; 1: Keyboard LED status
0416BC             0189*  sysvar_scrMode:			EQU	27h	; 1: Screen mode
0416BC             0190*  sysvar_rtcEnable:		EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
0416BC             0191*  
0416BC             0192*  ; Flags for the VPD protocol
0416BC             0193*  ;
0416BC             0194*  vdp_pflag_cursor:		EQU	00000001b
0416BC             0195*  vdp_pflag_scrchar:		EQU	00000010b
0416BC             0196*  vdp_pflag_point:		EQU	00000100b
0416BC             0197*  vdp_pflag_audio:		EQU	00001000b
0416BC             0198*  vdp_pflag_mode:			EQU	00010000b
0416BC             0199*  vdp_pflag_rtc:			EQU	00100000b
0416BC             0200*  
0416BC             0201*  ;
0416BC             0202*  ; FatFS structures
0416BC             0203*  ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
0416BC             0204*  ;
0416BC             0205*  ; Object ID and allocation information (FFOBJID)
0416BC             0206*  ;
0416BC             0207*  ; Indexes into FFOBJID structure
0416BC             0208*  ffobjid_fs:			EQU	0	; 3: Pointer to the hosting volume of this object
0416BC             0209*  ffobjid_id:			EQU	3	; 2: Hosting volume mount ID
0416BC             0210*  ffobjid_attr:		EQU	5	; 1: Object attribute
0416BC             0211*  ffobjid_stat:		EQU	6	; 1: Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
0416BC             0212*  ffobjid_sclust:		EQU	7	; 4: Object data start cluster (0:no cluster or root directory)
0416BC             0213*  ffobjid_objsize:	EQU	11	; 4: Object size (valid when sclust != 0)
0416BC             0214*  ;
0416BC             0215*  ; File object structure (FIL)
0416BC             0216*  ;
0416BC             0217*  ; Indexes into FIL structure
0416BC             0218*  fil_obj:		EQU 0	; 15: Object identifier
0416BC             0219*  fil_flag:		EQU	15 	;  1: File status flags
0416BC             0220*  fil_err:		EQU	16	;  1: Abort flag (error code)
0416BC             0221*  fil_fptr:		EQU	17	;  4: File read/write pointer (Zeroed on file open)
0416BC             0222*  fil_clust:		EQU	21	;  4: Current cluster of fpter (invalid when fptr is 0)
0416BC             0223*  fil_sect:		EQU	25	;  4: Sector number appearing in buf[] (0:invalid)
0416BC             0224*  fil_dir_sect:	EQU	29	;  4: Sector number containing the directory entry
0416BC             0225*  fil_dir_ptr:	EQU	33	;  3: Pointer to the directory entry in the win[]
0416BC             0226*  ;
0416BC             0227*  ; Directory object structure (DIR)
0416BC             0228*  ; Indexes into DIR structure
0416BC             0229*  dir_obj:		EQU  0	; 15: Object identifier
0416BC             0230*  dir_dptr:		EQU	15	;  4: Current read/write offset
0416BC             0231*  dir_clust:		EQU	19	;  4: Current cluster
0416BC             0232*  dir_sect:		EQU	23	;  4: Current sector (0:Read operation has terminated)
0416BC             0233*  dir_dir:		EQU	27	;  3: Pointer to the directory item in the win[]
0416BC             0234*  dir_fn:			EQU	30	; 12: SFN (in/out) {body[8],ext[3],status[1]}
0416BC             0235*  dir_blk_ofs:	EQU	42	;  4: Offset of current entry block being processed (0xFFFFFFFF:Invalid)
0416BC             0236*  ;
0416BC             0237*  ; File information structure (FILINFO)
0416BC             0238*  ;
0416BC             0239*  ; Indexes into FILINFO structure
0416BC             0240*  filinfo_fsize:		EQU 0	;   4: File size
0416BC             0241*  filinfo_fdate:		EQU	4	;   2: Modified date
0416BC             0242*  filinfo_ftime:		EQU	6	;   2: Modified time
0416BC             0243*  filinfo_fattrib:	EQU	8	;   1: File attribute
0416BC             0244*  filinfo_altname:	EQU	9	;  13: Alternative file name
0416BC             0245*  filinfo_fname:		EQU	22	; 256: Primary file name
0416BC             0246*  ;
0416BC             0247*  ; Macro for calling the API
0416BC             0248*  ; Parameters:
0416BC             0249*  ; - function: One of the function numbers listed above
0416BC             0250*  ;
0416BC             0251*  	MACRO	MOSCALL	function
0416BC             0252*  			LD	A, function
0416BC             0253*  			RST.LIL	08h
0416BC             0254*  	ENDMACRO
0416BC             0052       include "functions.inc"
0416BC             0001*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
0416BC             0002*  ; Print a zero-terminated string
0416BC             0003*  ; HL: Pointer to string
0416BC             0004*  printString:
0416BC C5          0005*  	PUSH	BC
0416BD 01 00 00 00 0006*  	LD		BC,0
0416C1 3E 00       0007*  	LD 	 	A,0
0416C3 5B DF       0008*  	RST.LIL 18h
0416C5 C1          0009*  	POP		BC
0416C6 C9          0010*  	RET
0416C7             0011*  ; print a VDU sequence
0416C7             0012*  ; HL: Pointer to VDU sequence - <1 byte length> <data>
0416C7             0013*  sendVDUsequence:
0416C7 C5          0014*  	PUSH	BC
0416C8 01 00 00 00 0015*  	LD		BC, 0
0416CC 4E          0016*  	LD		C, (HL)
0416CD 5B DF       0017*  	RST.LIL	18h
0416CF C1          0018*  	POP		BC
0416D0 C9          0019*  	RET
0416D1             0020*  ; Print Newline sequence to VDP
0416D1             0021*  printNewLine:
0416D1 3E 0D       0022*  	LD	A, '\r'
0416D3 5B D7       0023*  	RST.LIL 10h
0416D5 3E 0A       0024*  	LD	A, '\n'
0416D7 5B D7       0025*  	RST.LIL 10h
0416D9 C9          0026*  	RET
0416DA             0027*  ; Print a 24-bit HEX number
0416DA             0028*  ; HLU: Number to print
0416DA             0029*  printHex24:
0416DA E5          0030*  	PUSH	HL
0416DB 21 02 00 00 0031*  	LD		HL, 2
0416DF 39          0032*  	ADD		HL, SP
0416E0 7E          0033*  	LD		A, (HL)
0416E1 E1          0034*  	POP		HL
0416E2 CD EC 16 04 0035*  	CALL	printHex8
0416E6             0036*  ; Print a 16-bit HEX number
0416E6             0037*  ; HL: Number to print
0416E6             0038*  printHex16:
0416E6 7C          0039*  	LD		A,H
0416E7 CD EC 16 04 0040*  	CALL	printHex8
0416EB 7D          0041*  	LD		A,L
0416EC             0042*  ; Print an 8-bit HEX number
0416EC             0043*  ; A: Number to print
0416EC             0044*  printHex8:
0416EC 4F          0045*  	LD		C,A
0416ED 1F          0046*  	RRA
0416EE 1F          0047*  	RRA
0416EF 1F          0048*  	RRA
0416F0 1F          0049*  	RRA
0416F1 CD F6 16 04 0050*  	CALL	@F
0416F5 79          0051*  	LD		A,C
0416F6             0052*  @@:
0416F6 E6 0F       0053*  	AND		0Fh
0416F8 C6 90       0054*  	ADD		A,90h
0416FA 27          0055*  	DAA
0416FB CE 40       0056*  	ADC		A,40h
0416FD 27          0057*  	DAA
0416FE 5B D7       0058*  	RST.LIL	10h
041700 C9          0059*  	RET
041701             0060*  
041701             0061*  ; Print a 0x HEX prefix
041701             0062*  DisplayHexPrefix:
041701 3E 30       0063*  	LD	A, '0'
041703 5B D7       0064*  	RST.LIL 10h
041705 3E 78       0065*  	LD	A, 'x'
041707 5B D7       0066*  	RST.LIL 10h
041709 C9          0067*  	RET
04170A             0068*  
04170A             0069*  
04170A             0070*  ; Prints the right justified decimal value in HL without leading zeroes
04170A             0071*  ; HL : Value to print
04170A             0072*  printDec:
04170A 11 2E 17 04 0073*  	LD	 DE, _printDecBuffer
04170E CD 37 17 04 0074*  	CALL Num2String
041712             0075*  ; BEGIN MY CODE
041712             0076*  ; replace leading zeroes with spaces
041712 21 2E 17 04 0077*      LD	 HL, _printDecBuffer
041716 06 07       0078*      ld   B, 7 ; if HL was 0, we want to keep the final zero
041718             0079*  @loop:
041718 7E          0080*      LD	 A, (HL)
041719 FE 30       0081*      CP	 '0'
04171B C2 29 17 04 0082*      JP	 NZ, @done
04171F 3E 20       0083*      LD   A, ' '
041721 77          0084*      LD	 (HL), A
041722 23          0085*      INC	 HL
041723 CD E7 1A 04 0086*      CALL vdu_cursor_forward
041727 10 EF       0087*      DJNZ @loop
041729             0088*  @done:
041729             0089*  ; END MY CODE
041729             0090*  	; LD	 HL, _printDecBuffer
041729 CD BC 16 04 0091*  	CALL printString
04172D C9          0092*  	RET
04172E 00 00 00 00 0093*  _printDecBuffer: blkb 9,0 ; nine bytes full of zeroes
       00 00 00 00 
       00          
041737             0094*  
041737             0095*  ; This routine converts the value from HL into it's ASCII representation,
041737             0096*  ; starting to memory location pointing by DE, in decimal form and with leading zeroes
041737             0097*  ; so it will allways be 8 characters length
041737             0098*  ; HL : Value to convert to string
041737             0099*  ; DE : pointer to buffer, at least 8 byte + 0
041737             0100*  Num2String:
041737 01 80 69 67 0101*  	LD	 BC,-10000000
04173B CD 6E 17 04 0102*  	CALL OneDigit
04173F 01 C0 BD F0 0103*  	LD	 BC,-1000000
041743 CD 6E 17 04 0104*  	CALL OneDigit
041747 01 60 79 FE 0105*  	LD	 BC,-100000
04174B CD 6E 17 04 0106*  	CALL OneDigit
04174F 01 F0 D8 FF 0107*  	LD   BC,-10000
041753 CD 6E 17 04 0108*  	CALL OneDigit
041757 01 18 FC FF 0109*  	LD   BC,-1000
04175B CD 6E 17 04 0110*  	CALL OneDigit
04175F 01 9C FF FF 0111*  	LD   BC,-100
041763 CD 6E 17 04 0112*  	CALL OneDigit
041767 0E F6       0113*  	LD   C,-10
041769 CD 6E 17 04 0114*  	CALL OneDigit
04176D 48          0115*  	LD   C,B
04176E             0116*  OneDigit:
04176E 3E 2F       0117*  	LD   A,'0'-1
041770             0118*  DivideMe:
041770 3C          0119*  	INC  A
041771 09          0120*  	ADD  HL,BC
041772 38 FC       0121*  	JR   C,DivideMe
041774 ED 42       0122*  	SBC  HL,BC
041776 12          0123*  	LD   (DE),A
041777 13          0124*  	INC  DE
041778 C9          0125*  	RET
041779             0126*  
041779             0127*  
041779             0128*  ; #### new functions added by Brandon R. Gates ####
041779             0129*  
041779             0130*  ; print the binary representation of the 8-bit value in a
041779             0131*  ; destroys a, hl, bc
041779             0132*  printBin8:
041779 06 08       0133*      ld b,8      ; loop counter for 8 bits
04177B 21 96 17 04 0134*      ld hl,@cmd  ; set hl to the low byte of the output string
04177F             0135*                  ; (which will be the high bit of the value in a)
04177F             0136*  @loop:
04177F 07          0137*      rlca ; put the next highest bit into carry
041780 38 04       0138*      jr c,@one
041782 36 30       0139*      ld (hl),'0'
041784 18 02       0140*      jr @next_bit
041786             0141*  @one:
041786 36 31       0142*      ld (hl),'1'
041788             0143*  @next_bit:
041788 23          0144*      inc hl
041789 10 F4       0145*      djnz @loop
04178B             0146*  ; print it
04178B 21 96 17 04 0147*  	ld hl,@cmd
04178F 01 08 00 00 0148*  	ld bc,@end-@cmd
041793 5B DF       0149*  	rst.lil $18
041795 C9          0150*  	ret
041796             0151*  @cmd: ds 8 ; eight bytes for eight bits
04179E             0152*  @end:
04179E             0153*  
04179E             0154*  ; print the binary representation of the 8-bit value in a
04179E             0155*  ; in reverse order (lsb first)
04179E             0156*  ; destroys a, hl, bc
04179E             0157*  printBin8Rev:
04179E 06 08       0158*      ld b,8      ; loop counter for 8 bits
0417A0 21 BB 17 04 0159*      ld hl,@cmd  ; set hl to the low byte of the output string
0417A4             0160*                  ; (which will be the high bit of the value in a)
0417A4             0161*  @loop:
0417A4 0F          0162*      rrca ; put the next lowest bit into carry
0417A5 38 04       0163*      jr c,@one
0417A7 36 30       0164*      ld (hl),'0'
0417A9 18 02       0165*      jr @next_bit
0417AB             0166*  @one:
0417AB 36 31       0167*      ld (hl),'1'
0417AD             0168*  @next_bit:
0417AD 23          0169*      inc hl
0417AE 10 F4       0170*      djnz @loop
0417B0             0171*  ; print it
0417B0 21 BB 17 04 0172*  	ld hl,@cmd
0417B4 01 08 00 00 0173*  	ld bc,@end-@cmd
0417B8 5B DF       0174*  	rst.lil $18
0417BA C9          0175*  	ret
0417BB             0176*  @cmd: ds 8 ; eight bytes for eight bits
0417C3             0177*  @end:
0417C3             0178*  
0417C3             0179*  ; print registers to screen in hexidecimal format
0417C3             0180*  ; inputs: none
0417C3             0181*  ; outputs: values of every register printed to screen
0417C3             0182*  ;    values of each register in global scratch memory
0417C3             0183*  ; destroys: nothing
0417C3             0184*  stepRegistersHex:
0417C3             0185*  ; store everything in scratch
0417C3 22 C2 19 04 0186*      ld (uhl),hl
0417C7 ED 43 C5 19 0187*      ld (ubc),bc
       04          
0417CC ED 53 C8 19 0188*      ld (ude),de
       04          
0417D1 DD 22 CB 19 0189*      ld (uix),ix
       04          
0417D6 FD 22 CE 19 0190*      ld (uiy),iy
       04          
0417DB F5          0191*      push af ; fml
0417DC E1          0192*      pop hl  ; thanks, zilog
0417DD 22 BF 19 04 0193*      ld (uaf),hl
0417E1 F5          0194*      push af ; dammit
0417E2             0195*  
0417E2             0196*  ; home the cursor
0417E2 CD B5 1A 04 0197*      call vdu_home_cursor
0417E6             0198*  
0417E6             0199*  ; print each register
0417E6 21 4B 19 04 0200*      ld hl,str_afu
0417EA CD BC 16 04 0201*      call printString
0417EE 2A BF 19 04 0202*      ld hl,(uaf)
0417F2 CD DA 16 04 0203*      call printHex24
0417F6 CD D1 16 04 0204*      call printNewLine
0417FA             0205*  
0417FA 21 4F 19 04 0206*      ld hl,str_hlu
0417FE CD BC 16 04 0207*      call printString
041802 2A C2 19 04 0208*      ld hl,(uhl)
041806 CD DA 16 04 0209*      call printHex24
04180A CD D1 16 04 0210*      call printNewLine
04180E             0211*  
04180E 21 53 19 04 0212*      ld hl,str_bcu
041812 CD BC 16 04 0213*      call printString
041816 2A C5 19 04 0214*      ld hl,(ubc)
04181A CD DA 16 04 0215*      call printHex24
04181E CD D1 16 04 0216*      call printNewLine
041822             0217*  
041822 21 57 19 04 0218*      ld hl,str_deu
041826 CD BC 16 04 0219*      call printString
04182A 2A C8 19 04 0220*      ld hl,(ude)
04182E CD DA 16 04 0221*      call printHex24
041832 CD D1 16 04 0222*      call printNewLine
041836             0223*  
041836 21 5B 19 04 0224*      ld hl,str_ixu
04183A CD BC 16 04 0225*      call printString
04183E 2A CB 19 04 0226*      ld hl,(uix)
041842 CD DA 16 04 0227*      call printHex24
041846 CD D1 16 04 0228*      call printNewLine
04184A             0229*  
04184A 21 5F 19 04 0230*      ld hl,str_iyu
04184E CD BC 16 04 0231*      call printString
041852 2A CE 19 04 0232*      ld hl,(uiy)
041856 CD DA 16 04 0233*      call printHex24
04185A CD D1 16 04 0234*      call printNewLine
04185E             0235*  
04185E             0236*      ; call vdu_vblank
04185E             0237*  
04185E CD D1 16 04 0238*      call printNewLine
041862             0239*  
041862             0240*  ; check for right shift key and quit if pressed
041862             0241*  	MOSCALL mos_getkbmap
041862 3E 1E       0001*M 			LD	A, function
041864 5B CF       0002*M 			RST.LIL	08h
041866             0242*  @stayhere:
041866             0243*  ; 7 RightShift
041866 DD CB 00 76 0244*      bit 6,(ix+0)
04186A 20 02       0245*      jr nz,@RightShift
04186C 18 F8       0246*      jr @stayhere
04186E             0247*  @RightShift:
04186E DD CB 0E 86 0248*      res 0,(ix+14) ; debounce the key (hopefully)
041872 3E 80       0249*      ld a,%10000000
041874 CD 17 32 04 0250*      call multiPurposeDelay
041878             0251*  
041878             0252*  ; restore everything
041878 2A C2 19 04 0253*      ld hl, (uhl)
04187C ED 4B C5 19 0254*      ld bc, (ubc)
       04          
041881 ED 5B C8 19 0255*      ld de, (ude)
       04          
041886 DD 2A CB 19 0256*      ld ix, (uix)
       04          
04188B FD 2A CE 19 0257*      ld iy, (uiy)
       04          
041890 F1          0258*      pop af
041891             0259*  ; all done
041891 C9          0260*      ret
041892             0261*  
041892             0262*  ; print registers to screen in hexidecimal format
041892             0263*  ; inputs: none
041892             0264*  ; outputs: values of every register printed to screen
041892             0265*  ;    values of each register in global scratch memory
041892             0266*  ; destroys: nothing
041892             0267*  dumpRegistersHex:
041892             0268*  ; store everything in scratch
041892 22 C2 19 04 0269*      ld (uhl),hl
041896 ED 43 C5 19 0270*      ld (ubc),bc
       04          
04189B ED 53 C8 19 0271*      ld (ude),de
       04          
0418A0 DD 22 CB 19 0272*      ld (uix),ix
       04          
0418A5 FD 22 CE 19 0273*      ld (uiy),iy
       04          
0418AA F5          0274*      push af ; fml
0418AB E1          0275*      pop hl  ; thanks, zilog
0418AC 22 BF 19 04 0276*      ld (uaf),hl
0418B0 F5          0277*      push af ; dammit
0418B1             0278*  
0418B1             0279*  ; home the cursor
0418B1 CD B5 1A 04 0280*      call vdu_home_cursor
0418B5             0281*  
0418B5             0282*  ; print each register
0418B5 21 4B 19 04 0283*      ld hl,str_afu
0418B9 CD BC 16 04 0284*      call printString
0418BD 2A BF 19 04 0285*      ld hl,(uaf)
0418C1 CD DA 16 04 0286*      call printHex24
0418C5 CD D1 16 04 0287*      call printNewLine
0418C9             0288*  
0418C9 21 4F 19 04 0289*      ld hl,str_hlu
0418CD CD BC 16 04 0290*      call printString
0418D1 2A C2 19 04 0291*      ld hl,(uhl)
0418D5 CD DA 16 04 0292*      call printHex24
0418D9 CD D1 16 04 0293*      call printNewLine
0418DD             0294*  
0418DD 21 53 19 04 0295*      ld hl,str_bcu
0418E1 CD BC 16 04 0296*      call printString
0418E5 2A C5 19 04 0297*      ld hl,(ubc)
0418E9 CD DA 16 04 0298*      call printHex24
0418ED CD D1 16 04 0299*      call printNewLine
0418F1             0300*  
0418F1 21 57 19 04 0301*      ld hl,str_deu
0418F5 CD BC 16 04 0302*      call printString
0418F9 2A C8 19 04 0303*      ld hl,(ude)
0418FD CD DA 16 04 0304*      call printHex24
041901 CD D1 16 04 0305*      call printNewLine
041905             0306*  
041905 21 5B 19 04 0307*      ld hl,str_ixu
041909 CD BC 16 04 0308*      call printString
04190D 2A CB 19 04 0309*      ld hl,(uix)
041911 CD DA 16 04 0310*      call printHex24
041915 CD D1 16 04 0311*      call printNewLine
041919             0312*  
041919 21 5F 19 04 0313*      ld hl,str_iyu
04191D CD BC 16 04 0314*      call printString
041921 2A CE 19 04 0315*      ld hl,(uiy)
041925 CD DA 16 04 0316*      call printHex24
041929 CD D1 16 04 0317*      call printNewLine
04192D             0318*  
04192D             0319*      ; call vdu_vblank
04192D             0320*  
04192D CD D1 16 04 0321*      call printNewLine
041931             0322*  ; restore everything
041931 2A C2 19 04 0323*      ld hl, (uhl)
041935 ED 4B C5 19 0324*      ld bc, (ubc)
       04          
04193A ED 5B C8 19 0325*      ld de, (ude)
       04          
04193F DD 2A CB 19 0326*      ld ix, (uix)
       04          
041944 FD 2A CE 19 0327*      ld iy, (uiy)
       04          
041949 F1          0328*      pop af
04194A             0329*  ; all done
04194A C9          0330*      ret
04194B             0331*  
04194B 61 66 3D 00 0332*  str_afu: db "af=",0
04194F 68 6C 3D 00 0333*  str_hlu: db "hl=",0
041953 62 63 3D 00 0334*  str_bcu: db "bc=",0
041957 64 65 3D 00 0335*  str_deu: db "de=",0
04195B 69 78 3D 00 0336*  str_ixu: db "ix=",0
04195F 69 79 3D 00 0337*  str_iyu: db "iy=",0
041963             0338*  
041963             0339*  ; print udeuhl to screen in hexidecimal format
041963             0340*  ; inputs: none
041963             0341*  ; outputs: concatenated hexidecimal udeuhl
041963             0342*  ; destroys: nothing
041963             0343*  dumpUDEUHLHex:
041963             0344*  ; store everything in scratch
041963 22 C2 19 04 0345*      ld (uhl),hl
041967 ED 43 C5 19 0346*      ld (ubc),bc
       04          
04196C ED 53 C8 19 0347*      ld (ude),de
       04          
041971 DD 22 CB 19 0348*      ld (uix),ix
       04          
041976 FD 22 CE 19 0349*      ld (uiy),iy
       04          
04197B F5          0350*      push af
04197C             0351*  
04197C             0352*  ; print each register
04197C             0353*  
04197C 21 B6 19 04 0354*      ld hl,str_udeuhl
041980 CD BC 16 04 0355*      call printString
041984 2A C8 19 04 0356*      ld hl,(ude)
041988 CD DA 16 04 0357*      call printHex24
04198C 3E 2E       0358*  	ld a,'.'	; print a dot to separate the values
04198E 5B D7       0359*  	rst.lil 10h
041990 2A C2 19 04 0360*      ld hl,(uhl)
041994 CD DA 16 04 0361*      call printHex24
041998 CD D1 16 04 0362*      call printNewLine
04199C             0363*  
04199C             0364*  ; restore everything
04199C 2A C2 19 04 0365*      ld hl, (uhl)
0419A0 ED 4B C5 19 0366*      ld bc, (ubc)
       04          
0419A5 ED 5B C8 19 0367*      ld de, (ude)
       04          
0419AA DD 2A CB 19 0368*      ld ix, (uix)
       04          
0419AF FD 2A CE 19 0369*      ld iy, (uiy)
       04          
0419B4 F1          0370*      pop af
0419B5             0371*  ; all done
0419B5 C9          0372*      ret
0419B6             0373*  
0419B6 75 64 65 2E 0374*  str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
0419BF             0375*  
0419BF             0376*  ; global scratch memory for registers
0419BF 00 00 00    0377*  uaf: dl 0
0419C2 00 00 00    0378*  uhl: dl 0
0419C5 00 00 00    0379*  ubc: dl 0
0419C8 00 00 00    0380*  ude: dl 0
0419CB 00 00 00    0381*  uix: dl 0
0419CE 00 00 00    0382*  uiy: dl 0
0419D1 00 00 00    0383*  usp: dl 0
0419D4 00 00 00    0384*  upc: dl 0
0419D7             0385*  
0419D7             0386*  ; inputs: whatever is in the flags register
0419D7             0387*  ; outputs: binary representation of flags
0419D7             0388*  ;          with a header so we know which is what
0419D7             0389*  ; destroys: nothing
0419D7             0390*  ; preserves: everything
0419D7             0391*  dumpFlags:
0419D7             0392*  ; first we curse zilog for not giving direct access to flags
0419D7 F5          0393*      push af ; this is so we can send it back unharmed
0419D8 F5          0394*      push af ; this is so we can pop it to hl
0419D9             0395*  ; store everything in scratch
0419D9 22 C2 19 04 0396*      ld (uhl),hl
0419DD ED 43 C5 19 0397*      ld (ubc),bc
       04          
0419E2 ED 53 C8 19 0398*      ld (ude),de
       04          
0419E7 DD 22 CB 19 0399*      ld (uix),ix
       04          
0419EC FD 22 CE 19 0400*      ld (uiy),iy
       04          
0419F1             0401*  ; next we print the header
0419F1 21 1D 1A 04 0402*      ld hl,@header
0419F5 CD BC 16 04 0403*      call printString
0419F9 E1          0404*      pop hl ; flags are now in l
0419FA 7D          0405*      ld a,l ; flags are now in a
0419FB CD 79 17 04 0406*      call printBin8
0419FF CD D1 16 04 0407*  	call printNewLine
041A03             0408*  ; restore everything
041A03 2A C2 19 04 0409*      ld hl, (uhl)
041A07 ED 4B C5 19 0410*      ld bc, (ubc)
       04          
041A0C ED 5B C8 19 0411*      ld de, (ude)
       04          
041A11 DD 2A CB 19 0412*      ld ix, (uix)
       04          
041A16 FD 2A CE 19 0413*      ld iy, (uiy)
       04          
041A1B F1          0414*      pop af ; send her home the way she came
041A1C C9          0415*      ret
041A1D             0416*  ; Bit 7 (S): Sign flag
041A1D             0417*  ; Bit 6 (Z): Zero flag
041A1D             0418*  ; Bit 5 (5): Reserved (copy of bit 5 of the result)
041A1D             0419*  ; Bit 4 (H): Half Carry flag
041A1D             0420*  ; Bit 3 (3): Reserved (copy of bit 3 of the result)
041A1D             0421*  ; Bit 2 (PV): Parity/Overflow flag
041A1D             0422*  ; Bit 1 (N): Subtract flag
041A1D             0423*  ; Bit 0 (C): Carry flag
041A1D 53 5A 78 48 0424*  @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
       78 50 4E 43 
       0D 0A 00    
041A28             0425*  
041A28             0426*  ; set all the bits in the flag register
041A28             0427*  ; more of an academic exercise than anything useful
041A28             0428*  ; inputs; none
041A28             0429*  ; outputs; a=0,f=255
041A28             0430*  ; destroys: flags, hl
041A28             0431*  ; preserves: a, because why not
041A28             0432*  setAllFlags:
041A28 21 FF 00 00 0433*      ld hl,255
041A2C 67          0434*      ld h,a ; four cycles to preserve a is cheap
041A2D E5          0435*      push hl
041A2E F1          0436*      pop af
041A2F C9          0437*      ret
041A30             0438*  
041A30             0439*  ; reset all the bits in the flag register
041A30             0440*  ; unlike its inverse counterpart, this may actually be useful
041A30             0441*  ; inputs; none
041A30             0442*  ; outputs; a=0,f=0
041A30             0443*  ; destroys: flags, hl
041A30             0444*  ; preserves: a, because why not
041A30             0445*  resetAllFlags:
041A30 21 00 00 00 0446*      ld hl,0
041A34 67          0447*      ld h,a ; four cycles to preserve a is cheap
041A35 E5          0448*      push hl
041A36 F1          0449*      pop af
041A37 C9          0450*      ret
041A38             0451*  
041A38             0452*  ; wait until user presses a key
041A38             0453*  ; inputs: none
041A38             0454*  ; outputs: none
041A38             0455*  ; destroys: af,ix
041A38             0456*  waitKeypress:
041A38             0457*      MOSCALL mos_sysvars
041A38 3E 08       0001*M 			LD	A, function
041A3A 5B CF       0002*M 			RST.LIL	08h
041A3C AF          0458*      xor a ; zero out any prior keypresses
041A3D DD 77 05    0459*      ld (ix+sysvar_keyascii),a
041A40             0460*  @loop:
041A40 DD 7E 05    0461*      ld a,(ix+sysvar_keyascii)
041A43 A7          0462*      and a
041A44 C0          0463*      ret nz
041A45 18 F9       0464*      jr @loop
041A47             0465*  
041A47             0466*  
041A47             0467*  ; print bytes from an address to the screen in hexidecimal format
041A47             0468*  ; inputs: hl = address of first byte to print, a = number of bytes to print
041A47             0469*  ; outputs: values of each byte printed to screen separated by spaces
041A47             0470*  ; destroys: nothing
041A47             0471*  dumpMemoryHex:
041A47             0472*  ; save all registers to the stack
041A47 F5          0473*      push af
041A48 C5          0474*      push bc
041A49 D5          0475*      push de
041A4A E5          0476*      push hl
041A4B DD E5       0477*      push ix
041A4D FD E5       0478*      push iy
041A4F             0479*  
041A4F             0480*  ; set b to be our loop counter
041A4F 47          0481*      ld b,a
041A50             0482*  @loop:
041A50             0483*  ; print the byte
041A50 7E          0484*      ld a,(hl)
041A51 CD EC 16 04 0485*      call printHex8
041A55             0486*  ; print a space
041A55 3E 20       0487*      ld a,' '
041A57 5B D7       0488*      rst.lil 10h
041A59 23          0489*      inc hl
041A5A 10 F4       0490*      djnz @loop
041A5C CD D1 16 04 0491*      call printNewLine
041A60             0492*  
041A60             0493*  ; restore everything
041A60 FD E1       0494*      pop iy
041A62 DD E1       0495*      pop ix
041A64 E1          0496*      pop hl
041A65 D1          0497*      pop de
041A66 C1          0498*      pop bc
041A67 F1          0499*      pop af
041A68             0500*  ; all done
041A68 C9          0501*      ret
041A69             0502*  
041A69             0503*  
041A69             0504*  ; print bytes from an address to the screen in binary format
041A69             0505*  ; inputs: hl = address of first byte to print, a = number of bytes to print
041A69             0506*  ; outputs: values of each byte printed to screen separated by spaces
041A69             0507*  ; destroys: nothing
041A69             0508*  dumpMemoryBin:
041A69             0509*  ; save all registers to the stack
041A69 F5          0510*      push af
041A6A C5          0511*      push bc
041A6B D5          0512*      push de
041A6C E5          0513*      push hl
041A6D DD E5       0514*      push ix
041A6F FD E5       0515*      push iy
041A71             0516*  
041A71             0517*  ; set b to be our loop counter
041A71 47          0518*      ld b,a
041A72             0519*  @loop:
041A72             0520*  ; print the byte
041A72 7E          0521*      ld a,(hl)
041A73 E5          0522*      push hl
041A74 C5          0523*      push bc
041A75 CD 79 17 04 0524*      call printBin8
041A79 C1          0525*      pop bc
041A7A             0526*  ; print a space
041A7A 3E 20       0527*      ld a,' '
041A7C 5B D7       0528*      rst.lil 10h
041A7E E1          0529*      pop hl
041A7F 23          0530*      inc hl
041A80 10 F0       0531*      djnz @loop
041A82 CD D1 16 04 0532*      call printNewLine
041A86             0533*  
041A86             0534*  ; restore everything
041A86 FD E1       0535*      pop iy
041A88 DD E1       0536*      pop ix
041A8A E1          0537*      pop hl
041A8B D1          0538*      pop de
041A8C C1          0539*      pop bc
041A8D F1          0540*      pop af
041A8E             0541*  ; all done
041A8E C9          0542*      ret
041A8F             0543*  
041A8F             0544*  ; print bytes from an address to the screen in binary format
041A8F             0545*  ; with the bits of each byte in reverse order (lsb first)
041A8F             0546*  ; inputs: hl = address of first byte to print, a = number of bytes to print
041A8F             0547*  ; outputs: values of each byte printed to screen separated by spaces
041A8F             0548*  ; destroys: nothing
041A8F             0549*  dumpMemoryBinRev:
041A8F             0550*  ; save all registers to the stack
041A8F F5          0551*      push af
041A90 C5          0552*      push bc
041A91 D5          0553*      push de
041A92 E5          0554*      push hl
041A93 DD E5       0555*      push ix
041A95 FD E5       0556*      push iy
041A97             0557*  
041A97             0558*  ; set b to be our loop counter
041A97 47          0559*      ld b,a
041A98             0560*  @loop:
041A98             0561*  ; print the byte
041A98 7E          0562*      ld a,(hl)
041A99 E5          0563*      push hl
041A9A C5          0564*      push bc
041A9B CD 9E 17 04 0565*      call printBin8Rev
041A9F C1          0566*      pop bc
041AA0             0567*  ; print a space
041AA0 3E 20       0568*      ld a,' '
041AA2 5B D7       0569*      rst.lil 10h
041AA4 E1          0570*      pop hl
041AA5 23          0571*      inc hl
041AA6 10 F0       0572*      djnz @loop
041AA8 CD D1 16 04 0573*      call printNewLine
041AAC             0574*  
041AAC             0575*  ; restore everything
041AAC FD E1       0576*      pop iy
041AAE DD E1       0577*      pop ix
041AB0 E1          0578*      pop hl
041AB1 D1          0579*      pop de
041AB2 C1          0580*      pop bc
041AB3 F1          0581*      pop af
041AB4             0582*  ; all done
041AB4 C9          0583*      ret
041AB5             0053       include "vdu.inc"
041AB5             0001*  
041AB5             0002*  ; VDU 30: Home cursor
041AB5             0003*  vdu_home_cursor:
041AB5 3E 1E       0004*      ld a,30
041AB7 5B D7       0005*  	rst.lil $10
041AB9 C9          0006*  	ret
041ABA             0007*  
041ABA             0008*  vdu_cursor_on:
041ABA 21 C5 1A 04 0009*  	ld hl,@cmd
041ABE 01 03 00 00 0010*  	ld bc,@end-@cmd
041AC2 5B DF       0011*  	rst.lil $18
041AC4 C9          0012*  	ret
041AC5             0013*  @cmd:
041AC5 17 01 01    0014*  	db 23,1,1
041AC8             0015*  @end:
041AC8             0016*  
041AC8             0017*  vdu_cursor_off:
041AC8 21 D3 1A 04 0018*  	ld hl,@cmd
041ACC 01 03 00 00 0019*  	ld bc,@end-@cmd
041AD0 5B DF       0020*  	rst.lil $18
041AD2 C9          0021*  	ret
041AD3             0022*  @cmd:
041AD3 17 01 00    0023*  	db 23,1,0
041AD6             0024*  @end:
041AD6             0025*  
041AD6             0026*  ; VDU 5: Write text at graphics cursor
041AD6             0027*  ; inputs: a is the character to write to the screen
041AD6             0028*  ; prerequisites: the graphics cursor at the intended position on screen
041AD6             0029*  ; outputs: see the name of the function
041AD6             0030*  ; destroys: a, hl, bc
041AD6             0031*  vdu_char_to_gfx_cursor:
041AD6 32 E6 1A 04 0032*  	ld (@arg),a
041ADA 21 E5 1A 04 0033*  	ld hl,@cmd
041ADE 01 02 00 00 0034*  	ld bc,@end-@cmd
041AE2 5B DF       0035*  	rst.lil $18
041AE4 C9          0036*  	ret
041AE5 05          0037*  @cmd: db 5
041AE6 00          0038*  @arg: db 0
041AE7             0039*  @end:
041AE7             0040*  ; VDU 9: Move cursor forward one character
041AE7             0041*  vdu_cursor_forward:
041AE7 3E 09       0042*      ld a,9
041AE9 5B D7       0043*  	rst.lil $10
041AEB C9          0044*  	ret
041AEC             0045*  
041AEC             0046*  ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
041AEC             0047*  ; inputs: c=x, b=y 8-bit unsigned integers
041AEC             0048*  vdu_move_cursor:
041AEC ED 43 FD 1A 0049*      ld (@x0),bc
       04          
041AF1 21 FC 1A 04 0050*  	ld hl,@cmd
041AF5 01 03 00 00 0051*  	ld bc,@end-@cmd
041AF9 5B DF       0052*  	rst.lil $18
041AFB C9          0053*  	ret
041AFC 1F          0054*  @cmd: 	db 31
041AFD 00          0055*  @x0:	db 0
041AFE 00          0056*  @y0: 	db 0
041AFF 00          0057*  @end: 	db 0 ; padding
041B00             0058*  
041B00             0059*  ; VDU 12: Clear text area (CLS)
041B00             0060*  vdu_cls:
041B00 3E 0C       0061*      ld a,12
041B02 5B D7       0062*  	rst.lil $10
041B04 C9          0063*  	ret
041B05             0064*  
041B05             0065*  vdu_flip:
041B05 21 10 1B 04 0066*  	ld hl,@cmd
041B09 01 03 00 00 0067*  	ld bc,@end-@cmd
041B0D 5B DF       0068*  	rst.lil $18
041B0F C9          0069*  	ret
041B10 17 00 C3    0070*  @cmd: db 23,0,0xC3
041B13             0071*  @end:
041B13             0072*  
041B13             0073*  ; VDU 16: Clear graphics area (CLG)
041B13             0074*  vdu_clg:
041B13 3E 10       0075*      ld a,16
041B15 5B D7       0076*  	rst.lil $10
041B17 C9          0077*  	ret
041B18             0078*  
041B18             0079*  ; https://github.com/breakintoprogram/agon-docs/wiki/VDP
041B18             0080*  ; VDU 23, 7: Scrolling
041B18             0081*  ;     VDU 23, 7, extent, direction, speed: Scroll the screen
041B18             0082*  ; inputs: a, extent; l, direction; h; speed
041B18             0083*  vdu_scroll_down:
041B18 32 2D 1B 04 0084*  	ld (@extent),a
041B1C 22 2E 1B 04 0085*  	ld (@dir),hl ; implicitly populates @speed
041B20 21 2B 1B 04 0086*  	ld hl,@cmd
041B24 01 05 00 00 0087*  	ld bc,@end-@cmd
041B28 5B DF       0088*  	rst.lil $18     ;; Sending command to VDP
041B2A C9          0089*  	ret
041B2B 17 07       0090*  @cmd:       db 23,7
041B2D 00          0091*  @extent:    db 0x00 ; 0 current text window, 1 entire screen, 2 curr gfx viewport
041B2E 00          0092*  @dir:       db 0x00 ; 0 right, 1 left, 2 down, 3 up
041B2F 00          0093*  @speed:     db 0x00 ; pixels
041B30 00          0094*  @end:		db 0x00 ; padding
041B31             0095*  
041B31             0096*  ; COLOUR MODES
041B31             0097*  ; Mode	Effect
041B31             0098*  ; 0	Set on-screen pixel to target colour value
041B31             0099*  ; 1	OR value with the on-screen pixel
041B31             0100*  ; 2	AND value with the on-screen pixel
041B31             0101*  ; 3	XOR value with the on-screen pixel
041B31             0102*  ; 4	Invert the on-screen pixel
041B31             0103*  ; 5	No operation
041B31             0104*  ; 6	AND the inverse of the specified colour with the on-screen pixel
041B31             0105*  ; 7	OR the inverse of the specified colour with the on-screen pixel
041B31             0106*  
041B31             0107*  ; VDU 17, colour: Define text colour (COLOUR)
041B31             0108*  vdu_colour_text:
041B31 32 41 1B 04 0109*  	ld (@arg),a
041B35 21 40 1B 04 0110*  	ld hl,@cmd
041B39 01 02 00 00 0111*  	ld bc,@end-@cmd
041B3D 5B DF       0112*  	rst.lil $18
041B3F C9          0113*  	ret
041B40 11          0114*  @cmd: db 17
041B41 00          0115*  @arg: db 0
041B42             0116*  @end:
041B42             0117*  
041B42             0118*  ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
041B42             0119*  ; inputs: a=mode, c=colour (add 128 to set background colour)
041B42             0120*  vdu_gcol:
041B42 32 57 1B 04 0121*  	ld (@mode),a
041B46 79          0122*      ld a,c
041B47 32 58 1B 04 0123*      ld (@col),a
041B4B 21 56 1B 04 0124*  	ld hl,@cmd
041B4F 01 03 00 00 0125*  	ld bc,@end-@cmd
041B53 5B DF       0126*  	rst.lil $18
041B55 C9          0127*  	ret
041B56 12          0128*  @cmd:  db 18
041B57 00          0129*  @mode: db 0
041B58 00          0130*  @col:  db 0
041B59             0131*  @end:
041B59             0132*  
041B59             0133*  
041B59             0134*  ; VDU 28, left, bottom, right, top: Set text viewport **
041B59             0135*  ; MIND THE LITTLE-ENDIANESS
041B59             0136*  ; inputs: c=left,b=bottom,e=right,d=top
041B59             0137*  ; outputs; nothing
041B59             0138*  ; destroys: a might make it out alive
041B59             0139*  vdu_set_txt_viewport:
041B59 ED 43 6F 1B 0140*      ld (@lb),bc
       04          
041B5E ED 53 71 1B 0141*  	ld (@rt),de
       04          
041B63 21 6E 1B 04 0142*  	ld hl,@cmd
041B67 01 05 00 00 0143*  	ld bc,@end-@cmd
041B6B 5B DF       0144*  	rst.lil $18
041B6D C9          0145*  	ret
041B6E 1C          0146*  @cmd:   db 28 ; set text viewport command
041B6F 00 00       0147*  @lb: 	dw 0x0000 ; set by bc
041B71 00 00       0148*  @rt: 	dw 0x0000 ; set by de
041B73 00          0149*  @end:   db 0x00	  ; padding
041B74             0150*  
041B74             0151*  ; Wait for VBLANK interrupt
041B74             0152*  vdu_vblank:
041B74 DD E5       0153*      PUSH 	IX
041B76             0154*  	MOSCALL	mos_sysvars
041B76 3E 08       0001*M 			LD	A, function
041B78 5B CF       0002*M 			RST.LIL	08h
041B7A DD 7E 00    0155*  	LD	A, (IX + sysvar_time + 0)
041B7D             0156*  @wait:
041B7D DD BE 00    0157*      CP 	A, (IX + sysvar_time + 0)
041B80 28 FB       0158*      JR	Z, @wait
041B82 DD E1       0159*      POP	IX
041B84 C9          0160*      RET
041B85             0161*  
041B85             0162*  ; VDU 29, x; y;: Set graphics origin
041B85             0163*  ; This command sets the graphics origin.
041B85             0164*  ; The origin is the point on the screen where the coordinates (0,0) are located.
041B85             0165*  ; inputs: bc=x0,de=y0
041B85             0166*  ; outputs; nothing
041B85             0167*  ; destroys: a might make it out alive
041B85             0168*  vdu_set_gfx_origin:
041B85 ED 43 9B 1B 0169*      ld (@x0),bc
       04          
041B8A ED 53 9D 1B 0170*      ld (@y0),de
       04          
041B8F 21 9A 1B 04 0171*      ld hl,@cmd
041B93 01 05 00 00 0172*      ld bc,@end-@cmd
041B97 5B DF       0173*      rst.lil $18
041B99 C9          0174*      ret
041B9A 1D          0175*  @cmd:   db 29 ; set graphics origin command
041B9B 00 00       0176*  @x0: 	dw 0x0000 ; set by bc
041B9D 00 00       0177*  @y0: 	dw 0x0000 ; set by de
041B9F 00          0178*  @end:   db 0x00	  ; padding
041BA0             0179*  
041BA0             0180*  ; VDU 24, left; bottom; right; top;: Set graphics viewport
041BA0             0181*  ; NOTE: the order of the y-coordinate parameters are inverted
041BA0             0182*  ; 	because we have turned off logical screen scaling
041BA0             0183*  ; inputs: bc=x0,de=y0,ix=x1,iy=y1
041BA0             0184*  ; outputs; nothing
041BA0             0185*  ; destroys: a might make it out alive
041BA0             0186*  vdu_set_gfx_viewport:
041BA0 ED 43 C0 1B 0187*      ld (@x0),bc
       04          
041BA5 FD 22 C2 1B 0188*      ld (@y1),iy
       04          
041BAA DD 22 C4 1B 0189*  	ld (@x1),ix
       04          
041BAF ED 53 C6 1B 0190*  	ld (@y0),de
       04          
041BB4 21 BF 1B 04 0191*  	ld hl,@cmd
041BB8 01 09 00 00 0192*  	ld bc,@end-@cmd
041BBC 5B DF       0193*  	rst.lil $18
041BBE C9          0194*  	ret
041BBF 18          0195*  @cmd:   db 24 ; set graphics viewport command
041BC0 00 00       0196*  @x0: 	dw 0x0000 ; set by bc
041BC2 00 00       0197*  @y1: 	dw 0x0000 ; set by iy
041BC4 00 00       0198*  @x1: 	dw 0x0000 ; set by ix
041BC6 00 00       0199*  @y0: 	dw 0x0000 ; set by de
041BC8 00          0200*  @end:   db 0x00	  ; padding
041BC9             0201*  
041BC9             0202*  ; SCREEN MODES
041BC9             0203*  ; ===============================
041BC9             0204*  ; Mode  Horz  Vert  Cols  Refresh
041BC9             0205*  ; ---   ----  ----  ----  -------
041BC9             0206*  ; 11    320   240   2     60hz
041BC9             0207*  ; 139   320   240   2     60hz
041BC9             0208*  ; 23    512   384   2     60hz
041BC9             0209*  ; 151   512   384   2     60hz
041BC9             0210*  ; 6     640   240   2     60hz
041BC9             0211*  ; 134   640   240   2     60hz
041BC9             0212*  ; 2     640   480   2     60hz
041BC9             0213*  ; 130   640   480   2     60hz
041BC9             0214*  ; 17    800   600   2     60hz
041BC9             0215*  ; 145   800   600   2     60hz
041BC9             0216*  ; 18    1024  768   2     60hz
041BC9             0217*  ; 146   1024  768   2     60hz
041BC9             0218*  ; ---   ----  ----  ----  -------
041BC9             0219*  ; 10    320   240   4     60hz
041BC9             0220*  ; 138   320   240   4     60hz
041BC9             0221*  ; 22    512   384   4     60hz
041BC9             0222*  ; 150   512   384   4     60hz
041BC9             0223*  ; 5     640   240   4     60hz
041BC9             0224*  ; 133   640   240   4     60hz
041BC9             0225*  ; 1     640   480   4     60hz
041BC9             0226*  ; 129   640   480   4     60hz
041BC9             0227*  ; 16    800   600   4     60hz
041BC9             0228*  ; 19    1024  768   4     60hz
041BC9             0229*  ; ---   ----  ----  ----  -------
041BC9             0230*  ; 9     320   240   16    60hz
041BC9             0231*  ; 137   320   240   16    60hz
041BC9             0232*  ; 21    512   384   16    60hz
041BC9             0233*  ; 149   512   384   16    60hz
041BC9             0234*  ; 4     640   240   16    60hz
041BC9             0235*  ; 132   640   240   16    60hz
041BC9             0236*  ; 0     640   480   16    60hz
041BC9             0237*  ; 7     n/a   n/a   16    60hz
041BC9             0238*  ; ---   ----  ----  ----  -------
041BC9             0239*  ; 8     320   240   64    60hz
041BC9             0240*  ; 136   320   240   64    60hz
041BC9             0241*  ; 20    512   384   64    60hz
041BC9             0242*  ; 3     640   240   64    60hz
041BC9             0243*  ; ---   ----  ----  ----  -------
041BC9             0244*  vdu_set_screen_mode:
041BC9 32 D9 1B 04 0245*  	ld (@arg),a
041BCD 21 D8 1B 04 0246*  	ld hl,@cmd
041BD1 01 02 00 00 0247*  	ld bc,@end-@cmd
041BD5 5B DF       0248*  	rst.lil $18
041BD7 C9          0249*  	ret
041BD8 16          0250*  @cmd: db 22 ; set screen mode
041BD9 00          0251*  @arg: db 0  ; screen mode parameter
041BDA             0252*  @end:
041BDA             0253*  
041BDA             0254*  ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
041BDA             0255*  ; inputs: a is scaling mode, 1=on, 0=off
041BDA             0256*  ; note: default setting on boot is scaling ON
041BDA             0257*  vdu_set_scaling:
041BDA 32 EC 1B 04 0258*  	ld (@arg),a
041BDE 21 E9 1B 04 0259*  	ld hl,@cmd
041BE2 01 04 00 00 0260*  	ld bc,@end-@cmd
041BE6 5B DF       0261*  	rst.lil $18
041BE8 C9          0262*  	ret
041BE9 17 00 C0    0263*  @cmd: db 23,0,0xC0
041BEC 00          0264*  @arg: db 0  ; scaling on/off
041BED             0265*  @end:
041BED             0266*  
041BED             0267*  ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
041BED             0268*  ; inputs: hl=bufferId
041BED             0269*  vdu_buff_select:
041BED 22 FF 1B 04 0270*  	ld (@bufferId),hl
041BF1 21 FC 1B 04 0271*  	ld hl,@cmd
041BF5 01 05 00 00 0272*  	ld bc,@end-@cmd
041BF9 5B DF       0273*  	rst.lil $18
041BFB C9          0274*  	ret
041BFC 17 1B 20    0275*  @cmd: db 23,27,0x20
041BFF 00 00       0276*  @bufferId: dw 0x0000
041C01 00          0277*  @end: db 0x00 ; padding
041C02             0278*  
041C02             0279*  ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
041C02             0280*  ; inputs: a=format; bc=width; de=height
041C02             0281*  ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
041C02             0282*  ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
041C02             0283*  ; 0 	RGBA8888 (4-bytes per pixel)
041C02             0284*  ; 1 	RGBA2222 (1-bytes per pixel)
041C02             0285*  ; 2 	Mono/Mask (1-bit per pixel)
041C02             0286*  ; 3 	Reserved for internal use by VDP (“native” format)
041C02             0287*  vdu_bmp_create:
041C02 ED 43 1E 1C 0288*      ld (@width),bc
       04          
041C07 ED 53 20 1C 0289*      ld (@height),de
       04          
041C0C 32 22 1C 04 0290*      ld (@fmt),a
041C10 21 1B 1C 04 0291*  	ld hl,@cmd
041C14 01 08 00 00 0292*  	ld bc,@end-@cmd
041C18 5B DF       0293*  	rst.lil $18
041C1A C9          0294*  	ret
041C1B 17 1B 21    0295*  @cmd:       db 23,27,0x21
041C1E 00 00       0296*  @width:     dw 0x0000
041C20 00 00       0297*  @height:    dw 0x0000
041C22 00          0298*  @fmt:       db 0x00
041C23             0299*  @end:
041C23             0300*  
041C23             0301*  ; load an rgba2222 image file to a working buffer and make it an rgba8888 bitmap in a target buffer
041C23             0302*  ; inputs: bc,de image width,height ; hl = targetBufferId ; ix = file size ; iy = pointer to filename
041C23             0303*  vdu_load_img_rgba2_to_8:
041C23             0304*  ; backup the target buffer id and image dimensions
041C23 E5          0305*      push hl
041C24 D5          0306*      push de
041C25 C5          0307*      push bc
041C26             0308*  ; load the rgba2 image to working buffer 65534
041C26 21 FE FF 00 0309*      ld hl,65534 ; temporary working buffer id
041C2A CD 2D 1D 04 0310*  	call vdu_load_buffer_from_file
041C2E             0311*  ; restore the image dimensions and target buffer id
041C2E C1          0312*      pop bc
041C2F D1          0313*      pop de
041C30 E1          0314*      pop hl
041C31             0315*  ; fall through to vdu_rgba2_to_8
041C31             0316*  
041C31             0317*  ; https://discord.com/channels/1158535358624039014/1158536711148675072/1257757461729771771
041C31             0318*  ; ok, so the "expand bitmap" can be used, when coupled with a "reverse" - the expanded bitmap _doesn't_ come out "right" otherwise, cos of endian-ness
041C31             0319*  ; the "expand bitmap" command is:
041C31             0320*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
041C31             0321*  ; and then to reverse the byte order to fix endian-ness:
041C31             0322*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
041C31             0323*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
041C31             0324*  ; VDU 23,27,&20,targetBufferID%;
041C31             0325*  ; VDU 23,27,&21,width%;height%;0
041C31             0326*  ; -------------------------------------------------------------------
041C31             0327*  ; inputs: bc,de image width,height ; hl = targetBufferId
041C31             0328*  ; prerequisites: rgba2 image data loaded into workingBufferId 65534
041C31             0329*  vdu_rgba2_to_8:
041C31             0330*  ; load the image dimensions and buffer id parameters
041C31 ED 43 8D 1C 0331*      ld (@width),bc
       04          
041C36 ED 53 8F 1C 0332*      ld (@height),de
       04          
041C3B 22 72 1C 04 0333*      ld (@bufferId0),hl
041C3F 22 7F 1C 04 0334*      ld (@bufferId2),hl
041C43 22 88 1C 04 0335*      ld (@bufferId1),hl
041C47             0336*  ; clean up bytes that got stomped on by the ID loads
041C47 3E 48       0337*      ld a,0x48
041C49 32 74 1C 04 0338*      ld (@bufferId0+2),a
041C4D 3E 17       0339*      ld a,23
041C4F 32 8A 1C 04 0340*      ld (@bufferId1+2),a
041C53 3E 18       0341*      ld a,24
041C55 32 81 1C 04 0342*      ld (@bufferId2+2),a
041C59 AF          0343*      xor a
041C5A 32 91 1C 04 0344*      ld (@height+2),a
041C5E             0345*  ; send the vdu command strings
041C5E 21 69 1C 04 0346*      ld hl,@beg
041C62 01 29 00 00 0347*      ld bc,@end-@beg
041C66 5B DF       0348*      rst.lil $18
041C68 C9          0349*      ret
041C69             0350*  @beg:
041C69             0351*  ; Command 14: Consolidate blocks in a buffer
041C69             0352*  ; VDU 23, 0, &A0, bufferId; 14
041C69 17 00 A0    0353*      db 23,0,0xA0
041C6C FE FF       0354*      dw 65534 ; workingBufferId
041C6E 0E          0355*      db 14 ; consolidate blocks
041C6F             0356*  ; the "expand bitmap" command is:
041C6F             0357*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
041C6F 17 00 A0    0358*      db 23,0,0xA0
041C72 00 00       0359*  @bufferId0: dw 0x0000 ; targetBufferId
041C74 48          0360*      db 0x48 ; given as decimal command 72 in the docs
041C75 02          0361*      db 2 ; options mask: %00000011 is the number of bits per pixel in the source bitmap
041C76 FE FF       0362*      dw 65534 ; sourceBufferId
041C78 00 7F BF FF 0363*      db 0x00,0x7F,0xBF,0xFF ; expanding to bytes by bit-shifting?
041C7C             0364*  ; reverse the byte order to fix endian-ness:
041C7C             0365*  ; Command 24: Reverse the order of data of blocks within a buffer
041C7C             0366*  ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
041C7C             0367*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
041C7C 17 00 A0    0368*      db 23,0,0xA0
041C7F 00 00       0369*  @bufferId2:    dw 0x0000 ; targetBufferId
041C81 18          0370*      db 24 ; reverse byte order
041C82 04          0371*      db 4 ; option: Reverse data of the value size within chunk of data of the specified size
041C83 04 00       0372*      dw 4 ; size (4 bytes)
041C85             0373*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
041C85             0374*  ; VDU 23,27,&20,targetBufferID%;
041C85 17 1B 20    0375*      db 23,27,0x20 ; select bitmap
041C88 00 00       0376*  @bufferId1: dw 0x0000 ; targetBufferId
041C8A             0377*  ; VDU 23,27,&21,width%;height%;0
041C8A 17 1B 21    0378*      db 23,27,0x21 ; create bitmap from buffer
041C8D 00 00       0379*  @width: dw 0x0000
041C8F 00 00       0380*  @height: dw 0x0000
041C91 00          0381*      db 0x00 ; rgba8888 format
041C92             0382*  @end:
041C92             0383*  
041C92             0384*  ; scratch variables
041C92 00 00 00    0385*  bufferId0: dl 0x000000
041C95 00 00 00    0386*  bufferId1: dl 0x000000
041C98             0387*  
041C98             0388*  ; load a vdu buffer from local memory
041C98             0389*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
041C98             0390*  vdu_load_buffer:
041C98 ED 43 C1 1C 0391*      ld (@length),bc
       04          
041C9D D5          0392*      push de ; save data pointer
041C9E             0393*  ; send the vdu command string
041C9E 7D          0394*      ld a,l
041C9F 32 BE 1C 04 0395*      ld (@bufferId),a
041CA3 7C          0396*      ld a,h
041CA4 32 BF 1C 04 0397*      ld (@bufferId+1),a
041CA8 21 BB 1C 04 0398*      ld hl,@cmd
041CAC 01 08 00 00 0399*      ld bc,@end-@cmd
041CB0 5B DF       0400*      rst.lil $18
041CB2             0401*  ; send the buffer data
041CB2 E1          0402*      pop hl ; pointer to data
041CB3 ED 4B C1 1C 0403*      ld bc,(@length)
       04          
041CB8 5B DF       0404*      rst.lil $18 ; send it
041CBA C9          0405*      ret
041CBB             0406*  ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
041CBB 17 00 A0    0407*  @cmd:       db 23,0,0xA0
041CBE 00 00       0408*  @bufferId:	dw 0x0000
041CC0 00          0409*  		    db 0 ; load buffer
041CC1 00 00       0410*  @length:	dw 0x0000
041CC3 00          0411*  @end: db 0 ; padding
041CC4             0412*  
041CC4             0413*  ; clear a buffer
041CC4             0414*  ; inputs: hl = bufferId
041CC4             0415*  vdu_clear_buffer:
041CC4 7D          0416*      ld a,l
041CC5 32 DC 1C 04 0417*      ld (@bufferId),a
041CC9 7C          0418*      ld a,h
041CCA 32 DD 1C 04 0419*      ld (@bufferId+1),a
041CCE 21 D9 1C 04 0420*      ld hl,@cmd
041CD2 01 06 00 00 0421*      ld bc,@end-@cmd
041CD6 5B DF       0422*      rst.lil $18
041CD8 C9          0423*      ret
041CD9 17 00 A0    0424*  @cmd:       db 23,0,0xA0
041CDC 00 00       0425*  @bufferId:	dw 0x0000
041CDE 02          0426*  		    db 2 ; clear buffer
041CDF             0427*  @end:
041CDF             0428*  
041CDF             0429*  vdu_clear_all_buffers:
041CDF             0430*  ; clear all buffers
041CDF 21 EA 1C 04 0431*      ld hl,@beg
041CE3 01 06 00 00 0432*      ld bc,@end-@beg
041CE7 5B DF       0433*      rst.lil $18
041CE9 C9          0434*      ret
041CEA 17 00 A0    0435*  @beg: db 23,0,$A0
041CED FF FF       0436*        dw -1 ; clear all buffers
041CEF 02          0437*        db 2  ; command 2: clear a buffer
041CF0             0438*  @end:
041CF0             0439*  
041CF0             0440*  ; Command 14: Consolidate blocks in a buffer
041CF0             0441*  vdu_consolidate_buffer:
041CF0             0442*  ; set parameters for vdu call
041CF0 7D          0443*      ld a,l
041CF1 32 08 1D 04 0444*      ld (@bufferId),a
041CF5 7C          0445*      ld a,h
041CF6 32 09 1D 04 0446*      ld (@bufferId+1),a
041CFA 21 05 1D 04 0447*      ld hl,@beg
041CFE 01 06 00 00 0448*      ld bc,@end-@beg
041D02 5B DF       0449*      rst.lil $18
041D04 C9          0450*      ret
041D05             0451*  ; VDU 23, 0, &A0, bufferId; 14
041D05 17 00 A0    0452*  @beg: db 23,0,0xA0
041D08 00 00       0453*  @bufferId: dw 0x0000
041D0A 0E          0454*             db 14
041D0B             0455*  @end:
041D0B             0456*  
041D0B             0457*  ; load an image file to a buffer and make it a bitmap
041D0B             0458*  ; inputs: a = image type ; bc,de image width,height ; hl = bufferId ; ix = file size ; iy = pointer to filename
041D0B             0459*  vdu_load_img:
041D0B             0460*  ; back up image type and dimension parameters
041D0B 22 92 1C 04 0461*      ld (bufferId0),hl
041D0F F5          0462*      push af
041D10 C5          0463*  	push bc
041D11 D5          0464*  	push de
041D12             0465*  ; load the image
041D12 CD 2D 1D 04 0466*  	call vdu_load_buffer_from_file
041D16             0467*  ; now make it a bitmap
041D16 2A 92 1C 04 0468*      ld hl,(bufferId0)
041D1A CD F0 1C 04 0469*      call vdu_consolidate_buffer
041D1E 2A 92 1C 04 0470*      ld hl,(bufferId0)
041D22 CD ED 1B 04 0471*      call vdu_buff_select
041D26 D1          0472*  	pop de ; image height
041D27 C1          0473*  	pop bc ; image width
041D28 F1          0474*  	pop af ; image type
041D29 C3 02 1C 04 0475*  	jp vdu_bmp_create ; will return to caller from there
041D2D             0476*  
041D2D             0477*  ; inputs: hl = bufferId; iy = pointer to filename
041D2D             0478*  vdu_load_buffer_from_file:
041D2D 22 92 1C 04 0479*      ld (bufferId0),hl
041D31             0480*  
041D31             0481*  ; clear target buffer
041D31 CD C4 1C 04 0482*      call vdu_clear_buffer
041D35             0483*  
041D35             0484*  ; open the file in read mode
041D35             0485*  ; Open a file
041D35             0486*  ; HLU: Filename
041D35             0487*  ;   C: Mode
041D35             0488*  ; Returns:
041D35             0489*  ;   A: Filehandle, or 0 if couldn't open
041D35 FD E5       0490*  	push iy ; pointer to filename
041D37 E1          0491*  	pop hl
041D38 0E 01       0492*  	ld c,fa_read
041D3A             0493*      MOSCALL mos_fopen
041D3A 3E 0A       0001*M 			LD	A, function
041D3C 5B CF       0002*M 			RST.LIL	08h
041D3E 32 79 1D 04 0494*      ld (@filehandle),a
041D42             0495*  
041D42             0496*  @read_file:
041D42             0497*  ; Read a block of data from a file
041D42             0498*  ;   C: Filehandle
041D42             0499*  ; HLU: Pointer to where to write the data to
041D42             0500*  ; DEU: Number of bytes to read
041D42             0501*  ; Returns:
041D42             0502*  ; DEU: Number of bytes read
041D42 3A 79 1D 04 0503*      ld a,(@filehandle)
041D46 4F          0504*      ld c,a
041D47 21 00 E0 B7 0505*      ld hl,filedata
041D4B 11 00 20 00 0506*      ld de,8192 ; max we can read into onboard sram at one time
041D4F             0507*      MOSCALL mos_fread
041D4F 3E 1A       0001*M 			LD	A, function
041D51 5B CF       0002*M 			RST.LIL	08h
041D53             0508*  
041D53             0509*  ; ; DEBUG: print chunk size
041D53             0510*  ;     push de
041D53             0511*  ;     pop hl
041D53             0512*  ;     call printDec
041D53             0513*  ;     call printNewLine
041D53             0514*  
041D53             0515*  ; test de for zero bytes read
041D53 21 00 00 00 0516*      ld hl,0
041D57 AF          0517*      xor a ; clear carry
041D58 ED 52       0518*      sbc hl,de
041D5A CA 70 1D 04 0519*      jp z,@close_file
041D5E             0520*  
041D5E             0521*  ; load a vdu buffer from local memory
041D5E             0522*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
041D5E 2A 92 1C 04 0523*      ld hl,(bufferId0)
041D62 D5          0524*      push de ; chunksize
041D63 C1          0525*      pop bc
041D64 11 00 E0 B7 0526*      ld de,filedata
041D68 CD 98 1C 04 0527*      call vdu_load_buffer
041D6C             0528*  
041D6C             0529*  ; ; print progress breadcrumbs
041D6C             0530*  ;     ld a,'.'
041D6C             0531*  ;     rst.lil 10h
041D6C             0532*  
041D6C             0533*  ; read the next block
041D6C C3 42 1D 04 0534*      jp @read_file
041D70             0535*  
041D70             0536*  ; close the file
041D70             0537*  @close_file:
041D70 3A 79 1D 04 0538*      ld a,(@filehandle)
041D74             0539*      MOSCALL mos_fclose
041D74 3E 0B       0001*M 			LD	A, function
041D76 5B CF       0002*M 			RST.LIL	08h
041D78 C9          0540*      ret ; vdu_load_buffer_from_file
041D79             0541*  
041D79 00          0542*  @filehandle: db 0 ; file handle
041D7A 00 00 00    0543*  @fil: dl 0 ; pointer to FIL struct
041D7D             0544*  
041D7D 00 00 00    0545*  @chunkpointer: dl 0 ; pointer to current chunk
041D80             0546*  
041D80             0547*  ; File information structure (FILINFO)
041D80             0548*  @filinfo:
041D80 00 00 00 00 0549*  @filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
041D84 00 00       0550*  @filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
041D86 00 00       0551*  @filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
041D88 00          0552*  @filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
041D89 00 00 00 00 0553*  @filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
041D96 00 00 00 00 0554*  @filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041E96             0054       include "vdu_buff.inc"
041E96             0001*  ; VDP Buffered Commands API
041E96             0002*  ; https://agonconsole8.github.io/agon-docs/VDP---Buffered-Commands-API.html
041E96             0003*  
041E96             0004*  ; VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
041E96             0005*  ; This command is used to store a data block (a sequence of bytes)
041E96             0006*  ; in a buffer on the VDP. The exact nature of this data may vary.
041E96             0007*  ; It could be a sequence of VDU commands which can be executed
041E96             0008*  ; later, a bitmap, a sound sample, or just a sequence of bytes.
041E96             0009*  ; When used for a sequence of VDU commands, this effectively
041E96             0010*  ; allows for functions or stored procedures to be created.
041E96             0011*  
041E96             0012*  ; This is the most common command to use to send data to the VDP.
041E96             0013*  ; Typically you will call command 2 first to ensure that the
041E96             0014*  ; buffer is empty, and then make a series of calls to this command
041E96             0015*  ; to send data to the buffer.
041E96             0016*  
041E96             0017*  ; The bufferId is a 16-bit integer that identifies the buffer to
041E96             0018*  ; write to. Writing to the same buffer ID multiple times will add
041E96             0019*  ; new blocks to that buffer. This allows a buffer to be built up
041E96             0020*  ; over time, essentially allowing for a command to be sent across
041E96             0021*  ; to the VDP in multiple separate packets.
041E96             0022*  
041E96             0023*  ; Whilst the length of an individual block added using this command
041E96             0024*  ; is restricted to 65535 bytes (as the largest value that can be
041E96             0025*  ; sent in a 16-bit number) the total size of a buffer is not
041E96             0026*  ; restricted to this size, as multiple blocks can be added to a
041E96             0027*  ; buffer. Given how long it takes to send data to the VDP it is
041E96             0028*  ; advisable to send data across in smaller chunks, such as 1kb of
041E96             0029*  ; data or less at a time.
041E96             0030*  
041E96             0031*  ; As writing to a single buffer ID is cumulative with this command,
041E96             0032*  ; care should be taken to ensure that the buffer is cleared out
041E96             0033*  ; before writing to it.
041E96             0034*  
041E96             0035*  ; When building up a complex sequence of commands it is often
041E96             0036*  ; advisable to use multiple blocks within a buffer. Typically
041E96             0037*  ; this is easier to code, as otherwise working out exactly how
041E96             0038*  ; many bytes long a command sequence is can be can be onerously
041E96             0039*  ; difficult. It is also easier to modify a command sequences that
041E96             0040*  ; are broken up into multiple blocks.
041E96             0041*  
041E96             0042*  ; As mentioned above it is advisable to send large pieces of data,
041E96             0043*  ; such as bitmaps or sound samples, in smaller chunks. In between
041E96             0044*  ; each packet of data sent to a buffer, the user can then perform
041E96             0045*  ; other operations, such as updating the screen to indicate
041E96             0046*  ; progress. This allows for long-running operations to be performed
041E96             0047*  ; without blocking the screen, and larger amounts of data to be
041E96             0048*  ; transferred over to the VDP than may otherwise be practical given
041E96             0049*  ; the limitations of the eZ80.
041E96             0050*  
041E96             0051*  ; If a buffer ID of 65535 is used then this command will be
041E96             0052*  ; ignored, and the data discarded. This is because this buffer ID
041E96             0053*  ; is reserved for special functions.
041E96             0054*  
041E96             0055*  ; Using buffers for bitmaps
041E96             0056*  
041E96             0057*  ; Whilst it is advisable to send bitmaps over in multiple blocks,
041E96             0058*  ; they cannot be used if they are spread over multiple blocks.
041E96             0059*  ; To use a bitmap its data must be in a single contiguous block,
041E96             0060*  ; and this is achieved by using the “consolidate” command &0E.
041E96             0061*  
041E96             0062*  ; Once you have a block that is ready to be used for a bitmap,
041E96             0063*  ; the buffer must be selected, and then a bitmap created for that
041E96             0064*  ; buffer using the bitmap and sprites API. This is done with the
041E96             0065*  ; following commands:
041E96             0066*  
041E96             0067*  ; VDU 23, 27, &20, bufferId;              : REM Select bitmap (using a buffer ID)
041E96             0068*  ; VDU 23, 27, &21, width; height; format  : REM Create bitmap from buffer
041E96             0069*  
041E96             0070*  ; Until the “create bitmap” call has been made the buffer cannot
041E96             0071*  ; be used as a bitmap. That is because the system needs to
041E96             0072*  ; understand the dimensions of the bitmap, as well as the format
041E96             0073*  ; of the data. Usually this only needs to be done once. The format
041E96             0074*  ; is given as an 8-bit value, with the following values supported:
041E96             0075*  ; Value 	Type 	Description
041E96             0076*  ; 0 	RGBA8888 	RGBA, 8-bits per channel, with bytes ordered sequentially for red, green, blue and alpha
041E96             0077*  ; 1 	RGBA2222 	RGBA, 2-bits per channel, with bits ordered from highest bits as alpha, blue, green and red
041E96             0078*  ; 2 	Mono 	Monochrome, 1-bit per pixel
041E96             0079*  
041E96             0080*  ; The existing bitmap API uses an 8-bit number to select bitmaps,
041E96             0081*  ; and these are automatically stored in buffers numbered 64000-64255
041E96             0082*  ; (&FA00-&FAFF). Working out the buffer number for a bitmap is
041E96             0083*  ; simply a matter of adding 64000. All bitmaps created with that
041E96             0084*  ; API will be RGBA8888 format.
041E96             0085*  
041E96             0086*  ; There is one other additional call added to the bitmap and
041E96             0087*  ; sprites API, which allows for bitmaps referenced with a
041E96             0088*  ; buffer ID to be added to sprites. This is done with the
041E96             0089*  ; following command:
041E96             0090*  
041E96             0091*  ; VDU 23, 27, &26, bufferId;              : REM Add bitmap to the current sprite
041E96             0092*  
041E96             0093*  ; This command otherwise works identically to VDU 23, 27, 6.
041E96             0094*  
041E96             0095*  ; It should be noted that it is possible to modify the buffer
041E96             0096*  ; that a bitmap is stored in using the “adjust buffer contents”
041E96             0097*  ; and “reverse contents” commands (5 and 24 respectively). This
041E96             0098*  ; can allow you to do things such as changing colours in a bitmap,
041E96             0099*  ; or flipping an image horizontally or vertically. This will even
041E96             0100*  ; work on bitmaps that are being used inside sprites.
041E96             0101*  
041E96             0102*  ; Using commands targetting a buffer that create new blocks,
041E96             0103*  ; such as “consolidate” or “split”, will invalidate the bitmap
041E96             0104*  ; and remove it from use.
041E96             0105*  
041E96             0106*  ; Using buffers for sound samples
041E96             0107*  
041E96             0108*  ; Much like with bitmaps, it is advisable to send samples over
041E96             0109*  ; to the VDP in multiple blocks for the same reasons.
041E96             0110*  
041E96             0111*  ; In contrast to bitmaps, the sound system can play back samples
041E96             0112*  ; that are spread over multiple blocks, so there is no need to
041E96             0113*  ; consolidate buffers. As a result of this, the sample playback
041E96             0114*  ; system is also more tolerant of modifications being made to
041E96             0115*  ; the buffer after a sample has been created from it, even if
041E96             0116*  ; the sample is currently playing. It should be noted that
041E96             0117*  ; splitting a buffer may result in unexpected behaviour if
041E96             0118*  ; the sample is currently playing, such as skipping to other
041E96             0119*  ; parts of the sample.
041E96             0120*  
041E96             0121*  ; Once you have a buffer that contains block(s) that are ready
041E96             0122*  ; to be used for a sound sample, the following command must be
041E96             0123*  ; used to indicate that a sample should be created from that buffer:
041E96             0124*  
041E96             0125*  ; VDU 23, 0, &85, 0, 5, 2, bufferId; format
041E96             0126*  
041E96             0127*  ; The format parameter is an 8-bit value that indicates the
041E96             0128*  ; format of the sample data. The following values are supported:
041E96             0129*  ; Value 	Description
041E96             0130*  ; 0 	8-bit signed, 16KHz
041E96             0131*  ; 1 	8-bit unsigned, 16KHz
041E96             0132*  
041E96             0133*  ; Once a sample has been created in this way, the sample can
041E96             0134*  ; be selected for use on a channel using the following command:
041E96             0135*  
041E96             0136*  ; VDU 23, 0, &85, channel, 4, 8, bufferId;
041E96             0137*  
041E96             0138*  ; Samples uploaded using the existing “load sample” command
041E96             0139*  ; (VDU 23, 0, &85, sampleNumber, 5, 0, length; lengthHighByte, <sample data>)
041E96             0140*  ; are also stored in buffers automatically. A sample number using this system is in
041E96             0141*  ; the range of -1 to -128, but these are stored in the range 64256-64383 (&FB00-&FB7F).
041E96             0142*  ; To map a number to a buffer range, you need to negate it, subtract 1, and then add
041E96             0143*  ; it to 64256. This means sample number -1 is stored in buffer 64256, -2 is stored in
041E96             0144*  ; buffer 64257, and so on.
041E96             0145*  ; Command 1: Call a buffer
041E96             0146*  
041E96             0147*  ; VDU 23, 0 &A0, bufferId; 1
041E96             0148*  
041E96             0149*  ; This command will attempt to execute all of the commands
041E96             0150*  ; stored in the buffer with the given ID. If the buffer does
041E96             0151*  ; not exist, or is empty, then this command will do nothing.
041E96             0152*  
041E96             0153*  ; Essentially, this command passes the contents of the buffer
041E96             0154*  ; to the VDP’s VDU command processor system, and executes them
041E96             0155*  ; as if they were sent directly to the VDP.
041E96             0156*  
041E96             0157*  ; As noted against command 0, it is possible to build up a
041E96             0158*  ; buffer over time by sending across multiple commands to write
041E96             0159*  ; to the same buffer ID. When calling a buffer with multiple
041E96             0160*  ; blocks, the blocks are executed in order.
041E96             0161*  
041E96             0162*  ; Care should be taken when using this command within a buffer,
041E96             0163*  ; as it is possible to create an infinite loop. For instance,
041E96             0164*  ; if a buffer contains a command to call itself, then this will
041E96             0165*  ; result in an infinite loop. This will cause the VDP to hang,
041E96             0166*  ; and the only way to recover from this is to reset the VDP.
041E96             0167*  
041E96             0168*  ; Using a bufferId of -1 (65535) will cause the current buffer
041E96             0169*  ; to be executed. This can be useful for creating loops within
041E96             0170*  ; a buffer. It will be ignored if used outside of a buffered
041E96             0171*  ; command sequence.
041E96             0172*  
041E96             0173*  ; Command 2: Clear a buffer
041E96             0174*  ; VDU 23, 0 &A0, bufferId; 2
041E96             0175*  
041E96             0176*  ; This command will clear the buffer with the given ID. If
041E96             0177*  ; the buffer does not exist then this command will do nothing.
041E96             0178*  
041E96             0179*  ; Please note that this clears out all of the blocks sent to
041E96             0180*  ; a buffer via command 0, not just the last one. i.e. if you
041E96             0181*  ; have built up a buffer over time by sending multiple commands
041E96             0182*  ; to write to the same buffer ID, this command will clear out
041E96             0183*  ; all of those commands.
041E96             0184*  
041E96             0185*  ; Calling this command with a bufferId value of -1 (65535) will
041E96             0186*  ; clear out all buffers.
041E96             0187*  
041E96             0188*  ; Command 3: Create a writeable buffer
041E96             0189*  ; VDU 23, 0 &A0, bufferId; 3, length;
041E96             0190*  ; This command will create a new writeable buffer with the given
041E96             0191*  ; ID. If a buffer with the given ID already exists then this
041E96             0192*  ; command will do nothing. This command is primarily intended
041E96             0193*  ; for use to create a buffer that can be used to capture output
041E96             0194*  ; using the “set output stream” command (see below), or to store
041E96             0195*  ; data that can be used for other commands.
041E96             0196*  
041E96             0197*  ; It is generally quite rare that you will want to use this
041E96             0198*  ; command. Typically you will instead want to use command 0
041E96             0199*  ; to write data to a buffer. It is not necessary to use this
041E96             0200*  ; command before using command 0, and indeed doing so will
041E96             0201*  ; lead to errors as you will end up with two blocks in the
041E96             0202*  ; buffer, the first of which will be empty. If you do wish
041E96             0203*  ; to use this command to create a buffer for data and then
041E96             0204*  ; write to it, you would need to use operation 2 of command 5,
041E96             0205*  ; the “set” operation in the “buffer adjust” command, to set a
041E96             0206*  ; sequence of bytes in the buffer to the data you want to write.
041E96             0207*  ; This is not recommended, as it is much easier to just use
041E96             0208*  ; command 0 to write a data block to a buffer.
041E96             0209*  
041E96             0210*  ; This new buffer will be a single empty single block upon
041E96             0211*  ; creation, containing zeros.
041E96             0212*  
041E96             0213*  ; The length parameter is a 16-bit integer that specifies
041E96             0214*  ; the maximum size of the buffer. This is the maximum number
041E96             0215*  ; of bytes that can be stored in the buffer. If the buffer
041E96             0216*  ; is full then no more data can be written to it, and subsequent
041E96             0217*  ; writes will be ignored.
041E96             0218*  
041E96             0219*  ; After creating a buffer with this command it is possible to
041E96             0220*  ; use command 0 to write further blocks to the buffer, however
041E96             0221*  ; this is probably not advisable.
041E96             0222*  
041E96             0223*  ; A bufferId of -1 (65535) and 0 will be ignored, as these
041E96             0224*  ; values have special meanings for writable buffers. See command 4.
041E96             0225*  
041E96             0226*  ; Command 4: Set output stream to a buffer
041E96             0227*  ; VDU 23, 0 &A0, bufferId; 4
041E96             0228*  
041E96             0229*  ; Sets then current output stream to the buffer with the given ID.
041E96             0230*  ; With two exceptions, noted below, this needs to be a writable
041E96             0231*  ; buffer created with command 3. If the buffer does not exist,
041E96             0232*  ; or the first block within the buffer is not writable, then
041E96             0233*  ; this command will do nothing.
041E96             0234*  
041E96             0235*  ; Following this command, any subsequent VDU commands that send
041E96             0236*  ; response packets will have those packets written to the specified
041E96             0237*  ; output buffer. This allows the user to capture the response
041E96             0238*  ; packets from a command sent to the VDP.
041E96             0239*  
041E96             0240*  ; By default, the output stream (for the main VDU command processor)
041E96             0241*  ; is the communications channel from the VDP to MOS running on the
041E96             0242*  ; eZ80.
041E96             0243*  
041E96             0244*  ; Passing a buffer ID of -1 (65535) to this command will
041E96             0245*  ; remove/detach the output buffer. From that point onwards,
041E96             0246*  ; any subsequent VDU commands that send response packets will
041E96             0247*  ; have those responses discarded/ignored.
041E96             0248*  
041E96             0249*  ; Passing a buffer ID of 0 to this command will set the output
041E96             0250*  ; buffer back to its original value for the current command stream.
041E96             0251*  ; Typically that will be the communications channel from the VDP to
041E96             0252*  ; MOS running on the eZ80, but this may not be the case if a nested
041E96             0253*  ; call has been made.
041E96             0254*  
041E96             0255*  ; When used inside a buffered command sequence, this command will
041E96             0256*  ; only affect the output stream for that sequence of commands, and
041E96             0257*  ; any other buffered command sequences that are called from within
041E96             0258*  ; that sequence. Once the buffered command sequence has completed,
041E96             0259*  ; the output stream will effectively be reset to its original value.
041E96             0260*  
041E96             0261*  ; It is strongly recommended to only use this command from within a
041E96             0262*  ; buffered command sequence. Whilst it is possible to use this
041E96             0263*  ; command from within a normal VDU command sequence, it is not
041E96             0264*  ; recommended as it may cause unexpected behaviour. If you do use
041E96             0265*  ; it in that context, it is very important to remember to restore
041E96             0266*  ; the original output channel using VDU 23, 0, &A0, 0; 4. (In the
041E96             0267*  ; future, this command may be disabled from being used outside of
041E96             0268*  ; a buffered command sequence.)
041E96             0269*  
041E96             0270*  ; At present, writable buffers can only be written to until the end
041E96             0271*  ; of the buffer has been reached; once that happens no more data
041E96             0272*  ; will be written to the buffer. It is not currently possible to
041E96             0273*  ; “rewind” an output stream. It is therefore advisable to ensure
041E96             0274*  ; that the buffer is large enough to capture all of the data that
041E96             0275*  ; is expected to be written to it. The only current way to “rewind”
041E96             0276*  ; an output stream would be to clear the buffer and create a new
041E96             0277*  ; one, and then call set output stream again with the newly created
041E96             0278*  ; buffer.
041E96             0279*  
041E96             0280*  ; Command 5: Adjust buffer contents
041E96             0281*  ; VDU 23, 0, &A0, bufferId; 5, operation, offset; [count;] <operand>, [arguments]
041E96             0282*  
041E96             0283*  ; This command will adjust the contents of a buffer, at a given
041E96             0284*  ; offset. The exact nature of the adjustment will depend on the
041E96             0285*  ; operation used.
041E96             0286*  
041E96             0287*  ; Passing a bufferId of -1 (65535) to this command will adjust
041E96             0288*  ; the contents of the current buffer. This will only work if this
041E96             0289*  ; command is used within a buffered command sequence, otherwise the
041E96             0290*  ; command will not do anything.
041E96             0291*  
041E96             0292*  ; The basic set of adjustment operations are as follows:
041E96             0293*  ; Operation 	Description
041E96             0294*  ; 0 	NOT
041E96             0295*  ; 1 	Negate
041E96             0296*  ; 2 	Set value
041E96             0297*  ; 3 	Add
041E96             0298*  ; 4 	Add with carry
041E96             0299*  ; 5 	AND
041E96             0300*  ; 6 	OR
041E96             0301*  ; 7 	XOR
041E96             0302*  
041E96             0303*  ; All of these operations will modify a byte found at the given
041E96             0304*  ; offset in the buffer. The only exception to that is the “Add with
041E96             0305*  ; carry” operation, which will also store the “carry” value in the
041E96             0306*  ; byte at the next offset. With the exception of NOT and Negate,
041E96             0307*  ; each command requires an operand value to be specified.
041E96             0308*  
041E96             0309*  ; To flip the bits of a byte at offset 12 in buffer 3, you would
041E96             0310*  ; need to use the NOT operation, and so the following command would
041E96             0311*  ; be used:
041E96             0312*  
041E96             0313*  ; VDU 23, 0, &A0, 3; 5, 0, 12;
041E96             0314*  
041E96             0315*  ; To add 42 to the byte at offset 12 in buffer 3, you would need
041E96             0316*  ; to use the Add operation, and so the following command would be
041E96             0317*  ; used:
041E96             0318*  
041E96             0319*  ; VDU 23, 0, &A0, 3; 5, 3, 12; 42
041E96             0320*  
041E96             0321*  ; When using add with carry, the carry value is stored in the byte
041E96             0322*  ; at the next offset. So to add 42 to the byte at offset 12 in
041E96             0323*  ; buffer 3, and store the carry value in the byte at offset 13,
041E96             0324*  ; you would need to use the Add with carry operation, and so the
041E96             0325*  ; following command would be used:
041E96             0326*  
041E96             0327*  ; VDU 23, 0, &A0, 3; 5, 4, 12; 42
041E96             0328*  
041E96             0329*  ; Advanced operations
041E96             0330*  
041E96             0331*  ; Whilst these operations are useful, they are not particularly
041E96             0332*  ; powerful as they only operate one one byte at a time, with a
041E96             0333*  ; fixed operand value, and potentially cannot reach all bytes in
041E96             0334*  ; a buffer. To address this, the API supports a number of advanced
041E96             0335*  ; operations.
041E96             0336*  
041E96             0337*  ; The operation value used is an 8-bit value that can have bits
041E96             0338*  ; set to modify the behaviour of the operation. The following bits
041E96             0339*  ; are defined:
041E96             0340*  ; Bit 	Description
041E96             0341*  ; &10 	Use “advanced” offsets
041E96             0342*  ; &20 	Operand is a buffer-fetched value (buffer ID and an offset)
041E96             0343*  ; &40 	Multiple target values should be adjusted
041E96             0344*  ; &80 	Multiple operand values should be used
041E96             0345*  
041E96             0346*  ; These bits can be combined together to modify the behaviour of
041E96             0347*  ; the operation.
041E96             0348*  
041E96             0349*  ; Fundamentally, this command adjusts values of a buffer at a given
041E96             0350*  ; offset one byte at a time. When either of the “multiple” variants
041E96             0351*  ; are used, a 16-bit count must be provided to indicate how many
041E96             0352*  ; bytes should be altered.
041E96             0353*  
041E96             0354*  ; Advanced offsets are sent as a 24-bit value in little-endian
041E96             0355*  ; order, which can allow for buffers that are larger than 64kb
041E96             0356*  ; to be adjusted. If the top-bit of this 24-bit value is set, then
041E96             0357*  ; the 16-bit value immediately following the offset is used as a
041E96             0358*  ; block index number, and the remaining 23-bits of the offset value
041E96             0359*  ; are used as an offset within that block. When the “advanced”
041E96             0360*  ; offset mode bit has been set then all offsets associated with
041E96             0361*  ; this command must be sent as advanced offsets.
041E96             0362*  
041E96             0363*  ; The “buffer-fetched value” mode allows for the operand value to
041E96             0364*  ; be fetched from a buffer. The operand sent as part of the
041E96             0365*  ; command in this case is a pair of 16-bit values giving the
041E96             0366*  ; buffer ID and offset to indicate where the actual operand value
041E96             0367*  ; should be fetched from. An operand buffer ID of -1 (65535) will
041E96             0368*  ; be interpretted as meaning “this buffer”, and thus can only be
041E96             0369*  ; used inside a buffered command sequence. If the advanced offset
041E96             0370*  ; mode is used, then the operand value is an advanced offset value.
041E96             0371*  
041E96             0372*  ; The “multiple target values” mode allows for multiple bytes to
041E96             0373*  ; be adjusted at once. When this mode is used, the count value
041E96             0374*  ; must be provided to indicate how many bytes should be adjusted.
041E96             0375*  ; Unless the “multiple operand values” mode is also used, the
041E96             0376*  ; operand value is used for all bytes adjusted.
041E96             0377*  
041E96             0378*  ; The “multiple operand values” mode allows for multiple operand
041E96             0379*  ; values to be used. When this mode is used, the count value must
041E96             0380*  ; be provided to indicate how many operand values should be used.
041E96             0381*  ; This can allow, for instance, to add together several bytes in a
041E96             0382*  ; buffer. When this mode is used in conjunction with the “multiple
041E96             0383*  ; target values” mode, the number of operand values must match the
041E96             0384*  ; number of target values, and the operation happens one byte at a
041E96             0385*  ; time.
041E96             0386*  
041E96             0387*  ; Some examples of advanced operations are as follows:
041E96             0388*  
041E96             0389*  ; Flip the bits of 7 bytes in buffer 3 starting at offset 12:
041E96             0390*  
041E96             0391*  ; VDU 23, 0, &A0, 3; 5, &40, 12; 7;
041E96             0392*  
041E96             0393*  ; This uses operation 0 (NOT) with the “multiple target values”
041E96             0394*  ; modifier (&40).
041E96             0395*  
041E96             0396*  ; Add 42 to each of the 7 bytes in buffer 3 starting at offset 12:
041E96             0397*  
041E96             0398*  ; VDU 23, 0, &A0, 3; 5, &43, 12; 7; 42
041E96             0399*  
041E96             0400*  ; Set the byte at offset 12 in the fourth block of buffer 3 to 42:
041E96             0401*  
041E96             0402*  ; VDU 23, 0, &A0, 3; 5, &12, 12; &80, 4; 42
041E96             0403*  
041E96             0404*  ; This is using operation 2 (Set) with the “advanced offsets”
041E96             0405*  ; modifier (&10). As BBC BASIC doesn’t natively understand how
041E96             0406*  ; to send 24-bit values it is sent as the 16-bit value 12; followed
041E96             0407*  ; by a byte with its top bit set &80 to complete the 24-bit offset
041E96             0408*  ; in little-endian order. As the top bit of the offset is set, this
041E96             0409*  ; indicates that the next 16-bit value will be a block index, 4;.
041E96             0410*  ; Finally the value to write is sent, 42.
041E96             0411*  
041E96             0412*  ; An operation like this could be used to set the position as part
041E96             0413*  ; of a draw command.
041E96             0414*  
041E96             0415*  ; Set the value in buffer 3 at offset 12 to the sum of the five
041E96             0416*  ; values 1, 2, 3, 4, 5:
041E96             0417*  
041E96             0418*  ; VDU 23, 0, &A0, 3; 5, 2, 12; 0  : REM clear out the value at
041E96             0419*  ; offset 12 (set it to 0)
041E96             0420*  ; VDU 23, 0, &A0, 3; 5, &83, 12; 5; 1, 2, 3, 4, 5
041E96             0421*  
041E96             0422*  ; AND together 7 bytes in buffer 3 starting at offset 12 with the
041E96             0423*  ; 7 bytes in buffer 4 starting at offset 42:
041E96             0424*  
041E96             0425*  ; VDU 23, 0, &A0, 3; 5, &E5, 12; 7; 4; 42;
041E96             0426*  
041E96             0427*  ; As we are working on a little-endian system, integers longer
041E96             0428*  ; than one byte are sent with their least significant byte first.
041E96             0429*  ; This means that the add with carry operation can be used to add
041E96             0430*  ; together integers of any size, so long as they are the same size.
041E96             0431*  ; To do this, both the “multiple target values” and “multiple
041E96             0432*  ; operand values” modes must be used.
041E96             0433*  
041E96             0434*  ; The following commands will add together a 16-bit, 24-bit,
041E96             0435*  ; 32-bit, and 40-bit integers, all targetting the value stored
041E96             0436*  ; in buffer 3 starting at offset 12, and all using the operand
041E96             0437*  ; value of 42:
041E96             0438*  
041E96             0439*  ; VDU 23, 0, &A0, 3; 5, &C4, 12; 2; 42;  : REM 2 bytes; a 16-bit integer
041E96             0440*  ; VDU 23, 0, &A0, 3; 5, &C4, 12; 3; 42; 0  : REM 3 bytes; a 24-bit integer
041E96             0441*  ; VDU 23, 0, &A0, 3; 5, &C4, 12; 4; 42; 0;  : REM 4 bytes; a 32-bit integer
041E96             0442*  ; VDU 23, 0, &A0, 3; 5, &C4, 12; 5; 42; 0; 0  : REM 5 bytes; a 40-bit integer
041E96             0443*  
041E96             0444*  ; Take note of how the operand value is padded out with zeros
041E96             0445*  ; to match the size of the target value. 42; is used as a base
041E96             0446*  ; to send a 16-bit value, with zeros added of either 8-bit or
041E96             0447*  ; 16-bits to pad it out to the required size. The “carry” value
041E96             0448*  ; will be stored at the next offset in the target buffer after
041E96             0449*  ; the complete target value. So for a 16-bit value, the carry
041E96             0450*  ; will be stored at offset 14, for a 24-bit value it will be stored
041E96             0451*  ; at offset 15, and so on.
041E96             0452*  
041E96             0453*  ; Command 6: Conditionally call a buffer
041E96             0454*  
041E96             0455*  ; VDU 23, 0, &A0, bufferId; 6, operation, checkBufferId; checkOffset; [arguments]
041E96             0456*  
041E96             0457*  ; This command will conditionally call a buffer if the condition
041E96             0458*  ; operation passes. This command works in a similar manner to the
041E96             0459*  ; “Adjust buffer contents” command.
041E96             0460*  
041E96             0461*  ; With this command a buffer ID of 65535 (-1) is always
041E96             0462*  ; interpretted as “current buffer”, and so can only be used
041E96             0463*  ; within a buffered command sequence. If used outside of a
041E96             0464*  ; buffered command sequence then this command will do nothing.
041E96             0465*  
041E96             0466*  ; The basic set of condition operations are as follows:
041E96             0467*  ; Operation 	Description
041E96             0468*  ; 0 	Exists (value is non-zero)
041E96             0469*  ; 1 	Not exists (value is zero)
041E96             0470*  ; 2 	Equal
041E96             0471*  ; 3 	Not equal
041E96             0472*  ; 4 	Less than
041E96             0473*  ; 5 	Greater than
041E96             0474*  ; 6 	Less than or equal
041E96             0475*  ; 7 	Greater than or equal
041E96             0476*  ; 8 	AND
041E96             0477*  ; 9 	OR
041E96             0478*  
041E96             0479*  ; The value that is being checked is fetched from the specified
041E96             0480*  ; check buffer ID and offset. With the exception of “Exists” and
041E96             0481*  ; “Not exists”, each command requires an operand value to be
041E96             0482*  ; specified to check against.
041E96             0483*  
041E96             0484*  ; The operation value used is an 8-bit value that can have bits
041E96             0485*  ; set to modify the behaviour of the operation. The following bits
041E96             0486*  ; are defined:
041E96             0487*  ; Bit value 	Description
041E96             0488*  ; &10 	Use advanced offsets
041E96             0489*  ; &20 	Operand is a buffer-fetched value (buffer ID and an offset)
041E96             0490*  
041E96             0491*  ; These modifiers can be combined together to modify the behaviour
041E96             0492*  ; of the operation.
041E96             0493*  
041E96             0494*  ; At this time, unlike with the “adjust” command, multiple target
041E96             0495*  ; values and multiple operand values are not supported. All
041E96             0496*  ; comparisons are therefore only conducted on single 8-bit values.
041E96             0497*  ; (If comparisons of 16-bit values are required, multiple calls
041E96             0498*  ; can be combined.) Support for them may be added in the future.
041E96             0499*  
041E96             0500*  ; The AND and OR operations are logical operations, and so the
041E96             0501*  ; operand value is used as a boolean value. Any non-zero value is
041E96             0502*  ; considered to be true, and zero is considered to be false. These
041E96             0503*  ; operations therefore are most useful when used with buffer-fetched
041E96             0504*  ; operand values (operations &28, &29, &38 and &39).
041E96             0505*  
041E96             0506*  ; Some examples of condition operations are as follows:
041E96             0507*  
041E96             0508*  ; Call buffer 7 if the value in buffer 12 at offset 5 exists
041E96             0509*  ; (is non-zero):
041E96             0510*  
041E96             0511*  ; VDU 23, 0, &A0, 7; 6, 0, 12; 5;
041E96             0512*  
041E96             0513*  ; Call buffer 8 if the value in buffer 12 at offset 5 does not
041E96             0514*  ; exist (is zero):
041E96             0515*  
041E96             0516*  ; VDU 23, 0, &A0, 8; 6, 1, 12; 5;
041E96             0517*  
041E96             0518*  ; Combining the above two examples is effectively equivalent to
041E96             0519*  ; “if the value exists, call buffer 7, otherwise call buffer 8”:
041E96             0520*  
041E96             0521*  ; VDU 23, 0, &A0, 7; 6, 0, 12; 5;
041E96             0522*  ; VDU 23, 0, &A0, 8; 6, 1, 12; 5;
041E96             0523*  
041E96             0524*  ; Call buffer 3 if the value in buffer 4 at offset 12 is equal to 42:
041E96             0525*  
041E96             0526*  ; VDU 23, 0, &A0, 3; 6, 2, 4; 12; 42
041E96             0527*  
041E96             0528*  ; Call buffer 5 if the value in buffer 2 at offset 7 is less than
041E96             0529*  ; the value in buffer 2 at offset 8:
041E96             0530*  
041E96             0531*  ; VDU 23, 0, &A0, 5; 6, &24, 2; 7; 2; 8;
041E96             0532*  
041E96             0533*  ; Command 7: Jump to a buffer
041E96             0534*  
041E96             0535*  ; VDU 23, 0, &A0, bufferId; 7
041E96             0536*  
041E96             0537*  ; This command will jump to the buffer with the given ID. If
041E96             0538*  ; the buffer does not exist, or is empty, then this command will
041E96             0539*  ; do nothing.
041E96             0540*  
041E96             0541*  ; This essentially works the same as the call command (command 1),
041E96             0542*  ;  except that it does not return to the caller. This command is
041E96             0543*  ;  therefore useful for creating loops.
041E96             0544*  
041E96             0545*  ; Using this command to jump to buffer 65535 (buffer ID -1) is
041E96             0546*  ; treated as a “jump to end of current buffer”. This will return
041E96             0547*  ; execution to the caller, and can be useful for exiting a loop.
041E96             0548*  
041E96             0549*  ; ## Command 8: Conditional Jump to a buffer
041E96             0550*  
041E96             0551*  ; VDU 23, 0, &A0, bufferId; 8, operation, checkBufferId; checkOffset; [arguments]
041E96             0552*  
041E96             0553*  ; This command operates in a similar manner to the “Conditionally
041E96             0554*  ; call a buffer” command (command 6), except that it will jump to
041E96             0555*  ; the buffer if the condition operation passes.
041E96             0556*  
041E96             0557*  ; As with the “Jump to a buffer” command (command 7), a jump to
041E96             0558*  ; buffer 65535 is treated as a “jump to end of current buffer”.
041E96             0559*  ; Command 9: Jump to an offset in a buffer
041E96             0560*  
041E96             0561*  ; VDU 23, 0, &A0, bufferId; 9, offset; offsetHighByte, [blockNumber;]
041E96             0562*  
041E96             0563*  ; This command will jump to the given offset in the buffer with the
041E96             0564*  ; given ID. If the buffer does not exist, or is empty, then this
041E96             0565*  ; command will do nothing.
041E96             0566*  
041E96             0567*  ; The offset in this command is always an “advanced” offset, given
041E96             0568*  ; as a 24-bit value in little-endian order. As with other uses of
041E96             0569*  ; advanced offsets, if the top-bit is set in the high byte of the
041E96             0570*  ; offset value, a block number must also be provided.
041E96             0571*  
041E96             0572*  ; When jumping to an offset, using buffer ID 65535 is treated as
041E96             0573*  ; meaning “jump within current buffer”. This can be useful for
041E96             0574*  ; creating loops within a buffer, or when building up command
041E96             0575*  ; sequences that may be copied across multiple buffers.
041E96             0576*  
041E96             0577*  ; Jumping to an offset that is beyond the end of the buffer is
041E96             0578*  ; equivalent to jumping to the end of the buffer.
041E96             0579*  ; Command 10: Conditional jump to an offset in a buffer
041E96             0580*  
041E96             0581*  ; VDU 23, 0, &A0, bufferId; 10, offset; offsetHighByte, [blockNumber;] [arguments]
041E96             0582*  
041E96             0583*  ; A conditional jump with an offset works in a similar manner to
041E96             0584*  ; the “Conditional call a buffer” command (command 6), except that
041E96             0585*  ; it will jump to the given offset in the buffer if the condition
041E96             0586*  ; operation passes.
041E96             0587*  
041E96             0588*  ; As with the “Jump to an offset in a buffer” command (command 9),
041E96             0589*  ; the offset in this command is always an “advanced” offset, given
041E96             0590*  ; as a 24-bit value in little-endian order, and the usual advanced
041E96             0591*  ; offset rules apply. And similarly, using buffer ID 65535 is
041E96             0592*  ; treated as meaning “jump within current buffer”.
041E96             0593*  ; Command 11: Call buffer with an offset
041E96             0594*  
041E96             0595*  ; VDU 23, 0, &A0, bufferId; 11, offset; offsetHighByte, [blockNumber;]
041E96             0596*  
041E96             0597*  ; Works just like “Call a buffer” (command 1), except that it also
041E96             0598*  ; accepts an advanced offset.
041E96             0599*  
041E96             0600*  ; Command 12: Conditional call buffer with an offset
041E96             0601*  
041E96             0602*  ; VDU 23, 0, &A0, bufferId; 12, offset; offsetHighByte, [blockNumber;] [arguments]
041E96             0603*  
041E96             0604*  ; Works just like the “Conditional call a buffer” command
041E96             0605*  ; (command 6), except that it also accepts an advanced offset.
041E96             0606*  
041E96             0607*  ; Command 13: Copy blocks from multiple buffers into a single buffer
041E96             0608*  
041E96             0609*  ; VDU 23, 0, &A0, targetBufferId; 13, sourceBufferId1; sourceBufferId2; ... 65535;
041E96             0610*  
041E96             0611*  ; This command will copy the contents of multiple buffers into a
041E96             0612*  ; single buffer. The buffers to copy from are specified as a list
041E96             0613*  ; of buffer IDs, terminated by a buffer ID of -1 (65535). The
041E96             0614*  ; buffers are copied in the order they are specified.
041E96             0615*  
041E96             0616*  ; This is a block-wise copy, so the blocks from the source buffers
041E96             0617*  ; are copied into the target buffer. The blocks are copied in the
041E96             0618*  ; order they are found in the source buffers.
041E96             0619*  
041E96             0620*  ; The target buffer will be overwritten with the contents of the
041E96             0621*  ; source buffers. This will not be done however until after all the
041E96             0622*  ; data has been gathered and copied. The target buffer can therefore
041E96             0623*  ; included in the list of the source buffers.
041E96             0624*  
041E96             0625*  ; If a source buffer that does not exist is specified, or a source
041E96             0626*  ; buffer that is empty is specified, then that buffer will be ignored. If no source buffers are specified, or all of the source buffers are empty, then the target buffer will be cleared out.
041E96             0627*  
041E96             0628*  ; The list of source buffers can contain repeated buffer IDs. If a
041E96             0629*  ; buffer ID is repeated, then the blocks from that buffer will be
041E96             0630*  ; copied multiple times into the target buffer.
041E96             0631*  
041E96             0632*  ; If there is insufficient memory available on the VDP to complete
041E96             0633*  ; this command then it will fail, and the target buffer will be
041E96             0634*  ; left unchanged.
041E96             0635*  
041E96             0636*  
041E96             0637*  ; Command 14: Consolidate blocks in a buffer
041E96             0638*  
041E96             0639*  ; VDU 23, 0, &A0, bufferId; 14
041E96             0640*  
041E96             0641*  ; Takes all the blocks in a buffer and consolidates them into a
041E96             0642*  ; single block. This is useful for bitmaps, as it allows for a
041E96             0643*  ; bitmap to be built up over time in multiple blocks, and then
041E96             0644*  ; consolidated into a single block for use as a bitmap.
041E96             0645*  
041E96             0646*  ; If there is insufficient memory available on the VDP to complete
041E96             0647*  ; this command then it will fail, and the buffer will be left
041E96             0648*  ; unchanged.
041E96             0649*  
041E96             0650*  ; Command 15: Split a buffer into multiple blocks
041E96             0651*  
041E96             0652*  ; VDU 23, 0, &A0, bufferId; 15, blockSize;
041E96             0653*  
041E96             0654*  ; Splits a buffer into multiple blocks. The blockSize parameter
041E96             0655*  ; is a 16-bit integer that specifies the target size of each block.
041E96             0656*  ; If the source data is not a multiple of the block size then the
041E96             0657*  ; last block will be smaller than the specified block size.
041E96             0658*  
041E96             0659*  ; If this command is used on a buffer that is already split into
041E96             0660*  ; multiple blocks, then the blocks will be consolidated first,
041E96             0661*  ; and then re-split into the new block size.
041E96             0662*  
041E96             0663*  ; If there is insufficient memory available on the VDP to complete
041E96             0664*  ; this command then it will fail, and the buffer will be left
041E96             0665*  ; unchanged.
041E96             0666*  ; Command 16: Split a buffer into multiple blocks and spread across
041E96             0667*  ; multiple buffers
041E96             0668*  
041E96             0669*  ; VDU 23, 0, &A0, bufferId; 16, blockSize; [targetBufferId1;] [targetBufferId2;] ... 65535;
041E96             0670*  
041E96             0671*  ; Splits a buffer into multiple blocks, as per command 15, but
041E96             0672*  ; then spreads the resultant blocks across the target buffers.
041E96             0673*  ; The target buffers are specified as a list of buffer IDs,
041E96             0674*  ; terminated by a buffer ID of -1 (65535).
041E96             0675*  
041E96             0676*  ; The blocks are spread across the target buffers in the order
041E96             0677*  ; they are specified, and the spread will loop around the buffers
041E96             0678*  ; until all the blocks have been distributed. The target buffers
041E96             0679*  ; will be cleared out before the blocks are spread across them.
041E96             0680*  
041E96             0681*  ; What this means is that if the source buffer is, let’s say,
041E96             0682*  ; 100 bytes in size and we split using a block size of 10 bytes
041E96             0683*  ; then we will end up with 10 blocks. If we then spread those
041E96             0684*  ; blocks across 3 target buffers, then the first buffer will
041E96             0685*  ; contain blocks 1, 4, 7 and 10, the second buffer will contain
041E96             0686*  ; blocks 2, 5 and 8, and the third buffer will contain
041E96             0687*  ; blocks 3, 6 and 9.
041E96             0688*  
041E96             0689*  ; This command attempts to ensure that, in the event of
041E96             0690*  ; insufficient memory being available on the VDP to complete
041E96             0691*  ; the command, it will leave the targets as they were before
041E96             0692*  ; the command was executed. However this may not always be
041E96             0693*  ; possible. The first step of this command is to consolidate
041E96             0694*  ; the source buffer into a single block, and this may fail from
041E96             0695*  ; insufficient memory. If that happens then all the buffers will
041E96             0696*  ; be left as they were. After this however the target buffers
041E96             0697*  ; will be cleared. If there is insufficient memory to successfully
041E96             0698*  ; split the buffer into multiple blocks then the call will exit,
041E96             0699*  ; and the target buffers will be left empty.
041E96             0700*  ; Command 17: Split a buffer and spread across blocks, starting
041E96             0701*  ; at target buffer ID
041E96             0702*  
041E96             0703*  ; VDU 23, 0, &A0, bufferId; 17, blockSize; targetBufferId;
041E96             0704*  
041E96             0705*  ; As per the above two commands, this will split a buffer into
041E96             0706*  ; multiple blocks. It will then spread the blocks across buffers
041E96             0707*  ; starting at the target buffer ID, incrementing the target buffer
041E96             0708*  ; ID until all the blocks have been distributed.
041E96             0709*  
041E96             0710*  ; Target blocks will be cleared before a block is stored in them.
041E96             0711*  ; Each target will contain a single block. The exception to this
041E96             0712*  ; is if the target buffer ID reaches 65534, as it is not possible
041E96             0713*  ; to store a block in buffer 65535. In this case, multiple blocks
041E96             0714*  ; will be placed into buffer 65534.
041E96             0715*  
041E96             0716*  ; With this command if there is insufficient memory available on
041E96             0717*  ; the VDP to complete the command then it will fail, and the target
041E96             0718*  ; buffers will be left unchanged.
041E96             0719*  
041E96             0720*  ; Command 18: Split a buffer into blocks by width
041E96             0721*  
041E96             0722*  ; VDU 23, 0, &A0, bufferId; 18, width; blockCount;
041E96             0723*  
041E96             0724*  ; This command splits a buffer into a given number of blocks by
041E96             0725*  ; first of all splitting the buffer into blocks of a given width
041E96             0726*  ; (number of bytes), and then consolidating those blocks into the
041E96             0727*  ; given number of blocks.
041E96             0728*  
041E96             0729*  ; This is useful for splitting a bitmap into a number of separate
041E96             0730*  ; columns, which can then be manipulated individually. This can be
041E96             0731*  ; useful for dealing with sprite sheets.
041E96             0732*  ; Command 19: Split by width into blocks and spread across target
041E96             0733*  ; buffers
041E96             0734*  
041E96             0735*  ; VDU 23, 0, &A0, bufferId; 19, width; [targetBufferId1;] [targetBufferId2;] ... 65535;
041E96             0736*  
041E96             0737*  ; This command essentially operates the same as command 18, but the
041E96             0738*  ; block count is determined by the number of target buffers specified. The blocks are spread across the target buffers in the order they are specified, with one block placed in each target.
041E96             0739*  
041E96             0740*  ; Command 20: Split by width into blocks and spread across blocks
041E96             0741*  ; starting at target buffer ID
041E96             0742*  
041E96             0743*  ; VDU 23, 0, &A0, bufferId; 20, width; blockCount; targetBufferId;
041E96             0744*  
041E96             0745*  ; This command essentially operates the same as command 18, but
041E96             0746*  ; the generated blocks are spread across blocks starting at the
041E96             0747*  ; target buffer ID, as per command 17.
041E96             0748*  
041E96             0749*  ; Command 21: Spread blocks from a buffer across multiple target
041E96             0750*  ; buffers
041E96             0751*  
041E96             0752*  ; VDU 23, 0, &A0, bufferId; 21, [targetBufferId1;] [targetBufferId2;] ... 65535;
041E96             0753*  
041E96             0754*  ; Spreads the blocks from a buffer across multiple target buffers.
041E96             0755*  ; The target buffers are specified as a list of buffer IDs,
041E96             0756*  ; terminated by a buffer ID of -1 (65535). The blocks are spread
041E96             0757*  ; across the target buffers in the order they are specified, and
041E96             0758*  ; the spread will loop around the buffers until all the blocks have
041E96             0759*  ; been distributed.
041E96             0760*  
041E96             0761*  ; It should be noted that this command does not copy the blocks,
041E96             0762*  ; and nor does it move them. Unless the source buffer has been
041E96             0763*  ; included in the list of targets, it will remain completely
041E96             0764*  ; intact. The blocks distributed across the target buffers will
041E96             0765*  ; point to the same memory as the blocks in the source buffer.
041E96             0766*  ; Operations to modify data in the source buffer will also modify
041E96             0767*  ; the data in the target buffers. Clearing the source buffer
041E96             0768*  ; however will not clear the target buffers.
041E96             0769*  
041E96             0770*  ; Command 22: Spread blocks from a buffer across blocks starting
041E96             0771*  ; at target buffer ID
041E96             0772*  
041E96             0773*  ; VDU 23, 0, &A0, bufferId; 22, targetBufferId;
041E96             0774*  
041E96             0775*  ; Spreads the blocks from a buffer across blocks starting at
041E96             0776*  ; the target buffer ID.
041E96             0777*  
041E96             0778*  ; This essentially works the same as command 21, and the same
041E96             0779*  ; notes about copying and moving blocks apply. Blocks are spread
041E96             0780*  ; in the same manner as commands 17 and 20.
041E96             0781*  
041E96             0782*  ; Command 23: Reverse the order of blocks in a buffer
041E96             0783*  
041E96             0784*  ; VDU 23, 0, &A0, bufferId; 23
041E96             0785*  
041E96             0786*  ; Reverses the order of the blocks in a buffer.
041E96             0787*  ; Command 24: Reverse the order of data of blocks within a buffer
041E96             0788*  
041E96             0789*  ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
041E96             0790*  
041E96             0791*  ; Reverses the order of the data within the blocks of a buffer.
041E96             0792*  ; The options parameter is an 8-bit value that can have bits set
041E96             0793*  ; to modify the behaviour of the operation. The following bits
041E96             0794*  ; are defined:
041E96             0795*  ; Bit value 	Description
041E96             0796*  ; 1 	Values are 16-bits in size
041E96             0797*  ; 2 	Values are 32-bits in size
041E96             0798*  ; 3 (1+2) 	If both value size bits are set, then the value size is sent as a 16-bit value
041E96             0799*  ; 4 	Reverse data of the value size within chunk of data of the specified size, sent as a 16-bit value
041E96             0800*  ; 8 	Reverse blocks
041E96             0801*  
041E96             0802*  ; These modifiers can be combined together to modify the behaviour
041E96             0803*  ; of the operation.
041E96             0804*  
041E96             0805*  ; If no value size is set in the options (i.e. the value of the
041E96             0806*  ; bottom two bits of the options is zero) then the value size is
041E96             0807*  ; assumed to be 8-bits.
041E96             0808*  
041E96             0809*  ; It is probably easiest to understand what this operation is
041E96             0810*  ; capable of by going through some examples of how it can be used
041E96             0811*  ; to manipulate bitmaps. The VDP supports two different formats
041E96             0812*  ; of color bitmap, either RGBA8888 which uses 4-bytes per pixel,
041E96             0813*  ; i.e. 32-bit values, or RGBA2222 which uses a single byte per
041E96             0814*  ; pixel.
041E96             0815*  
041E96             0816*  ; The simplest example is rotating an RGBA2222 bitmap by 180
041E96             0817*  ; degrees, which can be done by just reversing the order of
041E96             0818*  ; bytes in the buffer:
041E96             0819*  
041E96             0820*  ; VDU 23, 0, &A0, bufferId; 24, 0
041E96             0821*  
041E96             0822*  ; Rotating an RGBA8888 bitmap by 180 degrees is in principle a
041E96             0823*  ; little more complex, as each pixel is made up of 4 bytes.
041E96             0824*  ; However with this command it is still a simple operation, as
041E96             0825*  ; we can just reverse the order of the 32-bit values that make
041E96             0826*  ; up the bitmap by using an options value of 2:
041E96             0827*  
041E96             0828*  ; VDU 23, 0, &A0, bufferId; 24, 2
041E96             0829*  
041E96             0830*  ; Mirroring a bitmap around the x-axis is a matter of reversing
041E96             0831*  ; the order of rows of pixels. To do this we can set a custom
041E96             0832*  ; value size that corresponds to our bitmap width. For an RGBA2222
041E96             0833*  ; bitmap we can just set a custom value size to our bitmap width:
041E96             0834*  
041E96             0835*  ; VDU 23, 0, &A0, bufferId; 24, 3, width
041E96             0836*  
041E96             0837*  ; As an RGBA8888 bitmap uses 4 bytes per pixel we need to multiply
041E96             0838*  ; our width by 4:
041E96             0839*  
041E96             0840*  ; VDU 23, 0, &A0, bufferId; 24, 3, width * 4
041E96             0841*  
041E96             0842*  ; To mirror a bitmap around the y-axis, we need to reverse the
041E96             0843*  ; order of pixels within each row. For an RGBA2222 bitmap we can
041E96             0844*  ; just set a custom chunk size to our bitmap width:
041E96             0845*  
041E96             0846*  ; VDU 23, 0, &A0, bufferId; 24, 4, width
041E96             0847*  
041E96             0848*  ; For an RGBA8888 bitmap we need to set our options to indicate
041E96             0849*  ; 32-bit values as well as a custom chunk size:
041E96             0850*  
041E96             0851*  ; VDU 23, 0, &A0, bufferId; 24, 6, width * 4
041E96             0852*  
041E96             0853*  ; Command 25: Copy blocks from multiple buffers by reference
041E96             0854*  
041E96             0855*  ; VDU 23, 0, &A0, targetBufferId; 25, sourceBufferId1; sourceBufferId2; ...; 65535;
041E96             0856*  
041E96             0857*  ; This command is essentially a version of command 13 that copies
041E96             0858*  ; blocks by reference rather than by value. The parameters for
041E96             0859*  ; this command are the same as for command 13, and the same rules
041E96             0860*  ; apply.
041E96             0861*  
041E96             0862*  ; If the target buffer is included in the list of source buffers
041E96             0863*  ; then it will be skipped to prevent a reference loop.
041E96             0864*  
041E96             0865*  ; Copying by reference means that the blocks in the target buffer
041E96             0866*  ; will point to the same memory as the blocks in the source
041E96             0867*  ; buffers. Operations to modify data blocks in the source buffers
041E96             0868*  ; will therefore also modify those blocks in the target buffer.
041E96             0869*  ; Clearing the source buffers will not clear the target buffer -
041E96             0870*  ; it will still point to the original data blocks. Data blocks
041E96             0871*  ; are only freed from memory when no buffers are left with any
041E96             0872*  ; references to them.
041E96             0873*  
041E96             0874*  ; Buffers that get consolidated become new blocks, so will lose
041E96             0875*  ; their links to the original blocks, thus after a “consolidate”
041E96             0876*  ; operation modifications to the original blocks will no longer be
041E96             0877*  ; reflected in the consolidated buffer.
041E96             0878*  
041E96             0879*  ; This command is useful to construct a single buffer from multiple
041E96             0880*  ; sources without the copy overhead, which can be costly. For
041E96             0881*  ; example, this can be useful for constructing a bitmap from
041E96             0882*  ; multiple constituent parts before consolidating it into a
041E96             0883*  ; single block. In such an example, using command 13 instead
041E96             0884*  ; would first make a copy of the contents of the source buffers,
041E96             0885*  ; and then consolidate them into a single block. Using this
041E96             0886*  ; command does not make that first copy, and so would be faster.
041E96             0887*  
041E96             0888*  ; This command is also useful for creating multiple buffers that
041E96             0889*  ; all point to the same data.
041E96             0890*  
041E96             0891*  ; Command 26: Copy blocks from multiple buffers and consolidate
041E96             0892*  
041E96             0893*  ; VDU 23, 0, &A0, targetBufferId; 26, sourceBufferId1; sourceBufferId2; ...; 65535;
041E96             0055       include "vdu_plot.inc"
041E96             0001*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
041E96             0002*  ; PLOT code 	(Decimal) 	Effect
041E96             0003*  ; &00-&07 	0-7 	Solid line, includes both ends
041E96             0004*  plot_sl_both: equ 0x00
041E96             0005*  
041E96             0006*  ; &08-&0F 	8-15 	Solid line, final point omitted
041E96             0007*  plot_sl_first: equ 0x08
041E96             0008*  
041E96             0009*  ; &10-&17 	16-23 	Not supported (Dot-dash line, includes both ends, pattern restarted)
041E96             0010*  ; &18-&1F 	24-31 	Not supported (Dot-dash line, first point omitted, pattern restarted)
041E96             0011*  
041E96             0012*  ; &20-&27 	32-39 	Solid line, first point omitted
041E96             0013*  plot_sl_last: equ 0x20
041E96             0014*  
041E96             0015*  ; &28-&2F 	40-47 	Solid line, both points omitted
041E96             0016*  plot_sl_none: equ 0x28
041E96             0017*  
041E96             0018*  ; &30-&37 	48-55 	Not supported (Dot-dash line, first point omitted, pattern continued)
041E96             0019*  ; &38-&3F 	56-63 	Not supported (Dot-dash line, both points omitted, pattern continued)
041E96             0020*  
041E96             0021*  ; &40-&47 	64-71 	Point plot
041E96             0022*  plot_pt: equ 0x40
041E96             0023*  
041E96             0024*  ; &48-&4F 	72-79 	Line fill left and right to non-background §§
041E96             0025*  plot_lf_lr_non_bg: equ 0x48
041E96             0026*  
041E96             0027*  ; &50-&57 	80-87 	Triangle fill
041E96             0028*  plot_tf: equ 0x50
041E96             0029*  
041E96             0030*  ; &58-&5F 	88-95 	Line fill right to background §§
041E96             0031*  plot_lf_r_bg: equ 0x58
041E96             0032*  
041E96             0033*  ; &60-&67 	96-103 	Rectangle fill
041E96             0034*  plot_rf: equ 0x60
041E96             0035*  
041E96             0036*  ; &68-&6F 	104-111 	Line fill left and right to foreground §§
041E96             0037*  plot_lf_lr_fg: equ 0x60
041E96             0038*  
041E96             0039*  ; &70-&77 	112-119 	Parallelogram fill
041E96             0040*  plot_pf: equ 0x70
041E96             0041*  
041E96             0042*  ; &78-&7F 	120-127 	Line fill right to non-foreground §§
041E96             0043*  plot_lf_r_non_fg: equ 0x78
041E96             0044*  
041E96             0045*  ; &80-&87 	128-135 	Not supported (Flood until non-background)
041E96             0046*  ; &88-&8F 	136-143 	Not supported (Flood until foreground)
041E96             0047*  
041E96             0048*  ; &90-&97 	144-151 	Circle outline
041E96             0049*  plot_co: equ 0x90
041E96             0050*  
041E96             0051*  ; &98-&9F 	152-159 	Circle fill
041E96             0052*  plot_cf: equ 0x98
041E96             0053*  
041E96             0054*  ; &A0-&A7 	160-167 	Not supported (Circular arc)
041E96             0055*  ; &A8-&AF 	168-175 	Not supported (Circular segment)
041E96             0056*  ; &B0-&B7 	176-183 	Not supported (Circular sector)
041E96             0057*  
041E96             0058*  ; &B8-&BF 	184-191 	Rectangle copy/move
041E96             0059*  plot_rcm: equ 0xB8
041E96             0060*  
041E96             0061*  ; &C0-&C7 	192-199 	Not supported (Ellipse outline)
041E96             0062*  ; &C8-&CF 	200-207 	Not supported (Ellipse fill)
041E96             0063*  ; &D0-&D7 	208-215 	Not defined
041E96             0064*  ; &D8-&DF 	216-223 	Not defined
041E96             0065*  ; &E0-&E7 	224-231 	Not defined
041E96             0066*  
041E96             0067*  ; &E8-&EF 	232-239 	Bitmap plot §
041E96             0068*  plot_bmp: equ 0xE8
041E96             0069*  
041E96             0070*  ; &F0-&F7 	240-247 	Not defined
041E96             0071*  ; &F8-&FF 	248-255 	Not defined
041E96             0072*  
041E96             0073*  ; § Support added in Agon Console8 VDP 2.1.0 §§ Support added in
041E96             0074*  ; Agon Console8 VDP 2.2.0
041E96             0075*  
041E96             0076*  ; Within each group of eight plot codes, the effects are as follows:
041E96             0077*  ; Plot code 	Effect
041E96             0078*  ; 0 	Move relative
041E96             0079*  mv_rel: equ 0
041E96             0080*  
041E96             0081*  ; 1 	Plot relative in current foreground colour
041E96             0082*  dr_rel_fg: equ 1
041E96             0083*  
041E96             0084*  ; 2 	Not supported (Plot relative in logical inverse colour)
041E96             0085*  ; 3 	Plot relative in current background colour
041E96             0086*  dr_rel_bg: equ 3
041E96             0087*  
041E96             0088*  ; 4 	Move absolute
041E96             0089*  mv_abs: equ 4
041E96             0090*  
041E96             0091*  ; 5 	Plot absolute in current foreground colour
041E96             0092*  dr_abs_fg: equ 5
041E96             0093*  
041E96             0094*  ; 6 	Not supported (Plot absolute in logical inverse colour)
041E96             0095*  ; 7 	Plot absolute in current background colour
041E96             0096*  dr_abs_bg: equ 7
041E96             0097*  
041E96             0098*  ; Codes 0-3 use the position data provided as part of the command
041E96             0099*  ; as a relative position, adding the position given to the current
041E96             0100*  ; graphical cursor position. Codes 4-7 use the position data provided
041E96             0101*  ; as part of the command as an absolute position, setting the current
041E96             0102*  ; graphical cursor position to the position given.
041E96             0103*  
041E96             0104*  ; Codes 2 and 6 on Acorn systems plot using a logical inverse of the
041E96             0105*  ; current pixel colour. These operations cannot currently be supported
041E96             0106*  ; by the graphics system the Agon VDP uses, so these codes are not
041E96             0107*  ; supported. Support for these codes may be added in a future version
041E96             0108*  ; of the VDP firmware.
041E96             0109*  
041E96             0110*  ; 16 colour palette constants
041E96             0111*  c_black: equ 0
041E96             0112*  c_red_dk: equ 1
041E96             0113*  c_green_dk: equ 2
041E96             0114*  c_yellow_dk: equ 3
041E96             0115*  c_blue_dk: equ 4
041E96             0116*  c_magenta_dk: equ 5
041E96             0117*  c_cyan_dk: equ 6
041E96             0118*  c_grey: equ 7
041E96             0119*  c_grey_dk: equ 8
041E96             0120*  c_red: equ 9
041E96             0121*  c_green: equ 10
041E96             0122*  c_yellow: equ 11
041E96             0123*  c_blue: equ 12
041E96             0124*  c_magenta: equ 13
041E96             0125*  c_cyan: equ 14
041E96             0126*  c_white: equ 15
041E96             0127*  
041E96             0128*  ; VDU 25, mode, x; y;: PLOT command
041E96             0129*  ; inputs: a=mode, bc=x0, de=y0
041E96             0130*  vdu_plot:
041E96 32 B0 1E 04 0131*      ld (@mode),a
041E9A ED 43 B1 1E 0132*      ld (@x0),bc
       04          
041E9F ED 53 B3 1E 0133*      ld (@y0),de
       04          
041EA4 21 AF 1E 04 0134*  	ld hl,@cmd
041EA8 01 06 00 00 0135*  	ld bc,@end-@cmd
041EAC 5B DF       0136*  	rst.lil $18
041EAE C9          0137*  	ret
041EAF 19          0138*  @cmd:   db 25
041EB0 00          0139*  @mode:  db 0
041EB1 00 00       0140*  @x0: 	dw 0
041EB3 00 00       0141*  @y0: 	dw 0
041EB5 00          0142*  @end:   db 0 ; extra byte to soak up deu
041EB6             0143*  
041EB6             0144*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
041EB6             0145*  ; &E8-&EF 	232-239 	Bitmap plot §
041EB6             0146*  ; VDU 25, mode, x; y;: PLOT command
041EB6             0147*  ; inputs: bc=x0, de=y0
041EB6             0148*  ; prerequisites: vdu_buff_select
041EB6             0149*  vdu_plot_bmp:
041EB6 ED 43 CD 1E 0150*      ld (@x0),bc
       04          
041EBB ED 53 CF 1E 0151*      ld (@y0),de
       04          
041EC0 21 CB 1E 04 0152*  	ld hl,@cmd
041EC4 01 06 00 00 0153*  	ld bc,@end-@cmd
041EC8 5B DF       0154*  	rst.lil $18
041ECA C9          0155*  	ret
041ECB 19          0156*  @cmd:   db 25
041ECC ED          0157*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
041ECD 00 00       0158*  @x0: 	dw 0x0000
041ECF 00 00       0159*  @y0: 	dw 0x0000
041ED1 00          0160*  @end:   db 0x00 ; padding
041ED2             0161*  
041ED2             0162*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
041ED2             0163*  ; &E8-&EF 	232-239 	Bitmap plot §
041ED2             0164*  ; VDU 25, mode, x; y;: PLOT command
041ED2             0165*  ; inputs: bc=x0, de=y0
041ED2             0166*  ; USING 16.8 FIXED POINT COORDINATES
041ED2             0167*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
041ED2             0168*  ;   the fractional portiion of the inputs are truncated
041ED2             0169*  ;   leaving only the 16-bit integer portion
041ED2             0170*  ; prerequisites: vdu_buff_select
041ED2             0171*  vdu_plot_bmp168:
041ED2             0172*  ; populate in the reverse of normal to keep the
041ED2             0173*  ; inputs from stomping on each other
041ED2 ED 53 F0 1E 0174*      ld (@y0-1),de
       04          
041ED7 ED 43 EE 1E 0175*      ld (@x0-1),bc
       04          
041EDC 3E ED       0176*      ld a,plot_bmp+dr_abs_fg ; 0xED
041EDE 32 EE 1E 04 0177*      ld (@mode),a ; restore the mode byte that got stomped on by bcu
041EE2 21 ED 1E 04 0178*  	ld hl,@cmd
041EE6 01 06 00 00 0179*  	ld bc,@end-@cmd
041EEA 5B DF       0180*  	rst.lil $18
041EEC C9          0181*  	ret
041EED 19          0182*  @cmd:   db 25
041EEE ED          0183*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
041EEF 00 00       0184*  @x0: 	dw 0x0000
041EF1 00 00       0185*  @y0: 	dw 0x0000
041EF3             0186*  @end:  ; no padding required b/c we shifted de right
041EF3             0187*  
041EF3             0188*  ; draw a filled rectangle
041EF3             0189*  vdu_plot_rf:
041EF3 ED 43 1A 1F 0190*      ld (@x0),bc
       04          
041EF8 ED 53 1C 1F 0191*      ld (@y0),de
       04          
041EFD DD 22 20 1F 0192*      ld (@x1),ix
       04          
041F02 FD 22 22 1F 0193*      ld (@y1),iy
       04          
041F07 3E 19       0194*      ld a,25 ; we have to reload the 2nd plot command
041F09 32 1E 1F 04 0195*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
041F0D 21 18 1F 04 0196*  	ld hl,@cmd0
041F11 01 0C 00 00 0197*  	ld bc,@end-@cmd0
041F15 5B DF       0198*  	rst.lil $18
041F17 C9          0199*      ret
041F18 19          0200*  @cmd0:  db 25 ; plot
041F19 04          0201*  @arg0:  db plot_sl_both+mv_abs
041F1A 00 00       0202*  @x0:    dw 0x0000
041F1C 00 00       0203*  @y0:    dw 0x0000
041F1E 19          0204*  @cmd1:  db 25 ; plot
041F1F 65          0205*  @arg1:  db plot_rf+dr_abs_fg
041F20 00 00       0206*  @x1:    dw 0x0000
041F22 00 00       0207*  @y1:    dw 0x0000
041F24 00          0208*  @end:   db 0x00 ; padding
041F25             0209*  
041F25             0210*  ; draw a filled circle
041F25             0211*  vdu_plot_cf:
041F25 ED 43 4C 1F 0212*      ld (@x0),bc
       04          
041F2A ED 53 4E 1F 0213*      ld (@y0),de
       04          
041F2F DD 22 52 1F 0214*      ld (@x1),ix
       04          
041F34 FD 22 54 1F 0215*      ld (@y1),iy
       04          
041F39 3E 19       0216*      ld a,25 ; we have to reload the 2nd plot command
041F3B 32 50 1F 04 0217*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
041F3F 21 4A 1F 04 0218*  	ld hl,@cmd0
041F43 01 0C 00 00 0219*  	ld bc,@end-@cmd0
041F47 5B DF       0220*  	rst.lil $18
041F49 C9          0221*      ret
041F4A 19          0222*  @cmd0:  db 25 ; plot
041F4B 04          0223*  @arg0:  db plot_sl_both+mv_abs
041F4C 00 00       0224*  @x0:    dw 0x0000
041F4E 00 00       0225*  @y0:    dw 0x0000
041F50 19          0226*  @cmd1:  db 25 ; plot
041F51 9D          0227*  @arg1:  db plot_cf+dr_abs_fg
041F52 00 00       0228*  @x1:    dw 0x0000
041F54 00 00       0229*  @y1:    dw 0x0000
041F56 00          0230*  @end:   db 0x00 ; padding
041F57             0056   	include "vdu_sprites.inc"
041F57             0001*  ; ; https://github.com/AgonConsole8/agon-docs/blob/main/VDP---Bitmaps-API.md
041F57             0002*  ; the VDP can support up to 256 sprites. They must be defined
041F57             0003*  ; contiguously, and so the first sprite is sprite 0.
041F57             0004*  ; (In contrast, bitmaps can have any ID from 0 to 65534.)
041F57             0005*  ; Once a selection of sprites have been defined, you can activate
041F57             0006*  ; them using the VDU 23, 27, 7, n command, where n is the number
041F57             0007*  ; of sprites to activate. This will activate the first n sprites,
041F57             0008*  ; starting with sprite 0. All sprites from 0 to n-1 must be defined.
041F57             0009*  
041F57             0010*  ; A single sprite can have multiple "frames", referring to
041F57             0011*  ; different bitmaps.
041F57             0012*  ; (These bitmaps do not need to be the same size.)
041F57             0013*  ; This allows a sprite to include an animation sequence,
041F57             0014*  ; which can be stepped through one frame at a time, or picked
041F57             0015*  ; in any order.
041F57             0016*  
041F57             0017*  ; Any format of bitmap can be used as a sprite frame. It should
041F57             0018*  ; be noted however that "native" format bitmaps are not
041F57             0019*  ; recommended for use as sprite frames, as they cannot get
041F57             0020*  ; erased from the screen. (As noted above, the "native" bitmap
041F57             0021*  ; format is not really intended for general use.) This is part
041F57             0022*  ; of why from Agon Console8 VDP 2.6.0 bitmaps captured from the
041F57             0023*  ; screen are now stored in RGBA2222 format.
041F57             0024*  
041F57             0025*  ; An "active" sprite can be hidden, so it will stop being drawn,
041F57             0026*  ; and then later shown again.
041F57             0027*  
041F57             0028*  ; Moving sprites around the screen is done by changing the
041F57             0029*  ; position of the sprite. This can be done either by setting
041F57             0030*  ; the absolute position of the sprite, or by moving the sprite
041F57             0031*  ; by a given number of pixels. (Sprites are positioned using
041F57             0032*  ; pixel coordinates, and not by the logical OS coordinate system.)
041F57             0033*  ; In the current sprite system, sprites will not update their
041F57             0034*  ; position on-screen until either another drawing operation is
041F57             0035*  ; performed or an explicit VDU 23, 27, 15 command is performed.
041F57             0036*  
041F57             0037*  ; VDU 23, 27, 4, n: Select sprite n
041F57             0038*  ; inputs: a is the 8-bit sprite id
041F57             0039*  vdu_sprite_select:
041F57 32 69 1F 04 0040*      ld (@sprite),a
041F5B 21 66 1F 04 0041*      ld hl,@cmd
041F5F 01 04 00 00 0042*      ld bc,@end-@cmd
041F63 5B DF       0043*      rst.lil $18
041F65 C9          0044*      ret
041F66 17 1B 04    0045*  @cmd:    db 23,27,4
041F69 00          0046*  @sprite: db 0x00
041F6A             0047*  @end:
041F6A             0048*  
041F6A             0049*  ; VDU 23, 27, 5: Clear frames in current sprite
041F6A             0050*  ; inputs: none
041F6A             0051*  ; prerequisites: vdu_sprite_select
041F6A             0052*  vdu_sprite_clear_frames:
041F6A 21 75 1F 04 0053*      ld hl,@cmd
041F6E 01 03 00 00 0054*      ld bc,@end-@cmd
041F72 5B DF       0055*      rst.lil $18
041F74 C9          0056*      ret
041F75 17 1B 05    0057*  @cmd: db 23,27,5
041F78             0058*  @end:
041F78             0059*  
041F78             0060*  ; VDU 23, 27, 6, n: Add bitmap n as a frame to current sprite (where bitmap's buffer ID is 64000+n)
041F78             0061*  ; inputs: a is the 8-bit bitmap number
041F78             0062*  ; prerequisites: vdu_sprite_select
041F78             0063*  vdu_sprite_add_bmp:
041F78 32 8A 1F 04 0064*      ld (@bmp),a
041F7C 21 87 1F 04 0065*      ld hl,@cmd
041F80 01 04 00 00 0066*      ld bc,@end-@cmd
041F84 5B DF       0067*      rst.lil $18
041F86 C9          0068*      ret
041F87 17 1B 06    0069*  @cmd: db 23,27,6
041F8A 00          0070*  @bmp: db 0x00
041F8B             0071*  @end:
041F8B             0072*  
041F8B             0073*  ; VDU 23, 27, 7, n: Activate n sprites
041F8B             0074*  ; inputs: a is the number of sprites to activate
041F8B             0075*  ; prerequisites: each sprite activated must have at least one frame attached to it
041F8B             0076*  vdu_sprite_activate:
041F8B 32 9D 1F 04 0077*      ld (@num),a
041F8F 21 9A 1F 04 0078*      ld hl,@cmd
041F93 01 04 00 00 0079*      ld bc,@end-@cmd
041F97 5B DF       0080*      rst.lil $18
041F99 C9          0081*      ret
041F9A 17 1B 07    0082*  @cmd: db 23,27,7
041F9D 00          0083*  @num: db 0x00
041F9E             0084*  @end:
041F9E             0085*  
041F9E             0086*  ; VDU 23, 27, 8: Select next frame of current sprite
041F9E             0087*  ; inputs: none
041F9E             0088*  ; prerequisites: vdu_sprite_select
041F9E             0089*  vdu_sprite_next_frame:
041F9E 21 A9 1F 04 0090*      ld hl,@cmd
041FA2 01 03 00 00 0091*      ld bc,@end-@cmd
041FA6 5B DF       0092*      rst.lil $18
041FA8 C9          0093*      ret
041FA9 17 1B 08    0094*  @cmd: db 23,27,8
041FAC             0095*  @end:
041FAC             0096*  
041FAC             0097*  ; VDU 23, 27, 9: Select previous frame of current sprite
041FAC             0098*  ; inputs: none
041FAC             0099*  ; prerequisites: vdu_sprite_select
041FAC             0100*  vdu_sprite_prev_frame:
041FAC 21 B7 1F 04 0101*      ld hl,@cmd
041FB0 01 03 00 00 0102*      ld bc,@end-@cmd
041FB4 5B DF       0103*      rst.lil $18
041FB6 C9          0104*      ret
041FB7 17 1B 09    0105*  @cmd: db 23,27,9
041FBA             0106*  @end:
041FBA             0107*  
041FBA             0108*  ; VDU 23, 27, 10, n: Select the nth frame of current sprite
041FBA             0109*  ; inputs: a is frame number to select
041FBA             0110*  ; prerequisites: vdu_sprite_select
041FBA             0111*  vdu_sprite_select_frame:
041FBA 32 CC 1F 04 0112*      ld (@frame),a
041FBE 21 C9 1F 04 0113*      ld hl,@cmd
041FC2 01 04 00 00 0114*      ld bc,@end-@cmd
041FC6 5B DF       0115*      rst.lil $18
041FC8 C9          0116*      ret
041FC9 17 1B 0A    0117*  @cmd:    db 23,27,10
041FCC 00          0118*  @frame:  db 0x00
041FCD             0119*  @end:
041FCD             0120*  
041FCD             0121*  ; VDU 23, 27, 11: Show current sprite
041FCD             0122*  ; inputs: none
041FCD             0123*  ; prerequisites: vdu_sprite_select
041FCD             0124*  vdu_sprite_show:
041FCD 21 D8 1F 04 0125*      ld hl,@cmd
041FD1 01 03 00 00 0126*      ld bc,@end-@cmd
041FD5 5B DF       0127*      rst.lil $18
041FD7 C9          0128*      ret
041FD8 17 1B 0B    0129*  @cmd: db 23,27,11
041FDB             0130*  @end:
041FDB             0131*  
041FDB             0132*  ; VDU 23, 27, 12: Hide current sprite
041FDB             0133*  ; inputs: none
041FDB             0134*  ; prerequisites: vdu_sprite_select
041FDB             0135*  vdu_sprite_hide:
041FDB 21 E6 1F 04 0136*      ld hl,@cmd
041FDF 01 03 00 00 0137*      ld bc,@end-@cmd
041FE3 5B DF       0138*      rst.lil $18
041FE5 C9          0139*      ret
041FE6 17 1B 0C    0140*  @cmd: db 23,27,12
041FE9             0141*  @end:
041FE9             0142*  
041FE9             0143*  ; VDU 23, 27, 13, x; y;: Move current sprite to pixel position x, y
041FE9             0144*  ; inputs: bc is x coordinate, de is y coordinate
041FE9             0145*  ; prerequisites: vdu_sprite_select
041FE9             0146*  vdu_sprite_move_abs:
041FE9 ED 43 01 20 0147*      ld (@xpos),bc
       04          
041FEE ED 53 03 20 0148*      ld (@ypos),de
       04          
041FF3 21 FE 1F 04 0149*      ld hl,@cmd
041FF7 01 07 00 00 0150*      ld bc,@end-@cmd
041FFB 5B DF       0151*      rst.lil $18
041FFD C9          0152*      ret
041FFE 17 1B 0D    0153*  @cmd:  db 23,27,13
042001 00 00       0154*  @xpos: dw 0x0000
042003 00 00       0155*  @ypos: dw 0x0000
042005 00          0156*  @end:  db 0x00 ; padding
042006             0157*  
042006             0158*  ; VDU 23, 27, 14, x; y;: Move current sprite by x, y pixels
042006             0159*  ; inputs: bc is x coordinate, de is y coordinate
042006             0160*  ; prerequisites: vdu_sprite_select
042006             0161*  vdu_sprite_move_rel:
042006 ED 43 1E 20 0162*      ld (@dx),bc
       04          
04200B ED 53 20 20 0163*      ld (@dy),de
       04          
042010 21 1B 20 04 0164*      ld hl,@cmd
042014 01 07 00 00 0165*      ld bc,@end-@cmd
042018 5B DF       0166*      rst.lil $18
04201A C9          0167*      ret
04201B 17 1B 0E    0168*  @cmd: db 23,27,14
04201E 00 00       0169*  @dx:  dw 0x0000
042020 00 00       0170*  @dy:  dw 0x0000
042022 00          0171*  @end: db 0x00 ; padding
042023             0172*  
042023             0173*  ; VDU 23, 27, 13, x; y;: Move current sprite to pixel position x, y
042023             0174*  ; USING 16.8 FIXED POINT COORDINATES
042023             0175*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
042023             0176*  ;   the fractional portiion of the inputs are truncated
042023             0177*  ;   leaving only the 16-bit integer portion
042023             0178*  ; prerequisites: vdu_sprite_select
042023             0179*  vdu_sprite_move_abs168:
042023             0180*  ; populate in the reverse of normal to keep the
042023             0181*  ; inputs from stomping on each other
042023 ED 53 42 20 0182*      ld (@ypos-1),de
       04          
042028 ED 43 40 20 0183*      ld (@xpos-1),bc
       04          
04202D 3E 0D       0184*      ld a,13       ; restore the final byte of the command
04202F 32 40 20 04 0185*      ld (@cmd+2),a ; string that got stomped on by bcu
042033 21 3E 20 04 0186*      ld hl,@cmd
042037 01 07 00 00 0187*      ld bc,@end-@cmd
04203B 5B DF       0188*      rst.lil $18
04203D C9          0189*      ret
04203E 17 1B 0D    0190*  @cmd:  db 23,27,13
042041 00 00       0191*  @xpos: dw 0x0000
042043 00 00       0192*  @ypos: dw 0x0000
042045             0193*  @end:  ; no padding required b/c we shifted de right
042045             0194*  
042045             0195*  ; VDU 23, 27, 14, x; y;: Move current sprite by x, y pixels
042045             0196*  ; USING 16.8 FIXED POINT COORDINATES
042045             0197*  ; inputs: ub.c is dx, ud.e is dy
042045             0198*  ;   the fractional portiion of the inputs are truncated
042045             0199*  ;   leaving only the 16-bit integer portion
042045             0200*  ; prerequisites: vdu_sprite_select
042045             0201*  vdu_sprite_move_rel168:
042045             0202*  ; populate in the reverse of normal to keep the
042045             0203*  ; inputs from stomping on each other
042045 ED 53 64 20 0204*      ld (@dy-1),de
       04          
04204A ED 43 62 20 0205*      ld (@dx-1),bc
       04          
04204F 3E 0E       0206*      ld a,14       ; restore the final byte of the command
042051 32 62 20 04 0207*      ld (@cmd+2),a ; string that got stomped on by bcu
042055 21 60 20 04 0208*      ld hl,@cmd
042059 01 07 00 00 0209*      ld bc,@end-@cmd
04205D 5B DF       0210*      rst.lil $18
04205F C9          0211*      ret
042060 17 1B 0E    0212*  @cmd:  db 23,27,14
042063 00 00       0213*  @dx: dw 0x0000
042065 00 00       0214*  @dy: dw 0x0000
042067             0215*  @end:  ; no padding required b/c we shifted de right
042067             0216*  
042067             0217*  ; VDU 23, 27, 15: Update the sprites in the GPU
042067             0218*  ; inputs: none
042067             0219*  vdu_sprite_update:
042067 21 72 20 04 0220*      ld hl,@cmd
04206B 01 03 00 00 0221*      ld bc,@end-@cmd
04206F 5B DF       0222*      rst.lil $18
042071 C9          0223*      ret
042072 17 1B 0F    0224*  @cmd: db 23,27,15
042075             0225*  @end:
042075             0226*  
042075             0227*  ; VDU 23, 27, 16: Reset bitmaps and sprites and clear all data
042075             0228*  ; inputs: none
042075             0229*  vdu_sprite_bmp_reset:
042075 21 80 20 04 0230*      ld hl,@cmd
042079 01 03 00 00 0231*      ld bc,@end-@cmd
04207D 5B DF       0232*      rst.lil $18
04207F C9          0233*      ret
042080 17 1B 10    0234*  @cmd: db 23,27,16
042083             0235*  @end:
042083             0236*  
042083             0237*  ; VDU 23, 27, 17: Reset sprites (only) and clear all data
042083             0238*  ; inputs: none
042083             0239*  vdu_sprite_reset:
042083 21 8E 20 04 0240*      ld hl,@cmd
042087 01 03 00 00 0241*      ld bc,@end-@cmd
04208B 5B DF       0242*      rst.lil $18
04208D C9          0243*      ret
04208E 17 1B 11    0244*  @cmd: db 23,27,17
042091             0245*  @end:
042091             0246*  
042091             0247*  ; VDU 23, 27, 18, n: Set the current sprite GCOL paint mode to n **
042091             0248*  ; inputs: a is the GCOL paint mode
042091             0249*  ; prerequisites: vdu_sprite_select
042091             0250*  vdu_sprite_set_gcol:
042091 32 A3 20 04 0251*      ld (@mode),a
042095 21 A0 20 04 0252*      ld hl,@cmd
042099 01 04 00 00 0253*      ld bc,@end-@cmd
04209D 5B DF       0254*      rst.lil $18
04209F C9          0255*      ret
0420A0 17 1B 12    0256*  @cmd:  db 23,27,18
0420A3 00          0257*  @mode: db 0x00
0420A4             0258*  @end:
0420A4             0259*  
0420A4             0260*  ; VDU 23, 27, &26, n;: Add bitmap n as a frame to current sprite using a 16-bit buffer ID
0420A4             0261*  ; inputs: hl=bufferId
0420A4             0262*  ; prerequisites: vdu_sprite_select
0420A4             0263*  vdu_sprite_add_buff:
0420A4 22 B6 20 04 0264*      ld (@bufferId),hl
0420A8 21 B3 20 04 0265*      ld hl,@cmd
0420AC 01 05 00 00 0266*      ld bc,@end-@cmd
0420B0 5B DF       0267*      rst.lil $18
0420B2 C9          0268*      ret
0420B3 17 1B 26    0269*  @cmd:      db 23,27,0x26
0420B6 00 00       0270*  @bufferId: dw 0x0000
0420B8 00          0271*  @end:      db 0x00 ; padding
0420B9             0057   	; include "div_168_signed.inc" ; deprecated in favor of fixed24.inc
0420B9             0058   	include "maths.inc"
0420B9             0001*  ; test the sign of HL
0420B9             0002*  ; inputs: HL obviously
0420B9             0003*  ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
0420B9             0004*  ; destroys: flags
0420B9             0005*      MACRO sign_hlu
0420B9             0006*          add hl,de
0420B9             0007*          or a
0420B9             0008*          sbc hl,de
0420B9             0009*      ENDMACRO
0420B9             0010*  
0420B9             0011*  
0420B9             0012*  ;------------------------------------------------------------------------
0420B9             0013*  ; Scratch area for calculations
0420B9             0014*  ;------------------------------------------------------------------------
0420B9 00 00 00    0015*  scratch1:	dw24	0	;bit manipulation buffer 1
0420BC 00 00 00    0016*  scratch2:	dw24	0	;bit manipulation buffer 2
0420BF             0017*  
0420BF             0018*  ; absolute value of hlu
0420BF             0019*  ; returns: abs(hlu), flags set according to the incoming sign of hlu:
0420BF             0020*  ;         s1,z0,pv0,n1,c0 if hlu was negative
0420BF             0021*  ;         s0,z1,pv0,n1,c0 if hlu was zero
0420BF             0022*  ;         s0,z0,pv0,n1,c0 if hlu was positive
0420BF             0023*  ; destroys: a
0420BF             0024*  hlu_abs:
0420BF 19          0025*      add hl,de
0420C0 B7          0026*      or a
0420C1 ED 52       0027*      sbc hl,de
0420C3 FA C8 20 04 0028*      jp m,@is_neg
0420C7 C9          0029*      ret         ; hlu is positive or zero so we're done
0420C8             0030*  @is_neg:
0420C8 F5          0031*      push af     ; otherwise, save current flags for return
0420C9 CD CF 20 04 0032*      call neg_hlu ; negate hlu
0420CD F1          0033*      pop af      ; get back flags
0420CE C9          0034*      ret
0420CF             0035*  
0420CF             0036*  ; flip the sign of hlu
0420CF             0037*  ; inputs: hlu
0420CF             0038*  ; returns: 0-hlu, flags set appropriately for the result:
0420CF             0039*  ;         s1,z0,pv0,n1,c1 if result is negative
0420CF             0040*  ;         s0,z1,pv0,n1,c0 if result is zero
0420CF             0041*  ;         s0,z0,pv0,n1,c1 if result is positive
0420CF             0042*  ; destroys a
0420CF             0043*  neg_hlu:
0420CF D5          0044*      push de     ; save de
0420D0 EB          0045*      ex de,hl    ; put hl into de
0420D1 21 00 00 00 0046*      ld hl,0     ; clear hl
0420D5 AF          0047*      xor a       ; clear carry
0420D6 ED 52       0048*      sbc hl,de   ; 0-hlu = -hlu
0420D8 D1          0049*      pop de      ; get de back
0420D9 C9          0050*      ret         ; easy peasy
0420DA             0051*  
0420DA             0052*  ;------------------------------------------------------------------------
0420DA             0053*  ; divide hlu by 2, inspired by above
0420DA             0054*  ;------------------------------------------------------------------------
0420DA             0055*  hlu_div2:
0420DA 22 B9 20 04 0056*  	ld		(scratch1),hl
0420DE 21 BB 20 04 0057*  	ld		hl,scratch1+2
0420E2 CB 1E       0058*  	rr		(hl)
0420E4 2B          0059*  	dec		hl
0420E5 CB 1E       0060*  	rr		(hl)
0420E7 2B          0061*  	dec		hl
0420E8 CB 1E       0062*  	rr		(hl)
0420EA 23          0063*  	inc		hl
0420EB 23          0064*  	inc		hl
0420EC 2A B9 20 04 0065*      ld hl,(scratch1)
0420F0 C9          0066*      ret
0420F1             0067*  
0420F1             0068*  ; this is my little hack to divide by 16
0420F1             0069*  hlu_div16:
0420F1 AF          0070*      xor a
0420F2 29          0071*      add hl,hl
0420F3 17          0072*      rla
0420F4 29          0073*      add hl,hl
0420F5 17          0074*      rla
0420F6 29          0075*      add hl,hl
0420F7 17          0076*      rla
0420F8 29          0077*      add hl,hl
0420F9 17          0078*      rla
0420FA 22 07 21 04 0079*      ld (@scratch),hl
0420FE 32 0A 21 04 0080*      ld (@scratch+3),a
042102 2A 08 21 04 0081*      ld hl,(@scratch+1)
042106 C9          0082*      ret
042107             0083*  @scratch: ds 4
04210B             0084*  
04210B             0085*  ; hlu signed division by 256
04210B             0086*  ; returns: hlu / 256
04210B             0087*  ; destroys: af
04210B             0088*  hlu_sdiv256:
04210B AF          0089*      xor a ; assume hl is positive
04210C 22 22 21 04 0090*      ld (@buffer),hl
042110             0091*      sign_hlu
042110 19          0001*M         add hl,de
042111 B7          0002*M         or a
042112 ED 52       0003*M         sbc hl,de
042114 F2 19 21 04 0092*      jp p,@hl_pos
042118 3D          0093*      dec a
042119             0094*  @hl_pos:
042119 32 25 21 04 0095*      ld (@buffer+3),a
04211D 2A 23 21 04 0096*      ld hl,(@buffer+1)
042121 C9          0097*      ret
042122             0098*  @buffer: ds 4
042126             0099*  
042126             0100*  ; hlu 1 byte right shift, unsigned
042126             0101*  ; returns: hlu / 256, fractional portion in a
042126             0102*  ; destroys: af
042126             0103*  hlu_udiv256:
042126 AF          0104*  	xor a
042127 32 38 21 04 0105*  	ld (@buffer+3),a
04212B 7D          0106*  	ld a,l ; save the fractional portion
04212C 22 35 21 04 0107*  	ld (@buffer),hl
042130 2A 36 21 04 0108*  	ld hl,(@buffer+1)
042134 C9          0109*  	ret
042135             0110*  @buffer: ds 4
042139             0111*  
042139             0112*      MACRO hlu_mul256
042139             0113*          add hl,hl ; * 2
042139             0114*          add hl,hl ; * 4
042139             0115*          add hl,hl ; * 8
042139             0116*          add hl,hl ; * 16
042139             0117*          add hl,hl ; * 32
042139             0118*          add hl,hl ; * 64
042139             0119*          add hl,hl ; * 128
042139             0120*          add hl,hl ; * 256
042139             0121*      ENDMACRO
042139             0122*  
042139             0123*  ; compute the modulo of hlu by deu
042139             0124*  ; outputs: hlu = hlu % deu
042139             0125*  ; destroys: f, hl
042139             0126*  hlu_mod:
042139 B7          0127*  	or a ; clear carry
04213A             0128*  @loop:
04213A ED 52       0129*      sbc hl,de
04213C DA 44 21 04 0130*      jp c, @end
042140 C3 3A 21 04 0131*      jp @loop
042144             0132*  @end:
042144 19          0133*      add hl,de
042145 C9          0134*  	ret
042146             0135*  
042146             0136*  
042146 00 00 00 00 0137*  add_bcd_arg1: db #00,#00,#00,#00
04214A 00 00 00 00 0138*  add_bcd_arg2: db #00,#00,#00,#00
04214E             0139*  
04214E             0140*  ; set bcd values in a scratch memory address from registers bcde
04214E             0141*  ; input: hl; scratch address,bcde; 8-place bcd number
04214E             0142*  ; destroys ; hl
04214E             0143*  set_bcd:
04214E 73          0144*      ld (hl),e
04214F 23          0145*      inc hl
042150 72          0146*      ld (hl),d
042151 23          0147*      inc hl
042152 71          0148*      ld (hl),c
042153 23          0149*      inc hl
042154 70          0150*      ld (hl),b
042155 C9          0151*      ret
042156             0152*  
042156             0153*  ; load bcd values from a scratch memory address to bcde
042156             0154*  ; input: hl; scratch address
042156             0155*  ; output: bcde; 8-place bcd number
042156             0156*  ; destroys: hl
042156             0157*  get_bcd:
042156 5E          0158*      ld e,(hl)
042157 23          0159*      inc hl
042158 56          0160*      ld d,(hl)
042159 23          0161*      inc hl
04215A 4E          0162*      ld c,(hl)
04215B 23          0163*      inc hl
04215C 46          0164*      ld b,(hl)
04215D C9          0165*      ret
04215E             0166*  
04215E             0167*  ; BCD addition
04215E             0168*  ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
04215E             0169*  ;       a is the number of bytes holding each number (number of places/2)
04215E             0170*  ; outputs: (hl) + (de) --> (hl)
04215E             0171*  ; destroys: a,b,de,hl
04215E             0172*  add_bcd:
04215E 47          0173*      ld b,a ; loop counter
04215F AF          0174*      xor a ; reset a, clear carry flag
042160             0175*  adcec:
042160 1A          0176*      ld a,(de) ; addend to acc
042161 8E          0177*      adc a,(hl) ; add (hl) to acc
042162 27          0178*      daa ; adjust result to bcd
042163 77          0179*      ld (hl),a ; store result
042164 23          0180*      inc hl ; advance memory pointers
042165 13          0181*      inc de
042166 10 F8       0182*      djnz adcec ; loop until b == 0
042168 C9          0183*      ret
042169             0184*  
042169             0185*  ; BCD subtraction
042169             0186*  ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
042169             0187*  ;       a is the number of bytes holding each number (number of places/2)
042169             0188*  ; outputs: (hl) - (de) --> (hl)
042169             0189*  ; destroys: a,b,de,hl
042169             0190*  sub_bcd:
042169 47          0191*      ld b,a ; loop counter
04216A AF          0192*      xor a ; reset a,clear carry flag
04216B             0193*  subdec:
04216B 1A          0194*      ld a,(de) ; subtrahend to acc
04216C 9E          0195*      sbc a,(hl) ; subtract (hl) from acc
04216D 27          0196*      daa ; adjust result to bcd
04216E 77          0197*      ld (hl),a ; store result
04216F 23          0198*      inc hl ; advance memory pointers
042170 13          0199*      inc de
042171 10 F8       0200*      djnz subdec ; loop until b == 0
042173 C9          0201*      ret
042174             0202*  
042174             0203*  ; http://www.z80.info/pseudo-random.txt
042174             0204*  rand_8:
042174 C5          0205*      push bc
042175 3A 88 21 04 0206*      ld a,(r_seed)
042179 4F          0207*      ld c,a
04217A             0208*  
04217A 0F          0209*      rrca ; multiply by 32
04217B 0F          0210*      rrca
04217C 0F          0211*      rrca
04217D EE 1F       0212*      xor 0x1f
04217F             0213*  
04217F 81          0214*      add a,c
042180 DE FF       0215*      sbc a,255 ; carry
042182             0216*  
042182 32 88 21 04 0217*      ld (r_seed),a
042186 C1          0218*      pop bc
042187 C9          0219*      ret
042188 50          0220*  r_seed: defb $50
042189             0059   	include "trig24fast.inc"
042189             0001*  
042189             0002*  ; convert signed angles from a 360 to 256 degree circle
042189             0003*  ; inputs: uh.l is the angle360 in 16.8 fixed format
042189             0004*  ; outputs: uh.l is the angle256 in 16.8 fixed format
042189             0005*  ; destroys: TODO
042189             0006*  deg_360_to_256:
042189 D5          0007*  	push de ; preserve de
04218A             0008*  ; make angle positive and store sign flag
04218A CD BF 20 04 0009*  	call hlu_abs
04218E F5          0010*  	push af
04218F             0011*  ; multiply by 256 first to keep precision
04218F             0012*  	hlu_mul256 ; uh.l = uh.l * 256
04218F 29          0001*M         add hl,hl ; * 2
042190 29          0002*M         add hl,hl ; * 4
042191 29          0003*M         add hl,hl ; * 8
042192 29          0004*M         add hl,hl ; * 16
042193 29          0005*M         add hl,hl ; * 32
042194 29          0006*M         add hl,hl ; * 64
042195 29          0007*M         add hl,hl ; * 128
042196 29          0008*M         add hl,hl ; * 256
042197             0013*  ; divide uh.l by 360
042197 11 68 01 00 0014*  	ld de,360
04219B CD 54 2C 04 0015*  	call udiv24 ; ud.e = degrees / 360
04219F EB          0016*  	ex de,hl    ; uh.l = degrees / 360
0421A0             0017*  ; restore sign flag and adjust output accordingly
0421A0 F1          0018*  	pop af
0421A1 F2 A9 21 04 0019*  	jp p,@pos ; positive number
0421A5 CD CF 20 04 0020*  	call neg_hlu
0421A9             0021*  @pos:
0421A9             0022*  ; restore de and return uh.l as the result
0421A9 D1          0023*  	pop de
0421AA C9          0024*  	ret
0421AB             0025*  
0421AB             0026*  ; fixed 16.8 routine
0421AB             0027*  ; cos(uh.l) --> uh.l
0421AB             0028*  ; destroys: f, hl
0421AB             0029*  cos168:
0421AB D5          0030*      push de ; preserve de
0421AC             0031*  ; for cos we simply increment the angle by 90 degrees
0421AC             0032*  ; or 0x004000 in 16.8 degrees256
0421AC             0033*  ; which makes it a sin problem
0421AC 11 00 40 00 0034*      ld de,0x004000
0421B0 19          0035*      add hl,de ; modulo 256 happens below
0421B1 D1          0036*      pop de ; restore de
0421B2             0037*  ; fall through to sin168
0421B2             0038*  
0421B2             0039*  ; ---------------------
0421B2             0040*  ; fixed 16.8 routine
0421B2             0041*  ; sin(uh.l) --> uh.l
0421B2             0042*  ; destroys: f, hl
0421B2             0043*  sin168:
0421B2 D5          0044*  	push de
0421B3             0045*  ; handle negative angles appropriately
0421B3 CD BF 20 04 0046*  	call hlu_abs
0421B7 F2 C0 21 04 0047*  	jp p,@F
0421BB 11 00 00 FF 0048*  	ld de,-256*256
0421BF 19          0049*  	add hl,de
0421C0             0050*  @@:
0421C0 2E 03       0051*  	ld l,3 ; multiply by 3 to get our lookup index
0421C2 ED 6C       0052*      mlt hl
0421C4 11 05 24 04 0053*      ld de,sin_lut_168 ; grab the lut address
0421C8 19          0054*      add hl,de ; bump hl by the index
0421C9 ED 27       0055*      ld hl,(hl) ; don't try this on a z80!
0421CB D1          0056*      pop de
0421CC C9          0057*      ret
0421CD             0058*  
0421CD             0059*  ; 16.8 fixed inputs / outputs
0421CD             0060*  ; takes: uh.l as angle in degrees 256
0421CD             0061*  ;        ud.e as radius
0421CD             0062*  ; returns ub.c as dx, ud.e as dy, uh.l as radius
0421CD             0063*  ;        displacements from origin (0,0)
0421CD             0064*  ; destroys: everything except indexes
0421CD             0065*  polar_to_cartesian:
0421CD             0066*  ; back up input parameters
0421CD 22 00 22 04 0067*      ld (@angle), hl
0421D1 ED 53 03 22 0068*      ld (@radius), de
       04          
0421D6             0069*  ; compute dx = sin(uh.l) * ud.e
0421D6 CD AB 21 04 0070*      call cos168 ; uh.l = cos(uh.l)
0421DA ED 5B 03 22 0071*  	ld de,(@radius)
       04          
0421DF CD C9 2B 04 0072*  	call smul168 ; uh.l = dx
0421E3 E5          0073*      push hl
0421E4             0074*  ; compute dy = -cos(uh.l) * ud.e
0421E4 2A 00 22 04 0075*      ld hl,(@angle)
0421E8 CD B2 21 04 0076*      call sin168 ; uh.l = cos(uh.l)
0421EC ED 5B 03 22 0077*      ld de,(@radius)
       04          
0421F1 CD C9 2B 04 0078*      call smul168    ; uh.l = dy
0421F5 CD CF 20 04 0079*      call neg_hlu ; invert dy for screen coords convention
0421F9 EB          0080*      ex de,hl       ; de = dy for output
0421FA C1          0081*      pop bc          ; bc = dx for output
0421FB CD 92 18 04 0082*  	call dumpRegistersHex ; DEBUG
0421FF             0083*  ; and out
0421FF C9          0084*      ret
042200             0085*  @angle: ds 3
042203             0086*  @radius: ds 3
042206             0087*  
042206             0088*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
042206             0089*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
042206             0090*  ; output: ub.c and ud.e are dx and dy in 16.8 fixed format
042206             0091*  ;         also populates scratch locations dx168 and dy168
042206             0092*  ; destroys: a,hl,bc,de
042206             0093*  dxy168:
042206             0094*  ; compute dx = x1-x0
042206 AF          0095*      xor a ; clear carry
042207 DD E5       0096*      push ix ; move ix to hl via the stack
042209 E1          0097*      pop hl ; hl = x1
04220A ED 42       0098*      sbc hl,bc ; hl = dx
04220C 22 61 22 04 0099*      ld (dx168),hl ; dx to scratch
042210             0100*  ; compute dy = y1-y0
042210 AF          0101*      xor a ; clear carry
042211 FD E5       0102*      push iy ; move iy to hl via the stack
042213 E1          0103*      pop hl ; hl = y1
042214 ED 52       0104*      sbc hl,de ; hl = dy
042216 22 67 22 04 0105*      ld (dy168),hl ; dy to scratch
04221A             0106*  ; populate output registers and return
04221A EB          0107*      ex de,hl        ; ud.e = dy
04221B ED 4B 61 22 0108*      ld bc,(dx168)   ; ub.c = dx
       04          
042220 C9          0109*      ret
042221             0110*  
042221             0111*  ; compute the euclidian distance between two cartesian coordinates
042221             0112*  ; using the formula d = sqrt(dx^2+dy^2
042221             0113*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
042221             0114*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
042221             0115*  ; output; uh.l is the 16.8 fixed format distance
042221             0116*  ;       dx168/y are the 16.8 fixed format dx and dy
042221             0117*  ; destroys: a,hl,bc,de
042221             0118*  distance168:
042221             0119*  ; compute dx = x1-x0
042221 AF          0120*      xor a ; clear carry
042222 DD E5       0121*      push ix ; move ix to hl via the stack
042224 E1          0122*      pop hl ; hl = x1
042225 ED 42       0123*      sbc hl,bc ; hl = dx
042227 22 61 22 04 0124*      ld (dx168),hl ; dx to scratch
04222B             0125*  ; ; test dx for overflow
04222B             0126*  ; 	ld de,0x007F00 ; max positive 16.8 value we can square without overflow
04222B             0127*  ; 	ex de,hl
04222B             0128*  ; 	sbc hl,de ; test for overflow
04222B             0129*  ; 	push af ; carry indicates overflow
04222B             0130*  ; compute dy = y1-y0
04222B AF          0131*      xor a ; clear carry
04222C FD E5       0132*      push iy ; move iy to hl via the stack
04222E E1          0133*      pop hl ; hl = y1
04222F ED 52       0134*      sbc hl,de ; hl = dy
042231 22 67 22 04 0135*      ld (dy168),hl ; dy to scratch
042235             0136*  ; ; test dy for overflow
042235             0137*  ; 	ld de,0x007F00 ; max positive 16.8 value we can square without overflow
042235             0138*  ; 	ex de,hl
042235             0139*  ; 	sbc hl,de ; test for overflow
042235             0140*  ; 	push af ; carry indicates overflow
042235             0141*  ; compute dy^2
042235 2A 67 22 04 0142*  	ld hl,(dy168)
042239 CD BF 20 04 0143*      call hlu_abs  ; make dy positive so we can use unsigned multiply
04223D             0144*      ; call hlu_div2 ; divide hlu by 2 to give us some headroom
04223D E5          0145*      push hl ; load hl/2 to bc via the stack
04223E C1          0146*      pop bc ; bc = dy/2
04223F EB          0147*      ex de,hl ; de = dy/2
042240 CD C1 2B 04 0148*      call umul168 ; uh.l = dy^2/2
042244 E5          0149*      push hl ; dy^2/2 to the stack
042245             0150*  ; compute dx^2
042245 2A 61 22 04 0151*      ld hl,(dx168) ; get back dx
042249 CD BF 20 04 0152*      call hlu_abs  ; make dx positive so we can use unsigned multiply
04224D             0153*      ; call hlu_div2 ; divide hlu by 2 to give us some headroom
04224D E5          0154*      push hl ; load hl/2 to bc via the stack
04224E C1          0155*      pop bc ; bc = dx/2
04224F EB          0156*      ex de,hl ; de = dx/2
042250 CD C1 2B 04 0157*      call umul168 ; uh.l = dx^2/2
042254             0158*  ; commpute dy^2+dx^2
042254 D1          0159*      pop de ; get back dx^2/2
042255 19          0160*      add hl,de ; hl = dx^2/2+dy^2/2
042256             0161*  ; compute sqrt(dx^2/2+dy^2/2)
042256 CD 1A 23 04 0162*      call sqrt168 ; uh.l = distance/2
04225A             0163*      ; add hl,hl ; hl = distance
04225A             0164*  ; ; check for overflow
04225A             0165*  ; 	pop af ; get back the overflow flags
04225A             0166*  ; 	sbc a,a ; will be -1 if overflow, 0 if not
04225A             0167*  ; 	ld b,a ; save the overflow flag
04225A             0168*  ; 	pop af ; get back the overflow flags
04225A             0169*  ; 	sbc a,a ; will be -1 if overflow, 0 if not
04225A             0170*  ; 	add a,b ; if a != 0 then we had overflow
04225A             0171*  ;     ret z ; no overflow we're done
04225A             0172*  ; @overflow:
04225A             0173*  ; 	ld hl,0x7FFFFF ; max positive 16.8 fixed value indicates overflow
04225A C9          0174*  	ret
04225B             0175*  @scratch: ds 6
042261             0176*  dx168: ds 6
042267             0177*  dy168: ds 6
04226D             0178*  
04226D             0179*  ; atan2(ub.c,ud.e) --> uh.l
04226D             0180*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
04226D             0181*  ;   whether inputs are integers or fractional doesn't matter
04226D             0182*  ;   so long as the sign bit of the upper byte is correct
04226D             0183*  ; output: uh.l is the 16.8 fixed angle in degrees 256
04226D             0184*  ; angles are COMPASS HEADINGS based on
04226D             0185*  ; screen coordinate conventions,where the y axis is flipped
04226D             0186*  ; #E0 315      0       45 #20
04226D             0187*  ;        -x,-y | +x,-y
04226D             0188*  ; #C0 270------+------ 90 #40
04226D             0189*  ;        -x,+y | +x,+y
04226D             0190*  ; #A0 225   180 #80   135 #60
04226D             0191*  atan2_168game:
04226D             0192*  ; get signs and make everything positive
04226D             0193*  ; get abs(x) and store its original sign
04226D C5          0194*      push bc
04226E E1          0195*      pop hl
04226F CD BF 20 04 0196*      call hlu_abs ; if x was negative this also sets the sign flag
042273 E5          0197*      push hl ; store abs(x)
042274 C1          0198*      pop bc ; bc = abs(x)
042275 F5          0199*      push af ; store sign of x
042276             0200*  ; get abs(y) and store its original sign
042276 EB          0201*      ex de,hl ; hl = y
042277 CD BF 20 04 0202*      call hlu_abs ; if y was negative this also sets the sign flag
04227B EB          0203*      ex de,hl ; de = abs(y)
04227C F5          0204*      push af ; store sign of y
04227D             0205*  ; if abs(bc) < abs(de),then we do bc/de,otherwise de/bc
04227D             0206*  ; this ensures that our lookup value is between 0 and 1 inclusive
04227D AF          0207*      xor a ; clear the carry flag
04227E D5          0208*      push de
04227F E1          0209*      pop hl
042280 ED 42       0210*      sbc hl,bc
042282 F5          0211*      push af ; save sign of de - bc
042283 F2 8C 22 04 0212*      jp p,@1 ; bc <= de, so we skip ahead
042287             0213*  ; otherwise we swap bc and de
042287 C5          0214*      push bc
042288 E1          0215*      pop hl
042289 EB          0216*      ex de,hl
04228A E5          0217*      push hl
04228B C1          0218*      pop bc
04228C             0219*  @1:
04228C             0220*  ; now we're ready to snag our preliminary result
04228C CD FA 22 04 0221*      call atan_168game ; uh.l comes back with prelim result
042290             0222*  ; now we adjust uh.l based on sign of de - bc
042290 F1          0223*      pop af
042291 F2 9D 22 04 0224*      jp p,@2 ; bc <= de,so we skip ahead
042295 EB          0225*      ex de,hl
042296 21 00 40 00 0226*      ld hl,0x004000 ; 90 degrees
04229A AF          0227*      xor a ; clear the carry flag
04229B ED 52       0228*      sbc hl,de ; subtract result from 90 degrees
04229D             0229*      ; ld de,0 ; prep to clear hlu
04229D             0230*      ; ld d,h
04229D             0231*      ; ld e,l
04229D             0232*      ; ex de,hl ; now we have 0 <= uh.l < 256 in 16.8 fixed format
04229D             0233*      ; fall through
04229D             0234*  @2:
04229D             0235*  ; now the fun part of adjusting the result
04229D             0236*  ; based on which quadrant (x,y) is in
04229D             0237*  ; #E0 315      0       45 #20
04229D             0238*  ;        -x,-y | +x,-y
04229D             0239*  ; #C0 270------+------ 90 #40
04229D             0240*  ;        -x,+y | +x,+y
04229D             0241*  ; #A0 225   180 #80   135 #60
04229D F1          0242*      pop af ; sign of y
04229E CA DB 22 04 0243*      jp z,@y_zero
0422A2 F2 BB 22 04 0244*      jp p,@y_pos
0422A6             0245*  ; y neg,check x
0422A6 F1          0246*      pop af ; sign of x
0422A7 CA B5 22 04 0247*      jp z,@y_neg_x_zero
0422AB F2 BA 22 04 0248*      jp p,@y_neg_x_pos
0422AF             0249*  ; y neg,x neg
0422AF             0250*  ; angle is 270-360
0422AF             0251*  ; negating the intermediate does the trick
0422AF CD CF 20 04 0252*      call neg_hlu
0422B3 18 31       0253*      jr @zero_hlu
0422B5             0254*  
0422B5             0255*  @y_neg_x_zero:
0422B5             0256*  ; y neg,x zero
0422B5             0257*  ; angle is 0
0422B5 21 00 00 00 0258*      ld hl,0
0422B9 C9          0259*      ret
0422BA             0260*  @y_neg_x_pos:
0422BA             0261*  ; y neg,x pos
0422BA             0262*  ; angle is 0 to 90
0422BA             0263*  ; so we're good
0422BA C9          0264*      ret
0422BB             0265*  
0422BB             0266*  @y_pos:
0422BB F1          0267*      pop af ; sign of x
0422BC CA CB 22 04 0268*      jp z,@y_pos_x_zero
0422C0 F2 D0 22 04 0269*      jp p,@y_pos_x_pos
0422C4             0270*  ; y pos,x neg
0422C4             0271*  ; angle is 180-270
0422C4             0272*  ; so we add 180 to intermediate
0422C4 11 00 80 00 0273*      ld de,0x008000
0422C8 19          0274*      add hl,de
0422C9 18 1B       0275*      jr @zero_hlu
0422CB             0276*  @y_pos_x_zero:
0422CB             0277*  ; y pos,x zero
0422CB             0278*  ; angle is 180
0422CB 21 00 80 00 0279*      ld hl,0x008000
0422CF C9          0280*      ret
0422D0             0281*  @y_pos_x_pos:
0422D0             0282*  ; y pos,x pos
0422D0             0283*  ; angle is 90-180
0422D0             0284*  ; neg the intermediate and add 180 degrees
0422D0 CD CF 20 04 0285*      call neg_hlu
0422D4 11 00 80 00 0286*      ld de,0x008000
0422D8 19          0287*      add hl,de
0422D9 18 0B       0288*      jr @zero_hlu
0422DB             0289*  
0422DB             0290*  @y_zero:
0422DB F1          0291*      pop af ; sign of x
0422DC FA E1 22 04 0292*      jp m,@y_zero_x_neg
0422E0             0293*  ; y zero,x pos
0422E0             0294*  ; angle is 90,nothing to do
0422E0 C9          0295*      ret
0422E1             0296*  @y_zero_x_neg:
0422E1             0297*  ; y zero ,x neg
0422E1             0298*  ; angle is 270
0422E1 21 00 C0 00 0299*      ld hl,0x00C000
0422E5 C9          0300*      ret
0422E6             0301*  @zero_hlu:
0422E6 AF          0302*      xor a
0422E7 22 F4 22 04 0303*      ld (@scratch),hl
0422EB 32 F6 22 04 0304*      ld (@scratch+2),a
0422EF 2A F4 22 04 0305*      ld hl,(@scratch)
0422F3 C9          0306*      ret
0422F4             0307*  @scratch: ds 6
0422FA             0308*  
0422FA             0309*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
0422FA             0310*  ; output: uh.l is the 16.8 fixed format angle
0422FA             0311*  ; destroys: a,hl,bc,de
0422FA             0312*  ; the following note was written by github copilot:
0422FA             0313*  ; note: this routine is a bit of a hack
0422FA             0314*  ;      but it works
0422FA             0315*  ;      and it's fast
0422FA             0316*  ;      and it's small
0422FA             0317*  ;      and it's accurate
0422FA             0318*  ;      and it's easy to understand
0422FA             0319*  ;      and it's easy to modify
0422FA             0320*  ;      and it's easy to use
0422FA             0321*  ;      and it's easy to remember
0422FA             0322*  ;      and it's easy to love
0422FA             0323*  ;      and it's easy to hate
0422FA             0324*  ;      and it's easy to ignore
0422FA             0325*  ;      and it's easy to forget
0422FA             0326*  ;      and it's easy to remember
0422FA             0327*  ;      and it's easy to forget
0422FA             0328*  ;      and it's easy to remember
0422FA             0329*  ;      (ok the bot is stuck in a loop)
0422FA             0330*  ; REAL NOTE: only works for angles from 0 to 45 degrees
0422FA             0331*  ;   use atan2_168 (which calls this proc) to handle the full 360 degrees
0422FA             0332*  atan_168game:
0422FA             0333*  ; because we use compass headings instead of geometric angles
0422FA             0334*  ; we compute dx/dy which is 1/tan(theta) in the maths world
0422FA             0335*  ; we can do faster unsigned division here because we know dx and dy are positive
0422FA CD EC 2B 04 0336*  	call udiv168 ; uh.l = dx/dy
0422FE             0337*  ; ; TODO: IMPLEMENT THIS, RIGHT NOW IS IS BUGGED
0422FE             0338*  ; ; test uh.l for 0
0422FE             0339*  ;     add hl,de
0422FE             0340*  ;     or a
0422FE             0341*  ;     sbc hl,de
0422FE             0342*  ;     jr z,@is_zero
0422FE             0343*  ; ; test uh.l for 1
0422FE             0344*  ;     xor a ; clear carry
0422FE             0345*  ;     ex de,hl
0422FE             0346*  ;     ld hl,0x000100 ; 1 in 16.8 fixed format
0422FE             0347*  ;     sbc hl,de
0422FE             0348*  ;     jr z,@is_45
0422FE             0349*  ; ; END TODO
0422FE             0350*  
0422FE             0351*  ; no special cases so we move on
0422FE             0352*  ; l contains the fractional portion of tan(uh.l)
0422FE             0353*  ; we multiply it by three to get our lookup table index
0422FE 26 03       0354*      ld h,3
042300 ED 6C       0355*      mlt hl ; gosh that is handy
042302 11 00 00 00 0356*      ld de,0 ; clear deu
042306 54          0357*      ld d,h ; copy hl to de
042307 5D          0358*      ld e,l ; de contains our index
042308 21 08 27 04 0359*      ld hl,atan_lut_168 ; grab the lut address
04230C 19          0360*      add hl,de ; bump hl by the index
04230D ED 27       0361*      ld hl,(hl) ; don't try this on a z80!
04230F C9          0362*      ret ; and out
042310             0363*  @is_45:
042310 21 00 20 00 0364*      ld hl,0x002000 ; 45 degrees decimal
042314 C9          0365*      ret
042315             0366*  ; for the case tan(0)
042315             0367*  @is_zero:
042315 21 00 00 00 0368*      ld hl,0x000000
042319 C9          0369*      ret
04231A             0370*  
04231A             0371*  
04231A             0372*  ; Expects  ADL mode
04231A             0373*  ; Inputs:  UH.L
04231A             0374*  ; Outputs: UH.L is the 16.8 square root
04231A             0375*  ;          UD.E is the difference inputHL-DE^2
04231A             0376*  ;          c flag reset
04231A             0377*  sqrt168:
04231A CD 24 23 04 0378*      call sqrt24
04231E EB          0379*      ex de,hl
04231F 29          0380*      add hl,hl
042320 29          0381*      add hl,hl
042321 29          0382*      add hl,hl
042322 29          0383*      add hl,hl
042323 C9          0384*      ret
042324             0385*  
042324             0386*  ; Expects  ADL mode
042324             0387*  ; Inputs:  HL
042324             0388*  ; Outputs: DE is the integer square root
042324             0389*  ;          HL is the difference inputHL-DE^2
042324             0390*  ;          c flag reset
042324             0391*  sqrt24:
042324 AF          0392*      xor a
042325 45          0393*      ld b,l
042326 C5          0394*      push bc
042327 47          0395*      ld b,a
042328 57          0396*      ld d,a
042329 4F          0397*      ld c,a
04232A 6F          0398*      ld l,a
04232B 5F          0399*      ld e,a
04232C             0400*  
04232C             0401*      ;Iteration 1
04232C 29          0402*      add hl,hl
04232D CB 11       0403*      rl c
04232F 29          0404*      add hl,hl
042330 CB 11       0405*      rl c
042332 91          0406*      sub c
042333 30 04       0407*      jr nc,$+6
042335 1C          0408*      inc e
042336 1C          0409*      inc e
042337 2F          0410*      cpl
042338 4F          0411*      ld c,a
042339             0412*  
042339             0413*      ;Iteration 2
042339 29          0414*      add hl,hl
04233A CB 11       0415*      rl c
04233C 29          0416*      add hl,hl
04233D CB 11       0417*      rl c
04233F CB 13       0418*      rl e
042341 7B          0419*      ld a,e
042342 91          0420*      sub c
042343 30 04       0421*      jr nc,$+6
042345 1C          0422*      inc e
042346 1C          0423*      inc e
042347 2F          0424*      cpl
042348 4F          0425*      ld c,a
042349             0426*  
042349             0427*      ;Iteration 3
042349 29          0428*      add hl,hl
04234A CB 11       0429*      rl c
04234C 29          0430*      add hl,hl
04234D CB 11       0431*      rl c
04234F CB 13       0432*      rl e
042351 7B          0433*      ld a,e
042352 91          0434*      sub c
042353 30 04       0435*      jr nc,$+6
042355 1C          0436*      inc e
042356 1C          0437*      inc e
042357 2F          0438*      cpl
042358 4F          0439*      ld c,a
042359             0440*  
042359             0441*      ;Iteration 4
042359 29          0442*      add hl,hl
04235A CB 11       0443*      rl c
04235C 29          0444*      add hl,hl
04235D CB 11       0445*      rl c
04235F CB 13       0446*      rl e
042361 7B          0447*      ld a,e
042362 91          0448*      sub c
042363 30 04       0449*      jr nc,$+6
042365 1C          0450*      inc e
042366 1C          0451*      inc e
042367 2F          0452*      cpl
042368 4F          0453*      ld c,a
042369             0454*  
042369             0455*      ;Iteration 5
042369 29          0456*      add hl,hl
04236A CB 11       0457*      rl c
04236C 29          0458*      add hl,hl
04236D CB 11       0459*      rl c
04236F CB 13       0460*      rl e
042371 7B          0461*      ld a,e
042372 91          0462*      sub c
042373 30 04       0463*      jr nc,$+6
042375 1C          0464*      inc e
042376 1C          0465*      inc e
042377 2F          0466*      cpl
042378 4F          0467*      ld c,a
042379             0468*  
042379             0469*      ;Iteration 6
042379 29          0470*      add hl,hl
04237A CB 11       0471*      rl c
04237C 29          0472*      add hl,hl
04237D CB 11       0473*      rl c
04237F CB 13       0474*      rl e
042381 7B          0475*      ld a,e
042382 91          0476*      sub c
042383 30 04       0477*      jr nc,$+6
042385 1C          0478*      inc e
042386 1C          0479*      inc e
042387 2F          0480*      cpl
042388 4F          0481*      ld c,a
042389             0482*  
042389             0483*      ;Iteration 7
042389 29          0484*      add hl,hl
04238A CB 11       0485*      rl c
04238C 29          0486*      add hl,hl
04238D CB 11       0487*      rl c
04238F CB 10       0488*      rl b
042391 EB          0489*      ex de,hl
042392 29          0490*      add hl,hl
042393 E5          0491*      push hl
042394 ED 42       0492*      sbc hl,bc
042396 30 06       0493*      jr nc,$+8
042398 7C          0494*      ld a,h
042399 2F          0495*      cpl
04239A 47          0496*      ld b,a
04239B 7D          0497*      ld a,l
04239C 2F          0498*      cpl
04239D 4F          0499*      ld c,a
04239E E1          0500*      pop hl
04239F 30 02       0501*      jr nc,$+4
0423A1 23          0502*      inc hl
0423A2 23          0503*      inc hl
0423A3 EB          0504*      ex de,hl
0423A4             0505*  
0423A4             0506*      ;Iteration 8
0423A4 29          0507*      add hl,hl
0423A5 69          0508*      ld l,c
0423A6 60          0509*      ld h,b
0423A7 ED 6A       0510*      adc hl,hl
0423A9 ED 6A       0511*      adc hl,hl
0423AB EB          0512*      ex de,hl
0423AC 29          0513*      add hl,hl
0423AD ED 52       0514*      sbc hl,de
0423AF 19          0515*      add hl,de
0423B0 EB          0516*      ex de,hl
0423B1 30 04       0517*      jr nc,$+6
0423B3 ED 52       0518*      sbc hl,de
0423B5 13          0519*      inc de
0423B6 13          0520*      inc de
0423B7             0521*  
0423B7             0522*      ;Iteration 9
0423B7 F1          0523*      pop af
0423B8 17          0524*      rla
0423B9 ED 6A       0525*      adc hl,hl
0423BB 17          0526*      rla
0423BC ED 6A       0527*      adc hl,hl
0423BE EB          0528*      ex de,hl
0423BF 29          0529*      add hl,hl
0423C0 ED 52       0530*      sbc hl,de
0423C2 19          0531*      add hl,de
0423C3 EB          0532*      ex de,hl
0423C4 30 04       0533*      jr nc,$+6
0423C6 ED 52       0534*      sbc hl,de
0423C8 13          0535*      inc de
0423C9 13          0536*      inc de
0423CA             0537*  
0423CA             0538*      ;Iteration 10
0423CA 17          0539*      rla
0423CB ED 6A       0540*      adc hl,hl
0423CD 17          0541*      rla
0423CE ED 6A       0542*      adc hl,hl
0423D0 EB          0543*      ex de,hl
0423D1 29          0544*      add hl,hl
0423D2 ED 52       0545*      sbc hl,de
0423D4 19          0546*      add hl,de
0423D5 EB          0547*      ex de,hl
0423D6 30 04       0548*      jr nc,$+6
0423D8 ED 52       0549*      sbc hl,de
0423DA 13          0550*      inc de
0423DB 13          0551*      inc de
0423DC             0552*  
0423DC             0553*      ;Iteration 11
0423DC 17          0554*      rla
0423DD ED 6A       0555*      adc hl,hl
0423DF 17          0556*      rla
0423E0 ED 6A       0557*      adc hl,hl
0423E2 EB          0558*      ex de,hl
0423E3 29          0559*      add hl,hl
0423E4 ED 52       0560*      sbc hl,de
0423E6 19          0561*      add hl,de
0423E7 EB          0562*      ex de,hl
0423E8 30 04       0563*      jr nc,$+6
0423EA ED 52       0564*      sbc hl,de
0423EC 13          0565*      inc de
0423ED 13          0566*      inc de
0423EE             0567*  
0423EE             0568*      ;Iteration 11
0423EE 17          0569*      rla
0423EF ED 6A       0570*      adc hl,hl
0423F1 17          0571*      rla
0423F2 ED 6A       0572*      adc hl,hl
0423F4 EB          0573*      ex de,hl
0423F5 29          0574*      add hl,hl
0423F6 ED 52       0575*      sbc hl,de
0423F8 19          0576*      add hl,de
0423F9 EB          0577*      ex de,hl
0423FA 30 04       0578*      jr nc,$+6
0423FC ED 52       0579*      sbc hl,de
0423FE 13          0580*      inc de
0423FF 13          0581*      inc de
042400             0582*  
042400 CB 1A       0583*      rr d
042402 CB 1B       0584*      rr e
042404 C9          0585*      ret
042405             0586*  
042405             0587*  sin_lut_168:
042405 00 00 00    0588*  	dl 0x000000 ; 0.000 00, 0.000
042408 06 00 00    0589*  	dl 0x000006 ; 1.406 01, 0.025
04240B 0C 00 00    0590*  	dl 0x00000C ; 2.813 02, 0.049
04240E 12 00 00    0591*  	dl 0x000012 ; 4.219 03, 0.074
042411 19 00 00    0592*  	dl 0x000019 ; 5.625 04, 0.098
042414 1F 00 00    0593*  	dl 0x00001F ; 7.031 05, 0.122
042417 25 00 00    0594*  	dl 0x000025 ; 8.438 06, 0.147
04241A 2B 00 00    0595*  	dl 0x00002B ; 9.844 07, 0.171
04241D 31 00 00    0596*  	dl 0x000031 ; 11.250 08, 0.195
042420 38 00 00    0597*  	dl 0x000038 ; 12.656 09, 0.219
042423 3E 00 00    0598*  	dl 0x00003E ; 14.063 0A, 0.243
042426 44 00 00    0599*  	dl 0x000044 ; 15.469 0B, 0.267
042429 4A 00 00    0600*  	dl 0x00004A ; 16.875 0C, 0.290
04242C 50 00 00    0601*  	dl 0x000050 ; 18.281 0D, 0.314
04242F 56 00 00    0602*  	dl 0x000056 ; 19.688 0E, 0.337
042432 5C 00 00    0603*  	dl 0x00005C ; 21.094 0F, 0.360
042435 61 00 00    0604*  	dl 0x000061 ; 22.500 10, 0.383
042438 67 00 00    0605*  	dl 0x000067 ; 23.906 11, 0.405
04243B 6D 00 00    0606*  	dl 0x00006D ; 25.313 12, 0.428
04243E 73 00 00    0607*  	dl 0x000073 ; 26.719 13, 0.450
042441 78 00 00    0608*  	dl 0x000078 ; 28.125 14, 0.471
042444 7E 00 00    0609*  	dl 0x00007E ; 29.531 15, 0.493
042447 83 00 00    0610*  	dl 0x000083 ; 30.938 16, 0.514
04244A 88 00 00    0611*  	dl 0x000088 ; 32.344 17, 0.535
04244D 8E 00 00    0612*  	dl 0x00008E ; 33.750 18, 0.556
042450 93 00 00    0613*  	dl 0x000093 ; 35.156 19, 0.576
042453 98 00 00    0614*  	dl 0x000098 ; 36.563 1A, 0.596
042456 9D 00 00    0615*  	dl 0x00009D ; 37.969 1B, 0.615
042459 A2 00 00    0616*  	dl 0x0000A2 ; 39.375 1C, 0.634
04245C A7 00 00    0617*  	dl 0x0000A7 ; 40.781 1D, 0.653
04245F AB 00 00    0618*  	dl 0x0000AB ; 42.188 1E, 0.672
042462 B0 00 00    0619*  	dl 0x0000B0 ; 43.594 1F, 0.690
042465 B5 00 00    0620*  	dl 0x0000B5 ; 45.000 20, 0.707
042468 B9 00 00    0621*  	dl 0x0000B9 ; 46.406 21, 0.724
04246B BD 00 00    0622*  	dl 0x0000BD ; 47.813 22, 0.741
04246E C1 00 00    0623*  	dl 0x0000C1 ; 49.219 23, 0.757
042471 C5 00 00    0624*  	dl 0x0000C5 ; 50.625 24, 0.773
042474 C9 00 00    0625*  	dl 0x0000C9 ; 52.031 25, 0.788
042477 CD 00 00    0626*  	dl 0x0000CD ; 53.438 26, 0.803
04247A D1 00 00    0627*  	dl 0x0000D1 ; 54.844 27, 0.818
04247D D4 00 00    0628*  	dl 0x0000D4 ; 56.250 28, 0.831
042480 D8 00 00    0629*  	dl 0x0000D8 ; 57.656 29, 0.845
042483 DB 00 00    0630*  	dl 0x0000DB ; 59.063 2A, 0.858
042486 DE 00 00    0631*  	dl 0x0000DE ; 60.469 2B, 0.870
042489 E1 00 00    0632*  	dl 0x0000E1 ; 61.875 2C, 0.882
04248C E4 00 00    0633*  	dl 0x0000E4 ; 63.281 2D, 0.893
04248F E7 00 00    0634*  	dl 0x0000E7 ; 64.688 2E, 0.904
042492 EA 00 00    0635*  	dl 0x0000EA ; 66.094 2F, 0.914
042495 EC 00 00    0636*  	dl 0x0000EC ; 67.500 30, 0.924
042498 EE 00 00    0637*  	dl 0x0000EE ; 68.906 31, 0.933
04249B F1 00 00    0638*  	dl 0x0000F1 ; 70.313 32, 0.942
04249E F3 00 00    0639*  	dl 0x0000F3 ; 71.719 33, 0.950
0424A1 F4 00 00    0640*  	dl 0x0000F4 ; 73.125 34, 0.957
0424A4 F6 00 00    0641*  	dl 0x0000F6 ; 74.531 35, 0.964
0424A7 F8 00 00    0642*  	dl 0x0000F8 ; 75.938 36, 0.970
0424AA F9 00 00    0643*  	dl 0x0000F9 ; 77.344 37, 0.976
0424AD FB 00 00    0644*  	dl 0x0000FB ; 78.750 38, 0.981
0424B0 FC 00 00    0645*  	dl 0x0000FC ; 80.156 39, 0.985
0424B3 FD 00 00    0646*  	dl 0x0000FD ; 81.563 3A, 0.989
0424B6 FE 00 00    0647*  	dl 0x0000FE ; 82.969 3B, 0.992
0424B9 FE 00 00    0648*  	dl 0x0000FE ; 84.375 3C, 0.995
0424BC FF 00 00    0649*  	dl 0x0000FF ; 85.781 3D, 0.997
0424BF FF 00 00    0650*  	dl 0x0000FF ; 87.188 3E, 0.999
0424C2 FF 00 00    0651*  	dl 0x0000FF ; 88.594 3F, 1.000
0424C5 00 01 00    0652*  	dl 0x000100 ; 90.000 40, 1.000
0424C8 FF 00 00    0653*  	dl 0x0000FF ; 91.406 41, 1.000
0424CB FF 00 00    0654*  	dl 0x0000FF ; 92.813 42, 0.999
0424CE FF 00 00    0655*  	dl 0x0000FF ; 94.219 43, 0.997
0424D1 FE 00 00    0656*  	dl 0x0000FE ; 95.625 44, 0.995
0424D4 FE 00 00    0657*  	dl 0x0000FE ; 97.031 45, 0.992
0424D7 FD 00 00    0658*  	dl 0x0000FD ; 98.438 46, 0.989
0424DA FC 00 00    0659*  	dl 0x0000FC ; 99.844 47, 0.985
0424DD FB 00 00    0660*  	dl 0x0000FB ; 101.250 48, 0.981
0424E0 F9 00 00    0661*  	dl 0x0000F9 ; 102.656 49, 0.976
0424E3 F8 00 00    0662*  	dl 0x0000F8 ; 104.063 4A, 0.970
0424E6 F6 00 00    0663*  	dl 0x0000F6 ; 105.469 4B, 0.964
0424E9 F4 00 00    0664*  	dl 0x0000F4 ; 106.875 4C, 0.957
0424EC F3 00 00    0665*  	dl 0x0000F3 ; 108.281 4D, 0.950
0424EF F1 00 00    0666*  	dl 0x0000F1 ; 109.688 4E, 0.942
0424F2 EE 00 00    0667*  	dl 0x0000EE ; 111.094 4F, 0.933
0424F5 EC 00 00    0668*  	dl 0x0000EC ; 112.500 50, 0.924
0424F8 EA 00 00    0669*  	dl 0x0000EA ; 113.906 51, 0.914
0424FB E7 00 00    0670*  	dl 0x0000E7 ; 115.313 52, 0.904
0424FE E4 00 00    0671*  	dl 0x0000E4 ; 116.719 53, 0.893
042501 E1 00 00    0672*  	dl 0x0000E1 ; 118.125 54, 0.882
042504 DE 00 00    0673*  	dl 0x0000DE ; 119.531 55, 0.870
042507 DB 00 00    0674*  	dl 0x0000DB ; 120.938 56, 0.858
04250A D8 00 00    0675*  	dl 0x0000D8 ; 122.344 57, 0.845
04250D D4 00 00    0676*  	dl 0x0000D4 ; 123.750 58, 0.831
042510 D1 00 00    0677*  	dl 0x0000D1 ; 125.156 59, 0.818
042513 CD 00 00    0678*  	dl 0x0000CD ; 126.563 5A, 0.803
042516 C9 00 00    0679*  	dl 0x0000C9 ; 127.969 5B, 0.788
042519 C5 00 00    0680*  	dl 0x0000C5 ; 129.375 5C, 0.773
04251C C1 00 00    0681*  	dl 0x0000C1 ; 130.781 5D, 0.757
04251F BD 00 00    0682*  	dl 0x0000BD ; 132.188 5E, 0.741
042522 B9 00 00    0683*  	dl 0x0000B9 ; 133.594 5F, 0.724
042525 B5 00 00    0684*  	dl 0x0000B5 ; 135.000 60, 0.707
042528 B0 00 00    0685*  	dl 0x0000B0 ; 136.406 61, 0.690
04252B AB 00 00    0686*  	dl 0x0000AB ; 137.813 62, 0.672
04252E A7 00 00    0687*  	dl 0x0000A7 ; 139.219 63, 0.653
042531 A2 00 00    0688*  	dl 0x0000A2 ; 140.625 64, 0.634
042534 9D 00 00    0689*  	dl 0x00009D ; 142.031 65, 0.615
042537 98 00 00    0690*  	dl 0x000098 ; 143.438 66, 0.596
04253A 93 00 00    0691*  	dl 0x000093 ; 144.844 67, 0.576
04253D 8E 00 00    0692*  	dl 0x00008E ; 146.250 68, 0.556
042540 88 00 00    0693*  	dl 0x000088 ; 147.656 69, 0.535
042543 83 00 00    0694*  	dl 0x000083 ; 149.063 6A, 0.514
042546 7E 00 00    0695*  	dl 0x00007E ; 150.469 6B, 0.493
042549 78 00 00    0696*  	dl 0x000078 ; 151.875 6C, 0.471
04254C 73 00 00    0697*  	dl 0x000073 ; 153.281 6D, 0.450
04254F 6D 00 00    0698*  	dl 0x00006D ; 154.688 6E, 0.428
042552 67 00 00    0699*  	dl 0x000067 ; 156.094 6F, 0.405
042555 61 00 00    0700*  	dl 0x000061 ; 157.500 70, 0.383
042558 5C 00 00    0701*  	dl 0x00005C ; 158.906 71, 0.360
04255B 56 00 00    0702*  	dl 0x000056 ; 160.313 72, 0.337
04255E 50 00 00    0703*  	dl 0x000050 ; 161.719 73, 0.314
042561 4A 00 00    0704*  	dl 0x00004A ; 163.125 74, 0.290
042564 44 00 00    0705*  	dl 0x000044 ; 164.531 75, 0.267
042567 3E 00 00    0706*  	dl 0x00003E ; 165.938 76, 0.243
04256A 38 00 00    0707*  	dl 0x000038 ; 167.344 77, 0.219
04256D 31 00 00    0708*  	dl 0x000031 ; 168.750 78, 0.195
042570 2B 00 00    0709*  	dl 0x00002B ; 170.156 79, 0.171
042573 25 00 00    0710*  	dl 0x000025 ; 171.563 7A, 0.147
042576 1F 00 00    0711*  	dl 0x00001F ; 172.969 7B, 0.122
042579 19 00 00    0712*  	dl 0x000019 ; 174.375 7C, 0.098
04257C 12 00 00    0713*  	dl 0x000012 ; 175.781 7D, 0.074
04257F 0C 00 00    0714*  	dl 0x00000C ; 177.188 7E, 0.049
042582 06 00 00    0715*  	dl 0x000006 ; 178.594 7F, 0.025
042585 00 00 00    0716*  	dl 0x000000 ; 180.000 80, 0.000
042588 FA FF FF    0717*  	dl 0xFFFFFA ; 181.406 81, -0.025
04258B F4 FF FF    0718*  	dl 0xFFFFF4 ; 182.813 82, -0.049
04258E EE FF FF    0719*  	dl 0xFFFFEE ; 184.219 83, -0.074
042591 E7 FF FF    0720*  	dl 0xFFFFE7 ; 185.625 84, -0.098
042594 E1 FF FF    0721*  	dl 0xFFFFE1 ; 187.031 85, -0.122
042597 DB FF FF    0722*  	dl 0xFFFFDB ; 188.438 86, -0.147
04259A D5 FF FF    0723*  	dl 0xFFFFD5 ; 189.844 87, -0.171
04259D CF FF FF    0724*  	dl 0xFFFFCF ; 191.250 88, -0.195
0425A0 C8 FF FF    0725*  	dl 0xFFFFC8 ; 192.656 89, -0.219
0425A3 C2 FF FF    0726*  	dl 0xFFFFC2 ; 194.063 8A, -0.243
0425A6 BC FF FF    0727*  	dl 0xFFFFBC ; 195.469 8B, -0.267
0425A9 B6 FF FF    0728*  	dl 0xFFFFB6 ; 196.875 8C, -0.290
0425AC B0 FF FF    0729*  	dl 0xFFFFB0 ; 198.281 8D, -0.314
0425AF AA FF FF    0730*  	dl 0xFFFFAA ; 199.688 8E, -0.337
0425B2 A4 FF FF    0731*  	dl 0xFFFFA4 ; 201.094 8F, -0.360
0425B5 9F FF FF    0732*  	dl 0xFFFF9F ; 202.500 90, -0.383
0425B8 99 FF FF    0733*  	dl 0xFFFF99 ; 203.906 91, -0.405
0425BB 93 FF FF    0734*  	dl 0xFFFF93 ; 205.313 92, -0.428
0425BE 8D FF FF    0735*  	dl 0xFFFF8D ; 206.719 93, -0.450
0425C1 88 FF FF    0736*  	dl 0xFFFF88 ; 208.125 94, -0.471
0425C4 82 FF FF    0737*  	dl 0xFFFF82 ; 209.531 95, -0.493
0425C7 7D FF FF    0738*  	dl 0xFFFF7D ; 210.938 96, -0.514
0425CA 78 FF FF    0739*  	dl 0xFFFF78 ; 212.344 97, -0.535
0425CD 72 FF FF    0740*  	dl 0xFFFF72 ; 213.750 98, -0.556
0425D0 6D FF FF    0741*  	dl 0xFFFF6D ; 215.156 99, -0.576
0425D3 68 FF FF    0742*  	dl 0xFFFF68 ; 216.563 9A, -0.596
0425D6 63 FF FF    0743*  	dl 0xFFFF63 ; 217.969 9B, -0.615
0425D9 5E FF FF    0744*  	dl 0xFFFF5E ; 219.375 9C, -0.634
0425DC 59 FF FF    0745*  	dl 0xFFFF59 ; 220.781 9D, -0.653
0425DF 55 FF FF    0746*  	dl 0xFFFF55 ; 222.188 9E, -0.672
0425E2 50 FF FF    0747*  	dl 0xFFFF50 ; 223.594 9F, -0.690
0425E5 4B FF FF    0748*  	dl 0xFFFF4B ; 225.000 A0, -0.707
0425E8 47 FF FF    0749*  	dl 0xFFFF47 ; 226.406 A1, -0.724
0425EB 43 FF FF    0750*  	dl 0xFFFF43 ; 227.813 A2, -0.741
0425EE 3F FF FF    0751*  	dl 0xFFFF3F ; 229.219 A3, -0.757
0425F1 3B FF FF    0752*  	dl 0xFFFF3B ; 230.625 A4, -0.773
0425F4 37 FF FF    0753*  	dl 0xFFFF37 ; 232.031 A5, -0.788
0425F7 33 FF FF    0754*  	dl 0xFFFF33 ; 233.438 A6, -0.803
0425FA 2F FF FF    0755*  	dl 0xFFFF2F ; 234.844 A7, -0.818
0425FD 2C FF FF    0756*  	dl 0xFFFF2C ; 236.250 A8, -0.831
042600 28 FF FF    0757*  	dl 0xFFFF28 ; 237.656 A9, -0.845
042603 25 FF FF    0758*  	dl 0xFFFF25 ; 239.063 AA, -0.858
042606 22 FF FF    0759*  	dl 0xFFFF22 ; 240.469 AB, -0.870
042609 1F FF FF    0760*  	dl 0xFFFF1F ; 241.875 AC, -0.882
04260C 1C FF FF    0761*  	dl 0xFFFF1C ; 243.281 AD, -0.893
04260F 19 FF FF    0762*  	dl 0xFFFF19 ; 244.688 AE, -0.904
042612 16 FF FF    0763*  	dl 0xFFFF16 ; 246.094 AF, -0.914
042615 14 FF FF    0764*  	dl 0xFFFF14 ; 247.500 B0, -0.924
042618 12 FF FF    0765*  	dl 0xFFFF12 ; 248.906 B1, -0.933
04261B 0F FF FF    0766*  	dl 0xFFFF0F ; 250.313 B2, -0.942
04261E 0D FF FF    0767*  	dl 0xFFFF0D ; 251.719 B3, -0.950
042621 0C FF FF    0768*  	dl 0xFFFF0C ; 253.125 B4, -0.957
042624 0A FF FF    0769*  	dl 0xFFFF0A ; 254.531 B5, -0.964
042627 08 FF FF    0770*  	dl 0xFFFF08 ; 255.938 B6, -0.970
04262A 07 FF FF    0771*  	dl 0xFFFF07 ; 257.344 B7, -0.976
04262D 05 FF FF    0772*  	dl 0xFFFF05 ; 258.750 B8, -0.981
042630 04 FF FF    0773*  	dl 0xFFFF04 ; 260.156 B9, -0.985
042633 03 FF FF    0774*  	dl 0xFFFF03 ; 261.563 BA, -0.989
042636 02 FF FF    0775*  	dl 0xFFFF02 ; 262.969 BB, -0.992
042639 02 FF FF    0776*  	dl 0xFFFF02 ; 264.375 BC, -0.995
04263C 01 FF FF    0777*  	dl 0xFFFF01 ; 265.781 BD, -0.997
04263F 01 FF FF    0778*  	dl 0xFFFF01 ; 267.188 BE, -0.999
042642 01 FF FF    0779*  	dl 0xFFFF01 ; 268.594 BF, -1.000
042645 00 FF FF    0780*  	dl 0xFFFF00 ; 270.000 C0, -1.000
042648 01 FF FF    0781*  	dl 0xFFFF01 ; 271.406 C1, -1.000
04264B 01 FF FF    0782*  	dl 0xFFFF01 ; 272.813 C2, -0.999
04264E 01 FF FF    0783*  	dl 0xFFFF01 ; 274.219 C3, -0.997
042651 02 FF FF    0784*  	dl 0xFFFF02 ; 275.625 C4, -0.995
042654 02 FF FF    0785*  	dl 0xFFFF02 ; 277.031 C5, -0.992
042657 03 FF FF    0786*  	dl 0xFFFF03 ; 278.438 C6, -0.989
04265A 04 FF FF    0787*  	dl 0xFFFF04 ; 279.844 C7, -0.985
04265D 05 FF FF    0788*  	dl 0xFFFF05 ; 281.250 C8, -0.981
042660 07 FF FF    0789*  	dl 0xFFFF07 ; 282.656 C9, -0.976
042663 08 FF FF    0790*  	dl 0xFFFF08 ; 284.063 CA, -0.970
042666 0A FF FF    0791*  	dl 0xFFFF0A ; 285.469 CB, -0.964
042669 0C FF FF    0792*  	dl 0xFFFF0C ; 286.875 CC, -0.957
04266C 0D FF FF    0793*  	dl 0xFFFF0D ; 288.281 CD, -0.950
04266F 0F FF FF    0794*  	dl 0xFFFF0F ; 289.688 CE, -0.942
042672 12 FF FF    0795*  	dl 0xFFFF12 ; 291.094 CF, -0.933
042675 14 FF FF    0796*  	dl 0xFFFF14 ; 292.500 D0, -0.924
042678 16 FF FF    0797*  	dl 0xFFFF16 ; 293.906 D1, -0.914
04267B 19 FF FF    0798*  	dl 0xFFFF19 ; 295.313 D2, -0.904
04267E 1C FF FF    0799*  	dl 0xFFFF1C ; 296.719 D3, -0.893
042681 1F FF FF    0800*  	dl 0xFFFF1F ; 298.125 D4, -0.882
042684 22 FF FF    0801*  	dl 0xFFFF22 ; 299.531 D5, -0.870
042687 25 FF FF    0802*  	dl 0xFFFF25 ; 300.938 D6, -0.858
04268A 28 FF FF    0803*  	dl 0xFFFF28 ; 302.344 D7, -0.845
04268D 2C FF FF    0804*  	dl 0xFFFF2C ; 303.750 D8, -0.831
042690 2F FF FF    0805*  	dl 0xFFFF2F ; 305.156 D9, -0.818
042693 33 FF FF    0806*  	dl 0xFFFF33 ; 306.563 DA, -0.803
042696 37 FF FF    0807*  	dl 0xFFFF37 ; 307.969 DB, -0.788
042699 3B FF FF    0808*  	dl 0xFFFF3B ; 309.375 DC, -0.773
04269C 3F FF FF    0809*  	dl 0xFFFF3F ; 310.781 DD, -0.757
04269F 43 FF FF    0810*  	dl 0xFFFF43 ; 312.188 DE, -0.741
0426A2 47 FF FF    0811*  	dl 0xFFFF47 ; 313.594 DF, -0.724
0426A5 4B FF FF    0812*  	dl 0xFFFF4B ; 315.000 E0, -0.707
0426A8 50 FF FF    0813*  	dl 0xFFFF50 ; 316.406 E1, -0.690
0426AB 55 FF FF    0814*  	dl 0xFFFF55 ; 317.813 E2, -0.672
0426AE 59 FF FF    0815*  	dl 0xFFFF59 ; 319.219 E3, -0.653
0426B1 5E FF FF    0816*  	dl 0xFFFF5E ; 320.625 E4, -0.634
0426B4 63 FF FF    0817*  	dl 0xFFFF63 ; 322.031 E5, -0.615
0426B7 68 FF FF    0818*  	dl 0xFFFF68 ; 323.438 E6, -0.596
0426BA 6D FF FF    0819*  	dl 0xFFFF6D ; 324.844 E7, -0.576
0426BD 72 FF FF    0820*  	dl 0xFFFF72 ; 326.250 E8, -0.556
0426C0 78 FF FF    0821*  	dl 0xFFFF78 ; 327.656 E9, -0.535
0426C3 7D FF FF    0822*  	dl 0xFFFF7D ; 329.063 EA, -0.514
0426C6 82 FF FF    0823*  	dl 0xFFFF82 ; 330.469 EB, -0.493
0426C9 88 FF FF    0824*  	dl 0xFFFF88 ; 331.875 EC, -0.471
0426CC 8D FF FF    0825*  	dl 0xFFFF8D ; 333.281 ED, -0.450
0426CF 93 FF FF    0826*  	dl 0xFFFF93 ; 334.688 EE, -0.428
0426D2 99 FF FF    0827*  	dl 0xFFFF99 ; 336.094 EF, -0.405
0426D5 9F FF FF    0828*  	dl 0xFFFF9F ; 337.500 F0, -0.383
0426D8 A4 FF FF    0829*  	dl 0xFFFFA4 ; 338.906 F1, -0.360
0426DB AA FF FF    0830*  	dl 0xFFFFAA ; 340.313 F2, -0.337
0426DE B0 FF FF    0831*  	dl 0xFFFFB0 ; 341.719 F3, -0.314
0426E1 B6 FF FF    0832*  	dl 0xFFFFB6 ; 343.125 F4, -0.290
0426E4 BC FF FF    0833*  	dl 0xFFFFBC ; 344.531 F5, -0.267
0426E7 C2 FF FF    0834*  	dl 0xFFFFC2 ; 345.938 F6, -0.243
0426EA C8 FF FF    0835*  	dl 0xFFFFC8 ; 347.344 F7, -0.219
0426ED CF FF FF    0836*  	dl 0xFFFFCF ; 348.750 F8, -0.195
0426F0 D5 FF FF    0837*  	dl 0xFFFFD5 ; 350.156 F9, -0.171
0426F3 DB FF FF    0838*  	dl 0xFFFFDB ; 351.563 FA, -0.147
0426F6 E1 FF FF    0839*  	dl 0xFFFFE1 ; 352.969 FB, -0.122
0426F9 E7 FF FF    0840*  	dl 0xFFFFE7 ; 354.375 FC, -0.098
0426FC EE FF FF    0841*  	dl 0xFFFFEE ; 355.781 FD, -0.074
0426FF F4 FF FF    0842*  	dl 0xFFFFF4 ; 357.188 FE, -0.049
042702 FA FF FF    0843*  	dl 0xFFFFFA ; 358.594 FF, -0.025
042705 00 00 00    0844*  	dl 0x000000 ; 0.000 00, 0.000 for interpolation
042708             0845*  
042708             0846*  atan_lut_168:
042708 00 00 00    0847*  	dl 0x000000 ; 000000, 0.000
04270B 28 00 00    0848*  	dl 0x000028 ; 000001, 0.224
04270E 51 00 00    0849*  	dl 0x000051 ; 000002, 0.448
042711 7A 00 00    0850*  	dl 0x00007A ; 000003, 0.671
042714 A2 00 00    0851*  	dl 0x0000A2 ; 000004, 0.895
042717 CB 00 00    0852*  	dl 0x0000CB ; 000005, 1.119
04271A F4 00 00    0853*  	dl 0x0000F4 ; 000006, 1.343
04271D 1D 01 00    0854*  	dl 0x00011D ; 000007, 1.566
042720 45 01 00    0855*  	dl 0x000145 ; 000008, 1.790
042723 6E 01 00    0856*  	dl 0x00016E ; 000009, 2.013
042726 97 01 00    0857*  	dl 0x000197 ; 00000A, 2.237
042729 BF 01 00    0858*  	dl 0x0001BF ; 00000B, 2.460
04272C E8 01 00    0859*  	dl 0x0001E8 ; 00000C, 2.684
04272F 11 02 00    0860*  	dl 0x000211 ; 00000D, 2.907
042732 39 02 00    0861*  	dl 0x000239 ; 00000E, 3.130
042735 62 02 00    0862*  	dl 0x000262 ; 00000F, 3.353
042738 8B 02 00    0863*  	dl 0x00028B ; 000010, 3.576
04273B B3 02 00    0864*  	dl 0x0002B3 ; 000011, 3.799
04273E DC 02 00    0865*  	dl 0x0002DC ; 000012, 4.022
042741 04 03 00    0866*  	dl 0x000304 ; 000013, 4.245
042744 2D 03 00    0867*  	dl 0x00032D ; 000014, 4.467
042747 55 03 00    0868*  	dl 0x000355 ; 000015, 4.690
04274A 7E 03 00    0869*  	dl 0x00037E ; 000016, 4.912
04274D A6 03 00    0870*  	dl 0x0003A6 ; 000017, 5.134
042750 CE 03 00    0871*  	dl 0x0003CE ; 000018, 5.356
042753 F7 03 00    0872*  	dl 0x0003F7 ; 000019, 5.578
042756 1F 04 00    0873*  	dl 0x00041F ; 00001A, 5.799
042759 48 04 00    0874*  	dl 0x000448 ; 00001B, 6.021
04275C 70 04 00    0875*  	dl 0x000470 ; 00001C, 6.242
04275F 98 04 00    0876*  	dl 0x000498 ; 00001D, 6.463
042762 C0 04 00    0877*  	dl 0x0004C0 ; 00001E, 6.684
042765 E8 04 00    0878*  	dl 0x0004E8 ; 00001F, 6.905
042768 11 05 00    0879*  	dl 0x000511 ; 000020, 7.125
04276B 39 05 00    0880*  	dl 0x000539 ; 000021, 7.345
04276E 61 05 00    0881*  	dl 0x000561 ; 000022, 7.565
042771 89 05 00    0882*  	dl 0x000589 ; 000023, 7.785
042774 B1 05 00    0883*  	dl 0x0005B1 ; 000024, 8.005
042777 D9 05 00    0884*  	dl 0x0005D9 ; 000025, 8.224
04277A 01 06 00    0885*  	dl 0x000601 ; 000026, 8.443
04277D 28 06 00    0886*  	dl 0x000628 ; 000027, 8.662
042780 50 06 00    0887*  	dl 0x000650 ; 000028, 8.881
042783 78 06 00    0888*  	dl 0x000678 ; 000029, 9.099
042786 A0 06 00    0889*  	dl 0x0006A0 ; 00002A, 9.317
042789 C7 06 00    0890*  	dl 0x0006C7 ; 00002B, 9.535
04278C EF 06 00    0891*  	dl 0x0006EF ; 00002C, 9.752
04278F 16 07 00    0892*  	dl 0x000716 ; 00002D, 9.970
042792 3E 07 00    0893*  	dl 0x00073E ; 00002E, 10.187
042795 65 07 00    0894*  	dl 0x000765 ; 00002F, 10.403
042798 8D 07 00    0895*  	dl 0x00078D ; 000030, 10.620
04279B B4 07 00    0896*  	dl 0x0007B4 ; 000031, 10.836
04279E DB 07 00    0897*  	dl 0x0007DB ; 000032, 11.051
0427A1 03 08 00    0898*  	dl 0x000803 ; 000033, 11.267
0427A4 2A 08 00    0899*  	dl 0x00082A ; 000034, 11.482
0427A7 51 08 00    0900*  	dl 0x000851 ; 000035, 11.697
0427AA 78 08 00    0901*  	dl 0x000878 ; 000036, 11.911
0427AD 9F 08 00    0902*  	dl 0x00089F ; 000037, 12.125
0427B0 C6 08 00    0903*  	dl 0x0008C6 ; 000038, 12.339
0427B3 ED 08 00    0904*  	dl 0x0008ED ; 000039, 12.553
0427B6 13 09 00    0905*  	dl 0x000913 ; 00003A, 12.766
0427B9 3A 09 00    0906*  	dl 0x00093A ; 00003B, 12.978
0427BC 61 09 00    0907*  	dl 0x000961 ; 00003C, 13.191
0427BF 87 09 00    0908*  	dl 0x000987 ; 00003D, 13.403
0427C2 AE 09 00    0909*  	dl 0x0009AE ; 00003E, 13.614
0427C5 D4 09 00    0910*  	dl 0x0009D4 ; 00003F, 13.825
0427C8 FB 09 00    0911*  	dl 0x0009FB ; 000040, 14.036
0427CB 21 0A 00    0912*  	dl 0x000A21 ; 000041, 14.247
0427CE 47 0A 00    0913*  	dl 0x000A47 ; 000042, 14.457
0427D1 6D 0A 00    0914*  	dl 0x000A6D ; 000043, 14.666
0427D4 94 0A 00    0915*  	dl 0x000A94 ; 000044, 14.876
0427D7 BA 0A 00    0916*  	dl 0x000ABA ; 000045, 15.085
0427DA E0 0A 00    0917*  	dl 0x000AE0 ; 000046, 15.293
0427DD 05 0B 00    0918*  	dl 0x000B05 ; 000047, 15.501
0427E0 2B 0B 00    0919*  	dl 0x000B2B ; 000048, 15.709
0427E3 51 0B 00    0920*  	dl 0x000B51 ; 000049, 15.916
0427E6 77 0B 00    0921*  	dl 0x000B77 ; 00004A, 16.123
0427E9 9C 0B 00    0922*  	dl 0x000B9C ; 00004B, 16.329
0427EC C2 0B 00    0923*  	dl 0x000BC2 ; 00004C, 16.535
0427EF E7 0B 00    0924*  	dl 0x000BE7 ; 00004D, 16.740
0427F2 0C 0C 00    0925*  	dl 0x000C0C ; 00004E, 16.945
0427F5 32 0C 00    0926*  	dl 0x000C32 ; 00004F, 17.150
0427F8 57 0C 00    0927*  	dl 0x000C57 ; 000050, 17.354
0427FB 7C 0C 00    0928*  	dl 0x000C7C ; 000051, 17.558
0427FE A1 0C 00    0929*  	dl 0x000CA1 ; 000052, 17.761
042801 C6 0C 00    0930*  	dl 0x000CC6 ; 000053, 17.964
042804 EB 0C 00    0931*  	dl 0x000CEB ; 000054, 18.166
042807 0F 0D 00    0932*  	dl 0x000D0F ; 000055, 18.368
04280A 34 0D 00    0933*  	dl 0x000D34 ; 000056, 18.569
04280D 58 0D 00    0934*  	dl 0x000D58 ; 000057, 18.770
042810 7D 0D 00    0935*  	dl 0x000D7D ; 000058, 18.970
042813 A1 0D 00    0936*  	dl 0x000DA1 ; 000059, 19.170
042816 C6 0D 00    0937*  	dl 0x000DC6 ; 00005A, 19.370
042819 EA 0D 00    0938*  	dl 0x000DEA ; 00005B, 19.569
04281C 0E 0E 00    0939*  	dl 0x000E0E ; 00005C, 19.767
04281F 32 0E 00    0940*  	dl 0x000E32 ; 00005D, 19.965
042822 56 0E 00    0941*  	dl 0x000E56 ; 00005E, 20.163
042825 7A 0E 00    0942*  	dl 0x000E7A ; 00005F, 20.360
042828 9E 0E 00    0943*  	dl 0x000E9E ; 000060, 20.556
04282B C1 0E 00    0944*  	dl 0x000EC1 ; 000061, 20.752
04282E E5 0E 00    0945*  	dl 0x000EE5 ; 000062, 20.947
042831 08 0F 00    0946*  	dl 0x000F08 ; 000063, 21.142
042834 2C 0F 00    0947*  	dl 0x000F2C ; 000064, 21.337
042837 4F 0F 00    0948*  	dl 0x000F4F ; 000065, 21.531
04283A 72 0F 00    0949*  	dl 0x000F72 ; 000066, 21.724
04283D 95 0F 00    0950*  	dl 0x000F95 ; 000067, 21.917
042840 B8 0F 00    0951*  	dl 0x000FB8 ; 000068, 22.109
042843 DB 0F 00    0952*  	dl 0x000FDB ; 000069, 22.301
042846 FE 0F 00    0953*  	dl 0x000FFE ; 00006A, 22.493
042849 21 10 00    0954*  	dl 0x001021 ; 00006B, 22.683
04284C 44 10 00    0955*  	dl 0x001044 ; 00006C, 22.874
04284F 66 10 00    0956*  	dl 0x001066 ; 00006D, 23.063
042852 89 10 00    0957*  	dl 0x001089 ; 00006E, 23.253
042855 AB 10 00    0958*  	dl 0x0010AB ; 00006F, 23.441
042858 CD 10 00    0959*  	dl 0x0010CD ; 000070, 23.629
04285B EF 10 00    0960*  	dl 0x0010EF ; 000071, 23.817
04285E 11 11 00    0961*  	dl 0x001111 ; 000072, 24.004
042861 33 11 00    0962*  	dl 0x001133 ; 000073, 24.191
042864 55 11 00    0963*  	dl 0x001155 ; 000074, 24.376
042867 77 11 00    0964*  	dl 0x001177 ; 000075, 24.562
04286A 99 11 00    0965*  	dl 0x001199 ; 000076, 24.747
04286D BA 11 00    0966*  	dl 0x0011BA ; 000077, 24.931
042870 DC 11 00    0967*  	dl 0x0011DC ; 000078, 25.115
042873 FD 11 00    0968*  	dl 0x0011FD ; 000079, 25.298
042876 1E 12 00    0969*  	dl 0x00121E ; 00007A, 25.481
042879 3F 12 00    0970*  	dl 0x00123F ; 00007B, 25.663
04287C 60 12 00    0971*  	dl 0x001260 ; 00007C, 25.844
04287F 81 12 00    0972*  	dl 0x001281 ; 00007D, 26.025
042882 A2 12 00    0973*  	dl 0x0012A2 ; 00007E, 26.206
042885 C3 12 00    0974*  	dl 0x0012C3 ; 00007F, 26.386
042888 E4 12 00    0975*  	dl 0x0012E4 ; 000080, 26.565
04288B 04 13 00    0976*  	dl 0x001304 ; 000081, 26.744
04288E 25 13 00    0977*  	dl 0x001325 ; 000082, 26.922
042891 45 13 00    0978*  	dl 0x001345 ; 000083, 27.100
042894 65 13 00    0979*  	dl 0x001365 ; 000084, 27.277
042897 85 13 00    0980*  	dl 0x001385 ; 000085, 27.453
04289A A5 13 00    0981*  	dl 0x0013A5 ; 000086, 27.629
04289D C5 13 00    0982*  	dl 0x0013C5 ; 000087, 27.805
0428A0 E5 13 00    0983*  	dl 0x0013E5 ; 000088, 27.979
0428A3 05 14 00    0984*  	dl 0x001405 ; 000089, 28.154
0428A6 24 14 00    0985*  	dl 0x001424 ; 00008A, 28.327
0428A9 44 14 00    0986*  	dl 0x001444 ; 00008B, 28.501
0428AC 63 14 00    0987*  	dl 0x001463 ; 00008C, 28.673
0428AF 83 14 00    0988*  	dl 0x001483 ; 00008D, 28.845
0428B2 A2 14 00    0989*  	dl 0x0014A2 ; 00008E, 29.017
0428B5 C1 14 00    0990*  	dl 0x0014C1 ; 00008F, 29.187
0428B8 E0 14 00    0991*  	dl 0x0014E0 ; 000090, 29.358
0428BB FF 14 00    0992*  	dl 0x0014FF ; 000091, 29.527
0428BE 1E 15 00    0993*  	dl 0x00151E ; 000092, 29.697
0428C1 3C 15 00    0994*  	dl 0x00153C ; 000093, 29.865
0428C4 5B 15 00    0995*  	dl 0x00155B ; 000094, 30.033
0428C7 79 15 00    0996*  	dl 0x001579 ; 000095, 30.201
0428CA 98 15 00    0997*  	dl 0x001598 ; 000096, 30.368
0428CD B6 15 00    0998*  	dl 0x0015B6 ; 000097, 30.534
0428D0 D4 15 00    0999*  	dl 0x0015D4 ; 000098, 30.700
0428D3 F2 15 00    1000*  	dl 0x0015F2 ; 000099, 30.865
0428D6 10 16 00    1001*  	dl 0x001610 ; 00009A, 31.030
0428D9 2E 16 00    1002*  	dl 0x00162E ; 00009B, 31.194
0428DC 4C 16 00    1003*  	dl 0x00164C ; 00009C, 31.357
0428DF 6A 16 00    1004*  	dl 0x00166A ; 00009D, 31.520
0428E2 87 16 00    1005*  	dl 0x001687 ; 00009E, 31.682
0428E5 A5 16 00    1006*  	dl 0x0016A5 ; 00009F, 31.844
0428E8 C2 16 00    1007*  	dl 0x0016C2 ; 0000A0, 32.005
0428EB DF 16 00    1008*  	dl 0x0016DF ; 0000A1, 32.166
0428EE FC 16 00    1009*  	dl 0x0016FC ; 0000A2, 32.326
0428F1 19 17 00    1010*  	dl 0x001719 ; 0000A3, 32.486
0428F4 36 17 00    1011*  	dl 0x001736 ; 0000A4, 32.645
0428F7 53 17 00    1012*  	dl 0x001753 ; 0000A5, 32.803
0428FA 70 17 00    1013*  	dl 0x001770 ; 0000A6, 32.961
0428FD 8C 17 00    1014*  	dl 0x00178C ; 0000A7, 33.118
042900 A9 17 00    1015*  	dl 0x0017A9 ; 0000A8, 33.275
042903 C5 17 00    1016*  	dl 0x0017C5 ; 0000A9, 33.431
042906 E2 17 00    1017*  	dl 0x0017E2 ; 0000AA, 33.587
042909 FE 17 00    1018*  	dl 0x0017FE ; 0000AB, 33.742
04290C 1A 18 00    1019*  	dl 0x00181A ; 0000AC, 33.896
04290F 36 18 00    1020*  	dl 0x001836 ; 0000AD, 34.050
042912 52 18 00    1021*  	dl 0x001852 ; 0000AE, 34.203
042915 6E 18 00    1022*  	dl 0x00186E ; 0000AF, 34.356
042918 8A 18 00    1023*  	dl 0x00188A ; 0000B0, 34.509
04291B A5 18 00    1024*  	dl 0x0018A5 ; 0000B1, 34.660
04291E C1 18 00    1025*  	dl 0x0018C1 ; 0000B2, 34.811
042921 DC 18 00    1026*  	dl 0x0018DC ; 0000B3, 34.962
042924 F7 18 00    1027*  	dl 0x0018F7 ; 0000B4, 35.112
042927 13 19 00    1028*  	dl 0x001913 ; 0000B5, 35.262
04292A 2E 19 00    1029*  	dl 0x00192E ; 0000B6, 35.410
04292D 49 19 00    1030*  	dl 0x001949 ; 0000B7, 35.559
042930 64 19 00    1031*  	dl 0x001964 ; 0000B8, 35.707
042933 7F 19 00    1032*  	dl 0x00197F ; 0000B9, 35.854
042936 99 19 00    1033*  	dl 0x001999 ; 0000BA, 36.001
042939 B4 19 00    1034*  	dl 0x0019B4 ; 0000BB, 36.147
04293C CE 19 00    1035*  	dl 0x0019CE ; 0000BC, 36.293
04293F E9 19 00    1036*  	dl 0x0019E9 ; 0000BD, 36.438
042942 03 1A 00    1037*  	dl 0x001A03 ; 0000BE, 36.582
042945 1D 1A 00    1038*  	dl 0x001A1D ; 0000BF, 36.726
042948 37 1A 00    1039*  	dl 0x001A37 ; 0000C0, 36.870
04294B 51 1A 00    1040*  	dl 0x001A51 ; 0000C1, 37.013
04294E 6B 1A 00    1041*  	dl 0x001A6B ; 0000C2, 37.155
042951 85 1A 00    1042*  	dl 0x001A85 ; 0000C3, 37.297
042954 9F 1A 00    1043*  	dl 0x001A9F ; 0000C4, 37.439
042957 B9 1A 00    1044*  	dl 0x001AB9 ; 0000C5, 37.579
04295A D2 1A 00    1045*  	dl 0x001AD2 ; 0000C6, 37.720
04295D EC 1A 00    1046*  	dl 0x001AEC ; 0000C7, 37.859
042960 05 1B 00    1047*  	dl 0x001B05 ; 0000C8, 37.999
042963 1E 1B 00    1048*  	dl 0x001B1E ; 0000C9, 38.137
042966 37 1B 00    1049*  	dl 0x001B37 ; 0000CA, 38.276
042969 50 1B 00    1050*  	dl 0x001B50 ; 0000CB, 38.413
04296C 69 1B 00    1051*  	dl 0x001B69 ; 0000CC, 38.550
04296F 82 1B 00    1052*  	dl 0x001B82 ; 0000CD, 38.687
042972 9B 1B 00    1053*  	dl 0x001B9B ; 0000CE, 38.823
042975 B4 1B 00    1054*  	dl 0x001BB4 ; 0000CF, 38.959
042978 CC 1B 00    1055*  	dl 0x001BCC ; 0000D0, 39.094
04297B E5 1B 00    1056*  	dl 0x001BE5 ; 0000D1, 39.228
04297E FD 1B 00    1057*  	dl 0x001BFD ; 0000D2, 39.362
042981 16 1C 00    1058*  	dl 0x001C16 ; 0000D3, 39.496
042984 2E 1C 00    1059*  	dl 0x001C2E ; 0000D4, 39.629
042987 46 1C 00    1060*  	dl 0x001C46 ; 0000D5, 39.762
04298A 5E 1C 00    1061*  	dl 0x001C5E ; 0000D6, 39.894
04298D 76 1C 00    1062*  	dl 0x001C76 ; 0000D7, 40.025
042990 8E 1C 00    1063*  	dl 0x001C8E ; 0000D8, 40.156
042993 A5 1C 00    1064*  	dl 0x001CA5 ; 0000D9, 40.286
042996 BD 1C 00    1065*  	dl 0x001CBD ; 0000DA, 40.416
042999 D5 1C 00    1066*  	dl 0x001CD5 ; 0000DB, 40.546
04299C EC 1C 00    1067*  	dl 0x001CEC ; 0000DC, 40.675
04299F 04 1D 00    1068*  	dl 0x001D04 ; 0000DD, 40.803
0429A2 1B 1D 00    1069*  	dl 0x001D1B ; 0000DE, 40.931
0429A5 32 1D 00    1070*  	dl 0x001D32 ; 0000DF, 41.059
0429A8 49 1D 00    1071*  	dl 0x001D49 ; 0000E0, 41.186
0429AB 60 1D 00    1072*  	dl 0x001D60 ; 0000E1, 41.312
0429AE 77 1D 00    1073*  	dl 0x001D77 ; 0000E2, 41.438
0429B1 8E 1D 00    1074*  	dl 0x001D8E ; 0000E3, 41.564
0429B4 A5 1D 00    1075*  	dl 0x001DA5 ; 0000E4, 41.689
0429B7 BB 1D 00    1076*  	dl 0x001DBB ; 0000E5, 41.814
0429BA D2 1D 00    1077*  	dl 0x001DD2 ; 0000E6, 41.938
0429BD E9 1D 00    1078*  	dl 0x001DE9 ; 0000E7, 42.061
0429C0 FF 1D 00    1079*  	dl 0x001DFF ; 0000E8, 42.184
0429C3 15 1E 00    1080*  	dl 0x001E15 ; 0000E9, 42.307
0429C6 2C 1E 00    1081*  	dl 0x001E2C ; 0000EA, 42.429
0429C9 42 1E 00    1082*  	dl 0x001E42 ; 0000EB, 42.551
0429CC 58 1E 00    1083*  	dl 0x001E58 ; 0000EC, 42.672
0429CF 6E 1E 00    1084*  	dl 0x001E6E ; 0000ED, 42.793
0429D2 84 1E 00    1085*  	dl 0x001E84 ; 0000EE, 42.913
0429D5 99 1E 00    1086*  	dl 0x001E99 ; 0000EF, 43.033
0429D8 AF 1E 00    1087*  	dl 0x001EAF ; 0000F0, 43.152
0429DB C5 1E 00    1088*  	dl 0x001EC5 ; 0000F1, 43.271
0429DE DA 1E 00    1089*  	dl 0x001EDA ; 0000F2, 43.390
0429E1 F0 1E 00    1090*  	dl 0x001EF0 ; 0000F3, 43.508
0429E4 05 1F 00    1091*  	dl 0x001F05 ; 0000F4, 43.625
0429E7 1B 1F 00    1092*  	dl 0x001F1B ; 0000F5, 43.742
0429EA 30 1F 00    1093*  	dl 0x001F30 ; 0000F6, 43.859
0429ED 45 1F 00    1094*  	dl 0x001F45 ; 0000F7, 43.975
0429F0 5A 1F 00    1095*  	dl 0x001F5A ; 0000F8, 44.091
0429F3 6F 1F 00    1096*  	dl 0x001F6F ; 0000F9, 44.206
0429F6 84 1F 00    1097*  	dl 0x001F84 ; 0000FA, 44.321
0429F9 99 1F 00    1098*  	dl 0x001F99 ; 0000FB, 44.435
0429FC AD 1F 00    1099*  	dl 0x001FAD ; 0000FC, 44.549
0429FF C2 1F 00    1100*  	dl 0x001FC2 ; 0000FD, 44.662
042A02 D7 1F 00    1101*  	dl 0x001FD7 ; 0000FE, 44.775
042A05 EB 1F 00    1102*  	dl 0x001FEB ; 0000FF, 44.888
042A08 00 20 00    1103*  	dl 0x002000 ; 000100, 45.000 only needed for interpolation
042A0B             0060   	include "fixed24.inc"
042A0B             0001*  arith24uaf: ds 6
042A11             0002*  arith24uhl: ds 6
042A17             0003*  arith24ubc: ds 6
042A1D             0004*  arith24ude: ds 6
042A23             0005*  arith24uix: ds 6
042A29             0006*  arith24uiy: ds 6
042A2F             0007*  arith24usp: ds 6
042A35             0008*  arith24upc: ds 6
042A3B             0009*  
042A3B             0010*  ; write hlu to a 54-bit output buffer arithmetically shifted up or down a specified number of bits
042A3B             0011*  ; uses whole-byte shifts for the initial shift and bit shifts for the remainder
042A3B             0012*  ; inputs: hlu = 24-bit number to shift
042A3B             0013*  ;         a = signed number of bits to shift
042A3B             0014*  ;         ix = output buffer address
042A3B             0015*  ; outputs: hlu = shifted 24-bit number, ix = modified pointer aligned with value in hlu
042A3B             0016*  shift_hlu:
042A3B C5          0017*      push bc ; preserve
042A3C 47          0018*      ld b,a            ; store shift value in b for later
042A3D             0019*  
042A3D             0020*  ; Initialize DE to zero and clear output buffer
042A3D 11 00 00 00 0021*      ld de, 0
042A41 DD 1F FD    0022*      ld (ix-3), de
042A44 DD 1F 03    0023*      ld (ix+3), de
042A47             0024*  
042A47             0025*  ; Get absolute value of a and save its original sign
042A47 B7          0026*      or a
042A48 F5          0027*      push af ; save sign flag
042A49 F2 4F 2A 04 0028*      jp p,@F ; If a is positive do nothing
042A4D ED 44       0029*      neg ; If a is negative, negate it
042A4F             0030*  @@:
042A4F             0031*  
042A4F             0032*  ; Write abs(HLU) to the output buffer and save its original sign
042A4F CD BF 20 04 0033*      call hlu_abs
042A53 F5          0034*      push af ; save sign of HLU
042A54 DD 2F 00    0035*      ld (ix), hl
042A57             0036*  
042A57             0037*  ; Divide bits to shift by 8 to get the whole byte shift and bit remainder
042A57 78          0038*      ld a,b            ; Restore original shift value into 'a'
042A58 CB 3F       0039*      srl a             ; a = a / 2 (shift right 1 bit)
042A5A CB 3F       0040*      srl a             ; a = a / 4 (shift right another bit)
042A5C CB 3F       0041*      srl a             ; a = a / 8 (final shift for division by 8)
042A5E 4F          0042*      ld c,a            ; c holds the number of whole bytes to shift
042A5F             0043*  
042A5F             0044*  ; Calculate remainder of a (original shift) mod 8
042A5F E6 07       0045*      and 0x07          ; Mask with 0x07 to get the remainder (bits to shift back up)
042A61 47          0046*      ld b,a            ; 'b' now holds the number of bits to shift back up
042A62 11 00 00 00 0047*      ld de,0           ; Clear deu for computing the offset address later
042A66             0048*  
042A66             0049*      ; call dumpRegistersHex ; DEBUG
042A66             0050*  
042A66             0051*  ; Get back the original sign of the byte shift
042A66 F1          0052*      pop af            ; Restore sign flag
042A67 F2 75 2A 04 0053*      jp p,@F           ; If a was positive, we're done
042A6B 79          0054*      ld a,c            ; 'a' now holds the number of whole bytes to shift
042A6C ED 44       0055*      neg               ; Negate the number of whole bytes to shift
042A6E 3D          0056*      dec a             ; Subtract 1 because that's just how this works
042A6F 4F          0057*      ld c,a            ; 'c' now holds the number of whole bytes to shift
042A70 1B          0058*      dec de            ; DE = -1 to make the signed addition below work
042A71 3E 08       0059*      ld a,8            ; Subtract bits to shift from 8 because we're in backwards land
042A73 90          0060*      sub b
042A74 47          0061*      ld b,a            ; b is the number of bits to shift back up
042A75             0062*  
042A75             0063*      ; call dumpRegistersHex ; DEBUG
042A75             0064*  
042A75             0065*  @@:
042A75             0066*  
042A75             0067*  ; Add the byte offset to the base address of output buffer
042A75 59          0068*      ld e,c            ; DEU and D were properly signed above
042A76 DD 19       0069*      add ix,de         ; Add byte-aligned offset (hl = output buffer + l)
042A78             0070*  
042A78             0071*      ; call dumpRegistersHex ; DEBUG
042A78             0072*  
042A78             0073*  ; Read the byte-aligned result into HL and shift in the required number of bits
042A78 DD 27 00    0074*      ld hl,(ix)        ; Byte-aligned result
042A7B             0075*  
042A7B CD 92 18 04 0076*      call dumpRegistersHex ; DEBUG
042A7F             0077*  
042A7F             0078*  ; Check whether we're already byte-aligned
042A7F AF          0079*      xor a
042A80 B0          0080*      or b
042A81 28 10       0081*      jr z,@end         ; If no bits to shift, we're done
042A83             0082*  
042A83             0083*  ; Otherwise shiften zee bitzen
042A83 DD 7E FF    0084*      ld a,(ix-1)       ; read one byte below for the bits to shift into HLU
042A86             0085*  @loop:
042A86 07          0086*      rlca              ; One bit to carry
042A87             0087*  
042A87 CD D7 19 04 0088*      call dumpFlags ; DEBUG
042A8B             0089*  
042A8B ED 6A       0090*      adc hl,hl         ; Shift the carry into the result
042A8D             0091*  
042A8D CD 92 18 04 0092*      call dumpRegistersHex ; DEBUG
042A91             0093*  
042A91 10 F3       0094*      djnz @loop        ; Loop until all bits are shifted up
042A93             0095*  
042A93             0096*  @end:
042A93             0097*  
042A93 CD 92 18 04 0098*      call dumpRegistersHex ; DEBUG
042A97             0099*  
042A97             0100*  ; get back HLU's original sign and negate if necessary
042A97 F1          0101*      pop af
042A98 F2 A0 2A 04 0102*      jp p,@F
042A9C CD CF 20 04 0103*      call neg_hlu
042AA0             0104*  @@:
042AA0             0105*  ; return the result
042AA0 DD 2F 00    0106*      ld (ix),hl        ; Store the shifted result
042AA3 C1          0107*      pop bc              ; Restore BC
042AA4 C9          0108*      ret
042AA5             0109*  
042AA5             0110*  ; operation: UHL * UDE --> UHL
042AA5             0111*  ; multiply unsigned 24-bit numbers and return a 48-bit intermediate
042AA5             0112*  ; with inputs and outputs having an arbitrary number of fractional bits from 0 to 24
042AA5             0113*  ; inputs: hl = 24-bit number, de = 24-bit number,
042AA5             0114*  ;         b = hl fractional bits, c = de fractional bits, a = output fractional bits
042AA5             0115*  ; outputs: umulfxout = 48-bit intermediate
042AA5             0116*  ; destroys: af, hl, bc, de
042AA5             0117*  umulfx:
042AA5 DD E5       0118*      push ix ; preserve
042AA7 F5          0119*      push af ; need later
042AA8             0120*  
042AA8             0121*  ; do the multiplication
042AA8 CD 69 2B 04 0122*      call umul24x24
042AAC             0123*      ; DEBUG
042AAC 21 FE 2A 04 0124*      ld hl,umulfxout ; point to output buffer
042AB0 3E 06       0125*      ld a,6 ; 6 bytes to print
042AB2 CD 47 1A 04 0126*      call dumpMemoryHex ; print the result
042AB6             0127*      ; END DEBUG
042AB6             0128*  
042AB6             0129*  ; shift the result to the required output precision
042AB6 78          0130*      ld a,b
042AB7 81          0131*      add a,c ; a is left shift from the multiplication
042AB8 C1          0132*      pop bc ; b is the output precision (was a)
042AB9 90          0133*      sub b ; a is the net shift of the output
042ABA             0134*  
042ABA             0135*  ; Get absolute value of a and save its original sign
042ABA B7          0136*      or a
042ABB F5          0137*      push af ; save sign flag
042ABC F2 C2 2A 04 0138*      jp p,@F ; If a is positive do nothing
042AC0 ED 44       0139*      neg ; If a is negative, negate it
042AC2             0140*  @@:
042AC2             0141*  
042AC2             0142*  ; Divide a by 8 to get the whole byte shift and bit remainder
042AC2 47          0143*      ld b,a            ; Store 'a' temporarily in 'b' (net shift)
042AC3 CB 3F       0144*      srl a             ; a = a / 2 (shift right 1 bit)
042AC5 CB 3F       0145*      srl a             ; a = a / 4 (shift right another bit)
042AC7 CB 3F       0146*      srl a             ; a = a / 8 (final shift for division by 8)
042AC9 4F          0147*      ld c,a            ; c holds the number of whole bytes to shift
042ACA             0148*  
042ACA             0149*  ; Calculate remainder of a (original shift) mod 8
042ACA 78          0150*      ld a,b            ; Restore original shift value into 'a'
042ACB E6 07       0151*      and 0x07          ; Mask with 0x07 to get the remainder (bits to shift back up)
042ACD 47          0152*      ld b,a            ; 'b' now holds the number of bits to shift back up
042ACE 11 00 00 00 0153*      ld de,0           ; Clear deu for computing the offset address later
042AD2             0154*  
042AD2             0155*      ; call dumpRegistersHex ; DEBUG
042AD2             0156*  
042AD2             0157*  ; Get back the original sign of the byte shift
042AD2 F1          0158*      pop af            ; Restore sign flag
042AD3 F2 E1 2A 04 0159*      jp p,@F           ; If a was positive, we're done
042AD7 79          0160*      ld a,c            ; 'a' now holds the number of whole bytes to shift
042AD8 ED 44       0161*      neg               ; Negate the number of whole bytes to shift
042ADA 3D          0162*      dec a             ; Subtract 1 because that's just how this works
042ADB 4F          0163*      ld c,a            ; 'c' now holds the number of whole bytes to shift
042ADC 1B          0164*      dec de            ; DE = -1 to make the signed addition below work
042ADD 3E 08       0165*      ld a,8            ; Subtract bits to shift from 8 because we're in backwards land
042ADF 90          0166*      sub b
042AE0 47          0167*      ld b,a            ; b is the number of bits to shift back up
042AE1             0168*  
042AE1             0169*      ; call dumpRegistersHex ; DEBUG
042AE1             0170*  
042AE1             0171*  @@:
042AE1             0172*  
042AE1             0173*  ; Add the byte offset to the base address of umulfxout
042AE1 59          0174*      ld e,c            ; DEU and D were properly signed above
042AE2 DD 21 FE 2A 0175*      ld ix,umulfxout   ; Load base address of the output buffer
       04          
042AE7 DD 19       0176*      add ix,de         ; Add byte-aligned offset (hl = umulfxout + l)
042AE9             0177*  
042AE9             0178*      ; call dumpRegistersHex ; DEBUG
042AE9             0179*  
042AE9             0180*  ; Read the byte-aligned result into HL and shift in the required number of bits
042AE9 DD 27 00    0181*      ld hl,(ix)        ; Byte-aligned result
042AEC DD 7E FF    0182*      ld a,(ix-1)       ; One byte below
042AEF             0183*  
042AEF             0184*  ; Check whether we're already byte-aligned
042AEF AF          0185*      xor a
042AF0 B0          0186*      or b
042AF1 28 05       0187*      jr z,@end         ; If no bits to shift, we're done
042AF3             0188*  
042AF3             0189*  ; Otherwise shiften zee bitzen
042AF3             0190*  @loop:
042AF3             0191*  
042AF3             0192*      ; call dumpRegistersHex ; DEBUG
042AF3             0193*  
042AF3 07          0194*      rlca              ; One bit to carry
042AF4 ED 6A       0195*      adc hl,hl         ; Shift the carry into the result
042AF6             0196*  
042AF6 10 FB       0197*      djnz @loop        ; Loop until all bits are shifted up
042AF8             0198*  
042AF8             0199*  @end:
042AF8             0200*  ; return the result
042AF8 DD E1       0201*      pop ix ; restore
042AFA C9          0202*      ret
042AFB             0203*  
042AFB 00 00 00    0204*      dl 0 ; padding
042AFE 00 00 00 00 0205*  umulfxout: blkb 6,0
       00 00       
042B04 00 00 00    0206*      dl 0 ; padding
042B07             0207*  
042B07             0208*  ; operation: UHL * UDE --> UHL
042B07             0209*  ; multiply signed 24-bit numbers and return a 48-bit intermediate
042B07             0210*  ; with inputs and outputs having an arbitrary number of fractional bits from 0 to 24
042B07             0211*  ; inputs: hl = 24-bit number, de = 24-bit number,
042B07             0212*  ;         b = hl fractional bits, c = de fractional bits, a = output fractional bits
042B07             0213*  ; outputs: umulfxout = 48-bit intermediate
042B07             0214*  ; destroys: af, hl, bc, de
042B07             0215*  smulfx:
042B07             0216*  ; make everything positive and store sign flags
042B07 CD BF 20 04 0217*  	call hlu_abs
042B0B F5          0218*  	push af
042B0C EB          0219*  	ex de,hl
042B0D CD BF 20 04 0220*  	call hlu_abs
042B11 EB          0221*  	ex de,hl
042B12 F5          0222*  	push af
042B13             0223*  ; do the division
042B13 CD A5 2A 04 0224*      call umulfx ; hl = product
042B17             0225*  ; adjust sign of result
042B17 F1          0226*  	pop af ; sign de
042B18 FA 23 2B 04 0227*  	jp m,@de_neg
042B1C F1          0228*  	pop af ; sign hl
042B1D F0          0229*  	ret p ; both positive, nothing to do
042B1E             0230*  @hl_neg:
042B1E CD CF 20 04 0231*      call neg_hlu ; de pos, hl neg, result is negative
042B22 C9          0232*      ret
042B23             0233*  @de_neg:
042B23 F1          0234*  	pop af
042B24 F8          0235*  	ret m ; both negative, nothing to do
042B25 CD CF 20 04 0236*  	call neg_hlu ; result is negative
042B29 C9          0237*  	ret
042B2A             0238*  
042B2A             0239*  ; multiply a signed 24-bit number by an unsigned 8-bit number giving a signed 24-bit result
042B2A             0240*  ; uses EZ80 MLT instruction for speed
042B2A             0241*  ; operation: UHL * A --> UHL
042B2A             0242*  ; destroys: AF, HL
042B2A             0243*  smul24x8:
042B2A             0244*  ; make hl positive and store sign flag
042B2A CD BF 20 04 0245*  	call hlu_abs
042B2E F5          0246*  	push af
042B2F             0247*  ; do the division
042B2F CD 3A 2B 04 0248*      call umul24x8 ; hl = product
042B33             0249*  ; adjust sign of result
042B33 F1          0250*  	pop af ; sign de
042B34 F0          0251*  	ret p ; hl was positive, nothing to do
042B35 CD CF 20 04 0252*  	call neg_hlu ; result is negative
042B39 C9          0253*  	ret
042B3A             0254*  
042B3A             0255*  ; unsigned multiplication of a 24-bit and 8-bit number giving a 32-bit result
042B3A             0256*  ; uses EZ80 MLT instruction for speed
042B3A             0257*  ; operation: UHL * A --> AUHL
042B3A             0258*  ; destroys: AF, HL
042B3A             0259*  umul24x8:
042B3A D5          0260*  	push de ; preserve de
042B3B             0261*  ; low byte
042B3B 5D          0262*  	ld e,l
042B3C 57          0263*  	ld d,a
042B3D ED 5C       0264*  	mlt de
042B3F 6B          0265*  	ld l,e ; product low byte
042B40 08          0266*  	ex af,af' ; save multiplier
042B41 7A          0267*  	ld a,d ; carry
042B42 08          0268*  	ex af,af' ; save carry, restore multiplier
042B43             0269*  ; high byte
042B43 5C          0270*  	ld e,h
042B44 57          0271*  	ld d,a
042B45 ED 5C       0272*  	mlt de
042B47 08          0273*  	ex af,af' ; save multiplier, restore carry
042B48 83          0274*  	add a,e ; add carry
042B49 67          0275*  	ld h,a ; product middle byte
042B4A 7A          0276*  	ld a,d ; carry
042B4B 08          0277*  	ex af,af' ; save carry, restore multiplier
042B4C             0278*  ; upper byte
042B4C E5          0279*  	push hl
042B4D 33          0280*  	inc sp
042B4E D1          0281*  	pop de ; d = hlu
042B4F 3B          0282*  	dec sp
042B50 5F          0283*  	ld e,a
042B51 ED 5C       0284*  	mlt de
042B53 08          0285*  	ex af,af' ; restore carry
042B54 8B          0286*  	adc a,e ; add carry
042B55 22 66 2B 04 0287*      ld (@scratch),hl ; 7 cycles
042B59 32 68 2B 04 0288*      ld (@scratch+2),a ; 5 cycles
042B5D 2A 66 2B 04 0289*      ld hl,(@scratch) ; 7 cycles
042B61             0290*  ; highest byte
042B61 3E 00       0291*  	ld a,0 ; preserve carry flag
042B63 8A          0292*  	adc a,d ; product highest byte
042B64 D1          0293*  	pop de ; restore de
042B65 C9          0294*  	ret
042B66             0295*  @scratch: ds 3
042B69             0296*  
042B69             0297*  ; unsigned multiplication of two 24-bit numbers giving a 48-bit result
042B69             0298*  ; operation: UHL * UDE --> umulfxout
042B69             0299*  umul24x24:
042B69 FD 21 FE 2A 0300*  	ld iy,umulfxout ; point to output buffer
       04          
042B6E C5          0301*  	push bc
042B6F 01 00 00 00 0302*  	ld bc,0
042B73 FD 0F 00    0303*  	ld (iy),bc
042B76 FD 0F 03    0304*  	ld (iy+3),bc
042B79 C1          0305*  	pop bc
042B7A             0306*  
042B7A             0307*  ; STEP 1: UHL * E
042B7A 7B          0308*  	ld a,e
042B7B E5          0309*  	push hl
042B7C CD 3A 2B 04 0310*  	call umul24x8
042B80 FD 2F 00    0311*  	ld (iy+0),hl
042B83 FD 77 03    0312*  	ld (iy+3),a
042B86             0313*  
042B86             0314*  ; STEP 2: UHL * D
042B86 E1          0315*  	pop hl
042B87 E5          0316*  	push hl
042B88 7A          0317*  	ld a,d
042B89 CD 3A 2B 04 0318*  	call umul24x8
042B8D CD 9A 2B 04 0319*  	call @accumulate
042B91             0320*  
042B91             0321*  ; STEP 3: UHL * DEU
042B91 E1          0322*  	pop hl
042B92 D5          0323*  	push de
042B93 33          0324*  	inc sp
042B94 F1          0325*  	pop af
042B95 3B          0326*  	dec sp
042B96 CD 3A 2B 04 0327*  	call umul24x8
042B9A             0328*  
042B9A             0329*  @accumulate:
042B9A FD 23       0330*  	inc iy
042B9C             0331*  ; highest byte of product to carry
042B9C FD 77 03    0332*  	ld (iy+3),a
042B9F             0333*  ; low byte of product
042B9F 7D          0334*  	ld a,l
042BA0 FD 86 00    0335*  	add a,(iy+0)
042BA3 FD 77 00    0336*  	ld (iy+0),a
042BA6             0337*  ; high byte of product
042BA6 7C          0338*  	ld a,h
042BA7 FD 8E 01    0339*  	adc a,(iy+1)
042BAA FD 77 01    0340*  	ld (iy+1),a
042BAD             0341*  ; uppper byte of product
042BAD E5          0342*  	push hl
042BAE 33          0343*  	inc sp
042BAF E1          0344*  	pop hl
042BB0 3B          0345*  	dec sp
042BB1 7C          0346*  	ld a,h
042BB2 FD 8E 02    0347*  	adc a,(iy+2)
042BB5 FD 77 02    0348*  	ld (iy+2),a
042BB8             0349*  ; carry
042BB8 3E 00       0350*  	ld a,0 ; preserve flags
042BBA FD 8E 03    0351*  	adc a,(iy+3)
042BBD FD 77 03    0352*  	ld (iy+3),a
042BC0 C9          0353*  	ret
042BC1             0354*  
042BC1             0355*  ; UH.L = UH.L*UD.E (unsigned)
042BC1             0356*  umul168:
042BC1 CD 69 2B 04 0357*  	call umul24x24
042BC5 FD 27 FF    0358*  	ld hl,(iy-1)
042BC8 C9          0359*  	ret
042BC9             0360*  
042BC9             0361*  ; UH.L * UD.E --> UH.L (signed)
042BC9             0362*  smul168:
042BC9             0363*  ; make everything positive and store sign flags
042BC9 CD BF 20 04 0364*  	call hlu_abs
042BCD F5          0365*  	push af
042BCE EB          0366*  	ex de,hl
042BCF CD BF 20 04 0367*  	call hlu_abs
042BD3 EB          0368*  	ex de,hl
042BD4 F5          0369*  	push af
042BD5             0370*  ; do the division
042BD5 CD C1 2B 04 0371*      call umul168 ; hl = product
042BD9             0372*  ; adjust sign of result
042BD9 F1          0373*  	pop af ; sign de
042BDA FA E5 2B 04 0374*  	jp m,@de_neg
042BDE F1          0375*  	pop af ; sign hl
042BDF F0          0376*  	ret p ; both positive, nothing to do
042BE0             0377*  @hl_neg:
042BE0 CD CF 20 04 0378*      call neg_hlu ; de pos, hl neg, result is negative
042BE4 C9          0379*      ret
042BE5             0380*  @de_neg:
042BE5 F1          0381*  	pop af
042BE6 F8          0382*  	ret m ; both negative, nothing to do
042BE7 CD CF 20 04 0383*  	call neg_hlu ; result is negative
042BEB C9          0384*  	ret
042BEC             0385*  
042BEC             0386*  ; UH.L / UD.E --> UD.E rem UHL (unsigned)
042BEC             0387*  ; perform unsigned division of 16.8 fixed place values
042BEC             0388*  ; with an unsigned 16.8 fixed place result and 24-bit remainder
042BEC             0389*  udiv168:
042BEC             0390*  ; back up divisor
042BEC ED 53 23 2C 0391*  	ld (@ude),de
       04          
042BF1             0392*  ; get the 16-bit integer part of the quotient
042BF1 CD 54 2C 04 0393*      call udiv24 ; de = quotient, hl = remainder
042BF5             0394*  ; load quotient to upper three bytes of output
042BF5 ED 53 2A 2C 0395*      ld (div168_out+1),de
       04          
042BFA             0396*  @div256:
042BFA             0397*  ; multiply remainder by 256
042BFA             0398*  	hlu_mul256
042BFA 29          0001*M         add hl,hl ; * 2
042BFB 29          0002*M         add hl,hl ; * 4
042BFC 29          0003*M         add hl,hl ; * 8
042BFD 29          0004*M         add hl,hl ; * 16
042BFE 29          0005*M         add hl,hl ; * 32
042BFF 29          0006*M         add hl,hl ; * 64
042C00 29          0007*M         add hl,hl ; * 128
042C01 29          0008*M         add hl,hl ; * 256
042C02             0399*  ; skip fractional computation if remainder is zero
042C02             0400*      sign_hlu
042C02 19          0001*M         add hl,de
042C03 B7          0002*M         or a
042C04 ED 52       0003*M         sbc hl,de
042C06 20 03       0401*      jr nz,@div_frac
042C08 AF          0402*      xor a
042C09 18 0A       0403*      jr @write_frac
042C0B             0404*  ; now divide the shifted remainder by the divisor
042C0B             0405*  @div_frac:
042C0B ED 5B 23 2C 0406*  	ld de,(@ude) ; get back divisor
       04          
042C10 CD 54 2C 04 0407*      call udiv24 ; de = quotient, hl = remainder
042C14             0408*  ; load low byte of quotient to low byte of output
042C14 7B          0409*      ld a,e
042C15             0410*  @write_frac:
042C15 32 29 2C 04 0411*      ld (div168_out),a
042C19             0412*  ; load de with return value
042C19 ED 5B 29 2C 0413*      ld de,(div168_out)
       04          
042C1E             0414*  ; load a with any overflow
042C1E 3A 2C 2C 04 0415*      ld a,(div168_out+3)
042C22 C9          0416*      ret ; ud.e is the 16.8 result
042C23             0417*  @ude: ds 6
042C29             0418*  div168_out: ds 4 ; the extra byte is for overflow
042C2D             0419*  
042C2D             0420*  ; UH.L / UD.E --> UD.E (signed) rem UHL (unsigned)
042C2D             0421*  ; perform signed division of 16.8 fixed place values
042C2D             0422*  ; with a signed 16.8 fixed place result and unsigned 24-bit remainder
042C2D             0423*  sdiv168:
042C2D             0424*  ; make everything positive and store sign flags
042C2D CD BF 20 04 0425*  	call hlu_abs
042C31 F5          0426*  	push af
042C32 EB          0427*  	ex de,hl
042C33 CD BF 20 04 0428*  	call hlu_abs
042C37 EB          0429*  	ex de,hl
042C38 F5          0430*  	push af
042C39             0431*  ; do the division
042C39 CD EC 2B 04 0432*      call udiv168 ; de = quotient, hl = remainder
042C3D             0433*  ; adjust sign of result
042C3D F1          0434*  	pop af ; sign de
042C3E FA 4B 2C 04 0435*  	jp m,@de_neg
042C42 F1          0436*  	pop af ; sign hl
042C43 F0          0437*  	ret p ; both positive, nothing to do
042C44             0438*  @hl_neg:
042C44 EB          0439*      ex de,hl ; hl = quotient, de = remainder
042C45 CD CF 20 04 0440*      call neg_hlu ; de pos, hl neg, result is negative
042C49 EB          0441*      ex de,hl ; de = negated quotient, hl = remainder
042C4A C9          0442*      ret
042C4B             0443*  @de_neg:
042C4B F1          0444*  	pop af
042C4C F8          0445*  	ret m ; both negative, nothing to do
042C4D EB          0446*      ex de,hl ; hl = quotient, de = remainder
042C4E CD CF 20 04 0447*  	call neg_hlu ; result is negative
042C52 EB          0448*      ex de,hl ; de = negated quotient, hl = remainder
042C53 C9          0449*  	ret
042C54             0450*  
042C54             0451*  ;------------------------------------------------------------------------
042C54             0452*  ;  arith24.asm
042C54             0453*  ;  24-bit ez80 arithmetic routines
042C54             0454*  ;  Copyright (c) Shawn Sijnstra 2024
042C54             0455*  ;  MIT license
042C54             0456*  ;
042C54             0457*  ;  This library was created as a tool to help make ez80
042C54             0458*  ;  24-bit native assembly routines for simple mathematical problems
042C54             0459*  ;  more widely available.
042C54             0460*  ;
042C54             0461*  ;------------------------------------------------------------------------
042C54             0462*  ;
042C54             0463*  ;------------------------------------------------------------------------
042C54             0464*  ; udiv24
042C54             0465*  ; Unsigned 24-bit division
042C54             0466*  ; Divides HLU by DEU. Gives result in DEU (and BC), remainder in HLU.
042C54             0467*  ;
042C54             0468*  ; Uses AF BC DE HL
042C54             0469*  ; Uses Restoring Division algorithm
042C54             0470*  ;------------------------------------------------------------------------
042C54             0471*  
042C54             0472*  udiv24:
042C54 E5          0473*  	push	hl
042C55 C1          0474*  	pop		bc	;move dividend to BCU
042C56 21 00 00 00 0475*  	ld		hl,0	;result
042C5A A7          0476*  	and		a
042C5B ED 52       0477*  	sbc		hl,de	;test for div by 0
042C5D C8          0478*  	ret		z		;it's zero, carry flag is clear
042C5E 19          0479*  	add		hl,de	;HL is 0 again
042C5F 3E 18       0480*  	ld		a,24	;number of loops through.
042C61             0481*  udiv1:
042C61 C5          0482*  	push	bc	;complicated way of doing this because of lack of access to top bits
042C62 E3          0483*  	ex		(sp),hl
042C63 37          0484*  	scf
042C64 ED 6A       0485*  	adc	hl,hl
042C66 E3          0486*  	ex	(sp),hl
042C67 C1          0487*  	pop	bc		;we now have bc = (bc * 2) + 1
042C68             0488*  
042C68 ED 6A       0489*  	adc	hl,hl
042C6A A7          0490*  	and	a		;is this the bug
042C6B ED 52       0491*  	sbc	hl,de
042C6D 30 02       0492*  	jr	nc,udiv2
042C6F 19          0493*  	add	hl,de
042C70             0494*  ;	dec	c
042C70 0B          0495*  	dec	bc
042C71             0496*  udiv2:
042C71 3D          0497*  	dec	a
042C72 20 ED       0498*  	jr	nz,udiv1
042C74 37          0499*  	scf		;flag used for div0 error
042C75 C5          0500*  	push	bc
042C76 D1          0501*  	pop		de	;remainder
042C77 C9          0502*  	ret
042C78             0061   ; App-specific includes
042C78             0062   	include "player.inc"
042C78             0001*  ; ######## GAME STATE VARIABLES #######
042C78             0002*  ; THESE MUST BE IN THIS ORDER FOR new_game TO WORK PROPERLY
042C78 00 00 00    0003*  player_score: db 0x00,#00,#00 ; bcd
042C7B             0004*  ; player current shields,binary
042C7B             0005*  ; when < 0 player splodes
042C7B             0006*  ; restores to player_max_shields when new ship spawns
042C7B 10          0007*  player_shields: db 16 ; binary
042C7C             0008*  ; max player shields,binary
042C7C             0009*  ; can increase with power-ups (todo)
042C7C 10          0010*  player_max_shields: db 16 ; binary
042C7D             0011*  ; when reaches zero,game ends
042C7D             0012*  ; can increase based on TODO
042C7D 03          0013*  player_ships: db 0x03 ; binary
042C7E             0014*  
042C7E             0015*  ; ######### PLAYER SPRITE PARAMETERS ##########
042C7E             0016*  ; uses the same offsets from its table base as the main sprite table:
042C7E             0017*  player_start_variables: ; label marking beginning of table
042C7E 01          0018*  player_id:               db table_max_records
042C7F 00          0019*  player_type:             db     0x00 ; 1 bytes currently not used
042C80 34 01 00    0020*  player_base_bufferId:    dl BUF_SHIP_0L ; 3 bytes bitmap bufferId
042C83 00 00 00    0021*  player_move_program:     dl 0x000000 ; 3 bytes not currently used
042C86 00          0022*  player_collisions:       db     0x00 ; 1 bytes bit 0 set=alive, otherwise dead, bit 1 set=just died
042C87 00          0023*  player_dim_x:            db     0x00 ; 1 bytes sprite width in pixels
042C88 00          0024*  player_dim_y:            db     0x00 ; 1 bytes sprite height in pixels
042C89 00 00 00    0025*  player_x:                dl 0x000000 ; 3 bytes 16.8 fractional x position in pixels
042C8C 00 00 00    0026*  player_y:                dl 0x000000 ; 3 bytes 16.8 fractional y position in pixels
042C8F 00 00 00    0027*  player_xvel:             dl 0x000000 ; 3 bytes x-component velocity, 16.8 fixed, pixels
042C92 00 00 00    0028*  player_yvel:             dl 0x000000 ; 3 bytes y-component velocity, 16.8 fixed, pixels
042C95 00 00 00    0029*  player_vel:              dl 0x000000 ; 3 bytes velocity px/frame (16.8 fixed)
042C98 00 00 00    0030*  player_heading:          dl 0x000000 ; 3 bytes sprite movement direction deg256 16.8 fixed
042C9B 00 00 00    0031*  player_orientation:      dl 0x000000 ; 3 bytes not currently used
042C9E 00          0032*  player_animation:        db     0x00 ; 1 bytes not currently used
042C9F 00          0033*  player_animation_timer:  db     0x00 ; 1 bytes not currently used
042CA0 00          0034*  player_move_timer:       db     0x00 ; 1 bytes not currently used
042CA1 00          0035*  player_move_step:        db     0x00 ; 1 bytes not currently used
042CA2 00          0036*  player_points:           db     0x00 ; 1 bytes not currently used
042CA3 00          0037*  player_shield_damage:    db     0x00 ; 1 bytes not currently used
042CA4             0038*  player_end_variables: ; for when we want to traverse this table in reverse
042CA4             0039*  
042CA4             0040*  ; set initial player position
042CA4             0041*  ; inputs: none,everything is hardcoded
042CA4             0042*  ; outputs: player_x/y set to bottom-left corner of screen
042CA4             0043*  ; destroys: a
042CA4             0044*  player_init:
042CA4 3A 7E 2C 04 0045*  	ld a,(player_id)
042CA8 CD 57 1F 04 0046*  	call vdu_sprite_select
042CAC CD 6A 1F 04 0047*      call vdu_sprite_clear_frames
042CB0 21 34 01 00 0048*      ld hl,BUF_SHIP_0L
042CB4 CD A4 20 04 0049*      call vdu_sprite_add_buff
042CB8 21 35 01 00 0050*      ld hl,BUF_SHIP_1C
042CBC CD A4 20 04 0051*      call vdu_sprite_add_buff
042CC0 21 36 01 00 0052*      ld hl,BUF_SHIP_2R
042CC4 CD A4 20 04 0053*      call vdu_sprite_add_buff
042CC8 01 00 00 00 0054*      ld bc,0
042CCC ED 43 89 2C 0055*      ld (player_x),bc
       04          
042CD1 11 00 DF 00 0056*      ld de,0x00DF00
042CD5 ED 53 8C 2C 0057*      ld (player_y),de
       04          
042CDA CD 23 20 04 0058*      call vdu_sprite_move_abs168
042CDE CD CD 1F 04 0059*      call vdu_sprite_show
042CE2 C9          0060*      ret
042CE3             0061*  
042CE3             0062*  ; process player keyboard input, set player bitmap
042CE3             0063*  ; velocities and draw player bitmap at updated coordinates
042CE3             0064*  ; Inputs: player_x/y set at desired position
042CE3             0065*  ; Returns: player bitmap drawn at updated position
042CE3             0066*  ; Destroys: probably everything except maybe iy
042CE3             0067*  ; NOTE: in mode 9 we draw the ship as a sprite, not a bitmap
042CE3             0068*  ; TODO: requires sprite implementation
042CE3             0069*  player_input:
042CE3             0070*  ; reset player component velocities to zero as the default
042CE3 21 00 00 00 0071*  	ld hl,0
042CE7 22 8F 2C 04 0072*  	ld (player_xvel),hl
042CEB 22 92 2C 04 0073*  	ld (player_yvel),hl
042CEF             0074*  ; make ship the active sprite
042CEF 3A 7E 2C 04 0075*      ld a,(player_id)
042CF3 CD 57 1F 04 0076*      call vdu_sprite_select
042CF7             0077*  ; check for keypresses and branch accordingly
042CF7             0078*  ; for how this works,see: https://github.com/breakintoprogram/agon-docs/wiki/MOS-API-%E2%80%90-Virtual-Keyboard
042CF7             0079*      MOSCALL	mos_getkbmap ;ix = pointer to MOS virtual keys table
042CF7 3E 1E       0001*M 			LD	A, function
042CF9 5B CF       0002*M 			RST.LIL	08h
042CFB             0080*  ; we test all four arrow keys and add/subract velocities accordingly
042CFB             0081*  ; this handles the case where two opposing movement keys
042CFB             0082*  ; are down simultaneously (velocities will net to zero)
042CFB             0083*  ; and allows diagonal movement when a vertical and horizontal key are down
042CFB             0084*  ; it also allows movement and action keys to be detected simultaneously
042CFB             0085*  ; so we can walk and chew gum at the same time
042CFB 3E 01       0086*      ld a,1 ; set ship's default animation to center
042CFD             0087*          ; if left and right are both down a will net to
042CFD             0088*  
042CFD             0089*  @left:
042CFD DD CB 03 4E 0090*      bit 1,(ix+3) ; keycode 26
042D01 28 0E       0091*      jr z,@right
042D03 2A 8F 2C 04 0092*      ld hl,(player_xvel)
042D07 01 00 FD FF 0093*      ld bc,-speed_player
042D0B 09          0094*      add hl,bc
042D0C 22 8F 2C 04 0095*      ld (player_xvel),hl
042D10 3D          0096*      dec a ; set ship's animation to left
042D11             0097*  @right:
042D11 DD CB 0F 4E 0098*      bit 1,(ix+15) ; keycode 122
042D15 28 0E       0099*  	jr z,@up
042D17 2A 8F 2C 04 0100*      ld hl,(player_xvel)
042D1B 01 00 03 00 0101*      ld bc,speed_player
042D1F 09          0102*      add hl,bc
042D20 22 8F 2C 04 0103*      ld (player_xvel),hl
042D24 3C          0104*      inc a ; set ship's animation to right
042D25             0105*  @up:
042D25 DD CB 07 4E 0106*      bit 1,(ix+7) ; keycode 58
042D29 28 0D       0107*  	jr z,@down
042D2B 2A 92 2C 04 0108*      ld hl,(player_yvel)
042D2F 01 00 FD FF 0109*      ld bc,-speed_player
042D33 09          0110*      add hl,bc
042D34 22 92 2C 04 0111*      ld (player_yvel),hl
042D38             0112*  @down:
042D38 DD CB 05 4E 0113*      bit 1,(ix+5) ; keycode 42
042D3C 28 0D       0114*  	jr z,@done_keyboard
042D3E 2A 92 2C 04 0115*      ld hl,(player_yvel)
042D42 01 00 03 00 0116*      ld bc,speed_player
042D46 09          0117*      add hl,bc
042D47 22 92 2C 04 0118*      ld (player_yvel),hl
042D4B             0119*  @done_keyboard:
042D4B             0120*  ; move player sprite according to velocities set by keypresses
042D4B 2A 8F 2C 04 0121*      ld hl,(player_xvel)
042D4F             0122*  ; compute new x position
042D4F ED 5B 89 2C 0123*      ld de,(player_x)
       04          
042D54 19          0124*      add hl,de ; hl = player_x + player_xvel
042D55             0125*      ; check for horizontal screen edge collisions
042D55             0126*      ; and adjust coordinate as necessary
042D55             0127*  ; TODO: make this work using 24-bit registers
042D55             0128*      ; cp 8 ; 0 + 1/2 bitmap dim_x
042D55             0129*      ; jr nc,@check_right ; x >= 8, no adjustment necessary
042D55             0130*      ; ld a,8 ; set x to leftmost allowable position
042D55             0131*  ; @check_right:
042D55             0132*  ;     cp 248 ; 256 - 1/2 bitmap dim_x
042D55             0133*  ;     jr c,@x_ok ; x < 248, no adjustment necessary
042D55             0134*  ;     ld a,248 ; set x to rightmost allowable position
042D55             0135*  @x_ok:
042D55             0136*  ; save the updated drawing coordinate
042D55 22 89 2C 04 0137*      ld (player_x),hl
042D59             0138*  ;compute new y position
042D59 2A 8C 2C 04 0139*      ld hl,(player_y)
042D5D ED 5B 92 2C 0140*      ld de,(player_yvel)
       04          
042D62 19          0141*      add hl,de ; hl = player_y + player_yvel
042D63             0142*  ; TODO: make this work using 24-bit registers
042D63             0143*  ;     ; check for vertical screen edge collisions
042D63             0144*  ;     ; and adjust coordinate as necessary
042D63             0145*  ;     cp 8 ; 0 + 1/2 bitmap dim_y
042D63             0146*  ;     jr nc,@check_top ; y >= 8, no adjustment necessary
042D63             0147*  ;     ld a,8 ; set y to topmost allowable position
042D63             0148*  ; @check_top:
042D63             0149*  ;     cp 232 ; 240 - 1/2 bitmap dim_y
042D63             0150*  ;     jr c,@y_ok ; y < 248, no adjustment necessary
042D63             0151*  ;     ld a,232 ; set y to bottommost allowable position
042D63             0152*  @y_ok:
042D63 22 8C 2C 04 0153*      ld (player_y),hl ; do this here b/c next call destroys hl
042D67             0154*  ; a should land here loaded with the correct frame
042D67 CD BA 1F 04 0155*      call vdu_sprite_select_frame
042D6B             0156*  ; draw player at updated position
042D6B ED 4B 89 2C 0157*      ld bc,(player_x)
       04          
042D70 ED 5B 8C 2C 0158*  	ld de,(player_y)
       04          
042D75             0159*  
042D75             0160*      ; call dumpRegistersHex
042D75             0161*  
042D75 CD 23 20 04 0162*  	call vdu_sprite_move_abs168
042D79             0163*  
042D79             0164*  ; end player_input
042D79 C9          0165*  	ret
042D7A             0166*  
042D7A             0167*  ; ; THE BELOW WORKS WITH THE AGON BUT USES INTEGER COORDINATES
042D7A             0168*  ; ; INSTEAD OF FRACTIONAL
042D7A             0169*  ; ; ----------------------------------------------------------------
042D7A             0170*  ; ; process player keyboard input, set player bitmap
042D7A             0171*  ; ; velocities and draw player bitmap at updated coordinates
042D7A             0172*  ; ; Inputs: player_x/y set at desired position
042D7A             0173*  ; ; Returns: player bitmap drawn at updated position
042D7A             0174*  ; ; Destroys: probably everything except maybe iy
042D7A             0175*  ; ; NOTE: in mode 9 we draw the ship as a sprite, not a bitmap
042D7A             0176*  ; ; TODO: requires sprite implementation
042D7A             0177*  ; player_input:
042D7A             0178*  ; ; reset player component velocities to zero as the default
042D7A             0179*  ; 	ld hl,0
042D7A             0180*  ; 	ld (player_xvel),hl
042D7A             0181*  ; 	ld (player_yvel),hl
042D7A             0182*  ; ; check for keypresses and branch accordingly
042D7A             0183*  ; ; for how this works,see: https://github.com/breakintoprogram/agon-docs/wiki/MOS-API-%E2%80%90-Virtual-Keyboard
042D7A             0184*  ;     MOSCALL	mos_getkbmap ;ix = pointer to MOS virtual keys table
042D7A             0185*  ; ; we test all four arrow keys and add/subract velocities accordingly
042D7A             0186*  ; ; this handles the case where two opposing movement keys
042D7A             0187*  ; ; are down simultaneously (velocities will net to zero)
042D7A             0188*  ; ; and allows diagonal movement when a vertical and horizontal key are down
042D7A             0189*  ; ; it also allows movement and action keys to be detected simultaneously
042D7A             0190*  ; ; so we can walk and chew gum at the same time
042D7A             0191*  ; @left:
042D7A             0192*  ;     bit 1,(ix+3) ; keycode 26
042D7A             0193*  ;     jr z,@right
042D7A             0194*  ;     ld hl,(player_xvel)
042D7A             0195*  ;     ld bc,-3
042D7A             0196*  ;     add hl,bc
042D7A             0197*  ;     ld (player_xvel),hl
042D7A             0198*  ; @right:
042D7A             0199*  ;     bit 1,(ix+15) ; keycode 122
042D7A             0200*  ; 	jr z,@up
042D7A             0201*  ;     ld hl,(player_xvel)
042D7A             0202*  ;     ld bc,3
042D7A             0203*  ;     add hl,bc
042D7A             0204*  ;     ld (player_xvel),hl
042D7A             0205*  ; @up:
042D7A             0206*  ;     bit 1,(ix+7) ; keycode 58
042D7A             0207*  ; 	jr z,@down
042D7A             0208*  ;     ld hl,(player_yvel)
042D7A             0209*  ;     ld bc,-3
042D7A             0210*  ;     add hl,bc
042D7A             0211*  ;     ld (player_yvel),hl
042D7A             0212*  ; @down:
042D7A             0213*  ;     bit 1,(ix+5) ; keycode 42
042D7A             0214*  ; 	jr z,@done_keyboard
042D7A             0215*  ;     ld hl,(player_yvel)
042D7A             0216*  ;     ld bc,3
042D7A             0217*  ;     add hl,bc
042D7A             0218*  ;     ld (player_yvel),hl
042D7A             0219*  ; @done_keyboard:
042D7A             0220*  ; ; move player sprite according to velocities set by keypresses
042D7A             0221*  ;     ld hl,(player_xvel)
042D7A             0222*  ; ; compute new x position
042D7A             0223*  ;     ld de,(player_x)
042D7A             0224*  ;     add hl,de ; hl = player_x + player_xvel
042D7A             0225*  ;     ; check for horizontal screen edge collisions
042D7A             0226*  ;     ; and adjust coordinate as necessary
042D7A             0227*  ; ; TODO: make this work using 24-bit registers
042D7A             0228*  ;     ; cp 8 ; 0 + 1/2 bitmap dim_x
042D7A             0229*  ;     ; jr nc,@check_right ; x >= 8, no adjustment necessary
042D7A             0230*  ;     ; ld a,8 ; set x to leftmost allowable position
042D7A             0231*  ; ; @check_right:
042D7A             0232*  ; ;     cp 248 ; 256 - 1/2 bitmap dim_x
042D7A             0233*  ; ;     jr c,@x_ok ; x < 248, no adjustment necessary
042D7A             0234*  ; ;     ld a,248 ; set x to rightmost allowable position
042D7A             0235*  ; @x_ok:
042D7A             0236*  ;     ; save the updated drawing coordinate
042D7A             0237*  ;     ld (player_x),hl
042D7A             0238*  ; ;compute new y position
042D7A             0239*  ;     ld hl,(player_y)
042D7A             0240*  ;     ld de,(player_yvel)
042D7A             0241*  ;     add hl,de ; hl = player_y + player_yvel
042D7A             0242*  ; ; TODO: make this work using 24-bit registers
042D7A             0243*  ; ;     ; check for vertical screen edge collisions
042D7A             0244*  ; ;     ; and adjust coordinate as necessary
042D7A             0245*  ; ;     cp 8 ; 0 + 1/2 bitmap dim_y
042D7A             0246*  ; ;     jr nc,@check_top ; y >= 8, no adjustment necessary
042D7A             0247*  ; ;     ld a,8 ; set y to topmost allowable position
042D7A             0248*  ; ; @check_top:
042D7A             0249*  ; ;     cp 232 ; 240 - 1/2 bitmap dim_y
042D7A             0250*  ; ;     jr c,@y_ok ; y < 248, no adjustment necessary
042D7A             0251*  ; ;     ld a,232 ; set y to bottommost allowable position
042D7A             0252*  ; @y_ok:
042D7A             0253*  ;     ld (player_y),hl
042D7A             0254*  ; ; draw player at updated position
042D7A             0255*  ;     ld a,(player_id)
042D7A             0256*  ;     call vdu_sprite_select
042D7A             0257*  ;     ld hl,(player_xvel) ; we do a cheeky little hack
042D7A             0258*  ;     call get_sign_hlu ; to set the proper animation
042D7A             0259*  ;     add a,1 ; ...
042D7A             0260*  ;     call vdu_sprite_select_frame
042D7A             0261*  ;     ld bc,(player_x)
042D7A             0262*  ; 	ld de,(player_y)
042D7A             0263*  ; 	call vdu_sprite_move_abs
042D7A             0264*  ; ; end player_input
042D7A             0265*  ; 	ret
042D7A             0266*  
042D7A             0267*  
042D7A             0268*  ; ###################################################################
042D7A             0269*  ; TODO: the below is all stuff from the original code we need to port
042D7A             0270*  ; ###################################################################
042D7A             0271*  
042D7A             0272*  ; kill_player:
042D7A             0273*  ; ; set player status to dead
042D7A             0274*  ;     xor a; sets all player flags to zero
042D7A             0275*  ;     ld (player_collisions),a
042D7A             0276*  ; ; deduct a ship from the inventory
042D7A             0277*  ;     ld a,(player_ships)
042D7A             0278*  ;     dec a
042D7A             0279*  ;     ld (player_ships),a
042D7A             0280*  ; ; are we out of ships?
042D7A             0281*  ;     jp z,game_over
042D7A             0282*  ; ; wait a few ticks
042D7A             0283*  ;     ld a,32 ; 32-cycle timer ~1/2 second at 60fps
042D7A             0284*  ;     ld (player_move_timer),a
042D7A             0285*  ; kill_player_loop:
042D7A             0286*  ;     call vdu_vblank
042D7A             0287*  ;     ld a,(player_move_timer)
042D7A             0288*  ;     dec a
042D7A             0289*  ;     ld (player_move_timer),a
042D7A             0290*  ;     jr nz,kill_player_loop
042D7A             0291*  ;     call player_init ; player respawn if timer zero
042D7A             0292*  ;     ret ; and out
042D7A             0293*  
042D7A             0294*  
042D7A             0295*  ; player_move:
042D7A             0296*  ; ; begin setting player to active sprite
042D7A             0297*  ;     ld hl,player
042D7A             0298*  ;     ld (sprite_base_bufferId),hl
042D7A             0299*  ;     ld hl,0 ; north
042D7A             0300*  ;     ld (sprite_heading),hl
042D7A             0301*  ;     ld a,#01 ; animation 1 is center,which we set here as a default
042D7A             0302*  ;     ld (sprite_animation),a
042D7A             0303*  ;     ; we set position here for the time being as a default
042D7A             0304*  ;     ; in case the player doesn't move,or is flagged for deletion
042D7A             0305*  ;     ld hl,(player_x)
042D7A             0306*  ;     ld (sprite_x),hl
042D7A             0307*  ;     ld hl,(player_y)
042D7A             0308*  ;     ld (sprite_y),hl
042D7A             0309*  ; ; did we just die?
042D7A             0310*  ;     ld a,(player_collisions)
042D7A             0311*  ;     and %00000010 ; zero flag will be set if not dead
042D7A             0312*  ;     jr z,player_not_dead
042D7A             0313*  ; ; yes we died
042D7A             0314*  ;     call kill_player
042D7A             0315*  ;     ret ; done
042D7A             0316*  ; ; yay we didn't die
042D7A             0317*  ; player_not_dead:
042D7A             0318*  ; ; set player movements to zero by default
042D7A             0319*  ;     ld hl,0
042D7A             0320*  ;     ld (player_xvel),hl
042D7A             0321*  ;     ld (player_yvel),hl
042D7A             0322*  ; ; do we move it?
042D7A             0323*  ;     in a,(#82) ; keyboard
042D7A             0324*  ;     or a ; if zero,don't move
042D7A             0325*  ;     jr z,player_draw
042D7A             0326*  ; ; move it
042D7A             0327*  ;     call player_move_calc
042D7A             0328*  ; player_draw:
042D7A             0329*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
042D7A             0330*  ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
042D7A             0331*  ; player_move_done:
042D7A             0332*  ;     ; write updated x,y coordinates back to player table
042D7A             0333*  ;     ld hl,(sprite_x)
042D7A             0334*  ;     ld (player_x),hl
042D7A             0335*  ;     ld hl,(sprite_y)
042D7A             0336*  ;     ld (player_y),hl
042D7A             0337*  ;     ret
042D7A             0063   	include "tiles.inc"
042D7A             0001*  ; ######### TILES #########
042D7A             0002*  ; TODO: implement buffering of tiles here when there isn't other stuff to do
042D7A             0003*  ; tiles_defs: ds 256*16 ; 256 rows of 16 tiles, each tile is a byte
042D7A 00 00 00    0004*  tiles_row_defs: dl 0x000000 ; pointer to current row tiles definitions
042D7D 00          0005*  tiles_row: db 0 ; decrements each time a row is drawn. level is over when hits zero
042D7E             0006*                          ; initialize to zero for a maximum of 256 rows in a level
042D7E 00          0007*  cur_level: db 0
042D7F             0008*  num_levels: equ 2 ; number of levels,duh
042D7F             0009*  
042D7F             0010*  ; lookup table for level definitions
042D7F E0 04 04 E1 0011*  tiles_levels: dl tiles_level_00,tiles_level_01
       14 04       
042D85             0012*  
042D85             0013*  ; tiles_bufferId: dl 0
042D85 00 00 00    0014*  tiles_x_plot: dl 0
042D88 F1 FF FF    0015*  tiles_y_plot: dl -15
042D8B             0016*  
042D8B             0017*  
042D8B             0018*  tiles_plot:
042D8B             0019*  ; ; NOTE: this is bugged. y1 should be zero to get a 1px-tall viewport
042D8B             0020*  ; ;       as written it gves a 2px-tall window which is what we'd expect,
042D8B             0021*  ; ;       but don't want
042D8B             0022*  ; ; https://discord.com/channels/1158535358624039014/1158536809916149831/1209571014514712637
042D8B             0023*  ; ; set gfx viewport to one scanline to optimise plotting tiles
042D8B             0024*  ; 	ld bc,0 ; leftmost x-coord
042D8B             0025*  ; 	ld de,0 ; topmost y-coord
042D8B             0026*  ; 	ld ix,255 ; rightmost x-coord
042D8B             0027*  ; 	ld iy,1 ; bottommost y-coord
042D8B             0028*  ; 	call vdu_set_gfx_viewport
042D8B             0029*  
042D8B 21 00 00 00 0030*      ld hl,0 ; init plotting x-coordinate
042D8F 22 85 2D 04 0031*      ld (tiles_x_plot),hl
042D93 2A 7A 2D 04 0032*      ld hl,(tiles_row_defs)
042D97 06 10       0033*  	ld b,16 ; loop counter
042D99             0034*  @loop:
042D99 C5          0035*  	push bc ; save the loop counter
042D9A             0036*  ; read the tile defintion for the current column
042D9A 7E          0037*      ld a,(hl) ; a has tile definition
042D9B E5          0038*      push hl  ; save pointer to tile definition
042D9C 21 00 00 00 0039*      ld hl,0 ; hlu is non-zero
042DA0 6F          0040*      ld l,a ; l is tile defintion
042DA1 26 01       0041*      ld h,0x01 ; hl = 256 + tile index = the tile's bitmapId
042DA3 CD ED 1B 04 0042*      call vdu_buff_select ; tile bitmap buffer is now active
042DA7             0043*  
042DA7             0044*  ; plot the active bitmap
042DA7 ED 4B 85 2D 0045*      ld bc,(tiles_x_plot)
       04          
042DAC ED 5B 88 2D 0046*      ld de,(tiles_y_plot)
       04          
042DB1 CD B6 1E 04 0047*      call vdu_plot_bmp
042DB5             0048*  
042DB5             0049*  ; bump x-coords the width of one tile and save it
042DB5 2A 85 2D 04 0050*      ld hl,(tiles_x_plot)
042DB9 01 10 00 00 0051*      ld bc,16
042DBD 09          0052*      add hl,bc
042DBE 22 85 2D 04 0053*      ld (tiles_x_plot),hl
042DC2             0054*  
042DC2             0055*  ; prepare to loop to next column
042DC2 E1          0056*      pop hl ; get back pointer to tile def
042DC3 23          0057*      inc hl ; bump it to the next column
042DC4 C1          0058*  	pop bc ; snag our loop counter
042DC5 10 D2       0059*      djnz @loop
042DC7             0060*  
042DC7             0061*  ; increment tiles plotting y-coordinate
042DC7             0062*  ; when it hits zero, we go to next row of tiles in the map
042DC7             0063*  ; (we use ix b/c we want to preserve hl for the next step)
042DC7 DD 21 88 2D 0064*  	ld ix,tiles_y_plot
       04          
042DCC DD 34 00    0065*  	inc (ix)
042DCF C0          0066*  	ret nz
042DD0             0067*  
042DD0             0068*  ; time to bump tiles_row_defs to next row
042DD0             0069*  ; (hl was already there at the end of the loop)
042DD0 22 7A 2D 04 0070*      ld (tiles_row_defs),hl
042DD4             0071*  
042DD4             0072*  ; reset coords to plot next row of tiles
042DD4 21 00 00 00 0073*      ld hl,0
042DD8 22 85 2D 04 0074*      ld (tiles_x_plot),hl
042DDC 21 F1 FF FF 0075*      ld hl,-15
042DE0 22 88 2D 04 0076*      ld (tiles_y_plot),hl
042DE4             0077*  
042DE4             0078*  ; decrement tiles row counter
042DE4 21 7D 2D 04 0079*      ld hl,tiles_row
042DE8 35          0080*      dec (hl)
042DE9 C0          0081*      ret nz
042DEA             0082*  
042DEA             0083*  ; queue up next level
042DEA 3A 7E 2D 04 0084*      ld a,(cur_level)
042DEE FE 01       0085*      cp num_levels-1
042DF0 20 02       0086*      jr nz,@inc_level
042DF2 3E FF       0087*      ld a,-1 ; will wrap around to zero when we fall through
042DF4             0088*  
042DF4             0089*  @inc_level:
042DF4 3C          0090*      inc a
042DF5 32 7E 2D 04 0091*      ld (cur_level),a
042DF9             0092*  
042DF9             0093*  ; increase the number of enemy sprites
042DF9 3A 40 2E 04 0094*      ld a,(max_enemy_sprites)
042DFD 3C          0095*      inc a
042DFE FE 01       0096*      cp table_max_records ; if we're at the global limit,skip ahead at max level
042E00 28 04       0097*      jr z,init_level
042E02 32 40 2E 04 0098*      ld (max_enemy_sprites),a ; otherwise save the updated number
042E06             0099*  ; fall through to init_level
042E06             0100*  
042E06             0101*  init_level:
042E06             0102*  ; look up address of level's tile defintion
042E06 21 7F 2D 04 0103*      ld hl,tiles_levels
042E0A 3A 7E 2D 04 0104*      ld a,(cur_level)
042E0E 11 00 00 00 0105*      ld de,0 ; just in case deu is non-zero
042E12 57          0106*      ld d,a
042E13 1E 03       0107*      ld e,3
042E15 ED 5C       0108*      mlt de
042E17 19          0109*      add hl,de
042E18 ED 37       0110*      ld ix,(hl)
042E1A DD 22 7A 2D 0111*      ld (tiles_row_defs),ix
       04          
042E1F             0112*  
042E1F             0113*  ; set tiles_row counter
042E1F DD 7E 00    0114*      ld a,(ix)
042E22 32 7D 2D 04 0115*      ld (tiles_row),a
042E26 DD 23       0116*      inc ix ; now ix points first element of first row tile def
042E28 DD 22 7A 2D 0117*      ld (tiles_row_defs),ix ; ... so we save it
       04          
042E2D C9          0118*      ret
042E2E             0119*  
042E2E             0120*  
042E2E             0121*  ; ###### TODO: NEW CODE TO IMPLEMENT ######
042E2E             0122*  ; dt_is_active:
042E2E             0123*  ; ; a lands here containing a tile index in the low nibble
042E2E             0124*  ; ; we test the values for the tiles which are active
042E2E             0125*  ;     cp #07
042E2E             0126*  ;     call z,ld_act_landing_pad
042E2E             0127*  ;     cp #08
042E2E             0128*  ;     call z,ld_act_laser_turret
042E2E             0129*  ;     ; fall through
042E2E             0130*  ;     ret
042E2E             0131*  
042E2E             0132*  ; ; some tiles become active sprites,so we load those here
042E2E             0133*  ; ; sprite_x/y have already been loaded
042E2E             0134*  ; ; sprite_dim_x/y are loaded by table_add_record
042E2E             0135*  ; ; we don't want sprite drawn to background like other tiles
042E2E             0136*  ; ; so this routine only adds them to the sprite table
042E2E             0137*  ; dt_ld_act:
042E2E             0138*  ;     ld a,#48 ; top of screen + 1/2 tile height
042E2E             0139*  ;     ld (sprite_y+1),a ; just the integer part
042E2E             0140*  ;     ld (sprite_base_bufferId),hl
042E2E             0141*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
042E2E             0142*  ;     call table_add_record
042E2E             0143*  ;     call sprite_variables_from_stack
042E2E             0144*  ;     ld a,#FF ; lets calling proc know we loaded an active tile
042E2E             0145*  ;     ret ; and back
042E2E             0146*  
042E2E             0147*  ; ld_act_landing_pad:
042E2E             0148*  ;     call sprite_variables_to_stack
042E2E             0149*  
042E2E             0150*  ;     ld hl,move_landing_pad
042E2E             0151*  ;     ld (sprite_move_program),hl
042E2E             0152*  
042E2E             0153*  ;     xor a
042E2E             0154*  ;     ld (sprite_animation),a ; animation 0
042E2E             0155*  
042E2E             0156*  ;     call rand_8     ; snag a random number
042E2E             0157*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
042E2E             0158*  ;     add a,64 ; range is now 64-127
042E2E             0159*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn an enemy
042E2E             0160*  
042E2E             0161*  ;     ld a,%10 ; collides with laser but not player
042E2E             0162*  ;     ld (iy+sprite_collisions),a
042E2E             0163*  
042E2E             0164*  ;     ld a,#05 ; BCD
042E2E             0165*  ;     ld (sprite_points),a
042E2E             0166*  ;     ld a,0 ; binary
042E2E             0167*  ;     ld (sprite_shield_damage),a
042E2E             0168*  
042E2E             0169*  ;     ld hl,landing_pad ; dt_ld_act loads this to sprite_base_bufferId
042E2E             0170*  ;     jr dt_ld_act
042E2E             0171*  
042E2E             0172*  ; ld_act_laser_turret:
042E2E             0173*  ;     call sprite_variables_to_stack
042E2E             0174*  
042E2E             0175*  ;     ld hl,move_laser_turret
042E2E             0176*  ;     ld (sprite_move_program),hl
042E2E             0177*  
042E2E             0178*  ;     xor a
042E2E             0179*  ;     ld (sprite_animation),a
042E2E             0180*  ;     ld (sprite_move_step),a
042E2E             0181*  
042E2E             0182*  ;     call rand_8     ; snag a random number
042E2E             0183*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
042E2E             0184*  ;     add a,64 ; range is now 64-127
042E2E             0185*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn a fireball
042E2E             0186*  
042E2E             0187*  ;     ld a,%10 ; collides with laser but not player
042E2E             0188*  ;     ld (iy+sprite_collisions),a
042E2E             0189*  
042E2E             0190*  ;     ld a,#10 ; BCD
042E2E             0191*  ;     ld (sprite_points),a
042E2E             0192*  ;     ld a,0 ; binary
042E2E             0193*  ;     ld (sprite_shield_damage),a
042E2E             0194*  
042E2E             0195*  ;     ld hl,laser_turret ; dt_ld_act loads this to sprite_base_bufferId
042E2E             0196*  ;     jp dt_ld_act
042E2E             0197*  
042E2E             0198*  
042E2E             0199*  ; moves active tile sprites down one pixel in sync with tiles movement
042E2E             0200*  ; deletes sprites from table when they wrap around to top of screen
042E2E             0201*  move_active_tiles:
042E2E             0202*  ; get current position
042E2E 3A 0F 00 00 0203*      ld a,(sprite_y+1) ; we only need the integer part
042E32 3C          0204*      inc a
042E33             0205*  ; are we at the bottom of the screen?
042E33 20 06       0206*      jr nz,move_active_tiles_draw_sprite ; nope
042E35             0207*  ; otherwise kill sprite
042E35 3E 80       0208*      ld a,%10000000 ; any bit set in high nibble means sprite will die
042E37 FD 77 08    0209*      ld (iy+sprite_collisions),a
042E3A C9          0210*      ret ; debug
042E3B             0211*  move_active_tiles_draw_sprite:
042E3B 32 0F 00 00 0212*      ld (sprite_y+1),a ; update tile y position integer part
042E3F             0213*      ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
042E3F             0214*      ; call vdu_bmp_draw ; convert to vdu_bmp_plot ; draw it
042E3F C9          0215*      ret ; and done
042E40             0064   	include "enemies.inc"
042E40 10          0001*  max_enemy_sprites: db 16
042E41             0002*  
042E41             0003*  ; sprite_type
042E41             0004*  enemy_dead: equ 0
042E41             0005*  enemy_small: equ 1
042E41             0006*  enemy_medium: equ 2
042E41             0007*  enemy_large: equ 3
042E41             0008*  landing_pad: equ 4
042E41             0009*  laser_turret: equ 5
042E41             0010*  fireballs: equ 6
042E41             0011*  explosion: equ 7
042E41             0012*  
042E41             0013*  
042E41             0014*  respawn_countdown:
042E41 2A 62 2E 04 0015*      ld hl,(respawn_timer)
042E45 2B          0016*      dec hl
042E46 22 62 2E 04 0017*      ld (respawn_timer),hl
042E4A             0018*  ; check hl for zero
042E4A 19          0019*      add hl,de
042E4B B7          0020*      or a
042E4C ED 52       0021*      sbc hl,de
042E4E C0          0022*      ret nz
042E4F 06 01       0023*      ld b,table_max_records
042E51             0024*  @respawn_loop:
042E51 C5          0025*      push bc
042E52 CD 53 2F 04 0026*      call enemy_init_from_landing_pad
042E56 C1          0027*      pop bc
042E57 10 F8       0028*      djnz @respawn_loop
042E59 21 3C 00 00 0029*      ld hl,1*60 ; 1 second
042E5D 22 62 2E 04 0030*      ld (respawn_timer),hl
042E61 C9          0031*      ret
042E62 3C 00 00    0032*  respawn_timer: dl 1*60
042E65             0033*  
042E65             0034*  move_enemies:
042E65             0035*  ; are there any active enemies or explosions?
042E65 21 00 00 00 0036*      ld hl,0
042E69 3A 0B 16 04 0037*      ld a,(table_active_sprites)
042E6D 6F          0038*      ld l,a
042E6E             0039*      ; call dumpRegistersHex
042E6E A7          0040*      and a ; will be zero if no alive enemies or explosions
042E6F             0041*      ; ret z ; so nothing to do but go back
042E6F             0042*      ; ld hl,(respawn_timer)
042E6F             0043*      ; call dumpRegistersHex
042E6F 20 05       0044*      jr nz,move_enemies_do
042E71 CD 41 2E 04 0045*      call respawn_countdown
042E75 C9          0046*      ret
042E76             0047*  move_enemies_do:
042E76             0048*  ; initialize pointers and loop counter
042E76 FD 21 E2 15 0049*      ld iy,table_base ; set iy to first record in table
       04          
042E7B 06 01       0050*      ld b,table_max_records ; loop counter
042E7D             0051*  move_enemies_loop:
042E7D FD 22 08 16 0052*      ld (table_pointer),iy ; update table pointer
       04          
042E82 C5          0053*      push bc ; backup loop counter
042E83             0054*  ; check sprite_type to see if sprite is active
042E83 FD 7E 01    0055*      ld a,(iy+sprite_type)
042E86 A7          0056*      and a ; if zero, sprite is dead
042E87 28 2E       0057*      jr z,move_enemies_next_record ; ... and we skip to next record
042E89             0058*  ; otherwise we prepare to move the sprite
042E89 FD 7E 00    0059*      ld a,(iy+sprite_id) ; get spriteId
042E8C CD 57 1F 04 0060*      call vdu_sprite_select ; select sprite
042E90 FD 27 05    0061*      ld hl,(iy+sprite_move_program) ; load the behavior subroutine address
042E93 E9          0062*      jp (hl)  ; ... and jump to it
042E94             0063*  ; we always jp back here from behavior subroutines
042E94             0064*  move_enemies_loop_return:
042E94 FD 2A 08 16 0065*      ld iy,(table_pointer) ; get back table pointer
       04          
042E99             0066*  ; now we check results of all the moves
042E99 FD 7E 08    0067*      ld a,(iy+sprite_collisions)
042E9C E6 F0       0068*      and %11110000 ; any bits set in high nibble means we died
042E9E FD 7E 00    0069*      ld a,(iy+sprite_id) ; get spriteId for the deactivate_sprite call if needed
042EA1 28 0A       0070*      jr z,move_enemies_draw_sprite ; if not dead,draw sprite
042EA3 CD 54 16 04 0071*      call table_deactivate_sprite ; otherwise we ded
042EA7 AF          0072*      xor a ; zero a so that we can ...
042EA8 FD 77 08    0073*      ld (iy+sprite_collisions),a ; ... clear collision flags
042EAB 18 0A       0074*      jr move_enemies_next_record ; and to the next record
042EAD             0075*  move_enemies_draw_sprite:
042EAD             0076*  ; if we got here sprite will have already been activated
042EAD             0077*  ; so all we need to do is set its coordinates and draw it
042EAD FD 07 0B    0078*      ld bc,(iy+sprite_x)
042EB0 FD 17 0E    0079*      ld de,(iy+sprite_y)
042EB3 CD 23 20 04 0080*      call vdu_sprite_move_abs168
042EB7             0081*  ; fall through to next record
042EB7             0082*  move_enemies_next_record:
042EB7 11 26 00 00 0083*      ld de,table_bytes_per_record
042EBB FD 19       0084*      add iy,de ; point to next record
042EBD AF          0085*      xor a ; clears carry flag
042EBE 32 0C 16 04 0086*      ld (sprite_screen_edge),a ; clear screen edge collision flag
042EC2 C1          0087*      pop bc ; get back our loop counter
042EC3 10 B8       0088*      djnz move_enemies_loop ; loop until we've checked all the records
042EC5 C9          0089*      ret ; and we're out
042EC6             0090*  
042EC6             0091*  en_nav_zigzag_start:
042EC6 FD 2A 08 16 0092*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
042ECB CD 74 21 04 0093*      call rand_8
042ECF E6 3F       0094*      and %00111111 ; limit it to 64
042ED1 CB DF       0095*      set 3,a ; make sure it's at least 8
042ED3 FD 77 22    0096*      ld (iy+sprite_move_timer),a ; store it
042ED6             0097*      ; fall through to en_nav_zigzag
042ED6             0098*  en_nav_zigzag:
042ED6 FD 7E 22    0099*      ld a,(iy+sprite_move_timer)
042ED9 3D          0100*      dec a
042EDA FD 77 22    0101*      ld (iy+sprite_move_timer),a
042EDD 20 1C       0102*      jr nz,en_nav_zigzag_no_switch
042EDF             0103*      ; otherwise flip direction and restart timer
042EDF FD 7E 23    0104*      ld a,(iy+sprite_move_step)
042EE2 EE 01       0105*      xor %1 ; flips bit one
042EE4 FD 77 23    0106*      ld (iy+sprite_move_step),a ; store it
042EE7 20 09       0107*      jr nz,en_nav_zigzag_right
042EE9             0108*  ;otherwise zag left
042EE9 21 00 A0 00 0109*      ld hl,0x00A000; southwest heading
042EED FD 2F 1A    0110*      ld (iy+sprite_heading),hl ; save sprite heading
042EF0 18 D4       0111*      jr en_nav_zigzag_start
042EF2             0112*  en_nav_zigzag_right:
042EF2 21 00 60 00 0113*      ld hl,0x006000; southeast heading
042EF6 FD 2F 1A    0114*      ld (iy+sprite_heading),hl ; save sprite heading
042EF9 18 CB       0115*      jr en_nav_zigzag_start
042EFB             0116*  en_nav_zigzag_no_switch:
042EFB             0117*      ; ld a,(sprite_orientation)
042EFB FD 27 1A    0118*      ld hl,(iy+sprite_heading)
042EFE 18 13       0119*      jr en_nav_computevelocities
042F00             0120*  
042F00             0121*  ; contains the logic for how to move the enemy
042F00             0122*  ; and then does the moving
042F00             0123*  ; inputs: a fully-populated active sprite table
042F00             0124*  ;         player position variables
042F00             0125*  ; destroys: everything except index registers
042F00             0126*  ; outputs: moving enemies
042F00             0127*  en_nav:
042F00             0128*  ; set velocity and orientation by player's relative location
042F00             0129*  ; move enemies y-axis
042F00             0130*  ; where is player relative to us?
042F00 CD D6 2F 04 0131*      call orientation_to_player
042F04             0132*  ;    h.l 16.8 fixed angle256 to player
042F04             0133*  ;    ub.c and ud.e as 16.8 signed fixed point numbers
042F04             0134*  ; is player above or below us?
042F04 ED 53 C8 19 0135*      ld (ude),de ; dy
       04          
042F09 3A CA 19 04 0136*      ld a,(ude+2) ; deu
042F0D 17          0137*      rla ; shift sign bit into carry
042F0E 30 C6       0138*      jr nc,en_nav_zigzag ; player is below,evade
042F10             0139*  ; player is even or above,so home in on current heading
042F10 FD 2F 1A    0140*      ld (iy+sprite_heading),hl ; save sprite heading
042F13             0141*  
042F13             0142*  ; we land here from zig-zag program so as not to
042F13             0143*  ; redundantly save orientation and heading
042F13             0144*  en_nav_computevelocities:
042F13             0145*  ; set x/y component velocities based on bearing to player
042F13 FD 2A 08 16 0146*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
042F18 E5          0147*      push hl ; we need it back to set rotation frame
042F19 FD 17 17    0148*      ld de,(iy+sprite_vel)
042F1C CD CD 21 04 0149*      call polar_to_cartesian
042F20 FD 0F 11    0150*      ld (iy+sprite_xvel),bc ; save x-velocity component
042F23 FD 1F 14    0151*      ld (iy+sprite_yvel),de ; save y-velocity component
042F26             0152*  ; change the animation frame to match heading
042F26             0153*  ; by dividng the heading by 8
042F26 E1          0154*      pop hl ; get back Heading
042F27 7C          0155*      ld a,h
042F28 CB 3F       0156*      srl a
042F2A CB 3F       0157*      srl a
042F2C CB 3F       0158*      srl a
042F2E CD BA 1F 04 0159*      call vdu_sprite_select_frame
042F32             0160*  ; update sprite position
042F32             0161*  move_enemy_sprite:
042F32 FD 27 0B    0162*      ld hl,(iy+sprite_x)
042F35 FD 17 11    0163*      ld de,(iy+sprite_xvel)
042F38 19          0164*      add hl,de
042F39 FD 2F 0B    0165*      ld (iy+sprite_x),hl
042F3C             0166*  
042F3C FD 27 0E    0167*      ld hl,(iy+sprite_y)
042F3F FD 17 14    0168*      ld de,(iy+sprite_yvel)
042F42 19          0169*      add hl,de
042F43 FD 2F 0E    0170*      ld (iy+sprite_y),hl
042F46 C9          0171*      ret
042F47             0172*  
042F47             0173*  ; ; TODO: IMPLEMENT THIS PROPERLY
042F47             0174*  ; move_enemy_sprite:
042F47             0175*  ; ; x-axis movement first
042F47             0176*  ;     ld hl,(iy+sprite_x)
042F47             0177*  ;     push hl ; save pre-move position
042F47             0178*  ;     pop bc ; to detect screen edge collision
042F47             0179*  ;     ld de,(iy+sprite_xvel)
042F47             0180*  ;     add hl,de ;compute new x position
042F47             0181*  ;     ld (iy+sprite_x),hl ; store it
042F47             0182*  ;     and a ; clear the carry flag
042F47             0183*  ;     sbc hl,bc ; test which direction was our movement
042F47             0184*  ;     jr z,@move_y ; zero flag means no horizontal movement
042F47             0185*  ;     jp p,@move_right ; sign positive means moved right
042F47             0186*  ; @move_left: ; otherwise we moved left
042F47             0187*  ;     jr c,@move_y ; move left,no wraparound |C1 N1 PV1 H1 Z0 S1|A=00 HL=FF00 BC=0100 DE=FF00
042F47             0188*  ;     ld hl,0x000000   ; move left,with wraparound |C0 N1 PV0 H0 Z0 S1|A=00 HL=FF00 BC=0000 DE=FF00
042F47             0189*  ;     ld (iy+sprite_x),hl ; set x position to left edge of screen
042F47             0190*  ;     ld a,#20 ; west
042F47             0191*  ;     ld (sprite_screen_edge),a ; set screen edge collision flag
042F47             0192*  ;     jr @move_y
042F47             0193*  ; @move_right:
042F47             0194*  ;     jr nc,@move_y ; move right,no wraparound |C0 N1 PV1 H0 Z0 S0|A=00 HL=0100 BC=FE00 DE=0100
042F47             0195*  ;     ; move right,with wraparound |C1 N1 PV0 H1 Z0 S0|A=00 HL=0100 BC=FF00 DE=0100
042F47             0196*  ;     ld l,0x00
042F47             0197*  ;     ld a,(iy+sprite_dim_x)
042F47             0198*  ;     ld h,a
042F47             0199*  ;     ld a,0x00
042F47             0200*  ;     sub h
042F47             0201*  ;     ld h,a
042F47             0202*  ;     ld (iy+sprite_x),hl ; set x position to right edge of screen
042F47             0203*  ;     ld a,0x02 ; east
042F47             0204*  ;     ld (sprite_screen_edge),a ; set screen edge collision flag
042F47             0205*  ; @move_y:
042F47             0206*  ;     ld hl,(iy+sprite_y)
042F47             0207*  ;     ld b,h ; save pre-move position
042F47             0208*  ;     ld c,l ; to detect screen edge collision
042F47             0209*  ;     ld de,(iy+sprite_yvel)
042F47             0210*  ;     add hl,de ;compute new y position
042F47             0211*  ;     ld (iy+sprite_y),hl ; store it
042F47             0212*  ;     and a ; clear the carry flag
042F47             0213*  ;     sbc hl,bc ; test which direction was our movement
042F47             0214*  ;     jr z,@move_ret ; zero flag means no vertical movement
042F47             0215*  ;     jp p,@move_dn ; sign positive means moved down
042F47             0216*  ; @move_up:
042F47             0217*  ;     add hl,bc ; get back new y position
042F47             0218*  ;     ld de,0x5000 ; top edge of visible screen
042F47             0219*  ;     and a ; clear the carry flag
042F47             0220*  ;     sbc hl,de
042F47             0221*  ;     jr nc,@move_ret ; move up,no wraparound |C0 N1 PV0 H0 Z1 S0|A=00 HL=0000 BC=5100 DE=5000
042F47             0222*  ;     ; move up,with wraparound |C1 N1 PV1 H0 Z0 S1|A=00 HL=FF00 BC=5000 DE=5000
042F47             0223*  ;     ld (iy+sprite_y),de ; set y position flush with top of screen
042F47             0224*  ;     ld a,(sprite_screen_edge) ; load any vertical edge collision
042F47             0225*  ;     or 0x80 ; north
042F47             0226*  ;     ld (sprite_screen_edge),a ; set screen edge collision flag
042F47             0227*  ;     jr @move_ret
042F47             0228*  ; @move_dn:
042F47             0229*  ;     jr nc,@move_ret ; move down,no wraparound |C0 N1 PV0 H0 Z0 S0|A=00 HL=0100 BC=5100 DE=0100
042F47             0230*  ;     ; move down,with wraparound |C1 N1 PV0 H1 Z0 S0|A=00 HL=0100 BC=FF00 DE=0100
042F47             0231*  ;     ld l,0x00
042F47             0232*  ;     ld a,(iy+sprite_dim_y)
042F47             0233*  ;     ld h,a
042F47             0234*  ;     ld a,0x00
042F47             0235*  ;     sub h
042F47             0236*  ;     ld h,a
042F47             0237*  ;     ld (iy+sprite_y),hl ; set y position flush with bottom of screen
042F47             0238*  ;     ld a,(sprite_screen_edge) ; load any vertical edge collision
042F47             0239*  ;     or 0x08 ; south
042F47             0240*  ;     ld (sprite_screen_edge),a ; set screen edge collision flag
042F47             0241*  ; @move_ret:
042F47             0242*  ;     ret
042F47             0243*  
042F47             0244*  ; ; ######### SPRITE BEHAVIOR ROUTINES #########
042F47             0245*  ; ; each sprite in the table must have one of these defined
042F47             0246*  ; ; but they need not be unique to a particular sprite
042F47             0247*  ; ; these are jumped to from move_enemies_do_program,but could come from other places
042F47             0248*  ; ; and have the option but not obligation to go back to move_enemies_loop_return
042F47             0249*  ; ; but they can call anything they want between those two endpoints
042F47             0250*  ; move_programs: ; bookmark in case we want to know the first address of the first subroutine
042F47             0251*  
042F47             0252*  ; move_nop: ; does nothing but burn a few cycles changing the PC
042F47             0253*  ;     jp move_enemies_loop_return
042F47             0254*  
042F47             0255*  ; move_explosion:
042F47             0256*  ;     call animate_explosion
042F47             0257*  ;     jp move_enemies_loop_return
042F47             0258*  
042F47             0259*  move_enemy_small:
042F47 CD 00 2F 04 0260*      call en_nav
042F4B CD 72 30 04 0261*      call check_collisions
042F4F C3 94 2E 04 0262*      jp move_enemies_loop_return
042F53             0263*  
042F53             0264*  ; move_enemy_medium:
042F53             0265*  ;     call en_nav
042F53             0266*  ;     call check_collisions
042F53             0267*  ;     jp move_enemies_loop_return
042F53             0268*  
042F53             0269*  ; move_enemy_large:
042F53             0270*  ;     call en_nav
042F53             0271*  ;     call check_collisions
042F53             0272*  ;     jp move_enemies_loop_return
042F53             0273*  
042F53             0274*  ; move_landing_pad:
042F53             0275*  ;     call move_active_tiles
042F53             0276*  ;     call check_collisions
042F53             0277*  ; ; is it time to launch an enemy?
042F53             0278*  ;     ld hl,sprite_move_timer
042F53             0279*  ;     dec (hl)
042F53             0280*  ;     jp nz,move_enemies_loop_return
042F53             0281*  ;     call enemy_init_from_landing_pad
042F53             0282*  ;     ; reset move timer so can spawn again if player doesn't take us out
042F53             0283*  ;     call rand_8     ; snag a random number
042F53             0284*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
042F53             0285*  ;     add a,64 ; range is now 64-127
042F53             0286*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn an enemy
042F53             0287*  ;     jp move_enemies_loop_return
042F53             0288*  
042F53             0289*  enemy_init_from_landing_pad:
042F53             0290*  ; get next available spriteId
042F53 CD 2F 16 04 0291*      call table_get_next_id
042F57 D0          0292*      ret nc ; no carry means no free sprite slots, so we go home
042F58             0293*  ; ix comes back with the pointer to the new sprite variables
042F58 DD E5       0294*      push ix ; de picks it up when we're ready for the copy to the table
042F5A             0295*  ; a comes back with the spriteId of the new sprite
042F5A 32 B0 2F 04 0296*      ld (@id),a
042F5E             0297*  ; initialize the new sprite
042F5E CD 57 1F 04 0298*      call vdu_sprite_select
042F62 CD 6A 1F 04 0299*      call vdu_sprite_clear_frames
042F66 21 14 01 00 0300*      ld hl,BUF_SEEKER_000
042F6A 06 20       0301*      ld b,32
042F6C             0302*  @load_frames:
042F6C C5          0303*      push bc
042F6D E5          0304*      push hl
042F6E CD A4 20 04 0305*      call vdu_sprite_add_buff
042F72 E1          0306*      pop hl
042F73 23          0307*      inc hl
042F74 C1          0308*      pop bc
042F75 10 F5       0309*      djnz @load_frames
042F77             0310*  ; copy coordinates of active sprite to new sprite
042F77 FD 2A 08 16 0311*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
042F7C             0312*      ; ld hl,(iy+sprite_x)
042F7C             0313*  	; ld hl,0x008000 ; debug
042F7C             0314*  
042F7C CD 74 21 04 0315*      call rand_8
042F80 21 00 00 00 0316*      ld hl,0
042F84 67          0317*      ld h,a
042F85             0318*  
042F85 22 BB 2F 04 0319*      ld (@x),hl
042F89             0320*      ; ld hl,(iy+sprite_y)
042F89             0321*      ; ld hl,0x002000 ; debug
042F89             0322*  
042F89 CD 74 21 04 0323*      call rand_8
042F8D 21 00 00 00 0324*      ld hl,0
042F91 67          0325*      ld h,a
042F92             0326*  
042F92 22 BE 2F 04 0327*      ld (@y),hl
042F96 CD 74 21 04 0328*      call rand_8
042F9A E6 01       0329*      and %00000001 ; 50/50 chance of moving left or right on spanw
042F9C 32 D3 2F 04 0330*      ld (@move_step),a
042FA0             0331*  ; now copy to the table
042FA0 21 B0 2F 04 0332*      ld hl,@id ; address to copy from
042FA4 D1          0333*      pop de ; address to copy to (was ix)
042FA5 01 26 00 00 0334*      ld bc,table_bytes_per_record ; number of bytes to copy
042FA9 ED B0       0335*      ldir ; copy the records from local scratch to sprite table
042FAB             0336*  ; finally, make the new sprite visible
042FAB CD CD 1F 04 0337*      call vdu_sprite_show
042FAF C9          0338*      ret
042FB0 00          0339*  @id:               db     0x00 ; 1 bytes unique spriteId, zero-based
042FB1 01          0340*  @type:             db enemy_small ; 1 bytes type of sprite as defined in enemies.inc
042FB2 14 01 00    0341*  @base_bufferId:    dl BUF_SEEKER_000 ; 3 bytes bitmap bufferId
042FB5 47 2F 04    0342*  @move_program:     dl move_enemy_small ; 3 bytes address of sprite's behavior subroutine
042FB8 03          0343*  @collisions:       db %00000011 ; 3 bytes collides with enemy and laser
042FB9 10          0344*  @dim_x:            db     0x10 ; 1 bytes sprite width in pixels
042FBA 10          0345*  @dim_y:            db     0x10 ; 1 bytes sprite height in pixels
042FBB 00 00 00    0346*  @x:                dl 0x000000 ; 1 bytes 16.8 fractional x position in pixels
042FBE 00 00 00    0347*  @y:                dl 0x000000 ; 3 bytes 16.8 fractional y position in pixels
042FC1 00 00 00    0348*  @xvel:             dl 0x000000 ; 3 bytes x-component velocity, 16.8 fixed, pixels
042FC4 00 00 00    0349*  @yvel:             dl 0x000000 ; 3 bytes y-component velocity, 16.8 fixed, pixels
042FC7 80 02 00    0350*  @vel:              dl speed_seeker ; 3 bytes velocity, 16.8 fixed, pixels
042FCA 00 80 00    0351*  @heading:          dl 0x008000 ; 3 bytes sprite movement direction deg256 16.8 fixed
042FCD 00 80 00    0352*  @orientation:      dl 0x008000 ; 3 bytes orientation bits
042FD0 00          0353*  @animation:        db     0x00 ; 1 bytes current animation index, zero-based
042FD1 00          0354*  @animation_timer:  db     0x00 ; 1 bytes when hits zero, draw next animation
042FD2 01          0355*  @move_timer:       db     0x01 ; 1 bytes when zero, go to next move program, or step
042FD3 00          0356*  @move_step:        db     0x00 ; 1 bytes stage in a move program sequence, varies
042FD4 20          0357*  @points:           db     0x20 ; 1 bytes points awarded for killing this sprite type, BCD
042FD5 02          0358*  @shield_damage:    db     0x02 ; 1 bytes shield points deducted for collision, binary
042FD6             0359*  
042FD6             0360*  ; move_laser_turret:
042FD6             0361*  ; ; compute orientation to player
042FD6             0362*  ;     call orientation_to_player
042FD6             0363*  ; ; h.l 8.8 fixed angle256 to player
042FD6             0364*  ; ; bc and de as signed 16-bit integers
042FD6             0365*  ; ; representing delta-x/y *to* target respectively
042FD6             0366*  ;     ld (Bearing_t),hl
042FD6             0367*  ;     ld hl,0x0400
042FD6             0368*  ;     ld (Vp),hl
042FD6             0369*  ;     call targeting_computer
042FD6             0370*  ;     ld (sprite_heading),hl ; store bearing to player
042FD6             0371*  ; ; is it time to launch a fireball?
042FD6             0372*  ;     ld hl,sprite_move_timer
042FD6             0373*  ;     dec (hl)
042FD6             0374*  ;     jp nz,move_laser_turret_boilerplate
042FD6             0375*  ;     call fireballs_init
042FD6             0376*  ;     ; reset move timer so can fire again if player doesn't take us out
042FD6             0377*  ;     call rand_8     ; snag a random number
042FD6             0378*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
042FD6             0379*  ;     add a,64 ; range is now 64-127
042FD6             0380*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn a fireball
042FD6             0381*  ; move_laser_turret_boilerplate:
042FD6             0382*  ;     call move_active_tiles
042FD6             0383*  ;     call check_collisions
042FD6             0384*  ;     jp move_enemies_loop_return
042FD6             0385*  
042FD6             0386*  ; fireballs_init:
042FD6             0387*  ;     call sprite_variables_to_stack
042FD6             0388*  
042FD6             0389*  ;     ld hl,fireballs
042FD6             0390*  ;     ld (sprite_base_bufferId),hl
042FD6             0391*  
042FD6             0392*  ;     ld hl,move_fireballs
042FD6             0393*  ;     ld (sprite_move_program),hl
042FD6             0394*  
042FD6             0395*  ;     ld a,%11 ; collides with laser and player
042FD6             0396*  ;     ; ld a,%10 ; collides with laser DEBUG
042FD6             0397*  ;     ld (iy+sprite_collisions),a
042FD6             0398*  
042FD6             0399*  ;     ld hl,(Vp)
042FD6             0400*  ;     ld (sprite_vel),hl
042FD6             0401*  ;     ld hl,(Vp_x)
042FD6             0402*  ;     ld (sprite_xvel),hl
042FD6             0403*  ;     ld hl,(Vp_y)
042FD6             0404*  ;     inc h ; account for ground movement
042FD6             0405*  ;     ld (sprite_yvel),hl
042FD6             0406*  
042FD6             0407*  ;     xor a ; zero a
042FD6             0408*  ;     ld (sprite_animation),a
042FD6             0409*  ;     ld (sprite_move_step),a
042FD6             0410*  ;     ld (sprite_move_timer),a
042FD6             0411*  
042FD6             0412*  ;     ld a,6 ; 1/10th of a second timer
042FD6             0413*  ;     ld (sprite_animation_timer),a
042FD6             0414*  
042FD6             0415*  ;     ld a,0x00 ; BCD
042FD6             0416*  ;     ld (sprite_points),a
042FD6             0417*  ;     ld a,1 ; binary
042FD6             0418*  ;     ld (sprite_shield_damage),a
042FD6             0419*  
042FD6             0420*  ;     call table_add_record ; plops that on the sprite stack for later
042FD6             0421*  ;     call sprite_variables_from_stack ; come back to where we started
042FD6             0422*  ;     ret
042FD6             0423*  
042FD6             0424*  ; move_fireballs:
042FD6             0425*  ;     call move_enemy_sprite ; move sprite
042FD6             0426*  ;     ld a,(sprite_screen_edge) ; check for collision with screen edge
042FD6             0427*  ;     and a ; if zero we're still within screen bounds
042FD6             0428*  ;     jr z,move_fireballs_alive
042FD6             0429*  ; ; otherwise kill sprite
042FD6             0430*  ;     ld a,%10000000 ; any bit set in high nibble means sprite will die
042FD6             0431*  ;     ld (iy+sprite_collisions),a
042FD6             0432*  ;     jp move_enemies_loop_return
042FD6             0433*  ; move_fireballs_alive:
042FD6             0434*  ;     ld a,(sprite_animation_timer)
042FD6             0435*  ;     dec a
042FD6             0436*  ;     ld (sprite_animation_timer),a
042FD6             0437*  ;     jr nz,move_fireballs_draw
042FD6             0438*  ;     ld a,(sprite_animation)
042FD6             0439*  ;     xor %1
042FD6             0440*  ;     ld (sprite_animation),a
042FD6             0441*  ;     ld a,6 ; 1/10th of a second timer
042FD6             0442*  ;     ld (sprite_animation_timer),a
042FD6             0443*  ;     ; fall through
042FD6             0444*  
042FD6             0445*  ; move_fireballs_draw:
042FD6             0446*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
042FD6             0447*  ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
042FD6             0448*  ;     call check_collisions
042FD6             0449*  ;     jp move_enemies_loop_return
042FD6             0450*  
042FD6             0451*  ; compute orientation to player
042FD6             0452*  ; based on relative positions
042FD6             0453*  ; returns: h.l 16.8 fixed angle256 to player
042FD6             0454*  ;    ub.c and ud.e as 16.8 signed fixed point numbers
042FD6             0455*  ;    representing delta-x/y *to* target respectively
042FD6             0456*  orientation_to_player:
042FD6 FD 2A 08 16 0457*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
042FDB FD E5       0458*      push iy ; so we can send it back intact
042FDD FD 07 0B    0459*      ld bc,(iy+sprite_x)
042FE0 FD 17 0E    0460*      ld de,(iy+sprite_y)
042FE3 DD 2A 89 2C 0461*      ld ix,(player_x)
       04          
042FE8 FD 2A 8C 2C 0462*      ld iy,(player_y)
       04          
042FED CD 06 22 04 0463*      call dxy168
042FF1 CD 6D 22 04 0464*      call atan2_168game
042FF5 ED 4B 61 22 0465*      ld bc,(dx168)
       04          
042FFA ED 5B 67 22 0466*      ld de,(dy168)
       04          
042FFF FD E1       0467*      pop iy ; restore table pointer
043001 C9          0468*      ret
043002             0469*  
043002             0470*  
043002             0471*  ; targeting_computer scratch variables
043002 00 00       0472*  Bearing_t: dw #0000 ; 8.8 fixed
043004 00 00       0473*  Heading_t: dw #0000 ; 8.8 fixed
043006 00 00       0474*  Vp: dw #0000 ; 8.8 fixed
043008 00 00       0475*  Vp_x: dw #0000 ; 8.8 fixed
04300A 00 00       0476*  Vp_y: dw #0000 ; 8.8 fixed
04300C 00 00       0477*  Vt: dw #0000 ; 8.8 fixed
04300E 00 00       0478*  Vt_x: dw #0000 ; 8.8 fixed
043010 00 00       0479*  Vt_y: dw #0000 ; 8.8 fixed
043012             0480*  
043012             0481*  
043012             0482*  ; ; Inputs:   see scratch variables
043012             0483*  ; ; Note:     a call to orientation_to_player provides these inputs
043012             0484*  ; ; Outputs:  h.l is the 16.8 fixed firing angle256
043012             0485*  ; ;           b.c and d.e are the 16.8 fixed x,y component projectile velocities
043012             0486*  ; ; https://old.robowiki.net/cgi-bin/robowiki?LinearTargeting
043012             0487*  ; targeting_computer:
043012             0488*  ; ; compute target velocity from x,y component velocities
043012             0489*  ;     ld bc,(player_xvel)
043012             0490*  ;     ld de,(player_yvel)
043012             0491*  ;     dec d ; account for vertical ground movement: b.c=player_xvel,d.e=player_yvel-1
043012             0492*  
043012             0493*  ;     call cartesian_to_polar ; b.c=Heading_t, d.e=Vt
043012             0494*  ;     ld (Heading_t),bc
043012             0495*  ;     ld (Vt),de
043012             0496*  
043012             0497*  ; ; compute Heading_t-Bearing_t
043012             0498*  ;     ld h,b
043012             0499*  ;     ld l,c
043012             0500*  ;     ld bc,(Bearing_t)
043012             0501*  ;     and a ; clear carry
043012             0502*  ;     sbc hl,bc ; h.l=Heading_t-Bearing_t
043012             0503*  
043012             0504*  ; ; compute sin(Heading_t-Bearing_t)
043012             0505*  ;     ld b,h
043012             0506*  ;     ld c,l
043012             0507*  ;     call sin_bc ; h.l=sin(Heading_t-Bearing_t)
043012             0508*  
043012             0509*  ; ; compute (Vt*sin(Heading_t-Bearing_t))
043012             0510*  ;     ex de,hl
043012             0511*  ;     ld bc,(Vt)
043012             0512*  ;     call BC_Mul_DE_88 ; h.l=(Vt*sin(Heading_t-Bearing_t))
043012             0513*  
043012             0514*  ; ; compute (Vt * sin(Heading_t-Bearing_t)) / Vp
043012             0515*  ;     ld b,h
043012             0516*  ;     ld c,l
043012             0517*  ;     ld de,(Vp)
043012             0518*  ;     call div_88 ; h.l=(Vt*sin(Heading_t-Bearing_t)) / Vp
043012             0519*  ; ; answer is in radians, convert to degrees256
043012             0520*  ;     ex de,hl
043012             0521*  ;     ld bc,#28BE ; 40.74=57.29578*256/360
043012             0522*  ;     call BC_Mul_DE_88
043012             0523*  
043012             0524*  ; ; add lead angle to target bearing
043012             0525*  ;     ld de,(Bearing_t)
043012             0526*  ;     add hl,de ; h.l=lead angle+target bearing
043012             0527*  ;     push hl
043012             0528*  
043012             0529*  ; ; compute component projectile velocities
043012             0530*  ;     ld b,h
043012             0531*  ;     ld c,l
043012             0532*  ;     ld de,(Vp)
043012             0533*  ;     call polar_to_cartesian ; b.c=Vp_x, d.e=Vp_y
043012             0534*  
043012             0535*  ;     ld (Vp_x),bc
043012             0536*  ;     ld (Vp_y),de
043012             0537*  ;     pop hl ; h.l=lead angle+target bearing
043012             0538*  ;     ret
043012             0539*  
043012             0540*  ; this routine vanquishes the enemy sprite
043012             0541*  ; and replaces it with an animated explosion
043012             0542*  ; we jump here instead of call because
043012             0543*  ; we want to return to differing locations in the loop
043012             0544*  ; depending on whether we're still sploding
043012             0545*  ; destroys: everything except index registers
043012             0546*  ; returns: an incandescent ball of debris and gas
043012             0547*  kill_nurple:
043012             0548*  ; ; tally up points
043012             0549*  ;     ld bc,0
043012             0550*  ;     ld a,(sprite_points)
043012             0551*  ;     ld e,a
043012             0552*  ;     ld d,0
043012             0553*  ;     ld hl,add_bcd_arg2
043012             0554*  ;     call set_bcd
043012             0555*  ;     ld hl,player_score
043012             0556*  ;     ld de,add_bcd_arg2
043012             0557*  ;     ld a,3 ; number of bytes to add
043012             0558*  ;     call add_bcd
043012             0559*  ; ; initialize explosion
043012             0560*  ; init_explosion:
043012             0561*  ;     ld hl,explosion
043012             0562*  ;     ld (sprite_base_bufferId),hl
043012             0563*  ;     ld hl,move_explosion
043012             0564*  ;     ld (sprite_move_program),hl
043012             0565*  ;     ld a,%00000000 ; collides with nothing
043012             0566*  ;     ld (iy+sprite_collisions),a
043012             0567*  ;     ld hl,0 ; north
043012             0568*  ;     ld (sprite_heading),hl
043012             0569*  ;     ld a,0x04 ; will decrement to 03
043012             0570*  ;     ld (sprite_animation),a
043012             0571*  ;     ld a,0x07 ; 7/60th of a second timer
043012             0572*  ;     ld (sprite_animation_timer),a
043012             0573*  ;     xor a
043012             0574*  ;     ld (sprite_move_timer),a
043012             0575*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
043012             0576*  ; ; fall through to next_explosion
043012             0577*  ; next_explosion:
043012             0578*  ;     ld a,(sprite_animation)
043012             0579*  ;     dec a ; if rolled negative from zero,we're done sploding
043012             0580*  ;     jp m,done_explosion
043012             0581*  ;     ld (sprite_animation),a
043012             0582*  ;     ld a,0x7 ; 7/60th of a second timer
043012             0583*  ;     ld (sprite_animation_timer),a
043012             0584*  ; ; fall through to animate_explosion
043012             0585*  ; animate_explosion:
043012             0586*  ;     ld hl,sprite_y+1
043012             0587*  ;     inc (hl) ; move explosion down 1 pixel
043012             0588*  ;     jr z, done_explosion ; if wraparound to top of screen, kill explosion
043012             0589*  ;     ld hl,sprite_animation_timer
043012             0590*  ;     dec (hl) ; if timer is zero,we do next animation
043012             0591*  ;     jr z,next_explosion
043012             0592*  ;     ;otherwise we fall through to draw the current one
043012             0593*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
043012             0594*  ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
043012             0595*  ;     ret ; now we go back to caller
043012             0596*  ; done_explosion:
043012 3E 80       0597*      ld a,%10000000 ; high bit set is non-specific kill-me flag
043014 FD 2A 08 16 0598*      ld iy,(table_pointer); TODO: see if we can get IY to land here with the proper value
       04          
043019 FD 77 08    0599*      ld (iy+sprite_collisions),a
04301C C9          0600*      ret ; now we go back to caller
04301D             0601*  
04301D             0602*  ; game_over:
04301D             0603*  ;     jp new_game
04301D             0604*  
04301D             0605*  ; it's presumed we've already checked that laser is alive
04301D             0606*  collision_enemy_with_laser:
04301D DD 2A AA 30 0607*      ld ix,(laser_x)
       04          
043022 FD 2A AD 30 0608*      ld iy,(laser_y)
       04          
043027 3A A8 30 04 0609*      ld a,(laser_dim_x)
04302B CB 2F       0610*      sra a ; divide by 2
04302D F5          0611*      push af ; we need this later
04302E             0612*      ; ld de,0
04302E             0613*      ; ld d,a
04302E             0614*      ; add ix,de
04302E             0615*      ; add iy,de
04302E 18 11       0616*      jr collision_enemy
043030             0617*  
043030             0618*  ; it's presumed we've already checked that player is alive
043030             0619*  collision_enemy_with_player:
043030 DD 2A 89 2C 0620*      ld ix,(player_x)
       04          
043035 FD 2A 8C 2C 0621*      ld iy,(player_y)
       04          
04303A 3A 87 2C 04 0622*      ld a,(player_dim_x)
04303E             0623*  
04303E             0624*      ; call dumpRegistersHex
04303E             0625*  
04303E CB 2F       0626*      sra a ; divide by 2
043040 F5          0627*      push af ; we need this later
043041             0628*      ; ld de,0
043041             0629*      ; ld d,a
043041             0630*      ; add ix,de
043041             0631*      ; add iy,de
043041             0632*      ; fall through to collision_enemy
043041             0633*  
043041             0634*  ; compute the distance between the two sprites' centers
043041             0635*  ; inputs: bc and de as y0,x0 and y1,x1 respectively
043041             0636*  collision_enemy:
043041             0637*  ; back up iy because we need it as the sprite table pointer
043041 FD E5       0638*      push iy
043043 FD 2A 08 16 0639*      ld iy,(table_pointer)
       04          
043048 FD 27 0B    0640*      ld hl,(iy+sprite_x)
04304B FD 7E 09    0641*      ld a,(iy+sprite_dim_x)
04304E CB 2F       0642*      sra a
043050 F5          0643*      push af ; we need this later
043051             0644*      ; ld de,0
043051             0645*      ; ld d,a
043051             0646*      ; add hl,de
043051 E5          0647*      push hl
043052 C1          0648*      pop bc ; bc = x0
043053 FD 27 0E    0649*      ld hl,(iy+sprite_y)
043056 FD 7E 0A    0650*      ld a,(iy+sprite_dim_y)
043059             0651*      ; sra a
043059             0652*      ; ld de,0
043059             0653*      ; ld d,a
043059             0654*      ; add hl,de
043059 EB          0655*      ex de,hl ; de = y0
04305A F1          0656*      pop af ; TODO: srsly, this is the best way to do this?
04305B FD E1       0657*      pop iy
04305D F5          0658*      push af
04305E             0659*  
04305E             0660*      ; call dumpRegistersHex
04305E             0661*  
04305E CD 21 22 04 0662*      call distance168
043062             0663*      ; CALL dumpRegistersHex
043062             0664*  ; ; subtract sum of radii from distance between centers
043062             0665*  ;     ld de,0
043062             0666*  ;     pop af ; radius of enemy sprite
043062             0667*  ;     ld e,a
043062             0668*  ;     pop af ; radius of player or laser sprite
043062             0669*  ;     add a,e
043062             0670*  ;     ld e,a
043062             0671*  ;     and a ; clear carry
043062             0672*  ;     sbc hl,de
043062             0673*  ;     jr c,collision_enemy_is
043062             0674*  ;     xor a
043062             0675*  ;     ret
043062             0676*  ; temp fix TODO: remove this
043062 F1          0677*      pop af
043063 F1          0678*      pop af
043064 11 00 10 00 0679*      ld de,16*256
043068 A7          0680*      and a
043069 ED 52       0681*      sbc hl,de
04306B 38 02       0682*      jr c,collision_enemy_is
04306D AF          0683*      xor a
04306E             0684*      ; call dumpRegistersHex
04306E C9          0685*      ret
04306F             0686*  collision_enemy_is:
04306F AF          0687*      xor a
043070 3C          0688*      inc a
043071             0689*      ; call dumpRegistersHex
043071 C9          0690*      ret
043072             0691*  
043072             0692*  ; ; looks up what enemy sprite collides with
043072             0693*  ; ; detects collisions
043072             0694*  ; ; and sets things to sploding accordingly
043072             0695*  ; check_collisions:
043072             0696*  ;     ld a,(iy+sprite_collisions) ; snag what we collide with
043072             0697*  ;     and a ; if this is zero,
043072             0698*  ;     ret z ; there's nothing to do
043072             0699*  ;     and %01 ; do we collide with player?
043072             0700*  ;     jr z,move_enemies_laser ; if not,check laser collision
043072             0701*  ;     call collision_enemy_with_player ; otherwise see if we hit player
043072             0702*  ;     and a ; was there a collision?
043072             0703*  ;     jr z,move_enemies_laser ; if not,see if laser smacked us
043072             0704*  ; ; yes collision with player
043072             0705*  ;     ; deduct shield damage
043072             0706*  ;     ld hl,sprite_shield_damage
043072             0707*  ;     ld a,(player_shields)
043072             0708*  ;     sub (hl)
043072             0709*  ;     ld (player_shields),a
043072             0710*  ; ; if shields >= 0,player survives
043072             0711*  ;     jp p,check_collisions_kill_nurple
043072             0712*  ; ; otherwise update player status so it will die
043072             0713*  ;     ld a,(player_collisions)
043072             0714*  ;     or %10 ; sets bit 1,meaning player just died
043072             0715*  ;     ld (player_collisions),a
043072             0716*  ;     ; fall through
043072             0717*  ; check_collisions_kill_nurple:
043072             0718*  ; ; kill enemy and replace with explosion
043072             0719*  ;     call kill_nurple
043072             0720*  ;     ret ; and out
043072             0721*  
043072             0722*  check_collisions:
043072 CD 30 30 04 0723*      call collision_enemy_with_player ; did we hit the player?
043076 A7          0724*      and a ; was there a collision?
043077 C8          0725*      ret z ; if not,we're done
043078 CD 12 30 04 0726*      call kill_nurple ; otherwise kill enemy
04307C C9          0727*      ret
04307D             0728*  
04307D             0729*  ; did we hit the laser?
04307D             0730*  move_enemies_laser:
04307D FD 7E 08    0731*      ld a,(iy+sprite_collisions) ; snag what we collide with again
043080 E6 02       0732*      and %10 ; do we even collide with laser?
043082 C8          0733*      ret z ; if not,we're out
043083 3A A7 30 04 0734*      ld a,(laser_collisions) ; is laser alive?
043087 E6 01       0735*      and %1 ; if bit 0 is not set laser is dead
043089 C8          0736*      ret z ; so we're out
04308A CD 1D 30 04 0737*      call collision_enemy_with_laser ; otherwise check for collision
04308E A7          0738*      and a ; was there a collision?
04308F C8          0739*      ret z ; if not,we're done
043090             0740*  ; otherwise we mark laser for termination and kill enemy
043090             0741*  ; update laser status so it will die
043090 3A A7 30 04 0742*      ld a,(laser_collisions)
043094 F6 02       0743*      or %10 ; bit 1 set means laser just died
043096 32 A7 30 04 0744*      ld (laser_collisions),a
04309A CD 12 30 04 0745*      call kill_nurple ; yes there was a collision,so kill enemy
04309E C9          0746*      ret ; we're outta' here
04309F             0065   	include "laser.inc"
04309F             0001*  ; ##### LASER SPRITE PARAMETERS #####
04309F             0002*  ; uses the same offsets from its table base as the main sprite table:
04309F             0003*  laser_start_variables: ; label marking beginning of table
04309F 02          0004*  laser_id:               db table_max_records+1
0430A0 00          0005*  laser_type:             db     0x00 ; 1 bytes currently not used
0430A1 11 01 00    0006*  laser_base_bufferId:    dl BUF_LASER_A ; 3 bytes bitmap bufferId
0430A4 00 00 00    0007*  laser_move_program:     dl 0x000000 ; 3 bytes not currently used
0430A7 00          0008*  laser_collisions:       db     0x00 ; 1 bytes bit 0 set=alive, otherwise dead, bit 1 set=just died
0430A8 00          0009*  laser_dim_x:            db     0x00 ; 1 bytes sprite width in pixels
0430A9 00          0010*  laser_dim_y:            db     0x00 ; 1 bytes sprite height in pixels
0430AA 00 00 00    0011*  laser_x:                dl 0x000000 ; 3 bytes 16.8 fractional x position in pixels
0430AD 00 00 00    0012*  laser_y:                dl 0x000000 ; 3 bytes 16.8 fractional y position in pixels
0430B0 00 00 00    0013*  laser_xvel:             dl 0x000000 ; 3 bytes x-component velocity, 16.8 fixed, pixels
0430B3 00 F8 FF    0014*  laser_yvel:             dl 0xFFF800 ; 3 bytes y-component velocity, 16.8 fixed, pixels
0430B6 00 00 00    0015*  laser_vel:              dl 0x000000 ; 3 bytes not currently used
0430B9 00 00 00    0016*  laser_heading:          dl 0x000000 ; 3 bytes sprite movement direction deg256 16.8 fixed
0430BC 00 00 00    0017*  laser_orientation:      dl 0x000000 ; 3 bytes not currently used
0430BF 00          0018*  laser_animation:        db     0x00 ; 1 bytes current sprite animation frame
0430C0 00          0019*  laser_animation_timer:  db     0x00 ; 1 bytes decremented every frame, when zero, advance animation
0430C1 00          0020*  laser_move_timer:       db     0x00 ; 1 bytes not currently used
0430C2 00          0021*  laser_move_step:        db     0x00 ; 1 bytes not currently used
0430C3 00          0022*  laser_points:           db     0x00 ; 1 bytes not currently used
0430C4 00          0023*  laser_shield_damage:    db     0x00 ; 1 bytes not currently used
0430C5             0024*  laser_end_variables: ; for when we want to traverse this table in reverse
0430C5             0025*  
0430C5             0026*  ; laser_control:
0430C5             0027*  ; ; is laser already active?
0430C5             0028*  ;     ld a,(laser_collisions)
0430C5             0029*  ;     and %00000001 ; bit zero is lit if laser is active
0430C5             0030*  ;     jr nz,laser_move ; move laser if not zero
0430C5             0031*  ; ; otherwise check if laser fired
0430C5             0032*  ;     in a,(#82) ; keyboard
0430C5             0033*  ;     and %00010000 ; bit 4 is lit if space bar pressed
0430C5             0034*  ;     ret z ; go back if laser not fired
0430C5             0035*  ; ; otherwise,FIRE ZEE LASER!!1111
0430C5             0036*  ; ; set laser status to active (set bit 0)
0430C5             0037*  ;     ld a,%1
0430C5             0038*  ;     ld (laser_collisions),a
0430C5             0039*  ; ; initialize laser position
0430C5             0040*  ;     ld a,(player_x+1) ; we only need the integer part
0430C5             0041*  ;     ; add a,6 ; horizontal center with player sprite
0430C5             0042*  ;     ld (laser_x+1),a ; store laser x coordinate
0430C5             0043*  ;     ld a,(player_y+1) ; we only need the integer part
0430C5             0044*  ;     add a,-6 ; set laser y a few pixels above player
0430C5             0045*  ;     ld (laser_y+1),a ; store laser y coordinate
0430C5             0046*  ;     ; fall through to laser_move
0430C5             0047*  
0430C5             0048*  ; laser_move:
0430C5             0049*  ; ; begin setting laser to active sprite
0430C5             0050*  ;     ld hl,lasers
0430C5             0051*  ;     ld (sprite_base_bufferId),hl
0430C5             0052*  ;     ld hl,0 ; north
0430C5             0053*  ;     ld (sprite_heading),hl
0430C5             0054*  ;     xor a ; laser has no animations yet :-(
0430C5             0055*  ;     ld (sprite_animation),a
0430C5             0056*  ;     ; we set position here for the time being as a default
0430C5             0057*  ;     ; in case the laser is flagged for deletion
0430C5             0058*  ;     ; load sprite_x with laser x position (we do y further down)
0430C5             0059*  ;     ld hl,(laser_x)
0430C5             0060*  ;     ld (sprite_x),hl
0430C5             0061*  ; ; did laser just die?
0430C5             0062*  ;     ld a,(laser_collisions)
0430C5             0063*  ;     bit 1,a ; z if laser didn't just die
0430C5             0064*  ;     jr z,laser_not_dead_yet
0430C5             0065*  ; ; yes laser died
0430C5             0066*  ;     call kill_laser
0430C5             0067*  ;     ret ; done
0430C5             0068*  ; laser_not_dead_yet:
0430C5             0069*  ; ; draw it
0430C5             0070*  ; ; update laser y position
0430C5             0071*  ;     ld hl,(laser_y) ; grab laser y position
0430C5             0072*  ;     ld de,(laser_yvel) ; snag laser y velocity
0430C5             0073*  ;     add hl,de ; add y velocity to y pos
0430C5             0074*  ;     ld (sprite_y),hl ; update laser y position
0430C5             0075*  ;     ld (laser_y),hl ; update laser y position
0430C5             0076*  ; ; are we at top of screen?
0430C5             0077*  ;     ld a,#51 ; top of visible screen plus a pixel
0430C5             0078*  ;     sub h ; no carry if above threshold
0430C5             0079*  ;     jr c,finally_draw_the_frikken_laser
0430C5             0080*  ;     ; if at top of screen,laser dies
0430C5             0081*  ;     call kill_laser
0430C5             0082*  ;     ret
0430C5             0083*  ; ; otherwise,finally draw the frikken laser
0430C5             0084*  ; finally_draw_the_frikken_laser:
0430C5             0085*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
0430C5             0086*  ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
0430C5             0087*  ; ; all done
0430C5             0088*  ;     ret
0430C5             0089*  
0430C5             0090*  ; kill_laser:
0430C5             0091*  ; ; update status to inactive
0430C5             0092*  ;     xor a ; zero out a
0430C5             0093*  ;     ld (laser_collisions),a
0430C5             0094*  ;     ret
0430C5             0066   	include "timer.inc"
0430C5             0001*  ; Table 32. Timer Control Registers
0430C5             0002*  ; this constant is the base address of the timer control registers
0430C5             0003*  ; each timer takes three bytes:
0430C5             0004*  ;   0: control register
0430C5             0005*  ;   1: low byte of timer reset value
0430C5             0006*  ;   2: high byte of timer reset value
0430C5             0007*  ; note that the value is only 8-bits,so we use in0/out0 i/o calls,
0430C5             0008*  ; which correctly force the high and upper bytes of the address bus to zero
0430C5             0009*  TMR_CTL:     equ 80h
0430C5             0010*  
0430C5             0011*  ; Timer Control Register Bit Definitions
0430C5             0012*  PRT_IRQ_0:    equ %00000000 ; The timer does not reach its end-of-count value.
0430C5             0013*                              ; This bit is reset to 0 every time the TMRx_CTL register is read.
0430C5             0014*  PRT_IRQ_1:    equ %10000000 ; The timer reaches its end-of-count value. If IRQ_EN is set to 1,
0430C5             0015*                              ; an interrupt signal is sent to the CPU. This bit remains 1 until
0430C5             0016*                              ; the TMRx_CTL register is read.
0430C5             0017*  
0430C5             0018*  IRQ_EN_0:     equ %00000000 ; Timer interrupt requests are disabled.
0430C5             0019*  IRQ_EN_1:     equ %01000000 ; Timer interrupt requests are enabled.
0430C5             0020*  
0430C5             0021*  PRT_MODE_0:   equ %00000000 ; The timer operates in SINGLE PASS mode. PRT_EN (bit 0) is reset to
0430C5             0022*                              ;  0,and counting stops when the end-of-count value is reached.
0430C5             0023*  PRT_MODE_1:   equ %00010000 ; The timer operates in CONTINUOUS mode. The timer reload value is
0430C5             0024*                              ; written to the counter when the end-of-count value is reached.
0430C5             0025*  
0430C5             0026*  ; CLK_DIV is a 2-bit mask that sets the timer input source clock divider
0430C5             0027*  CLK_DIV_256:  equ %00001100 ;
0430C5             0028*  CLK_DIV_64:   equ %00001000 ;
0430C5             0029*  CLK_DIV_16:   equ %00000100 ;
0430C5             0030*  CLK_DIV_4:    equ %00000000 ;
0430C5             0031*  
0430C5             0032*  RST_EN_0:     equ %00000000 ; The reload and restart function is disabled.
0430C5             0033*  RST_EN_1:     equ %00000010 ; The reload and restart function is enabled.
0430C5             0034*                              ; When a 1 is written to this bit,the values in the reload registers
0430C5             0035*                              ;  are loaded into the downcounter when the timer restarts. The
0430C5             0036*                              ; programmer must ensure that this bit is set to 1 each time
0430C5             0037*                              ; SINGLE-PASS mode is used.
0430C5             0038*  
0430C5             0039*  ; disable/enable the programmable reload timer
0430C5             0040*  PRT_EN_0:     equ %00000000 ;
0430C5             0041*  PRT_EN_1:     equ %00000001 ;
0430C5             0042*  
0430C5             0043*  ; Table 37. Timer Input Source Select Register
0430C5             0044*  ; Each of the 4 timers are allocated two bits of the 8-bit register
0430C5             0045*  ; in little-endian order,with TMR0 using bits 0 and 1,TMR1 using bits 2 and 3,etc.
0430C5             0046*  ;   00: System clock / CLK_DIV
0430C5             0047*  ;   01: RTC / CLK_DIV
0430C5             0048*  ;   NOTE: these are the values given in the manual,but it may be a typo
0430C5             0049*  ;   10: GPIO port B pin 1.
0430C5             0050*  ;   11: GPIO port B pin 1.
0430C5             0051*  TMR_ISS:   equ 92h ; register address
0430C5             0052*  
0430C5             0053*  ; Table 51. Real-Time Clock Control Register
0430C5             0054*  RTC_CTRL: equ EDh ; register address
0430C5             0055*  
0430C5             0056*  ; alarm interrupt disable/enable
0430C5             0057*  RTC_ALARM_0:    equ %00000000
0430C5             0058*  RTC_ALARM_1:    equ %10000000
0430C5             0059*  
0430C5             0060*  ; interrupt on alarm disable/enable
0430C5             0061*  RTC_INT_ENT_0:  equ %00000000
0430C5             0062*  RTC_INT_ENT_1:  equ %01000000
0430C5             0063*  
0430C5             0064*  RTC_BCD_EN_0:   equ %00000000   ; RTC count and alarm registers are binary
0430C5             0065*  RTC_BCD_EN_1:   equ %00100000   ; RTC count and alarm registers are BCD
0430C5             0066*  
0430C5             0067*  RTC_CLK_SEL_0:  equ %00000000   ; RTC clock source is crystal oscillator output (32768 Hz).
0430C5             0068*                                  ; On-chip 32768 Hz oscillator is enabled.
0430C5             0069*  RTC_CLK_SEL_1:  equ %00010000   ; RTC clock source is power line frequency input as set by FREQ_SEL.
0430C5             0070*                                  ; On-chip 32768 Hz oscillator is disabled.
0430C5             0071*  
0430C5             0072*  RTC_FREQ_SEL_0: equ %00000000   ; 60 Hz power line frequency.
0430C5             0073*  RTC_FREQ_SEL_1: equ %00001000   ; 50 Hz power line frequency.
0430C5             0074*  
0430C5             0075*  RTC_SLP_WAKE_0: equ %00000000   ; RTC does not generate a sleep-mode recovery reset.
0430C5             0076*  RTC_SLP_WAKE_1: equ %00000010   ; RTC generates a sleep-mode recovery reset.
0430C5             0077*  
0430C5             0078*  RTC_UNLOCK_0:   equ %00000000   ; RTC count registers are locked to prevent Write access.
0430C5             0079*                                  ; RTC counter is enabled.
0430C5             0080*  RTC_UNLOCK_1:   equ %00000001   ; RTC count registers are unlocked to allow Write access.
0430C5             0081*                                  ; RTC counter is disabled.
0430C5             0082*  
0430C5             0083*  ; prt_reload_emulator: equ 11234 ; 1/102.4 seconds on emulator with 16 clock divider
0430C5             0084*  
0430C5             0085*  prt_reload_emulator: equ 11519 ; 1 centisecond on emulator with 16 clock divider
0430C5             0086*  prt_reload_hardware: equ 11532 ; 1 centisecond on hardware with 16 clock divider
0430C5 00 00 00    0087*  prt_reload: dl 0x000000
0430C8             0088*  
0430C8             0089*  ; set PRT timer
0430C8             0090*  prt_set:
0430C8 21 00 00 00 0091*      ld hl,0
0430CC 22 16 31 04 0092*      ld (prt_irq_counter),hl
0430D0 2A C5 30 04 0093*      ld hl,(prt_reload)
0430D4 ED 29 84    0094*      out0 ($84),l
0430D7 ED 21 85    0095*  	out0 ($85),h
0430DA             0096*  ; disable timer
0430DA 3E 06       0097*      ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_16 | RST_EN_1 | PRT_EN_0
0430DC ED 39 83    0098*  	out0 ($83),a
0430DF             0099*  ; enable timer,with interrupt and CONTINUOUS mode,clock divider 16
0430DF 3E 57       0100*      ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_16 | RST_EN_1 | PRT_EN_1
0430E1 ED 39 83    0101*  	out0 ($83),a
0430E4 C9          0102*      ret
0430E5             0103*  
0430E5             0104*  ; ===============================================
0430E5             0105*  ; PRT Timer Interrupt Handling
0430E5             0106*  ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.inc
0430E5             0107*  ; -----------------------------------------------
0430E5             0108*  prt_irq_init:
0430E5             0109*      ; set up interrupt vector table 2
0430E5 21 00 00 00 0110*  	ld hl,0
0430E9 3A 0C 01 00 0111*  	ld a,($10c)
0430ED 6F          0112*  	ld l,a
0430EE 3A 0D 01 00 0113*  	ld a,($10d)
0430F2 67          0114*  	ld h,a
0430F3             0115*  
0430F3             0116*  	; skip over CALL ($c3)
0430F3 23          0117*  	inc hl
0430F4             0118*  	; load address of jump into vector table 2 (in ram)
0430F4 ED 27       0119*  	ld hl,(hl)
0430F6             0120*  
0430F6             0121*  	; write CALL prt_irq_handler to vector table 2
0430F6 3E C3       0122*  	ld a,$c3
0430F8 77          0123*  	ld (hl),a
0430F9 23          0124*  	inc hl
0430FA 11 01 31 04 0125*  	ld de,prt_irq_handler
0430FE ED 1F       0126*  	ld (hl),de
043100             0127*  
043100 C9          0128*      ret
043101             0129*  
043101             0130*  prt_irq_handler:
043101 F3          0131*  	di
043102 F5          0132*  	push af
043103 E5          0133*      push hl
043104 ED 38 83    0134*  	in0 a,($83)
043107 2A 16 31 04 0135*  	ld hl,(prt_irq_counter)
04310B 23          0136*  	inc hl
04310C 22 16 31 04 0137*  	ld (prt_irq_counter),hl
043110 E1          0138*      pop hl
043111 F1          0139*  	pop af
043112 FB          0140*  	ei
043113 5B ED 4D    0141*  	reti.l
043116             0142*  
043116             0143*  prt_irq_counter:
043116 00 00 00    0144*  	.dl 0
043119             0145*  prt_irq_counter_saved:
043119 00 00 00    0146*      .dl 0
04311C             0147*  
04311C             0148*  prt_loop_reset:
04311C E5          0149*      push hl
04311D 21 00 00 00 0150*  	ld hl,0
043121 22 16 31 04 0151*  	ld (prt_irq_counter),hl
043125 22 87 31 04 0152*      ld (prt_loop_counter),hl
043129 22 8A 31 04 0153*      ld (prt_loops),hl
04312D CD C8 30 04 0154*      call prt_set
043131 E1          0155*      pop hl
043132 C9          0156*      ret
043133             0157*  
043133             0158*  prt_loop_start:
043133 E5          0159*      push hl
043134 21 00 00 00 0160*  	ld hl,0
043138 22 16 31 04 0161*  	ld (prt_irq_counter),hl
04313C E1          0162*      pop hl
04313D C9          0163*      ret
04313E             0164*  
04313E             0165*  prt_loop_stop:
04313E E5          0166*      push hl
04313F D5          0167*      push de
043140 2A 16 31 04 0168*      ld hl,(prt_irq_counter)
043144 ED 5B 87 31 0169*      ld de,(prt_loop_counter)
       04          
043149 19          0170*      add hl,de
04314A 22 87 31 04 0171*      ld (prt_loop_counter),hl
04314E 21 00 00 00 0172*      ld hl,0
043152 22 16 31 04 0173*      ld (prt_irq_counter),hl
043156 2A 8A 31 04 0174*      ld hl,(prt_loops)
04315A 23          0175*      inc hl
04315B 22 8A 31 04 0176*      ld (prt_loops),hl
04315F D1          0177*      pop de
043160 E1          0178*      pop hl
043161 C9          0179*      ret
043162             0180*  
043162             0181*  ; inputs: bc = y,x text coordinates to print
043162             0182*  prt_loop_print:
043162 F5          0183*      push af
043163 E5          0184*      push hl
043164 C5          0185*      push bc
043165 D5          0186*      push de
043166 DD E5       0187*      push ix
043168 FD E5       0188*      push iy
04316A CD EC 1A 04 0189*      call vdu_move_cursor
04316E             0190*  
04316E 2A 87 31 04 0191*      ld hl,(prt_loop_counter)
043172 CD 0A 17 04 0192*      call printDec
043176             0193*  
043176 2A 8A 31 04 0194*      ld hl,(prt_loops)
04317A CD 0A 17 04 0195*      call printDec
04317E             0196*  
04317E FD E1       0197*      pop iy
043180 DD E1       0198*      pop ix
043182 D1          0199*      pop de
043183 C1          0200*      pop bc
043184 E1          0201*      pop hl
043185 F1          0202*      pop af
043186 C9          0203*      ret
043187             0204*  
043187             0205*  prt_loop_counter:
043187 00 00 00    0206*      .dl 0
04318A             0207*  prt_loops:
04318A 00 00 00    0208*      .dl 0
04318D             0209*  
04318D             0210*  ; ===============================================
04318D             0211*  ; Timer functions
04318D             0212*  ; -----------------------------------------------
04318D             0213*  ; set a countdown timer
04318D             0214*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
04318D             0215*  ; returns: hl = current time
04318D             0216*  tmr_set:
04318D FD 2F 03    0217*      ld (iy+3),hl            ; set time remaining
043190             0218*      MOSCALL mos_sysvars     ; ix points to syvars table
043190 3E 08       0001*M 			LD	A, function
043192 5B CF       0002*M 			RST.LIL	08h
043194 DD 27 00    0219*      ld hl,(ix+sysvar_time)  ; get current time
043197 FD 2F 00    0220*      ld (iy+0),hl            ; set start time
04319A C9          0221*      ret
04319B             0222*  
04319B             0223*  ; gets time remaining on a countdown timer
04319B             0224*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
04319B             0225*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
04319B             0226*  ;          sign flags: pos = time not expired,zero or neg = time expired
04319B             0227*  tmr_get:
04319B             0228*      MOSCALL mos_sysvars     ; ix points to syvars table
04319B 3E 08       0001*M 			LD	A, function
04319D 5B CF       0002*M 			RST.LIL	08h
04319F DD 17 00    0229*      ld de,(ix+sysvar_time)  ; get current time
0431A2 FD 27 00    0230*      ld hl,(iy+0)            ; get start time
0431A5 AF          0231*      xor a                   ; clear carry
0431A6 ED 52       0232*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
0431A8 FD 17 03    0233*      ld de,(iy+3)            ; get timer set value
0431AB AF          0234*      xor a                   ; clear carry
0431AC ED 5A       0235*      adc hl,de               ; hl = time remaining
0431AE             0236*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
0431AE C9          0237*      ret
0431AF             0238*  
0431AF             0239*  tmr_test: ds 6 ; example of a buffer to hold timer data
0431B5             0240*  
0431B5 00 00 00    0241*  timestamp_now: dl 0
0431B8 00 00 00    0242*  timestamp_old: dl 0
0431BB 00 00 00    0243*  timestamp_chg: dl 0
0431BE             0244*  
0431BE             0245*  ; update the global timestamp from the system clock
0431BE             0246*  ; inputs: none
0431BE             0247*  ; returns: hl = time elapsed in 1/120ths of a second
0431BE             0248*  ;          de = current time
0431BE             0249*  ;          ix = pointer to syvars table
0431BE             0250*  ; destroys: af,hl,de,ix
0431BE             0251*  timestamp_tick:
0431BE ED 5B B5 31 0252*      ld de,(timestamp_now)   ; get previous time
       04          
0431C3 ED 53 B8 31 0253*      ld (timestamp_old),de   ; save previous time
       04          
0431C8             0254*      MOSCALL mos_sysvars     ; ix points to syvars table
0431C8 3E 08       0001*M 			LD	A, function
0431CA 5B CF       0002*M 			RST.LIL	08h
0431CC DD 27 00    0255*      ld hl,(ix+sysvar_time)  ; get current time
0431CF 22 B5 31 04 0256*      ld (timestamp_now),hl   ; save current time
0431D3 AF          0257*      xor a                   ; clear carry
0431D4 ED 52       0258*      sbc hl,de               ; hl = time elapsed
0431D6 22 BB 31 04 0259*      ld (timestamp_chg),hl   ; save elapsed time
0431DA C9          0260*      ret
0431DB             0261*  
0431DB             0262*  ; set a countdown timer
0431DB             0263*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0431DB             0264*  ; requires: timestamp_tick to be called at least once before this function
0431DB             0265*  ; returns: hl = current time
0431DB             0266*  ; destroys: hl
0431DB             0267*  timestamp_tmr_set:
0431DB FD 2F 03    0268*      ld (iy+3),hl            ; set time remaining
0431DE 2A B5 31 04 0269*      ld hl,(timestamp_now)   ; get current timestamp
0431E2 FD 2F 00    0270*      ld (iy+0),hl            ; set start time
0431E5 C9          0271*      ret
0431E6             0272*  
0431E6             0273*  ; gets time remaining on a countdown timer following the global timestamp
0431E6             0274*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0431E6             0275*  ; requires: timestamp_tick to be called at least once before this function
0431E6             0276*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0431E6             0277*  ;          sign flags: pos = time not expired,zero or neg = time expired
0431E6             0278*  ; destroys: af,hl,de
0431E6             0279*  timestamp_tmr_get:
0431E6 ED 5B B5 31 0280*      ld de,(timestamp_now)   ; get current timestamp
       04          
0431EB FD 27 00    0281*      ld hl,(iy+0)            ; get start time
0431EE AF          0282*      xor a                   ; clear carry
0431EF ED 52       0283*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
0431F1 FD 17 03    0284*      ld de,(iy+3)            ; get timer set value
0431F4 AF          0285*      xor a                   ; clear carry
0431F5 ED 5A       0286*      adc hl,de               ; hl = time remaining
0431F7             0287*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
0431F7 C9          0288*      ret
0431F8             0289*  
0431F8             0290*  ; set a stopwatch
0431F8             0291*  ; returns: hl = start time
0431F8             0292*  ; destroys: hl,ix
0431F8             0293*  stopwatch_set:
0431F8             0294*      MOSCALL mos_sysvars     ; ix points to syvars table
0431F8 3E 08       0001*M 			LD	A, function
0431FA 5B CF       0002*M 			RST.LIL	08h
0431FC DD 27 00    0295*      ld hl,(ix+sysvar_time)  ; get current time
0431FF 22 14 32 04 0296*      ld (stopwatch_started),hl            ; set start time
043203 C9          0297*      ret
043204             0298*  
043204             0299*  ; gets time elapsed on a stopwatch
043204             0300*  ; returns: hl = time elapsed in 1/120ths of a second
043204             0301*  ; destroys: af,hl,de,ix
043204             0302*  stopwatch_get:
043204             0303*      MOSCALL mos_sysvars     ; ix points to syvars table
043204 3E 08       0001*M 			LD	A, function
043206 5B CF       0002*M 			RST.LIL	08h
043208 DD 27 00    0304*      ld hl,(ix+sysvar_time)  ; get current time
04320B ED 5B 14 32 0305*      ld de,(stopwatch_started)            ; get start time
       04          
043210 AF          0306*      xor a                   ; clear carry
043211 ED 52       0307*      sbc hl,de               ; hl = time elapsed (will always be zero or positive)
043213 C9          0308*      ret
043214             0309*  
043214             0310*  stopwatch_started: ds 3 ; buffer to hold stopwatch start time
043217             0311*  
043217             0312*  ; ------------------
043217             0313*  ; delay routine
043217             0314*  ; Author: Richard Turrnidge
043217             0315*  ; https://github.com/richardturnnidge/lessons/blob/main/slowdown.inc
043217             0316*  ; routine waits a fixed time,then returns
043217             0317*  ; arrive with A =  the delay byte. One bit to be set only.
043217             0318*  ; eg. ld A,00000100b
043217             0319*  
043217             0320*  multiPurposeDelay:
043217 F5          0321*      push af
043218 C5          0322*      push bc
043219 DD E5       0323*      push ix
04321B 47          0324*      ld b,a
04321C 3E 08       0325*      ld a,$08
04321E 5B CF       0326*      RST.LIL	08h                 ; get IX pointer to sysvars
043220             0327*  
043220             0328*  waitLoop:
043220             0329*  
043220 DD 7E 00    0330*      ld a,(ix + 0)              ; ix+0h is lowest byte of clock timer
043223             0331*  
043223             0332*                                  ;   we check if bit set is same as last time we checked.
043223             0333*                                  ;   bit 0 - don't use
043223             0334*                                  ;   bit 1 - changes 64 times per second
043223             0335*                                  ;   bit 2 - changes 32 times per second
043223             0336*                                  ;   bit 3 - changes 16 times per second
043223             0337*  
043223             0338*                                  ;   bit 4 - changes 8 times per second
043223             0339*                                  ;   bit 5 - changes 4 times per second
043223             0340*                                  ;   bit 6 - changes 2 times per second
043223             0341*                                  ;   bit 7 - changes 1 times per second
043223 A0          0342*      and b
043224 4F          0343*      ld c,a
043225 3A 36 32 04 0344*      ld a,(oldTimeStamp)
043229 B9          0345*      cp c                        ; is A same as last value?
04322A 28 F4       0346*      jr z,waitLoop              ; loop here if it is
04322C 79          0347*      ld a,c
04322D 32 36 32 04 0348*      ld (oldTimeStamp),a        ; set new value
043231             0349*  
043231 DD E1       0350*      pop ix
043233 C1          0351*      pop bc
043234 F1          0352*      pop af
043235 C9          0353*      ret
043236             0354*  
043236 00          0355*  oldTimeStamp:   .db 00h
043237             0067   
043237             0068   ; new includes
043237             0069   	include "images.inc"
043237             0001*  image_type: equ 0
043237             0002*  image_width: equ image_type+3
043237             0003*  image_height: equ image_width+3
043237             0004*  image_filesize: equ image_height+3
043237             0005*  image_filename: equ image_filesize+3
043237             0006*  image_bufferId: equ image_filename+3
043237             0007*  image_record_size: equ image_bufferId+3
043237             0008*  
043237 00 00 00    0009*  cur_image_list: dl 0
04323A 00 00 00    0010*  cur_file_idx: dl 0
04323D 00 00 00    0011*  cur_filename: dl 0
043240 00 00 00    0012*  cur_buffer_id: dl 0
043243             0013*  
043243             0014*  load_ui_images:
043243             0015*  ; initialize image loading variables
043243 21 00 00 00 0016*  	ld hl,0
043247 22 3A 32 04 0017*  	ld (cur_file_idx),hl
04324B 21 25 42 04 0018*  	ld hl,ui_image_list
04324F 22 37 32 04 0019*  	ld (cur_image_list),hl
043253             0020*  ; load images
043253 06 02       0021*  	ld b,ui_num_images
043255             0022*  @loop:
043255 C5          0023*  	push bc
043256 CD B8 32 04 0024*  	call load_next_image
04325A C1          0025*  	pop bc
04325B 10 F8       0026*  	djnz @loop
04325D C9          0027*  	ret
04325E             0028*  
04325E             0029*  load_sprite_images:
04325E             0030*  ; initialize image loading variables
04325E 21 00 00 00 0031*  	ld hl,0
043262 22 3A 32 04 0032*  	ld (cur_file_idx),hl
043266 21 49 33 04 0033*  	ld hl,sprites_image_list
04326A 22 37 32 04 0034*  	ld (cur_image_list),hl
04326E 01 59 00 00 0035*  	ld bc,sprites_num_images
043272             0036*  ; load images
043272 CD 77 32 04 0037*  	call img_load_main
043276 C9          0038*  	ret
043277             0039*  
043277             0040*  ; inputs: bc is the number of images to load, cur_image_list set
043277             0041*  img_load_main:
043277 AF          0042*  	xor a
043278 32 3A 32 04 0043*      ld (cur_file_idx),a
04327C             0044*  
04327C             0045*  img_load_main_loop:
04327C             0046*  ; back up loop counter
04327C C5          0047*      push bc
04327D             0048*  
04327D             0049*  ; load the next image
04327D CD B8 32 04 0050*      call load_next_image
043281             0051*  
043281             0052*  ; plot the background
043281 CD 00 1B 04 0053*  	call vdu_cls
043285 21 00 00 00 0054*      ld hl,BUF_SPLASH_BG
043289 CD ED 1B 04 0055*      call vdu_buff_select
04328D 01 00 00 00 0056*      ld bc,0
043291 11 00 00 00 0057*      ld de,0
043295 CD B6 1E 04 0058*      call vdu_plot_bmp
043299             0059*  
043299             0060*  ; ; draw the most recently loaded image
043299             0061*  ; 	ld hl,(cur_buffer_id)
043299             0062*  ; 	call vdu_buff_select
043299             0063*  ; 	ld bc,0
043299             0064*  ; 	ld de,0
043299             0065*  ; 	call vdu_plot_bmp
043299             0066*  
043299             0067*  ; move logo
043299 CD 18 33 04 0068*  	call move_logo
04329D             0069*  
04329D             0070*  ; print current filename
04329D 2A 3D 32 04 0071*  	ld hl,(cur_filename)
0432A1 CD BC 16 04 0072*  	call printString
0432A5             0073*  
0432A5             0074*  ; flip the framebuffer
0432A5 CD 05 1B 04 0075*  	call vdu_flip
0432A9             0076*  
0432A9             0077*  ; decrement loop counter
0432A9 C1          0078*      pop bc
0432AA 0B          0079*  	dec bc
0432AB 79          0080*      ld a,c
0432AC B7          0081*      or a
0432AD C2 7C 32 04 0082*      jp nz,img_load_main_loop
0432B1 78          0083*      ld a,b
0432B2 B7          0084*      or a
0432B3 C2 7C 32 04 0085*      jp nz,img_load_main_loop
0432B7 C9          0086*      ret
0432B8             0087*  
0432B8             0088*  load_next_image:
0432B8 16 12       0089*      ld d,image_record_size
0432BA 3A 3A 32 04 0090*  	ld a,(cur_file_idx)
0432BE 5F          0091*  	ld e,a
0432BF ED 5C       0092*      mlt de
0432C1 FD 2A 37 32 0093*      ld iy,(cur_image_list)
       04          
0432C6 FD 19       0094*      add iy,de
0432C8             0095*  
0432C8 FD 7E 00    0096*      ld a,(iy+image_type) ; get image type
0432CB FD 07 03    0097*      ld bc,(iy+image_width) ; get image width
0432CE FD 17 06    0098*      ld de,(iy+image_height) ; get image height
0432D1 FD 31 09    0099*      ld ix,(iy+image_filesize) ; get image file size
0432D4 FD 27 0F    0100*  	ld hl,(iy+image_bufferId) ; get image bufferId
0432D7 22 40 32 04 0101*  	ld (cur_buffer_id),hl
0432DB FD 37 0C    0102*      ld iy,(iy+image_filename) ; get image filename
0432DE FD 22 3D 32 0103*  	ld (cur_filename),iy
       04          
0432E3 CD 0B 1D 04 0104*      call vdu_load_img
0432E7 FD 21 3A 32 0105*      ld iy,cur_file_idx
       04          
0432EC FD 34 00    0106*  	inc (iy)
0432EF C9          0107*  	ret
0432F0             0108*  
0432F0             0109*  img_load_init:
0432F0             0110*  ; initialize logo's position parameters
0432F0 21 00 00 00 0111*  	ld hl,0
0432F4 22 3D 33 04 0112*  	ld (logo_xvel),hl
0432F8 22 40 33 04 0113*  	ld (logo_xpos),hl
0432FC             0114*  ; begin 16.8 maths to determine logo's y position and velocity
0432FC 21 00 E0 00 0115*  	ld hl,240-16*256 ; allow space for text at bottom of screen
043300 22 46 33 04 0116*  	ld (logo_ypos),hl
043304 EB          0117*  	ex de,hl
043305 21 00 F8 FF 0118*  	ld hl,-8*256 ; 8 pixels from top of screen
043309 19          0119*  	add hl,de ; distance for logo to travel
04330A 11 00 A7 FF 0120*  	ld de,-sprites_num_images*256
04330E CD 2D 2C 04 0121*  	call sdiv168 ; ud.e = distance / num images = y velocity
043312 ED 53 43 33 0122*  	ld (logo_yvel),de
       04          
043317             0123*  ; all done
043317 C9          0124*      ret
043318             0125*  
043318             0126*  move_logo:
043318             0127*  ; activate logo bitmap
043318 21 01 00 00 0128*  	ld hl, BUF_SPLASH_LOGO
04331C CD ED 1B 04 0129*  	call vdu_buff_select
043320             0130*  ; update position based on velocity parameters
043320 2A 46 33 04 0131*  	ld hl,(logo_ypos)
043324 ED 5B 43 33 0132*  	ld de,(logo_yvel)
       04          
043329 19          0133*  	add hl,de
04332A 22 46 33 04 0134*  	ld (logo_ypos),hl
04332E             0135*  ; draw logo
04332E ED 4B 40 33 0136*  	ld bc,(logo_xpos)
       04          
043333 ED 5B 46 33 0137*  	ld de,(logo_ypos)
       04          
043338 CD D2 1E 04 0138*  	call vdu_plot_bmp168
04333C C9          0139*  	ret
04333D             0140*  
04333D 00 00 00    0141*  logo_xvel: dl 0
043340 00 00 00    0142*  logo_xpos: dl 0
043343             0143*  
043343 00 00 00    0144*  logo_yvel: dl 0
043346 00 00 00    0145*  logo_ypos: dl 0
043349             0070   	include "images_sprites.inc"
043349             0001*  ; Generated by make_images.py
043349             0002*  
043349             0003*  sprites_num_images: equ 89
043349             0004*  
043349             0005*  ; buffer_ids:
043349             0006*  BUF_0TILE_EMPTY: equ 256
043349             0007*  BUF_1TILE_CROSS: equ 257
043349             0008*  BUF_2TILE_HORIZ: equ 258
043349             0009*  BUF_3TILE_VERT: equ 259
043349             0010*  BUF_4TILE_SQUARE: equ 260
043349             0011*  BUF_5TILE_CIRCLE: equ 261
043349             0012*  BUF_6TILE_PAD: equ 262
043349             0013*  BUF_7TILE_TURRET: equ 263
043349             0014*  BUF_CIRCLE: equ 264
043349             0015*  BUF_CRATER: equ 265
043349             0016*  BUF_EXPLOSION_A: equ 266
043349             0017*  BUF_EXPLOSION_B: equ 267
043349             0018*  BUF_EXPLOSION_C: equ 268
043349             0019*  BUF_EXPLOSION_D: equ 269
043349             0020*  BUF_EXPLOSION_E: equ 270
043349             0021*  BUF_FIREBALL_A: equ 271
043349             0022*  BUF_FIREBALL_B: equ 272
043349             0023*  BUF_LASER_A: equ 273
043349             0024*  BUF_LASER_B: equ 274
043349             0025*  BUF_PAD: equ 275
043349             0026*  BUF_SEEKER_000: equ 276
043349             0027*  BUF_SEEKER_008: equ 277
043349             0028*  BUF_SEEKER_016: equ 278
043349             0029*  BUF_SEEKER_024: equ 279
043349             0030*  BUF_SEEKER_032: equ 280
043349             0031*  BUF_SEEKER_040: equ 281
043349             0032*  BUF_SEEKER_048: equ 282
043349             0033*  BUF_SEEKER_056: equ 283
043349             0034*  BUF_SEEKER_064: equ 284
043349             0035*  BUF_SEEKER_072: equ 285
043349             0036*  BUF_SEEKER_080: equ 286
043349             0037*  BUF_SEEKER_088: equ 287
043349             0038*  BUF_SEEKER_096: equ 288
043349             0039*  BUF_SEEKER_104: equ 289
043349             0040*  BUF_SEEKER_112: equ 290
043349             0041*  BUF_SEEKER_120: equ 291
043349             0042*  BUF_SEEKER_128: equ 292
043349             0043*  BUF_SEEKER_136: equ 293
043349             0044*  BUF_SEEKER_144: equ 294
043349             0045*  BUF_SEEKER_152: equ 295
043349             0046*  BUF_SEEKER_160: equ 296
043349             0047*  BUF_SEEKER_168: equ 297
043349             0048*  BUF_SEEKER_176: equ 298
043349             0049*  BUF_SEEKER_184: equ 299
043349             0050*  BUF_SEEKER_192: equ 300
043349             0051*  BUF_SEEKER_200: equ 301
043349             0052*  BUF_SEEKER_208: equ 302
043349             0053*  BUF_SEEKER_216: equ 303
043349             0054*  BUF_SEEKER_224: equ 304
043349             0055*  BUF_SEEKER_232: equ 305
043349             0056*  BUF_SEEKER_240: equ 306
043349             0057*  BUF_SEEKER_248: equ 307
043349             0058*  BUF_SHIP_0L: equ 308
043349             0059*  BUF_SHIP_1C: equ 309
043349             0060*  BUF_SHIP_2R: equ 310
043349             0061*  BUF_SHIP_SMALL: equ 311
043349             0062*  BUF_STAR: equ 312
043349             0063*  BUF_TURRET_000: equ 313
043349             0064*  BUF_TURRET_008: equ 314
043349             0065*  BUF_TURRET_016: equ 315
043349             0066*  BUF_TURRET_024: equ 316
043349             0067*  BUF_TURRET_032: equ 317
043349             0068*  BUF_TURRET_040: equ 318
043349             0069*  BUF_TURRET_048: equ 319
043349             0070*  BUF_TURRET_056: equ 320
043349             0071*  BUF_TURRET_064: equ 321
043349             0072*  BUF_TURRET_072: equ 322
043349             0073*  BUF_TURRET_080: equ 323
043349             0074*  BUF_TURRET_088: equ 324
043349             0075*  BUF_TURRET_096: equ 325
043349             0076*  BUF_TURRET_104: equ 326
043349             0077*  BUF_TURRET_112: equ 327
043349             0078*  BUF_TURRET_120: equ 328
043349             0079*  BUF_TURRET_128: equ 329
043349             0080*  BUF_TURRET_136: equ 330
043349             0081*  BUF_TURRET_144: equ 331
043349             0082*  BUF_TURRET_152: equ 332
043349             0083*  BUF_TURRET_160: equ 333
043349             0084*  BUF_TURRET_168: equ 334
043349             0085*  BUF_TURRET_176: equ 335
043349             0086*  BUF_TURRET_184: equ 336
043349             0087*  BUF_TURRET_192: equ 337
043349             0088*  BUF_TURRET_200: equ 338
043349             0089*  BUF_TURRET_208: equ 339
043349             0090*  BUF_TURRET_216: equ 340
043349             0091*  BUF_TURRET_224: equ 341
043349             0092*  BUF_TURRET_232: equ 342
043349             0093*  BUF_TURRET_240: equ 343
043349             0094*  BUF_TURRET_248: equ 344
043349             0095*  
043349             0096*  sprites_image_list: ; type; width; height; filename; bufferId:
043349 01 00 00 10 0097*  	dl 1, 16, 16, 256, fn_0tile_empty, 256
       00 00 10 00 
       00 00 01 00 
       8B 39 04 00 
       01 00       
04335B 01 00 00 10 0098*  	dl 1, 16, 16, 256, fn_1tile_cross, 257
       00 00 10 00 
       00 00 01 00 
       A5 39 04 01 
       01 00       
04336D 01 00 00 10 0099*  	dl 1, 16, 16, 256, fn_2tile_horiz, 258
       00 00 10 00 
       00 00 01 00 
       BF 39 04 02 
       01 00       
04337F 01 00 00 10 0100*  	dl 1, 16, 16, 256, fn_3tile_vert, 259
       00 00 10 00 
       00 00 01 00 
       D9 39 04 03 
       01 00       
043391 01 00 00 10 0101*  	dl 1, 16, 16, 256, fn_4tile_square, 260
       00 00 10 00 
       00 00 01 00 
       F2 39 04 04 
       01 00       
0433A3 01 00 00 10 0102*  	dl 1, 16, 16, 256, fn_5tile_circle, 261
       00 00 10 00 
       00 00 01 00 
       0D 3A 04 05 
       01 00       
0433B5 01 00 00 10 0103*  	dl 1, 16, 16, 256, fn_6tile_pad, 262
       00 00 10 00 
       00 00 01 00 
       28 3A 04 06 
       01 00       
0433C7 01 00 00 10 0104*  	dl 1, 16, 16, 256, fn_7tile_turret, 263
       00 00 10 00 
       00 00 01 00 
       40 3A 04 07 
       01 00       
0433D9 01 00 00 10 0105*  	dl 1, 16, 16, 256, fn_circle, 264
       00 00 10 00 
       00 00 01 00 
       5B 3A 04 08 
       01 00       
0433EB 01 00 00 10 0106*  	dl 1, 16, 16, 256, fn_crater, 265
       00 00 10 00 
       00 00 01 00 
       70 3A 04 09 
       01 00       
0433FD 01 00 00 10 0107*  	dl 1, 16, 16, 256, fn_explosion_a, 266
       00 00 10 00 
       00 00 01 00 
       85 3A 04 0A 
       01 00       
04340F 01 00 00 10 0108*  	dl 1, 16, 16, 256, fn_explosion_b, 267
       00 00 10 00 
       00 00 01 00 
       9F 3A 04 0B 
       01 00       
043421 01 00 00 10 0109*  	dl 1, 16, 16, 256, fn_explosion_c, 268
       00 00 10 00 
       00 00 01 00 
       B9 3A 04 0C 
       01 00       
043433 01 00 00 10 0110*  	dl 1, 16, 16, 256, fn_explosion_d, 269
       00 00 10 00 
       00 00 01 00 
       D3 3A 04 0D 
       01 00       
043445 01 00 00 10 0111*  	dl 1, 16, 16, 256, fn_explosion_e, 270
       00 00 10 00 
       00 00 01 00 
       ED 3A 04 0E 
       01 00       
043457 01 00 00 07 0112*  	dl 1, 7, 7, 49, fn_fireball_a, 271
       00 00 07 00 
       00 31 00 00 
       07 3B 04 0F 
       01 00       
043469 01 00 00 07 0113*  	dl 1, 7, 7, 49, fn_fireball_b, 272
       00 00 07 00 
       00 31 00 00 
       20 3B 04 10 
       01 00       
04347B 01 00 00 05 0114*  	dl 1, 5, 13, 65, fn_laser_a, 273
       00 00 0D 00 
       00 41 00 00 
       39 3B 04 11 
       01 00       
04348D 01 00 00 05 0115*  	dl 1, 5, 13, 65, fn_laser_b, 274
       00 00 0D 00 
       00 41 00 00 
       4F 3B 04 12 
       01 00       
04349F 01 00 00 10 0116*  	dl 1, 16, 16, 256, fn_pad, 275
       00 00 10 00 
       00 00 01 00 
       65 3B 04 13 
       01 00       
0434B1 01 00 00 10 0117*  	dl 1, 16, 16, 256, fn_seeker_000, 276
       00 00 10 00 
       00 00 01 00 
       77 3B 04 14 
       01 00       
0434C3 01 00 00 10 0118*  	dl 1, 16, 16, 256, fn_seeker_008, 277
       00 00 10 00 
       00 00 01 00 
       90 3B 04 15 
       01 00       
0434D5 01 00 00 10 0119*  	dl 1, 16, 16, 256, fn_seeker_016, 278
       00 00 10 00 
       00 00 01 00 
       A9 3B 04 16 
       01 00       
0434E7 01 00 00 10 0120*  	dl 1, 16, 16, 256, fn_seeker_024, 279
       00 00 10 00 
       00 00 01 00 
       C2 3B 04 17 
       01 00       
0434F9 01 00 00 10 0121*  	dl 1, 16, 16, 256, fn_seeker_032, 280
       00 00 10 00 
       00 00 01 00 
       DB 3B 04 18 
       01 00       
04350B 01 00 00 10 0122*  	dl 1, 16, 16, 256, fn_seeker_040, 281
       00 00 10 00 
       00 00 01 00 
       F4 3B 04 19 
       01 00       
04351D 01 00 00 10 0123*  	dl 1, 16, 16, 256, fn_seeker_048, 282
       00 00 10 00 
       00 00 01 00 
       0D 3C 04 1A 
       01 00       
04352F 01 00 00 10 0124*  	dl 1, 16, 16, 256, fn_seeker_056, 283
       00 00 10 00 
       00 00 01 00 
       26 3C 04 1B 
       01 00       
043541 01 00 00 10 0125*  	dl 1, 16, 16, 256, fn_seeker_064, 284
       00 00 10 00 
       00 00 01 00 
       3F 3C 04 1C 
       01 00       
043553 01 00 00 10 0126*  	dl 1, 16, 16, 256, fn_seeker_072, 285
       00 00 10 00 
       00 00 01 00 
       58 3C 04 1D 
       01 00       
043565 01 00 00 10 0127*  	dl 1, 16, 16, 256, fn_seeker_080, 286
       00 00 10 00 
       00 00 01 00 
       71 3C 04 1E 
       01 00       
043577 01 00 00 10 0128*  	dl 1, 16, 16, 256, fn_seeker_088, 287
       00 00 10 00 
       00 00 01 00 
       8A 3C 04 1F 
       01 00       
043589 01 00 00 10 0129*  	dl 1, 16, 16, 256, fn_seeker_096, 288
       00 00 10 00 
       00 00 01 00 
       A3 3C 04 20 
       01 00       
04359B 01 00 00 10 0130*  	dl 1, 16, 16, 256, fn_seeker_104, 289
       00 00 10 00 
       00 00 01 00 
       BC 3C 04 21 
       01 00       
0435AD 01 00 00 10 0131*  	dl 1, 16, 16, 256, fn_seeker_112, 290
       00 00 10 00 
       00 00 01 00 
       D5 3C 04 22 
       01 00       
0435BF 01 00 00 10 0132*  	dl 1, 16, 16, 256, fn_seeker_120, 291
       00 00 10 00 
       00 00 01 00 
       EE 3C 04 23 
       01 00       
0435D1 01 00 00 10 0133*  	dl 1, 16, 16, 256, fn_seeker_128, 292
       00 00 10 00 
       00 00 01 00 
       07 3D 04 24 
       01 00       
0435E3 01 00 00 10 0134*  	dl 1, 16, 16, 256, fn_seeker_136, 293
       00 00 10 00 
       00 00 01 00 
       20 3D 04 25 
       01 00       
0435F5 01 00 00 10 0135*  	dl 1, 16, 16, 256, fn_seeker_144, 294
       00 00 10 00 
       00 00 01 00 
       39 3D 04 26 
       01 00       
043607 01 00 00 10 0136*  	dl 1, 16, 16, 256, fn_seeker_152, 295
       00 00 10 00 
       00 00 01 00 
       52 3D 04 27 
       01 00       
043619 01 00 00 10 0137*  	dl 1, 16, 16, 256, fn_seeker_160, 296
       00 00 10 00 
       00 00 01 00 
       6B 3D 04 28 
       01 00       
04362B 01 00 00 10 0138*  	dl 1, 16, 16, 256, fn_seeker_168, 297
       00 00 10 00 
       00 00 01 00 
       84 3D 04 29 
       01 00       
04363D 01 00 00 10 0139*  	dl 1, 16, 16, 256, fn_seeker_176, 298
       00 00 10 00 
       00 00 01 00 
       9D 3D 04 2A 
       01 00       
04364F 01 00 00 10 0140*  	dl 1, 16, 16, 256, fn_seeker_184, 299
       00 00 10 00 
       00 00 01 00 
       B6 3D 04 2B 
       01 00       
043661 01 00 00 10 0141*  	dl 1, 16, 16, 256, fn_seeker_192, 300
       00 00 10 00 
       00 00 01 00 
       CF 3D 04 2C 
       01 00       
043673 01 00 00 10 0142*  	dl 1, 16, 16, 256, fn_seeker_200, 301
       00 00 10 00 
       00 00 01 00 
       E8 3D 04 2D 
       01 00       
043685 01 00 00 10 0143*  	dl 1, 16, 16, 256, fn_seeker_208, 302
       00 00 10 00 
       00 00 01 00 
       01 3E 04 2E 
       01 00       
043697 01 00 00 10 0144*  	dl 1, 16, 16, 256, fn_seeker_216, 303
       00 00 10 00 
       00 00 01 00 
       1A 3E 04 2F 
       01 00       
0436A9 01 00 00 10 0145*  	dl 1, 16, 16, 256, fn_seeker_224, 304
       00 00 10 00 
       00 00 01 00 
       33 3E 04 30 
       01 00       
0436BB 01 00 00 10 0146*  	dl 1, 16, 16, 256, fn_seeker_232, 305
       00 00 10 00 
       00 00 01 00 
       4C 3E 04 31 
       01 00       
0436CD 01 00 00 10 0147*  	dl 1, 16, 16, 256, fn_seeker_240, 306
       00 00 10 00 
       00 00 01 00 
       65 3E 04 32 
       01 00       
0436DF 01 00 00 10 0148*  	dl 1, 16, 16, 256, fn_seeker_248, 307
       00 00 10 00 
       00 00 01 00 
       7E 3E 04 33 
       01 00       
0436F1 01 00 00 10 0149*  	dl 1, 16, 16, 256, fn_ship_0l, 308
       00 00 10 00 
       00 00 01 00 
       97 3E 04 34 
       01 00       
043703 01 00 00 10 0150*  	dl 1, 16, 16, 256, fn_ship_1c, 309
       00 00 10 00 
       00 00 01 00 
       AD 3E 04 35 
       01 00       
043715 01 00 00 10 0151*  	dl 1, 16, 16, 256, fn_ship_2r, 310
       00 00 10 00 
       00 00 01 00 
       C3 3E 04 36 
       01 00       
043727 01 00 00 08 0152*  	dl 1, 8, 8, 64, fn_ship_small, 311
       00 00 08 00 
       00 40 00 00 
       D9 3E 04 37 
       01 00       
043739 01 00 00 05 0153*  	dl 1, 5, 5, 25, fn_star, 312
       00 00 05 00 
       00 19 00 00 
       F2 3E 04 38 
       01 00       
04374B 01 00 00 10 0154*  	dl 1, 16, 16, 256, fn_turret_000, 313
       00 00 10 00 
       00 00 01 00 
       05 3F 04 39 
       01 00       
04375D 01 00 00 10 0155*  	dl 1, 16, 16, 256, fn_turret_008, 314
       00 00 10 00 
       00 00 01 00 
       1E 3F 04 3A 
       01 00       
04376F 01 00 00 10 0156*  	dl 1, 16, 16, 256, fn_turret_016, 315
       00 00 10 00 
       00 00 01 00 
       37 3F 04 3B 
       01 00       
043781 01 00 00 10 0157*  	dl 1, 16, 16, 256, fn_turret_024, 316
       00 00 10 00 
       00 00 01 00 
       50 3F 04 3C 
       01 00       
043793 01 00 00 10 0158*  	dl 1, 16, 16, 256, fn_turret_032, 317
       00 00 10 00 
       00 00 01 00 
       69 3F 04 3D 
       01 00       
0437A5 01 00 00 10 0159*  	dl 1, 16, 16, 256, fn_turret_040, 318
       00 00 10 00 
       00 00 01 00 
       82 3F 04 3E 
       01 00       
0437B7 01 00 00 10 0160*  	dl 1, 16, 16, 256, fn_turret_048, 319
       00 00 10 00 
       00 00 01 00 
       9B 3F 04 3F 
       01 00       
0437C9 01 00 00 10 0161*  	dl 1, 16, 16, 256, fn_turret_056, 320
       00 00 10 00 
       00 00 01 00 
       B4 3F 04 40 
       01 00       
0437DB 01 00 00 10 0162*  	dl 1, 16, 16, 256, fn_turret_064, 321
       00 00 10 00 
       00 00 01 00 
       CD 3F 04 41 
       01 00       
0437ED 01 00 00 10 0163*  	dl 1, 16, 16, 256, fn_turret_072, 322
       00 00 10 00 
       00 00 01 00 
       E6 3F 04 42 
       01 00       
0437FF 01 00 00 10 0164*  	dl 1, 16, 16, 256, fn_turret_080, 323
       00 00 10 00 
       00 00 01 00 
       FF 3F 04 43 
       01 00       
043811 01 00 00 10 0165*  	dl 1, 16, 16, 256, fn_turret_088, 324
       00 00 10 00 
       00 00 01 00 
       18 40 04 44 
       01 00       
043823 01 00 00 10 0166*  	dl 1, 16, 16, 256, fn_turret_096, 325
       00 00 10 00 
       00 00 01 00 
       31 40 04 45 
       01 00       
043835 01 00 00 10 0167*  	dl 1, 16, 16, 256, fn_turret_104, 326
       00 00 10 00 
       00 00 01 00 
       4A 40 04 46 
       01 00       
043847 01 00 00 10 0168*  	dl 1, 16, 16, 256, fn_turret_112, 327
       00 00 10 00 
       00 00 01 00 
       63 40 04 47 
       01 00       
043859 01 00 00 10 0169*  	dl 1, 16, 16, 256, fn_turret_120, 328
       00 00 10 00 
       00 00 01 00 
       7C 40 04 48 
       01 00       
04386B 01 00 00 10 0170*  	dl 1, 16, 16, 256, fn_turret_128, 329
       00 00 10 00 
       00 00 01 00 
       95 40 04 49 
       01 00       
04387D 01 00 00 10 0171*  	dl 1, 16, 16, 256, fn_turret_136, 330
       00 00 10 00 
       00 00 01 00 
       AE 40 04 4A 
       01 00       
04388F 01 00 00 10 0172*  	dl 1, 16, 16, 256, fn_turret_144, 331
       00 00 10 00 
       00 00 01 00 
       C7 40 04 4B 
       01 00       
0438A1 01 00 00 10 0173*  	dl 1, 16, 16, 256, fn_turret_152, 332
       00 00 10 00 
       00 00 01 00 
       E0 40 04 4C 
       01 00       
0438B3 01 00 00 10 0174*  	dl 1, 16, 16, 256, fn_turret_160, 333
       00 00 10 00 
       00 00 01 00 
       F9 40 04 4D 
       01 00       
0438C5 01 00 00 10 0175*  	dl 1, 16, 16, 256, fn_turret_168, 334
       00 00 10 00 
       00 00 01 00 
       12 41 04 4E 
       01 00       
0438D7 01 00 00 10 0176*  	dl 1, 16, 16, 256, fn_turret_176, 335
       00 00 10 00 
       00 00 01 00 
       2B 41 04 4F 
       01 00       
0438E9 01 00 00 10 0177*  	dl 1, 16, 16, 256, fn_turret_184, 336
       00 00 10 00 
       00 00 01 00 
       44 41 04 50 
       01 00       
0438FB 01 00 00 10 0178*  	dl 1, 16, 16, 256, fn_turret_192, 337
       00 00 10 00 
       00 00 01 00 
       5D 41 04 51 
       01 00       
04390D 01 00 00 10 0179*  	dl 1, 16, 16, 256, fn_turret_200, 338
       00 00 10 00 
       00 00 01 00 
       76 41 04 52 
       01 00       
04391F 01 00 00 10 0180*  	dl 1, 16, 16, 256, fn_turret_208, 339
       00 00 10 00 
       00 00 01 00 
       8F 41 04 53 
       01 00       
043931 01 00 00 10 0181*  	dl 1, 16, 16, 256, fn_turret_216, 340
       00 00 10 00 
       00 00 01 00 
       A8 41 04 54 
       01 00       
043943 01 00 00 10 0182*  	dl 1, 16, 16, 256, fn_turret_224, 341
       00 00 10 00 
       00 00 01 00 
       C1 41 04 55 
       01 00       
043955 01 00 00 10 0183*  	dl 1, 16, 16, 256, fn_turret_232, 342
       00 00 10 00 
       00 00 01 00 
       DA 41 04 56 
       01 00       
043967 01 00 00 10 0184*  	dl 1, 16, 16, 256, fn_turret_240, 343
       00 00 10 00 
       00 00 01 00 
       F3 41 04 57 
       01 00       
043979 01 00 00 10 0185*  	dl 1, 16, 16, 256, fn_turret_248, 344
       00 00 10 00 
       00 00 01 00 
       0C 42 04 58 
       01 00       
04398B             0186*  
04398B             0187*  ; files_list: ; filename:
04398B 73 70 72 69 0188*  fn_0tile_empty: db "sprites/0tile_empty.rgba2",0
       74 65 73 2F 
       30 74 69 6C 
       65 5F 65 6D 
       70 74 79 2E 
       72 67 62 61 
       32 00       
0439A5 73 70 72 69 0189*  fn_1tile_cross: db "sprites/1tile_cross.rgba2",0
       74 65 73 2F 
       31 74 69 6C 
       65 5F 63 72 
       6F 73 73 2E 
       72 67 62 61 
       32 00       
0439BF 73 70 72 69 0190*  fn_2tile_horiz: db "sprites/2tile_horiz.rgba2",0
       74 65 73 2F 
       32 74 69 6C 
       65 5F 68 6F 
       72 69 7A 2E 
       72 67 62 61 
       32 00       
0439D9 73 70 72 69 0191*  fn_3tile_vert: db "sprites/3tile_vert.rgba2",0
       74 65 73 2F 
       33 74 69 6C 
       65 5F 76 65 
       72 74 2E 72 
       67 62 61 32 
       00          
0439F2 73 70 72 69 0192*  fn_4tile_square: db "sprites/4tile_square.rgba2",0
       74 65 73 2F 
       34 74 69 6C 
       65 5F 73 71 
       75 61 72 65 
       2E 72 67 62 
       61 32 00    
043A0D 73 70 72 69 0193*  fn_5tile_circle: db "sprites/5tile_circle.rgba2",0
       74 65 73 2F 
       35 74 69 6C 
       65 5F 63 69 
       72 63 6C 65 
       2E 72 67 62 
       61 32 00    
043A28 73 70 72 69 0194*  fn_6tile_pad: db "sprites/6tile_pad.rgba2",0
       74 65 73 2F 
       36 74 69 6C 
       65 5F 70 61 
       64 2E 72 67 
       62 61 32 00 
043A40 73 70 72 69 0195*  fn_7tile_turret: db "sprites/7tile_turret.rgba2",0
       74 65 73 2F 
       37 74 69 6C 
       65 5F 74 75 
       72 72 65 74 
       2E 72 67 62 
       61 32 00    
043A5B 73 70 72 69 0196*  fn_circle: db "sprites/circle.rgba2",0
       74 65 73 2F 
       63 69 72 63 
       6C 65 2E 72 
       67 62 61 32 
       00          
043A70 73 70 72 69 0197*  fn_crater: db "sprites/crater.rgba2",0
       74 65 73 2F 
       63 72 61 74 
       65 72 2E 72 
       67 62 61 32 
       00          
043A85 73 70 72 69 0198*  fn_explosion_a: db "sprites/explosion_a.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 61 2E 
       72 67 62 61 
       32 00       
043A9F 73 70 72 69 0199*  fn_explosion_b: db "sprites/explosion_b.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 62 2E 
       72 67 62 61 
       32 00       
043AB9 73 70 72 69 0200*  fn_explosion_c: db "sprites/explosion_c.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 63 2E 
       72 67 62 61 
       32 00       
043AD3 73 70 72 69 0201*  fn_explosion_d: db "sprites/explosion_d.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 64 2E 
       72 67 62 61 
       32 00       
043AED 73 70 72 69 0202*  fn_explosion_e: db "sprites/explosion_e.rgba2",0
       74 65 73 2F 
       65 78 70 6C 
       6F 73 69 6F 
       6E 5F 65 2E 
       72 67 62 61 
       32 00       
043B07 73 70 72 69 0203*  fn_fireball_a: db "sprites/fireball_a.rgba2",0
       74 65 73 2F 
       66 69 72 65 
       62 61 6C 6C 
       5F 61 2E 72 
       67 62 61 32 
       00          
043B20 73 70 72 69 0204*  fn_fireball_b: db "sprites/fireball_b.rgba2",0
       74 65 73 2F 
       66 69 72 65 
       62 61 6C 6C 
       5F 62 2E 72 
       67 62 61 32 
       00          
043B39 73 70 72 69 0205*  fn_laser_a: db "sprites/laser_a.rgba2",0
       74 65 73 2F 
       6C 61 73 65 
       72 5F 61 2E 
       72 67 62 61 
       32 00       
043B4F 73 70 72 69 0206*  fn_laser_b: db "sprites/laser_b.rgba2",0
       74 65 73 2F 
       6C 61 73 65 
       72 5F 62 2E 
       72 67 62 61 
       32 00       
043B65 73 70 72 69 0207*  fn_pad: db "sprites/pad.rgba2",0
       74 65 73 2F 
       70 61 64 2E 
       72 67 62 61 
       32 00       
043B77 73 70 72 69 0208*  fn_seeker_000: db "sprites/seeker_000.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       30 30 2E 72 
       67 62 61 32 
       00          
043B90 73 70 72 69 0209*  fn_seeker_008: db "sprites/seeker_008.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       30 38 2E 72 
       67 62 61 32 
       00          
043BA9 73 70 72 69 0210*  fn_seeker_016: db "sprites/seeker_016.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       31 36 2E 72 
       67 62 61 32 
       00          
043BC2 73 70 72 69 0211*  fn_seeker_024: db "sprites/seeker_024.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       32 34 2E 72 
       67 62 61 32 
       00          
043BDB 73 70 72 69 0212*  fn_seeker_032: db "sprites/seeker_032.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       33 32 2E 72 
       67 62 61 32 
       00          
043BF4 73 70 72 69 0213*  fn_seeker_040: db "sprites/seeker_040.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       34 30 2E 72 
       67 62 61 32 
       00          
043C0D 73 70 72 69 0214*  fn_seeker_048: db "sprites/seeker_048.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       34 38 2E 72 
       67 62 61 32 
       00          
043C26 73 70 72 69 0215*  fn_seeker_056: db "sprites/seeker_056.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       35 36 2E 72 
       67 62 61 32 
       00          
043C3F 73 70 72 69 0216*  fn_seeker_064: db "sprites/seeker_064.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       36 34 2E 72 
       67 62 61 32 
       00          
043C58 73 70 72 69 0217*  fn_seeker_072: db "sprites/seeker_072.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       37 32 2E 72 
       67 62 61 32 
       00          
043C71 73 70 72 69 0218*  fn_seeker_080: db "sprites/seeker_080.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       38 30 2E 72 
       67 62 61 32 
       00          
043C8A 73 70 72 69 0219*  fn_seeker_088: db "sprites/seeker_088.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       38 38 2E 72 
       67 62 61 32 
       00          
043CA3 73 70 72 69 0220*  fn_seeker_096: db "sprites/seeker_096.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 30 
       39 36 2E 72 
       67 62 61 32 
       00          
043CBC 73 70 72 69 0221*  fn_seeker_104: db "sprites/seeker_104.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       30 34 2E 72 
       67 62 61 32 
       00          
043CD5 73 70 72 69 0222*  fn_seeker_112: db "sprites/seeker_112.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       31 32 2E 72 
       67 62 61 32 
       00          
043CEE 73 70 72 69 0223*  fn_seeker_120: db "sprites/seeker_120.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       32 30 2E 72 
       67 62 61 32 
       00          
043D07 73 70 72 69 0224*  fn_seeker_128: db "sprites/seeker_128.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       32 38 2E 72 
       67 62 61 32 
       00          
043D20 73 70 72 69 0225*  fn_seeker_136: db "sprites/seeker_136.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       33 36 2E 72 
       67 62 61 32 
       00          
043D39 73 70 72 69 0226*  fn_seeker_144: db "sprites/seeker_144.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       34 34 2E 72 
       67 62 61 32 
       00          
043D52 73 70 72 69 0227*  fn_seeker_152: db "sprites/seeker_152.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       35 32 2E 72 
       67 62 61 32 
       00          
043D6B 73 70 72 69 0228*  fn_seeker_160: db "sprites/seeker_160.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       36 30 2E 72 
       67 62 61 32 
       00          
043D84 73 70 72 69 0229*  fn_seeker_168: db "sprites/seeker_168.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       36 38 2E 72 
       67 62 61 32 
       00          
043D9D 73 70 72 69 0230*  fn_seeker_176: db "sprites/seeker_176.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       37 36 2E 72 
       67 62 61 32 
       00          
043DB6 73 70 72 69 0231*  fn_seeker_184: db "sprites/seeker_184.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       38 34 2E 72 
       67 62 61 32 
       00          
043DCF 73 70 72 69 0232*  fn_seeker_192: db "sprites/seeker_192.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 31 
       39 32 2E 72 
       67 62 61 32 
       00          
043DE8 73 70 72 69 0233*  fn_seeker_200: db "sprites/seeker_200.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       30 30 2E 72 
       67 62 61 32 
       00          
043E01 73 70 72 69 0234*  fn_seeker_208: db "sprites/seeker_208.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       30 38 2E 72 
       67 62 61 32 
       00          
043E1A 73 70 72 69 0235*  fn_seeker_216: db "sprites/seeker_216.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       31 36 2E 72 
       67 62 61 32 
       00          
043E33 73 70 72 69 0236*  fn_seeker_224: db "sprites/seeker_224.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       32 34 2E 72 
       67 62 61 32 
       00          
043E4C 73 70 72 69 0237*  fn_seeker_232: db "sprites/seeker_232.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       33 32 2E 72 
       67 62 61 32 
       00          
043E65 73 70 72 69 0238*  fn_seeker_240: db "sprites/seeker_240.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       34 30 2E 72 
       67 62 61 32 
       00          
043E7E 73 70 72 69 0239*  fn_seeker_248: db "sprites/seeker_248.rgba2",0
       74 65 73 2F 
       73 65 65 6B 
       65 72 5F 32 
       34 38 2E 72 
       67 62 61 32 
       00          
043E97 73 70 72 69 0240*  fn_ship_0l: db "sprites/ship_0l.rgba2",0
       74 65 73 2F 
       73 68 69 70 
       5F 30 6C 2E 
       72 67 62 61 
       32 00       
043EAD 73 70 72 69 0241*  fn_ship_1c: db "sprites/ship_1c.rgba2",0
       74 65 73 2F 
       73 68 69 70 
       5F 31 63 2E 
       72 67 62 61 
       32 00       
043EC3 73 70 72 69 0242*  fn_ship_2r: db "sprites/ship_2r.rgba2",0
       74 65 73 2F 
       73 68 69 70 
       5F 32 72 2E 
       72 67 62 61 
       32 00       
043ED9 73 70 72 69 0243*  fn_ship_small: db "sprites/ship_small.rgba2",0
       74 65 73 2F 
       73 68 69 70 
       5F 73 6D 61 
       6C 6C 2E 72 
       67 62 61 32 
       00          
043EF2 73 70 72 69 0244*  fn_star: db "sprites/star.rgba2",0
       74 65 73 2F 
       73 74 61 72 
       2E 72 67 62 
       61 32 00    
043F05 73 70 72 69 0245*  fn_turret_000: db "sprites/turret_000.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       30 30 2E 72 
       67 62 61 32 
       00          
043F1E 73 70 72 69 0246*  fn_turret_008: db "sprites/turret_008.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       30 38 2E 72 
       67 62 61 32 
       00          
043F37 73 70 72 69 0247*  fn_turret_016: db "sprites/turret_016.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       31 36 2E 72 
       67 62 61 32 
       00          
043F50 73 70 72 69 0248*  fn_turret_024: db "sprites/turret_024.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       32 34 2E 72 
       67 62 61 32 
       00          
043F69 73 70 72 69 0249*  fn_turret_032: db "sprites/turret_032.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       33 32 2E 72 
       67 62 61 32 
       00          
043F82 73 70 72 69 0250*  fn_turret_040: db "sprites/turret_040.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       34 30 2E 72 
       67 62 61 32 
       00          
043F9B 73 70 72 69 0251*  fn_turret_048: db "sprites/turret_048.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       34 38 2E 72 
       67 62 61 32 
       00          
043FB4 73 70 72 69 0252*  fn_turret_056: db "sprites/turret_056.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       35 36 2E 72 
       67 62 61 32 
       00          
043FCD 73 70 72 69 0253*  fn_turret_064: db "sprites/turret_064.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       36 34 2E 72 
       67 62 61 32 
       00          
043FE6 73 70 72 69 0254*  fn_turret_072: db "sprites/turret_072.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       37 32 2E 72 
       67 62 61 32 
       00          
043FFF 73 70 72 69 0255*  fn_turret_080: db "sprites/turret_080.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       38 30 2E 72 
       67 62 61 32 
       00          
044018 73 70 72 69 0256*  fn_turret_088: db "sprites/turret_088.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       38 38 2E 72 
       67 62 61 32 
       00          
044031 73 70 72 69 0257*  fn_turret_096: db "sprites/turret_096.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 30 
       39 36 2E 72 
       67 62 61 32 
       00          
04404A 73 70 72 69 0258*  fn_turret_104: db "sprites/turret_104.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       30 34 2E 72 
       67 62 61 32 
       00          
044063 73 70 72 69 0259*  fn_turret_112: db "sprites/turret_112.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       31 32 2E 72 
       67 62 61 32 
       00          
04407C 73 70 72 69 0260*  fn_turret_120: db "sprites/turret_120.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       32 30 2E 72 
       67 62 61 32 
       00          
044095 73 70 72 69 0261*  fn_turret_128: db "sprites/turret_128.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       32 38 2E 72 
       67 62 61 32 
       00          
0440AE 73 70 72 69 0262*  fn_turret_136: db "sprites/turret_136.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       33 36 2E 72 
       67 62 61 32 
       00          
0440C7 73 70 72 69 0263*  fn_turret_144: db "sprites/turret_144.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       34 34 2E 72 
       67 62 61 32 
       00          
0440E0 73 70 72 69 0264*  fn_turret_152: db "sprites/turret_152.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       35 32 2E 72 
       67 62 61 32 
       00          
0440F9 73 70 72 69 0265*  fn_turret_160: db "sprites/turret_160.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       36 30 2E 72 
       67 62 61 32 
       00          
044112 73 70 72 69 0266*  fn_turret_168: db "sprites/turret_168.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       36 38 2E 72 
       67 62 61 32 
       00          
04412B 73 70 72 69 0267*  fn_turret_176: db "sprites/turret_176.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       37 36 2E 72 
       67 62 61 32 
       00          
044144 73 70 72 69 0268*  fn_turret_184: db "sprites/turret_184.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       38 34 2E 72 
       67 62 61 32 
       00          
04415D 73 70 72 69 0269*  fn_turret_192: db "sprites/turret_192.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 31 
       39 32 2E 72 
       67 62 61 32 
       00          
044176 73 70 72 69 0270*  fn_turret_200: db "sprites/turret_200.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       30 30 2E 72 
       67 62 61 32 
       00          
04418F 73 70 72 69 0271*  fn_turret_208: db "sprites/turret_208.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       30 38 2E 72 
       67 62 61 32 
       00          
0441A8 73 70 72 69 0272*  fn_turret_216: db "sprites/turret_216.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       31 36 2E 72 
       67 62 61 32 
       00          
0441C1 73 70 72 69 0273*  fn_turret_224: db "sprites/turret_224.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       32 34 2E 72 
       67 62 61 32 
       00          
0441DA 73 70 72 69 0274*  fn_turret_232: db "sprites/turret_232.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       33 32 2E 72 
       67 62 61 32 
       00          
0441F3 73 70 72 69 0275*  fn_turret_240: db "sprites/turret_240.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       34 30 2E 72 
       67 62 61 32 
       00          
04420C 73 70 72 69 0276*  fn_turret_248: db "sprites/turret_248.rgba2",0
       74 65 73 2F 
       74 75 72 72 
       65 74 5F 32 
       34 38 2E 72 
       67 62 61 32 
       00          
044225             0071   	include "images_ui.inc"
044225             0001*  ; Generated by make_images.py
044225             0002*  
044225             0003*  ui_num_images: equ 2
044225             0004*  
044225             0005*  ; buffer_ids:
044225             0006*  BUF_SPLASH_BG: equ 0
044225             0007*  BUF_SPLASH_LOGO: equ 1
044225             0008*  
044225             0009*  ui_image_list: ; type; width; height; filename; bufferId:
044225 01 00 00 40 0010*  	dl 1, 320, 240, 76800, fn_splash_bg, 0
       01 00 F0 00 
       00 00 2C 01 
       49 42 04 00 
       00 00       
044237 01 00 00 40 0011*  	dl 1, 320, 212, 67840, fn_splash_logo, 1
       01 00 D4 00 
       00 00 09 01 
       5C 42 04 01 
       00 00       
044249             0012*  
044249             0013*  ; files_list: ; filename:
044249 75 69 2F 73 0014*  fn_splash_bg: db "ui/splash_bg.rgba2",0
       70 6C 61 73 
       68 5F 62 67 
       2E 72 67 62 
       61 32 00    
04425C 75 69 2F 73 0015*  fn_splash_logo: db "ui/splash_logo.rgba2",0
       70 6C 61 73 
       68 5F 6C 6F 
       67 6F 2E 72 
       67 62 61 32 
       00          
044271             0072   	include "files.inc"
044271             0001*  ; load to onboard 8k sram
044271             0002*  filedata: equ 0xB7E000; Directory object structure (DIR)
044271             0073   
044271 57 65 6C 63 0074   hello_world: asciz "Welcome to Purple Nurples!"
       6F 6D 65 20 
       74 6F 20 50 
       75 72 70 6C 
       65 20 4E 75 
       72 70 6C 65 
       73 21 00    
04428C 4C 6F 61 64 0075   loading_ui: asciz "Loading UI"
       69 6E 67 20 
       55 49 00    
044297 4C 6F 61 64 0076   loading_time: asciz "Loading time:"
       69 6E 67 20 
       74 69 6D 65 
       3A 00       
0442A5 50 72 65 73 0077   loading_complete: asciz "Press any key to continue."
       73 20 61 6E 
       79 20 6B 65 
       79 20 74 6F 
       20 63 6F 6E 
       74 69 6E 75 
       65 2E 00    
0442C0             0078   
0442C0             0079   init:
0442C0             0080   ; clear all buffers
0442C0 CD DF 1C 04 0081       call vdu_clear_all_buffers
0442C4             0082   
0442C4             0083   ; set up the display
0442C4 3E 88       0084       ld a,8+128 ; 136   320   240   64    60hz double-buffered
0442C6 CD C9 1B 04 0085       call vdu_set_screen_mode
0442CA AF          0086       xor a
0442CB CD DA 1B 04 0087       call vdu_set_scaling
0442CF             0088   
0442CF             0089   ; ; enable additional audio channels
0442CF             0090   ; 	call vdu_enable_channels
0442CF             0091   
0442CF             0092   ; set text background color
0442CF 3E 84       0093   	ld a,4 + 128
0442D1 CD 31 1B 04 0094   	call vdu_colour_text
0442D5             0095   
0442D5             0096   ; set text foreground color
0442D5 3E 2F       0097   	ld a,47 ; aaaaff lavenderish
0442D7 CD 31 1B 04 0098   	call vdu_colour_text
0442DB             0099   
0442DB             0100   ; set gfx bg color
0442DB AF          0101   	xor a ; plotting mode 0
0442DC 0E 84       0102   	ld c,4+128 ; dark blue bg
0442DE CD 42 1B 04 0103   	call vdu_gcol
0442E2 CD 13 1B 04 0104   	call vdu_clg
0442E6             0105   
0442E6             0106   ; set the cursor off
0442E6 CD C8 1A 04 0107   	call vdu_cursor_off
0442EA             0108   
0442EA             0109   ; VDU 28, left, bottom, right, top: Set text viewport **
0442EA             0110   ; MIND THE LITTLE-ENDIANESS
0442EA             0111   ; inputs: c=left,b=bottom,e=right,d=top
0442EA 0E 00       0112   	ld c,0 ; left
0442EC 16 1D       0113   	ld d,29 ; top
0442EE 1E 27       0114   	ld e,39 ; right
0442F0 06 1D       0115   	ld b,29; bottom
0442F2 CD 59 1B 04 0116   	call vdu_set_txt_viewport
0442F6             0117   
0442F6             0118   ; print loading ui message
0442F6 21 8C 42 04 0119   	ld hl,loading_ui
0442FA CD BC 16 04 0120   	call printString
0442FE CD 05 1B 04 0121   	call vdu_flip
044302             0122   
044302             0123   ; load UI images
044302 CD 43 32 04 0124   	call load_ui_images
044306             0125   
044306             0126   ; ; load fonts ; TODO
044306             0127   ; 	call load_font_rc
044306             0128   
044306             0129   ; load sprites
044306 CD F0 32 04 0130   	call img_load_init ; sets up the animated load screen
04430A CD 5E 32 04 0131   	call load_sprite_images
04430E             0132   
04430E             0133   ; ; load sound effects ; TODO
04430E             0134   ; 	ld bc,SFX_num_buffers
04430E             0135   ; 	ld hl,SFX_buffer_id_lut
04430E             0136   ; 	ld (cur_buffer_id_lut),hl
04430E             0137   ; 	ld hl,SFX_load_routines_table
04430E             0138   ; 	ld (cur_load_jump_table),hl
04430E             0139   ; 	call sfx_load_main
04430E             0140   
04430E             0141   ; print loading complete message and wait for user keypress
04430E CD 00 1B 04 0142   	call vdu_cls
044312 21 A5 42 04 0143   	ld hl,loading_complete
044316 CD BC 16 04 0144   	call printString
04431A CD 05 1B 04 0145   	call vdu_flip
04431E CD 38 1A 04 0146   	call waitKeypress
044322             0147   
044322             0148   ; set up display for gameplay
044322             0149       ; ld a,8
044322 3E 14       0150   	ld a,20
044324 CD C9 1B 04 0151       call vdu_set_screen_mode
044328 AF          0152       xor a
044329 CD DA 1B 04 0153       call vdu_set_scaling
04432D 01 20 00 00 0154   	ld bc,32
044331 11 10 00 00 0155   	ld de,16
044335 CD 85 1B 04 0156   	call vdu_set_gfx_origin
044339 CD C8 1A 04 0157   	call vdu_cursor_off
04433D             0158   ; set gfx viewport to scrolling window
04433D 01 00 00 00 0159   	ld bc,0
044341 11 00 00 00 0160   	ld de,0
044345 DD 21 FF 00 0161   	ld ix,255
       00          
04434A FD 21 DF 00 0162   	ld iy,239-16
       00          
04434F CD A0 1B 04 0163   	call vdu_set_gfx_viewport
044353             0164   
044353 C9          0165   	ret
044354             0166   
044354             0167   new_game:
044354             0168   ; initialize sprites
044354 CD 7B 16 04 0169   	call sprites_init
044358             0170   
044358             0171   ; initialize the first level
044358 AF          0172   	xor a
044359 32 7E 2D 04 0173   	ld (cur_level),a
04435D CD 06 2E 04 0174   	call init_level
044361             0175   
044361             0176   ; initialize player
044361 CD A4 2C 04 0177   	call player_init
044365             0178   
044365             0179   ; spawn an enemy sprite
044365 06 01       0180   	ld b,table_max_records
044367             0181   @spawn_enemy_loop:
044367 C5          0182   	push bc
044368 CD 53 2F 04 0183   	call enemy_init_from_landing_pad
04436C C1          0184   	pop bc
04436D 10 F8       0185   	djnz @spawn_enemy_loop
04436F             0186   
04436F C9          0187   	ret
044370             0188   
044370             0189   ; ; ###### INITIALIZE GAME #######
044370             0190   ; ; clear the screen
044370             0191   ;     ld a,3
044370             0192   ;     out (81h),a
044370             0193   
044370             0194   ; ; reset the sprite table
044370             0195   ;     xor a
044370             0196   ;     ld (table_active_sprites),a
044370             0197   ;     ld hl,table_limit
044370             0198   ;     ld (table_base),hl
044370             0199   ;     ld (table_pointer),hl
044370             0200   
044370             0201   ; ; draw a starfield over the entire screen
044370             0202   ;     ld b,#50 ; first row of visible screen
044370             0203   ; new_game_draw_stars_loop:
044370             0204   ;     push bc
044370             0205   ;     call draw_stars
044370             0206   ;     pop bc
044370             0207   ;     ld a,#10
044370             0208   ;     add a,b
044370             0209   ;     ld b,a
044370             0210   ;     jr nz,new_game_draw_stars_loop
044370             0211   
044370             0212   ; ; ; print a welcome message
044370             0213   ; ;     ld de,msg_welcome
044370             0214   ; ;     ld hl,#581C
044370             0215   ; ;     ld c,218 ; a bright pastel purple d677e3
044370             0216   ; ;     call print_string
044370             0217   
044370             0218   ; ; push all that to frame buffer
044370             0219   ;     ld a,#01 ; send video to frame buffer
044370             0220   ;     out (81h),a
044370             0221   
044370             0222   ; ; reset score, lives, shields
044370             0223   ;     xor a
044370             0224   ;     ld hl,player_score
044370             0225   ;     ld (hl),a ; player_score 0
044370             0226   ;     inc hl
044370             0227   ;     ld (hl),a ; player_score 1
044370             0228   ;     inc hl
044370             0229   ;     ld (hl),a ; player_score 3
044370             0230   ;     inc hl
044370             0231   ;     ld a,16
044370             0232   ;     ld (hl),a ; player_shields
044370             0233   ;     inc hl
044370             0234   ;     ld (hl),a ; player_max_shields
044370             0235   ;     inc hl
044370             0236   ;     ld a,3
044370             0237   ;     ld (hl),a ; player_ships
044370             0238   ;     inc hl
044370             0239   
044370             0240   ; ; initialize first level
044370             0241   ;     ld a,1 ; levels are zero-based, so this will wrap around
044370             0242   ;     ld (cur_level),a
044370             0243   ;     ld a,3 ; set max enemy sprites to easy street
044370             0244   ;     ; ld a,64 ; DEBUG: BRING IT
044370             0245   ;     ld (max_enemy_sprites),a
044370             0246   ;     call dt_next_level
044370             0247   ;     call dt
044370             0248   
044370             0249   ; ; spawn our intrepid hero
044370             0250   ;     call player_init
044370             0251   
044370             0252   ; ; #### BEGIN GAME VARIABLES ####
044370             0253   speed_seeker: equ 0x000280 ; 2.5 pixels per frame
044370             0254   speed_player: equ 0x000300 ; 3 pixels per frame
044370             0255   
044370             0256   main:
044370             0257   ; start a new game
044370 CD 54 43 04 0258   	call new_game
044374             0259   
044374             0260   main_loop:
044374             0261   ; move the background down one pixel
044374 3E 02       0262   	ld a,2 ; current gfx viewport
044376 2E 02       0263   	ld l,2 ; direction=down
044378 26 01       0264   	ld h,1 ; speed=1 px
04437A CD 18 1B 04 0265   	call vdu_scroll_down
04437E             0266   
04437E             0267   ; scroll tiles
04437E CD 8B 2D 04 0268   	call tiles_plot
044382             0269   
044382             0270   ; get player input and update sprite position
044382 CD E3 2C 04 0271   	call player_input
044386             0272   
044386             0273   ; move enemies
044386 CD 65 2E 04 0274   	call move_enemies
04438A             0275   
04438A             0276   ; wait for the next vblank mitigate flicker and for loop timing
04438A CD 74 1B 04 0277   	call vdu_vblank
04438E             0278   
04438E             0279   ; poll keyboard
04438E 3E 08       0280       ld a, $08                           ; code to send to MOS
044390 5B CF       0281       rst.lil $08                         ; get IX pointer to System Variables
044392             0282   
044392 DD 7E 05    0283       ld a, (ix + $05)                    ; get ASCII code of key pressed
044395 FE 1B       0284       cp 27                               ; check if 27 (ascii code for ESC)
044397 CA 9F 43 04 0285       jp z, main_end                     ; if pressed, jump to exit
04439B             0286   
04439B C3 74 43 04 0287       jp main_loop
04439F             0288   
04439F             0289   main_end:
04439F CD BA 1A 04 0290       call vdu_cursor_on
0443A3 C9          0291   	ret
0443A4             0292   
0443A4             0293   
0443A4             0294   ; ; #### BEGIN GAME MAIN LOOP ####
0443A4             0295   ; main_loop:
0443A4             0296   ; ; ; debug: start execution counter
0443A4             0297   ; ;     ld a,1
0443A4             0298   ; ;     out (#e0),a ; start counting instructions
0443A4             0299   
0443A4             0300   ; ; refresh background from frame buffer
0443A4             0301   ;     ld a,#02
0443A4             0302   ;     out (81h),a
0443A4             0303   ;     call move_background ; now move it
0443A4             0304   ;     ld a,#01
0443A4             0305   ;     out (81h),a ; save it back to buffer
0443A4             0306   ; ; do all the things
0443A4             0307   ;     call move_enemies
0443A4             0308   ;     call player_move
0443A4             0309   ;     call laser_control
0443A4             0310   ;     call print_score
0443A4             0311   ;     call draw_shields
0443A4             0312   ;     call draw_lives
0443A4             0313   ; ; ; debug: stop execution counter and print results
0443A4             0314   ; ;     ld a,0
0443A4             0315   ; ;     out (#e0),a ; stop counting instructions
0443A4             0316   
0443A4             0317   ; ; ; debug: start execution counter
0443A4             0318   ; ;     ld a,1
0443A4             0319   ; ;     out (#e0),a ; start counting instructions
0443A4             0320   
0443A4             0321   ;     call vdu_vblank
0443A4             0322   ; ; ; debug: stop execution counter and print results
0443A4             0323   ; ;     ld a,0
0443A4             0324   ; ;     out (#e0),a ; stop counting instructions
0443A4             0325   
0443A4             0326   ;     jr main_loop
0443A4             0327   ; #### END GAME MAIN LOOP ####
0443A4             0328   
0443A4             0329   ; draws the player's shields level
0443A4             0330   ; draw_shields:
0443A4             0331   ; TODO: Agonize this routine
0443A4             0332   ; ; prep the loop to draw the bars
0443A4             0333   ;     ld a,(player_shields) ; snag shields
0443A4             0334   ;     and a
0443A4             0335   ;     ret z ; don't draw if zero shields
0443A4             0336   ; ; set loop counter and drawing position
0443A4             0337   ;     ld b,a ; loop counter
0443A4             0338   ;     ld hl,#5300+48+12
0443A4             0339   ; ; set color based on bars remaining
0443A4             0340   ;     ld c,103 ; bright green 28fe0a
0443A4             0341   ;     cp 9
0443A4             0342   ;     jp p,draw_shields_loop
0443A4             0343   ;     ld c,74 ; bright yellow eafe5b
0443A4             0344   ;     cp 3
0443A4             0345   ;     jp p,draw_shields_loop
0443A4             0346   ;     ld c,28 ; bright red fe0a0a
0443A4             0347   ; draw_shields_loop:
0443A4             0348   ;     push bc ; yup,outta
0443A4             0349   ;     push hl ; registers again
0443A4             0350   ;     ; ld a,#A8 ; ▀,168
0443A4             0351   ;     ld a,10 ; ▀,168 ; we renumber because we don't use the full charset
0443A4             0352   ;     ; call draw_char
0443A4             0353   ;     call draw_num ; we nuked draw_char for the time being
0443A4             0354   ;     pop hl
0443A4             0355   ;     ld a,8
0443A4             0356   ;     add a,l
0443A4             0357   ;     ld l,a
0443A4             0358   ;     pop bc
0443A4             0359   ;     djnz draw_shields_loop
0443A4             0360       ; ret
0443A4             0361   
0443A4             0362   ; prints the player's score
0443A4             0363   ; print_score:
0443A4             0364   ; TODO: Agonize this
0443A4             0365   ; ; draw score (we do it twice for a totally unecessary drop-shadow effect)
0443A4             0366   ;     ld c,42 ; dark orange b74400
0443A4             0367   ;     ld hl,#5200+1+8+6*6
0443A4             0368   ;     ld a,3 ; print 6 bdc digits
0443A4             0369   ;     ld de,player_score
0443A4             0370   ;     call print_num
0443A4             0371   
0443A4             0372   ;     ld c,58 ; golden yellow fec10a
0443A4             0373   ;     ld hl,#5100+8+6*6
0443A4             0374   ;     ld a,3 ; print 6 bdc digits
0443A4             0375   ;     ld de,player_score
0443A4             0376   ;     call print_num
0443A4             0377       ; ret
0443A4             0378   
0443A4             0379   ; draw_lives:
0443A4             0380   ;     ld hl,player_small ; make small yellow ship the active sprite
0443A4             0381   ;     ld (sprite_base_bufferId),hl
0443A4             0382   ;     ; ld a,#80 ; northern orientation
0443A4             0383   ;     ; ld (sprite_orientation),a
0443A4             0384   ;     ld hl,0 ; north
0443A4             0385   ;     ld (sprite_heading),hl
0443A4             0386   ;     xor a
0443A4             0387   ;     ld (sprite_animation),a
0443A4             0388   ;     ld a,#56 ; top of visible screen
0443A4             0389   ;     ld (sprite_y+1),a
0443A4             0390   ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
0443A4             0391   ;     ld a,(player_ships)
0443A4             0392   ;     dec a ; we draw one fewer ships than lives
0443A4             0393   ;     ret z ; nothing to draw here, move along
0443A4             0394   ;     ld b,a ; loop counter
0443A4             0395   ;     ld a,256-16 ; initial x position
0443A4             0396   ; draw_lives_loop:
0443A4             0397   ;     ld (sprite_x+1),a
0443A4             0398   ;     push af
0443A4             0399   ;     push bc
0443A4             0400   ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
0443A4             0401   ;     pop bc
0443A4             0402   ;     pop af
0443A4             0403   ;     sub 10
0443A4             0404   ;     djnz draw_lives_loop
0443A4             0405   ;     ret
