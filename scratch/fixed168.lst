PC     Output      Line
040000             0001       assume adl=1
040000             0002       org 0x040000
040000 C3 45 00 04 0003       jp start
040004             0004   
040004 FF FF FF FF 0005       align 64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040040 4D 4F 53    0006       db "MOS"
040043 00          0007       db 00h
040044 01          0008       db 01h
040045             0009   
040045             0010   start:
040045 F5          0011       push af
040046 C5          0012       push bc
040047 D5          0013       push de
040048 DD E5       0014       push ix
04004A FD E5       0015       push iy
04004C             0016   
04004C CD 65 0E 04 0017       call init
040050 CD 66 0E 04 0018       call main
040054             0019   
040054             0020   exit:
040054 FD E1       0021       pop iy
040056 DD E1       0022       pop ix
040058 D1          0023       pop de
040059 C1          0024       pop bc
04005A F1          0025       pop af
04005B 21 00 00 00 0026       ld hl,0
04005F             0027   
04005F C9          0028       ret
040060             0029   
040060             0030   ;--- APPLICATION INCLUDES ---
040060             0031       include "fixed168.inc"
040060             0001*  ; multiply HL by 256
040060             0002*  ; inputs: HL
040060             0003*  ; outputs: HL*256
040060             0004*  ; destroys: flags
040060             0005*      MACRO hlu_mul256
040060             0006*          add hl,hl ; * 2
040060             0007*          add hl,hl ; * 4
040060             0008*          add hl,hl ; * 8
040060             0009*          add hl,hl ; * 16
040060             0010*          add hl,hl ; * 32
040060             0011*          add hl,hl ; * 64
040060             0012*          add hl,hl ; * 128
040060             0013*          add hl,hl ; * 256
040060             0014*      ENDMACRO
040060             0015*  
040060             0016*  ; test the sign of HL
040060             0017*  ; inputs: HL obviously
040060             0018*  ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
040060             0019*  ; destroys: flags
040060             0020*      MACRO sign_hlu
040060             0021*          add hl,de
040060             0022*          or a
040060             0023*          sbc hl,de
040060             0024*      ENDMACRO
040060             0025*  
040060             0026*  ; hlu signed division by 256
040060             0027*  ; returns: hlu / 256
040060             0028*  ; destroys: af
040060             0029*  hlu_sdiv256:
040060 AF          0030*      xor a ; assume hl is positive
040061 22 77 00 04 0031*      ld (@buffer),hl
040065             0032*      sign_hlu
040065 19          0001*M         add hl,de
040066 B7          0002*M         or a
040067 ED 52       0003*M         sbc hl,de
040069 F2 6E 00 04 0033*      jp p,@hl_pos
04006D 3D          0034*      dec a
04006E             0035*  @hl_pos:
04006E 32 7A 00 04 0036*      ld (@buffer+3),a
040072 2A 78 00 04 0037*      ld hl,(@buffer+1)
040076 C9          0038*      ret
040077 00 00 00 00 0039*  @buffer: blkb 4,0
04007B             0040*  
04007B             0041*  ; hlu 1 byte right shift, unsigned
04007B             0042*  ; returns: hlu / 256
04007B             0043*  hlu_udiv256:
04007B 22 84 00 04 0044*  	ld (@buffer),hl
04007F 2A 85 00 04 0045*  	ld hl,(@buffer+1)
040083 C9          0046*  	ret
040084 00 00 00 00 0047*  @buffer: blkb 4,0
040088             0048*  
040088             0049*  ; absolute value of hlu
040088             0050*  ; returns: abs(hlu), flags set according to the incoming sign of hlu:
040088             0051*  ;         s1,z0,pv0,n1,c0 if hlu was negative
040088             0052*  ;         s0,z1,pv0,n1,c0 if hlu was zero
040088             0053*  ;         s0,z0,pv0,n1,c0 if hlu was positive
040088             0054*  ; destroys: a
040088             0055*  hlu_abs:
040088 19          0056*      add hl,de
040089 B7          0057*      or a
04008A ED 52       0058*      sbc hl,de
04008C FA 91 00 04 0059*      jp m,@is_neg
040090 C9          0060*      ret         ; hlu is positive or zero so we're done
040091             0061*  @is_neg:
040091 F5          0062*      push af     ; otherwise, save current flags for return
040092 CD 98 00 04 0063*      call neg_hlu ; negate hlu
040096 F1          0064*      pop af      ; get back flags
040097 C9          0065*      ret
040098             0066*  
040098             0067*  ; flip the sign of hlu
040098             0068*  ; inputs: hlu
040098             0069*  ; returns: 0-hlu, flags set appropriately for the result:
040098             0070*  ;         s1,z0,pv0,n1,c1 if result is negative
040098             0071*  ;         s0,z1,pv0,n1,c0 if result is zero
040098             0072*  ;         s0,z0,pv0,n1,c1 if result is positive
040098             0073*  ; destroys a
040098             0074*  neg_hlu:
040098 D5          0075*      push de     ; save de
040099 EB          0076*      ex de,hl    ; put hl into de
04009A 21 00 00 00 0077*      ld hl,0     ; clear hl
04009E AF          0078*      xor a       ; clear carry
04009F ED 52       0079*      sbc hl,de   ; 0-hlu = -hlu
0400A1 D1          0080*      pop de      ; get de back
0400A2 C9          0081*      ret         ; easy peasy
0400A3             0082*  
0400A3             0083*      ; include "fixed24.inc"
0400A3             0084*  
0400A3             0085*  ; multiply a signed 24-bit number by an unsigned 8-bit number giving a signed 24-bit result
0400A3             0086*  ; uses EZ80 MLT instruction for speed
0400A3             0087*  ; operation: UHL * A --> UHL
0400A3             0088*  ; destroys: AF, HL
0400A3             0089*  smul24x8:
0400A3             0090*  ; make hl positive and store sign flag
0400A3 CD 88 00 04 0091*  	call hlu_abs
0400A7 F5          0092*  	push af
0400A8             0093*  ; do the division
0400A8 CD B3 00 04 0094*      call mul24x8 ; hl = product
0400AC             0095*  ; adjust sign of result
0400AC F1          0096*  	pop af ; sign de
0400AD F0          0097*  	ret p ; hl was positive, nothing to do
0400AE CD 98 00 04 0098*  	call neg_hlu ; result is negative
0400B2 C9          0099*  	ret
0400B3             0100*  
0400B3             0101*  ; unsigned multiplication of a 24-bit and 8-bit number giving a 32-bit result
0400B3             0102*  ; uses EZ80 MLT instruction for speed
0400B3             0103*  ; operation: UHL * A --> AUHL
0400B3             0104*  ; destroys: AF, HL
0400B3             0105*  mul24x8:
0400B3 D5          0106*  	push de ; preserve de
0400B4             0107*  ; low byte
0400B4 5D          0108*  	ld e,l
0400B5 57          0109*  	ld d,a
0400B6 ED 5C       0110*  	mlt de
0400B8 6B          0111*  	ld l,e ; product low byte
0400B9 08          0112*  	ex af,af' ; save multiplier
0400BA 7A          0113*  	ld a,d ; carry
0400BB 08          0114*  	ex af,af' ; save carry, restore multiplier
0400BC             0115*  ; high byte
0400BC 5C          0116*  	ld e,h
0400BD 57          0117*  	ld d,a
0400BE ED 5C       0118*  	mlt de
0400C0 08          0119*  	ex af,af' ; save multiplier, restore carry
0400C1 83          0120*  	add a,e ; add carry
0400C2 67          0121*  	ld h,a ; product middle byte
0400C3 7A          0122*  	ld a,d ; carry
0400C4 08          0123*  	ex af,af' ; save carry, restore multiplier
0400C5             0124*  ; upper byte
0400C5 22 E0 00 04 0125*      ld (@scratch),hl ; 7 cycles
0400C9 5F          0126*  	ld e,a
0400CA 3A E2 00 04 0127*  	ld a,(@scratch+2)
0400CE 57          0128*  	ld d,a
0400CF ED 5C       0129*  	mlt de
0400D1 08          0130*  	ex af,af' ; restore carry
0400D2 8B          0131*  	adc a,e ; add carry
0400D3 32 E2 00 04 0132*      ld (@scratch+2),a ; 5 cycles
0400D7 2A E0 00 04 0133*      ld hl,(@scratch) ; 7 cycles
0400DB             0134*  ; highest byte
0400DB 3E 00       0135*  	ld a,0 ; preserve carry flag
0400DD 8A          0136*  	adc a,d ; product highest byte
0400DE D1          0137*  	pop de ; restore de
0400DF C9          0138*  	ret
0400E0             0139*  @scratch: ds 3
0400E3             0140*  
0400E3 00 00 00 00 0141*  mul24out: blkb 6,0
       00 00       
0400E9             0142*  
0400E9             0143*  ; unsigned multiplication of two 24-bit numbers giving a 48-bit result
0400E9             0144*  ; operation: UHL * UDE --> mul24out
0400E9             0145*  mul24:
0400E9 DD E5       0146*  	push ix ; preserve
0400EB             0147*  ; point to output buffer and clear it
0400EB DD 21 E3 00 0148*  	ld ix,mul24out
       04          
0400F0 C5          0149*  	push bc
0400F1 01 00 00 00 0150*  	ld bc,0
0400F5 DD 0F 00    0151*  	ld (ix),bc
0400F8 DD 0F 03    0152*  	ld (ix+3),bc
0400FB C1          0153*  	pop bc
0400FC             0154*  ; STEP 1: UHL * E
0400FC 7B          0155*  	ld a,e
0400FD E5          0156*  	push hl
0400FE CD B3 00 04 0157*  	call mul24x8
040102 DD 2F 00    0158*  	ld (ix+0),hl
040105 DD 77 03    0159*  	ld (ix+3),a
040108             0160*  ; STEP 2: UHL * D
040108 E1          0161*  	pop hl
040109 E5          0162*  	push hl
04010A 7A          0163*  	ld a,d
04010B CD B3 00 04 0164*  	call mul24x8
04010F CD 28 01 04 0165*  	call @accumulate
040113             0166*  ; STEP 3: UHL * DEU
040113 E1          0167*  	pop hl
040114 ED 53 58 01 0168*  	ld (@de),de
       04          
040119 3A 5A 01 04 0169*  	ld a,(@de+2)
04011D CD B3 00 04 0170*  	call mul24x8
040121 CD 28 01 04 0171*  	call @accumulate
040125             0172*  ; all done
040125 DD E1       0173*  	pop ix ; restore
040127 C9          0174*  	ret
040128             0175*  @accumulate:
040128 DD 23       0176*  	inc ix
04012A             0177*  ; highest byte of product to carry
04012A DD 77 03    0178*  	ld (ix+3),a
04012D             0179*  ; low byte of product
04012D 7D          0180*  	ld a,l
04012E DD 86 00    0181*  	add a,(ix+0)
040131 DD 77 00    0182*  	ld (ix+0),a
040134             0183*  ; high byte of product
040134 7C          0184*  	ld a,h
040135 DD 8E 01    0185*  	adc a,(ix+1)
040138 DD 77 01    0186*  	ld (ix+1),a
04013B             0187*  ; uppper byte of product
04013B 22 55 01 04 0188*  	ld (@hl),hl
04013F 3A 57 01 04 0189*  	ld a,(@hl+2)
040143 DD 8E 02    0190*  	adc a,(ix+2)
040146 DD 77 02    0191*  	ld (ix+2),a
040149             0192*  ; carry
040149 3E 00       0193*  	ld a,0 ; preserve flags
04014B DD 8E 03    0194*  	adc a,(ix+3)
04014E DD 77 03    0195*  	ld (ix+3),a
040151 C9          0196*  	ret
040152             0197*  
040152 00 00 00    0198*  @ix: dl 0
040155 00 00 00    0199*  @hl: dl 0
040158 00 00 00    0200*  @de: dl 0
04015B             0201*  
04015B             0202*  ; UHL * UDE --> UHL (unsigned)
04015B             0203*  umul24:
04015B CD E9 00 04 0204*  	call mul24
04015F 2A E3 00 04 0205*  	ld hl,(mul24out)
040163 C9          0206*  	ret
040164             0207*  
040164             0208*  ; UH.L = UH.L*UD.E (unsigned)
040164             0209*  umul168:
040164 CD E9 00 04 0210*  	call mul24
040168 2A E4 00 04 0211*  	ld hl,(mul24out+1)
04016C C9          0212*  	ret
04016D             0213*  
04016D             0214*  ; UH.L * UD.E --> UH.L (signed)
04016D             0215*  smul168:
04016D             0216*  ; make everything positive and store sign flags
04016D CD 88 00 04 0217*  	call hlu_abs
040171 F5          0218*  	push af
040172 EB          0219*  	ex de,hl
040173 CD 88 00 04 0220*  	call hlu_abs
040177 EB          0221*  	ex de,hl
040178 F5          0222*  	push af
040179             0223*  ; do the division
040179 CD 64 01 04 0224*      call umul168 ; hl = product
04017D             0225*  ; adjust sign of result
04017D F1          0226*  	pop af ; sign de
04017E FA 89 01 04 0227*  	jp m,@de_neg
040182 F1          0228*  	pop af ; sign hl
040183 F0          0229*  	ret p ; both positive, nothing to do
040184             0230*  @hl_neg:
040184 CD 98 00 04 0231*      call neg_hlu ; de pos, hl neg, result is negative
040188 C9          0232*      ret
040189             0233*  @de_neg:
040189 F1          0234*  	pop af
04018A F8          0235*  	ret m ; both negative, nothing to do
04018B CD 98 00 04 0236*  	call neg_hlu ; result is negative
04018F C9          0237*  	ret
040190             0238*  
040190             0239*  ; UH.L / UD.E --> UD.E rem UHL (unsigned)
040190             0240*  ; perform unsigned division of 16.8 fixed place values
040190             0241*  ; with an unsigned 16.8 fixed place result and 24-bit remainder
040190             0242*  udiv168:
040190             0243*  ; back up divisor
040190 ED 53 C7 01 0244*  	ld (@ude),de
       04          
040195             0245*  ; get the 16-bit integer part of the quotient
040195 CD F8 01 04 0246*      call udiv24 ; de = quotient, hl = remainder
040199             0247*  ; load quotient to upper three bytes of output
040199 ED 53 CE 01 0248*      ld (div168_out+1),de
       04          
04019E             0249*  @div256:
04019E             0250*  ; multiply remainder by 256
04019E             0251*  	hlu_mul256
04019E 29          0001*M         add hl,hl ; * 2
04019F 29          0002*M         add hl,hl ; * 4
0401A0 29          0003*M         add hl,hl ; * 8
0401A1 29          0004*M         add hl,hl ; * 16
0401A2 29          0005*M         add hl,hl ; * 32
0401A3 29          0006*M         add hl,hl ; * 64
0401A4 29          0007*M         add hl,hl ; * 128
0401A5 29          0008*M         add hl,hl ; * 256
0401A6             0252*  ; skip fractional computation if remainder is zero
0401A6             0253*      sign_hlu
0401A6 19          0001*M         add hl,de
0401A7 B7          0002*M         or a
0401A8 ED 52       0003*M         sbc hl,de
0401AA 20 03       0254*      jr nz,@div_frac
0401AC AF          0255*      xor a
0401AD 18 0A       0256*      jr @write_frac
0401AF             0257*  ; now divide the shifted remainder by the divisor
0401AF             0258*  @div_frac:
0401AF ED 5B C7 01 0259*  	ld de,(@ude) ; get back divisor
       04          
0401B4 CD F8 01 04 0260*      call udiv24 ; de = quotient, hl = remainder
0401B8             0261*  ; load low byte of quotient to low byte of output
0401B8 7B          0262*      ld a,e
0401B9             0263*  @write_frac:
0401B9 32 CD 01 04 0264*      ld (div168_out),a
0401BD             0265*  ; load de with return value
0401BD ED 5B CD 01 0266*      ld de,(div168_out)
       04          
0401C2             0267*  ; load a with any overflow
0401C2 3A D0 01 04 0268*      ld a,(div168_out+3)
0401C6 C9          0269*      ret ; ud.e is the 16.8 result
0401C7             0270*  @ude: ds 6
0401CD             0271*  div168_out: ds 4 ; the extra byte is for overflow
0401D1             0272*  
0401D1             0273*  ; UH.L / UD.E --> UD.E (signed) rem UHL (unsigned)
0401D1             0274*  ; perform signed division of 16.8 fixed place values
0401D1             0275*  ; with a signed 16.8 fixed place result and unsigned 24-bit remainder
0401D1             0276*  sdiv168:
0401D1             0277*  ; make everything positive and store sign flags
0401D1 CD 88 00 04 0278*  	call hlu_abs
0401D5 F5          0279*  	push af
0401D6 EB          0280*  	ex de,hl
0401D7 CD 88 00 04 0281*  	call hlu_abs
0401DB EB          0282*  	ex de,hl
0401DC F5          0283*  	push af
0401DD             0284*  ; do the division
0401DD CD 90 01 04 0285*      call udiv168 ; de = quotient, hl = remainder
0401E1             0286*  ; adjust sign of result
0401E1 F1          0287*  	pop af ; sign de
0401E2 FA EF 01 04 0288*  	jp m,@de_neg
0401E6 F1          0289*  	pop af ; sign hl
0401E7 F0          0290*  	ret p ; both positive, nothing to do
0401E8             0291*  @hl_neg:
0401E8 EB          0292*      ex de,hl ; hl = quotient, de = remainder
0401E9 CD 98 00 04 0293*      call neg_hlu ; de pos, hl neg, result is negative
0401ED EB          0294*      ex de,hl ; de = negated quotient, hl = remainder
0401EE C9          0295*      ret
0401EF             0296*  @de_neg:
0401EF F1          0297*  	pop af
0401F0 F8          0298*  	ret m ; both negative, nothing to do
0401F1 EB          0299*      ex de,hl ; hl = quotient, de = remainder
0401F2 CD 98 00 04 0300*  	call neg_hlu ; result is negative
0401F6 EB          0301*      ex de,hl ; de = negated quotient, hl = remainder
0401F7 C9          0302*  	ret
0401F8             0303*  
0401F8             0304*  ;------------------------------------------------------------------------
0401F8             0305*  ;  arith24.asm
0401F8             0306*  ;  24-bit ez80 arithmetic routines
0401F8             0307*  ;  Copyright (c) Shawn Sijnstra 2024
0401F8             0308*  ;  MIT license
0401F8             0309*  ;
0401F8             0310*  ;  This library was created as a tool to help make ez80
0401F8             0311*  ;  24-bit native assembly routines for simple mathematical problems
0401F8             0312*  ;  more widely available.
0401F8             0313*  ;
0401F8             0314*  ;------------------------------------------------------------------------
0401F8             0315*  ;
0401F8             0316*  ;------------------------------------------------------------------------
0401F8             0317*  ; udiv24
0401F8             0318*  ; Unsigned 24-bit division
0401F8             0319*  ; Divides HLU by DEU. Gives result in DEU (and BC), remainder in HLU.
0401F8             0320*  ;
0401F8             0321*  ; Uses AF BC DE HL
0401F8             0322*  ; Uses Restoring Division algorithm
0401F8             0323*  ;------------------------------------------------------------------------
0401F8             0324*  
0401F8             0325*  udiv24:
0401F8 E5          0326*  	push	hl
0401F9 C1          0327*  	pop		bc	;move dividend to BCU
0401FA 21 00 00 00 0328*  	ld		hl,0	;result
0401FE A7          0329*  	and		a
0401FF ED 52       0330*  	sbc		hl,de	;test for div by 0
040201 C8          0331*  	ret		z		;it's zero, carry flag is clear
040202 19          0332*  	add		hl,de	;HL is 0 again
040203 3E 18       0333*  	ld		a,24	;number of loops through.
040205             0334*  udiv1:
040205 C5          0335*  	push	bc	;complicated way of doing this because of lack of access to top bits
040206 E3          0336*  	ex		(sp),hl
040207 37          0337*  	scf
040208 ED 6A       0338*  	adc	hl,hl
04020A E3          0339*  	ex	(sp),hl
04020B C1          0340*  	pop	bc		;we now have bc = (bc * 2) + 1
04020C             0341*  
04020C ED 6A       0342*  	adc	hl,hl
04020E A7          0343*  	and	a		;is this the bug
04020F ED 52       0344*  	sbc	hl,de
040211 30 02       0345*  	jr	nc,udiv2
040213 19          0346*  	add	hl,de
040214             0347*  ;	dec	c
040214 0B          0348*  	dec	bc
040215             0349*  udiv2:
040215 3D          0350*  	dec	a
040216 20 ED       0351*  	jr	nz,udiv1
040218 37          0352*  	scf		;flag used for div0 error
040219 C5          0353*  	push	bc
04021A D1          0354*  	pop		de	;remainder
04021B C9          0355*  	ret
04021C             0356*  
04021C             0357*  ;------------------------------------------------------------------------
04021C             0358*  ;  END 24-bit ez80 arithmetic routines by Shawn Sijnstra
04021C             0359*  ;------------------------------------------------------------------------
04021C             0360*  
04021C             0361*  
04021C             0362*      ; include "trig24fast.inc"
04021C             0363*  
04021C             0364*  
04021C             0365*  ; convert signed angles from a 360 to 256 degree circle
04021C             0366*  ; inputs: uh.l is the angle360 in 16.8 fixed format
04021C             0367*  ; outputs: uh.l is the angle256 in 16.8 fixed format
04021C             0368*  ; destroys: TODO
04021C             0369*  deg_360_to_256:
04021C D5          0370*  	push de ; preserve de
04021D             0371*  ; make angle positive and store sign flag
04021D CD 88 00 04 0372*  	call hlu_abs
040221 F5          0373*  	push af
040222             0374*  ; multiply by coversion factor of 256/360
040222 11 B6 00 00 0375*  	ld de,0x0000B6 ; 0.711
040226 CD 64 01 04 0376*  	call umul168 ; uh.l = uh.l * 0.711
04022A             0377*  ; restore sign flag and adjust output accordingly
04022A F1          0378*  	pop af
04022B F2 33 02 04 0379*  	jp p,@pos ; positive number
04022F CD 98 00 04 0380*  	call neg_hlu
040233             0381*  @pos:
040233             0382*  ; restore de and return uh.l as the result
040233 D1          0383*  	pop de
040234 C9          0384*  	ret
040235             0385*  
040235             0386*  ; convert signed angles from a 256 to 360 degree circle
040235             0387*  ; inputs: uh.l is the angle256 in 16.8 fixed format
040235             0388*  ; outputs: uh.l is the angle360 in 16.8 fixed format
040235             0389*  ; destroys: TODO
040235             0390*  deg_256_to_360:
040235 D5          0391*  	push de ; preserve de
040236             0392*  ; make angle positive and store sign flag
040236 CD 88 00 04 0393*  	call hlu_abs
04023A F5          0394*  	push af
04023B             0395*  ; multiply by coversion factor of 360/256
04023B 11 68 01 00 0396*      ld de,0x000168 ; 1.406
04023F CD 64 01 04 0397*  	call umul168 ; uh.l = uh.l * 1.406
040243             0398*  ; restore sign flag and adjust output accordingly
040243 F1          0399*  	pop af
040244 F2 4C 02 04 0400*  	jp p,@pos ; positive number
040248 CD 98 00 04 0401*  	call neg_hlu
04024C             0402*  @pos:
04024C             0403*  ; restore de and return uh.l as the result
04024C D1          0404*  	pop de
04024D C9          0405*  	ret
04024E             0406*  
04024E             0407*  ; fixed 16.8 routine
04024E             0408*  ; cos(uh.l) --> uh.l
04024E             0409*  ; destroys: f, hl
04024E             0410*  cos168:
04024E D5          0411*      push de ; preserve de
04024F             0412*  ; for cos we simply increment the angle by 90 degrees
04024F             0413*  ; or 0x004000 in 16.8 degrees256
04024F             0414*  ; which makes it a sin problem
04024F 11 00 40 00 0415*      ld de,0x004000
040253 19          0416*      add hl,de ; modulo 256 happens below
040254 D1          0417*      pop de ; restore de
040255             0418*  ; fall through to sin168
040255             0419*  
040255             0420*  ; ---------------------
040255             0421*  ; fixed 16.8 routine
040255             0422*  ; sin(uh.l) --> uh.l
040255             0423*  ; destroys: f, hl
040255             0424*  sin168:
040255 D5          0425*  	push de
040256             0426*  ; handle negative angles appropriately
040256 CD 88 00 04 0427*  	call hlu_abs
04025A F2 63 02 04 0428*  	jp p,@F
04025E 11 00 00 FF 0429*  	ld de,-256*256
040262 19          0430*  	add hl,de
040263             0431*  @@:
040263 2E 03       0432*  	ld l,3 ; multiply by 3 to get our lookup index
040265 ED 6C       0433*      mlt hl
040267 11 B2 04 04 0434*      ld de,sin_lut_168 ; grab the lut address
04026B 19          0435*      add hl,de ; bump hl by the index
04026C ED 27       0436*      ld hl,(hl) ; don't try this on a z80!
04026E D1          0437*      pop de
04026F C9          0438*      ret
040270             0439*  
040270             0440*  ; 16.8 fixed inputs / outputs
040270             0441*  ; takes: uh.l as angle in degrees 256
040270             0442*  ;        ud.e as radius
040270             0443*  ; returns ub.c as dx, ud.e as dy, uh.l as radius
040270             0444*  ;        displacements from origin (0,0)
040270             0445*  ; destroys: everything except indexes
040270             0446*  polar_to_cartesian:
040270             0447*  ; back up input parameters
040270 22 9F 02 04 0448*      ld (@angle), hl
040274 ED 53 A2 02 0449*      ld (@radius), de
       04          
040279             0450*  ; compute dx = sin(uh.l) * ud.e
040279 CD 55 02 04 0451*      call sin168 ; uh.l = sin(uh.l)
04027D ED 5B A2 02 0452*  	ld de,(@radius)
       04          
040282 CD 6D 01 04 0453*  	call smul168 ; uh.l = dx
040286 E5          0454*      push hl
040287             0455*  ; compute dy = -cos(uh.l) * ud.e
040287 2A 9F 02 04 0456*      ld hl,(@angle)
04028B CD 4E 02 04 0457*      call cos168 ; uh.l = cos(uh.l)
04028F ED 5B A2 02 0458*      ld de,(@radius)
       04          
040294 CD 6D 01 04 0459*      call smul168    ; uh.l = dy
040298 CD 98 00 04 0460*      call neg_hlu ; invert dy for screen coords convention
04029C EB          0461*      ex de,hl       ; de = dy for output
04029D C1          0462*      pop bc          ; bc = dx for output
04029E             0463*  ; and out
04029E C9          0464*      ret
04029F             0465*  @angle: ds 3
0402A2             0466*  @radius: ds 3
0402A5             0467*  
0402A5             0468*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
0402A5             0469*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
0402A5             0470*  ; output: ub.c and ud.e are dx and dy in 16.8 fixed format
0402A5             0471*  ;         also populates scratch locations dx168 and dy168
0402A5             0472*  ; destroys: a,hl,bc,de
0402A5             0473*  dxy168:
0402A5             0474*  ; compute dx = x1-x0
0402A5 AF          0475*      xor a ; clear carry
0402A6 DD E5       0476*      push ix ; move ix to hl via the stack
0402A8 E1          0477*      pop hl ; hl = x1
0402A9 ED 42       0478*      sbc hl,bc ; hl = dx
0402AB 22 C0 02 04 0479*      ld (dx168),hl ; dx to scratch
0402AF             0480*  ; compute dy = y1-y0
0402AF AF          0481*      xor a ; clear carry
0402B0 FD E5       0482*      push iy ; move iy to hl via the stack
0402B2 E1          0483*      pop hl ; hl = y1
0402B3 ED 52       0484*      sbc hl,de ; hl = dy
0402B5 22 C6 02 04 0485*      ld (dy168),hl ; dy to scratch
0402B9             0486*  ; populate output registers and return
0402B9 EB          0487*      ex de,hl        ; ud.e = dy
0402BA ED 4B C0 02 0488*      ld bc,(dx168)   ; ub.c = dx
       04          
0402BF C9          0489*      ret
0402C0 00 00 00 00 0490*  dx168: blkb 6,0
       00 00       
0402C6 00 00 00 00 0491*  dy168: blkb 6,0
       00 00       
0402CC             0492*  
0402CC             0493*  ; compute the euclidian distance between two cartesian coordinates
0402CC             0494*  ; using the formula d = sqrt(dx^2+dy^2)
0402CC             0495*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
0402CC             0496*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
0402CC             0497*  ; output; uh.l is the 16.8 fixed format distance
0402CC             0498*  ;         also populates scratch locations dx168 and dy168
0402CC             0499*  ; destroys: a,hl,bc,de
0402CC             0500*  ; NOTE: rounds both deltas down to the nearest integer to avoid overflow when squaring,
0402CC             0501*  ;       thus the result will always be an integer, albeit in 16.8 format
0402CC             0502*  distance168:
0402CC CD A5 02 04 0503*  	call dxy168 ; ub.c = dx, ud.e = dy
0402D0             0504*  ; compute dy^2
0402D0 EB          0505*  	ex de,hl
0402D1 CD 88 00 04 0506*  	call hlu_abs
0402D5 CD 7B 00 04 0507*  	call hlu_udiv256 ; make integer to avoid overflow
0402D9 E5          0508*  	push hl
0402DA D1          0509*  	pop de
0402DB CD 5B 01 04 0510*  	call umul24 ; hl = dy^2
0402DF E5          0511*  	push hl ; save dy^2
0402E0             0512*  ; compute dx^2
0402E0 2A C0 02 04 0513*  	ld hl,(dx168)
0402E4 CD 88 00 04 0514*  	call hlu_abs
0402E8 CD 7B 00 04 0515*  	call hlu_udiv256 ; make integer to avoid overflow
0402EC E5          0516*  	push hl
0402ED D1          0517*  	pop de
0402EE CD 5B 01 04 0518*  	call umul24 ; hl = dx^2
0402F2             0519*  ; add dx^2 and dy^2
0402F2 D1          0520*  	pop de ; de = dy^2 (was hl)
0402F3 19          0521*  	add hl,de ; hl = dx^2 + dy^2
0402F4             0522*  ; compute the square root
0402F4 CD CD 03 04 0523*  	call sqrt24 ; de = sqrt(dx^2 + dy^2)
0402F8 EB          0524*      ex de,hl ; hl = distance
0402F9             0525*      hlu_mul256 ; convert back to 16.8 fixed
0402F9 29          0001*M         add hl,hl ; * 2
0402FA 29          0002*M         add hl,hl ; * 4
0402FB 29          0003*M         add hl,hl ; * 8
0402FC 29          0004*M         add hl,hl ; * 16
0402FD 29          0005*M         add hl,hl ; * 32
0402FE 29          0006*M         add hl,hl ; * 64
0402FF 29          0007*M         add hl,hl ; * 128
040300 29          0008*M         add hl,hl ; * 256
040301 C9          0526*  	ret
040302             0527*  
040302             0528*  ; atan2_(ub.c,ud.e) --> uh.l
040302             0529*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
040302             0530*  ;   whether inputs are integers or fractional doesn't matter
040302             0531*  ;   so long as the sign bit of the upper byte is correct
040302             0532*  ; output: uh.l is the 16.8 fixed angle in degrees 256
040302             0533*  ; angles are COMPASS HEADINGS based on
040302             0534*  ; screen coordinate conventions,where the y axis is flipped
040302             0535*  ; #E0 315      0       45 #20
040302             0536*  ;        -x,-y | +x,-y
040302             0537*  ; #C0 270------+------ 90 #40
040302             0538*  ;        -x,+y | +x,+y
040302             0539*  ; #A0 225   180 #80   135 #60
040302             0540*  atan2_168fast:
040302             0541*  ; get signs and make everything positive
040302             0542*  ; get abs(x) and store its original sign
040302 C5          0543*      push bc
040303 E1          0544*      pop hl
040304 CD 88 00 04 0545*      call hlu_abs ; if x was negative this also sets the sign flag
040308 E5          0546*      push hl ; store abs(x)
040309 C1          0547*      pop bc ; bc = abs(x)
04030A F5          0548*      push af ; store sign of x
04030B             0549*  ; get abs(y) and store its original sign
04030B EB          0550*      ex de,hl ; hl = y
04030C CD 88 00 04 0551*      call hlu_abs ; if y was negative this also sets the sign flag
040310 EB          0552*      ex de,hl ; de = abs(y)
040311 F5          0553*      push af ; store sign of y
040312             0554*  ; if abs(bc) < abs(de),then we do bc/de,otherwise de/bc
040312             0555*  ; this ensures that our lookup value is between 0 and 1 inclusive
040312 AF          0556*      xor a ; clear the carry flag
040313 D5          0557*      push de
040314 E1          0558*      pop hl
040315 ED 42       0559*      sbc hl,bc
040317 F5          0560*      push af ; save sign of de - bc
040318 F2 21 03 04 0561*      jp p,@1 ; bc <= de, so we skip ahead
04031C             0562*  ; otherwise we swap bc and de
04031C C5          0563*      push bc
04031D E1          0564*      pop hl
04031E EB          0565*      ex de,hl
04031F E5          0566*      push hl
040320 C1          0567*      pop bc
040321             0568*  @1:
040321             0569*  ; now we're ready to snag our preliminary result
040321 C5          0570*  	push bc
040322 E1          0571*  	pop hl
040323 CD 91 03 04 0572*      call atan_168fast ; uh.l comes back with prelim result
040327             0573*  ; now we adjust uh.l based on sign of de - bc
040327 F1          0574*      pop af
040328 F2 34 03 04 0575*      jp p,@2 ; bc <= de,so we skip ahead
04032C EB          0576*      ex de,hl
04032D 21 00 40 00 0577*      ld hl,0x004000 ; 90 degrees
040331 AF          0578*      xor a ; clear the carry flag
040332 ED 52       0579*      sbc hl,de ; subtract result from 90 degrees
040334             0580*  @2:
040334             0581*  ; now the fun part of adjusting the result
040334             0582*  ; based on which quadrant (x,y) is in
040334             0583*  ; #E0 315      0       45 #20
040334             0584*  ;        -x,-y | +x,-y
040334             0585*  ; #C0 270------+------ 90 #40
040334             0586*  ;        -x,+y | +x,+y
040334             0587*  ; #A0 225   180 #80   135 #60
040334 F1          0588*      pop af ; sign of y
040335 CA 72 03 04 0589*      jp z,@y_zero
040339 F2 52 03 04 0590*      jp p,@y_pos
04033D             0591*  ; y neg,check x
04033D F1          0592*      pop af ; sign of x
04033E CA 4C 03 04 0593*      jp z,@y_neg_x_zero
040342 F2 51 03 04 0594*      jp p,@y_neg_x_pos
040346             0595*  ; y neg,x neg
040346             0596*  ; angle is 270-360
040346             0597*  ; negating the intermediate does the trick
040346 CD 98 00 04 0598*      call neg_hlu
04034A 18 31       0599*      jr @zero_hlu
04034C             0600*  
04034C             0601*  @y_neg_x_zero:
04034C             0602*  ; y neg,x zero
04034C             0603*  ; angle is 0
04034C 21 00 00 00 0604*      ld hl,0
040350 C9          0605*      ret
040351             0606*  @y_neg_x_pos:
040351             0607*  ; y neg,x pos
040351             0608*  ; angle is 0 to 90
040351             0609*  ; so we're good
040351 C9          0610*      ret
040352             0611*  
040352             0612*  @y_pos:
040352 F1          0613*      pop af ; sign of x
040353 CA 62 03 04 0614*      jp z,@y_pos_x_zero
040357 F2 67 03 04 0615*      jp p,@y_pos_x_pos
04035B             0616*  ; y pos,x neg
04035B             0617*  ; angle is 180-270
04035B             0618*  ; so we add 180 to intermediate
04035B 11 00 80 00 0619*      ld de,0x008000
04035F 19          0620*      add hl,de
040360 18 1B       0621*      jr @zero_hlu
040362             0622*  @y_pos_x_zero:
040362             0623*  ; y pos,x zero
040362             0624*  ; angle is 180
040362 21 00 80 00 0625*      ld hl,0x008000
040366 C9          0626*      ret
040367             0627*  @y_pos_x_pos:
040367             0628*  ; y pos,x pos
040367             0629*  ; angle is 90-180
040367             0630*  ; neg the intermediate and add 180 degrees
040367 CD 98 00 04 0631*      call neg_hlu
04036B 11 00 80 00 0632*      ld de,0x008000
04036F 19          0633*      add hl,de
040370 18 0B       0634*      jr @zero_hlu
040372             0635*  
040372             0636*  @y_zero:
040372 F1          0637*      pop af ; sign of x
040373 FA 78 03 04 0638*      jp m,@y_zero_x_neg
040377             0639*  ; y zero,x pos
040377             0640*  ; angle is 90,nothing to do
040377 C9          0641*      ret
040378             0642*  @y_zero_x_neg:
040378             0643*  ; y zero ,x neg
040378             0644*  ; angle is 270
040378 21 00 C0 00 0645*      ld hl,0x00C000
04037C C9          0646*      ret
04037D             0647*  @zero_hlu:
04037D AF          0648*      xor a
04037E 22 8B 03 04 0649*      ld (@scratch),hl
040382 32 8D 03 04 0650*      ld (@scratch+2),a
040386 2A 8B 03 04 0651*      ld hl,(@scratch)
04038A C9          0652*      ret
04038B             0653*  @scratch: ds 6
040391             0654*  
040391             0655*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
040391             0656*  ; output: uh.l is the 16.8 fixed format angle in degrees 256
040391             0657*  ; destroys: a,hl,bc,de
040391             0658*  ; note: only works for angles from 0 to 32 (45) degrees
040391             0659*  ;   use atan2_168fast (which calls this proc) to handle the full 256 (360) degrees
040391             0660*  atan_168fast:
040391             0661*  ; because we use compass headings instead of geometric angles
040391             0662*  ; we compute dx/dy which is 1/tan(theta) in the maths world
040391             0663*  ; we can do faster unsigned division here because we know dx and dy are positive
040391 CD 90 01 04 0664*  	call udiv168 ; ud.e = dx/dy
040395 EB          0665*  	ex de,hl ; uh.l = dx/dy
040396             0666*  ; test uh.l for 0
040396 19          0667*      add hl,de
040397 B7          0668*      or a
040398 ED 52       0669*      sbc hl,de
04039A 28 22       0670*      jr z,@is_zero
04039C             0671*  ; test uh.l for 1
04039C AF          0672*      xor a ; clear carry
04039D EB          0673*      ex de,hl
04039E 21 00 01 00 0674*      ld hl,0x000100 ; 1 in 16.8 fixed format
0403A2 ED 52       0675*      sbc hl,de
0403A4 28 13       0676*      jr z,@is_45
0403A6 EB          0677*  	ex de,hl
0403A7             0678*  ; no special cases so we move on
0403A7             0679*  ; l contains the fractional portion of tan(uh.l)
0403A7             0680*  ; we multiply it by three to get our lookup table index
0403A7 26 03       0681*      ld h,3
0403A9 ED 6C       0682*      mlt hl ; gosh that is handy
0403AB 11 00 00 00 0683*      ld de,0 ; clear deu
0403AF 54          0684*      ld d,h ; copy hl to de
0403B0 5D          0685*      ld e,l ; de contains our index
0403B1 21 B5 07 04 0686*      ld hl,atan_lut_168 ; grab the lut address
0403B5 19          0687*      add hl,de ; bump hl by the index
0403B6 ED 27       0688*      ld hl,(hl) ; don't try this on a z80!
0403B8 C9          0689*      ret ; and out
0403B9             0690*  @is_45:
0403B9 21 00 20 00 0691*      ld hl,0x002000 ; 45 degrees decimal
0403BD C9          0692*      ret
0403BE             0693*  ; for the case tan(0)
0403BE             0694*  @is_zero:
0403BE 21 00 00 00 0695*      ld hl,0x000000
0403C2 C9          0696*      ret
0403C3             0697*  
0403C3             0698*  ; Expects  ADL mode
0403C3             0699*  ; Inputs:  UH.L
0403C3             0700*  ; Outputs: UH.L is the 16.8 square root
0403C3             0701*  ;          UDE is the integer difference inputHL-DE^2
0403C3             0702*  sqrt168:
0403C3 CD CD 03 04 0703*      call sqrt24
0403C7 EB          0704*      ex de,hl
0403C8 29          0705*      add hl,hl
0403C9 29          0706*      add hl,hl
0403CA 29          0707*      add hl,hl
0403CB 29          0708*      add hl,hl
0403CC C9          0709*      ret
0403CD             0710*  
0403CD             0711*  ; credit: xeda112358
0403CD             0712*  ; https://www.cemetech.net/forum/viewtopic.php?t=11178&postdays=0&postorder=asc&start=0
0403CD             0713*  sqrt24:
0403CD             0714*  ; Expects ADL mode
0403CD             0715*  ; Inputs: HL
0403CD             0716*  ; Outputs: DE is the integer square root
0403CD             0717*  ;  HL is the difference inputHL-DE^2
0403CD             0718*  ;  c flag reset
0403CD 01 00 00 00 0719*  	ld bc,0 ; clear bcu
0403D1 11 00 00 00 0720*  	ld de,0 ; clear deu
0403D5 AF          0721*      xor a
0403D6 45          0722*      ld b,l
0403D7 C5          0723*      push bc
0403D8 6F          0724*      ld l,a
0403D9             0725*  ; Iteration 1
0403D9 29          0726*      add hl,hl
0403DA CB 11       0727*      rl c
0403DC 29          0728*      add hl,hl
0403DD CB 11       0729*      rl c
0403DF 91          0730*      sub c
0403E0 30 04       0731*      jr nc,$+6
0403E2 1C          0732*      inc e
0403E3 1C          0733*      inc e
0403E4 2F          0734*      cpl
0403E5 4F          0735*      ld c,a
0403E6             0736*  ; Iteration 2
0403E6 29          0737*      add hl,hl
0403E7 CB 11       0738*      rl c
0403E9 29          0739*      add hl,hl
0403EA CB 11       0740*      rl c
0403EC CB 13       0741*      rl e
0403EE 7B          0742*      ld a,e
0403EF 91          0743*      sub c
0403F0 30 04       0744*      jr nc,$+6
0403F2 1C          0745*      inc e
0403F3 1C          0746*      inc e
0403F4 2F          0747*      cpl
0403F5 4F          0748*      ld c,a
0403F6             0749*  ; Iteration 3
0403F6 29          0750*      add hl,hl
0403F7 CB 11       0751*      rl c
0403F9 29          0752*      add hl,hl
0403FA CB 11       0753*      rl c
0403FC CB 13       0754*      rl e
0403FE 7B          0755*      ld a,e
0403FF 91          0756*      sub c
040400 30 04       0757*      jr nc,$+6
040402 1C          0758*      inc e
040403 1C          0759*      inc e
040404 2F          0760*      cpl
040405 4F          0761*      ld c,a
040406             0762*  ; Iteration 4
040406 29          0763*      add hl,hl
040407 CB 11       0764*      rl c
040409 29          0765*      add hl,hl
04040A CB 11       0766*      rl c
04040C CB 13       0767*      rl e
04040E 7B          0768*      ld a,e
04040F 91          0769*      sub c
040410 30 04       0770*      jr nc,$+6
040412 1C          0771*      inc e
040413 1C          0772*      inc e
040414 2F          0773*      cpl
040415 4F          0774*      ld c,a
040416             0775*  ; Iteration 5
040416 29          0776*      add hl,hl
040417 CB 11       0777*      rl c
040419 29          0778*      add hl,hl
04041A CB 11       0779*      rl c
04041C CB 13       0780*      rl e
04041E 7B          0781*      ld a,e
04041F 91          0782*      sub c
040420 30 04       0783*      jr nc,$+6
040422 1C          0784*      inc e
040423 1C          0785*      inc e
040424 2F          0786*      cpl
040425 4F          0787*      ld c,a
040426             0788*  ; Iteration 6
040426 29          0789*      add hl,hl
040427 CB 11       0790*      rl c
040429 29          0791*      add hl,hl
04042A CB 11       0792*      rl c
04042C CB 13       0793*      rl e
04042E 7B          0794*      ld a,e
04042F 91          0795*      sub c
040430 30 04       0796*      jr nc,$+6
040432 1C          0797*      inc e
040433 1C          0798*      inc e
040434 2F          0799*      cpl
040435 4F          0800*      ld c,a
040436             0801*  ; Iteration 7
040436 29          0802*      add hl,hl
040437 CB 11       0803*      rl c
040439 29          0804*      add hl,hl
04043A CB 11       0805*      rl c
04043C CB 10       0806*      rl b
04043E EB          0807*      ex de,hl
04043F 29          0808*      add hl,hl
040440 E5          0809*      push hl
040441 ED 42       0810*      sbc hl,bc
040443 30 06       0811*      jr nc,$+8
040445 7C          0812*      ld a,h
040446 2F          0813*      cpl
040447 47          0814*      ld b,a
040448 7D          0815*      ld a,l
040449 2F          0816*      cpl
04044A 4F          0817*      ld c,a
04044B E1          0818*      pop hl
04044C 30 02       0819*      jr nc,$+4
04044E 23          0820*      inc hl
04044F 23          0821*      inc hl
040450 EB          0822*      ex de,hl
040451             0823*  ; Iteration 8
040451 29          0824*      add hl,hl
040452 69          0825*      ld l,c
040453 60          0826*      ld h,b
040454 ED 6A       0827*      adc hl,hl
040456 ED 6A       0828*      adc hl,hl
040458 EB          0829*      ex de,hl
040459 29          0830*      add hl,hl
04045A ED 52       0831*      sbc hl,de
04045C 19          0832*      add hl,de
04045D EB          0833*      ex de,hl
04045E 30 04       0834*      jr nc,$+6
040460 ED 52       0835*      sbc hl,de
040462 13          0836*      inc de
040463 13          0837*      inc de
040464             0838*  ; Iteration 9
040464 F1          0839*      pop af
040465 17          0840*      rla
040466 ED 6A       0841*      adc hl,hl
040468 17          0842*      rla
040469 ED 6A       0843*      adc hl,hl
04046B EB          0844*      ex de,hl
04046C 29          0845*      add hl,hl
04046D ED 52       0846*      sbc hl,de
04046F 19          0847*      add hl,de
040470 EB          0848*      ex de,hl
040471 30 04       0849*      jr nc,$+6
040473 ED 52       0850*      sbc hl,de
040475 13          0851*      inc de
040476 13          0852*      inc de
040477             0853*  ; Iteration 10
040477 17          0854*      rla
040478 ED 6A       0855*      adc hl,hl
04047A 17          0856*      rla
04047B ED 6A       0857*      adc hl,hl
04047D EB          0858*      ex de,hl
04047E 29          0859*      add hl,hl
04047F ED 52       0860*      sbc hl,de
040481 19          0861*      add hl,de
040482 EB          0862*      ex de,hl
040483 30 04       0863*      jr nc,$+6
040485 ED 52       0864*      sbc hl,de
040487 13          0865*      inc de
040488 13          0866*      inc de
040489             0867*  ; Iteration 11
040489 17          0868*      rla
04048A ED 6A       0869*      adc hl,hl
04048C 17          0870*      rla
04048D ED 6A       0871*      adc hl,hl
04048F EB          0872*      ex de,hl
040490 29          0873*      add hl,hl
040491 ED 52       0874*      sbc hl,de
040493 19          0875*      add hl,de
040494 EB          0876*      ex de,hl
040495 30 04       0877*      jr nc,$+6
040497 ED 52       0878*      sbc hl,de
040499 13          0879*      inc de
04049A 13          0880*      inc de
04049B             0881*  ; Iteration 12
04049B 17          0882*      rla
04049C ED 6A       0883*      adc hl,hl
04049E 17          0884*      rla
04049F ED 6A       0885*      adc hl,hl
0404A1 EB          0886*      ex de,hl
0404A2 29          0887*      add hl,hl
0404A3 ED 52       0888*      sbc hl,de
0404A5 19          0889*      add hl,de
0404A6 EB          0890*      ex de,hl
0404A7 30 04       0891*      jr nc,$+6
0404A9 ED 52       0892*      sbc hl,de
0404AB 13          0893*      inc de
0404AC 13          0894*      inc de
0404AD CB 1A       0895*      rr d
0404AF CB 1B       0896*      rr e
0404B1 C9          0897*      ret
0404B2             0898*  
0404B2             0899*  sin_lut_168:
0404B2 00 00 00    0900*  	dl 0x000000 ; 0.000 00, 0.000
0404B5 06 00 00    0901*  	dl 0x000006 ; 1.406 01, 0.025
0404B8 0C 00 00    0902*  	dl 0x00000C ; 2.813 02, 0.049
0404BB 12 00 00    0903*  	dl 0x000012 ; 4.219 03, 0.074
0404BE 19 00 00    0904*  	dl 0x000019 ; 5.625 04, 0.098
0404C1 1F 00 00    0905*  	dl 0x00001F ; 7.031 05, 0.122
0404C4 25 00 00    0906*  	dl 0x000025 ; 8.438 06, 0.147
0404C7 2B 00 00    0907*  	dl 0x00002B ; 9.844 07, 0.171
0404CA 31 00 00    0908*  	dl 0x000031 ; 11.250 08, 0.195
0404CD 38 00 00    0909*  	dl 0x000038 ; 12.656 09, 0.219
0404D0 3E 00 00    0910*  	dl 0x00003E ; 14.063 0A, 0.243
0404D3 44 00 00    0911*  	dl 0x000044 ; 15.469 0B, 0.267
0404D6 4A 00 00    0912*  	dl 0x00004A ; 16.875 0C, 0.290
0404D9 50 00 00    0913*  	dl 0x000050 ; 18.281 0D, 0.314
0404DC 56 00 00    0914*  	dl 0x000056 ; 19.688 0E, 0.337
0404DF 5C 00 00    0915*  	dl 0x00005C ; 21.094 0F, 0.360
0404E2 61 00 00    0916*  	dl 0x000061 ; 22.500 10, 0.383
0404E5 67 00 00    0917*  	dl 0x000067 ; 23.906 11, 0.405
0404E8 6D 00 00    0918*  	dl 0x00006D ; 25.313 12, 0.428
0404EB 73 00 00    0919*  	dl 0x000073 ; 26.719 13, 0.450
0404EE 78 00 00    0920*  	dl 0x000078 ; 28.125 14, 0.471
0404F1 7E 00 00    0921*  	dl 0x00007E ; 29.531 15, 0.493
0404F4 83 00 00    0922*  	dl 0x000083 ; 30.938 16, 0.514
0404F7 88 00 00    0923*  	dl 0x000088 ; 32.344 17, 0.535
0404FA 8E 00 00    0924*  	dl 0x00008E ; 33.750 18, 0.556
0404FD 93 00 00    0925*  	dl 0x000093 ; 35.156 19, 0.576
040500 98 00 00    0926*  	dl 0x000098 ; 36.563 1A, 0.596
040503 9D 00 00    0927*  	dl 0x00009D ; 37.969 1B, 0.615
040506 A2 00 00    0928*  	dl 0x0000A2 ; 39.375 1C, 0.634
040509 A7 00 00    0929*  	dl 0x0000A7 ; 40.781 1D, 0.653
04050C AB 00 00    0930*  	dl 0x0000AB ; 42.188 1E, 0.672
04050F B0 00 00    0931*  	dl 0x0000B0 ; 43.594 1F, 0.690
040512 B5 00 00    0932*  	dl 0x0000B5 ; 45.000 20, 0.707
040515 B9 00 00    0933*  	dl 0x0000B9 ; 46.406 21, 0.724
040518 BD 00 00    0934*  	dl 0x0000BD ; 47.813 22, 0.741
04051B C1 00 00    0935*  	dl 0x0000C1 ; 49.219 23, 0.757
04051E C5 00 00    0936*  	dl 0x0000C5 ; 50.625 24, 0.773
040521 C9 00 00    0937*  	dl 0x0000C9 ; 52.031 25, 0.788
040524 CD 00 00    0938*  	dl 0x0000CD ; 53.438 26, 0.803
040527 D1 00 00    0939*  	dl 0x0000D1 ; 54.844 27, 0.818
04052A D4 00 00    0940*  	dl 0x0000D4 ; 56.250 28, 0.831
04052D D8 00 00    0941*  	dl 0x0000D8 ; 57.656 29, 0.845
040530 DB 00 00    0942*  	dl 0x0000DB ; 59.063 2A, 0.858
040533 DE 00 00    0943*  	dl 0x0000DE ; 60.469 2B, 0.870
040536 E1 00 00    0944*  	dl 0x0000E1 ; 61.875 2C, 0.882
040539 E4 00 00    0945*  	dl 0x0000E4 ; 63.281 2D, 0.893
04053C E7 00 00    0946*  	dl 0x0000E7 ; 64.688 2E, 0.904
04053F EA 00 00    0947*  	dl 0x0000EA ; 66.094 2F, 0.914
040542 EC 00 00    0948*  	dl 0x0000EC ; 67.500 30, 0.924
040545 EE 00 00    0949*  	dl 0x0000EE ; 68.906 31, 0.933
040548 F1 00 00    0950*  	dl 0x0000F1 ; 70.313 32, 0.942
04054B F3 00 00    0951*  	dl 0x0000F3 ; 71.719 33, 0.950
04054E F4 00 00    0952*  	dl 0x0000F4 ; 73.125 34, 0.957
040551 F6 00 00    0953*  	dl 0x0000F6 ; 74.531 35, 0.964
040554 F8 00 00    0954*  	dl 0x0000F8 ; 75.938 36, 0.970
040557 F9 00 00    0955*  	dl 0x0000F9 ; 77.344 37, 0.976
04055A FB 00 00    0956*  	dl 0x0000FB ; 78.750 38, 0.981
04055D FC 00 00    0957*  	dl 0x0000FC ; 80.156 39, 0.985
040560 FD 00 00    0958*  	dl 0x0000FD ; 81.563 3A, 0.989
040563 FE 00 00    0959*  	dl 0x0000FE ; 82.969 3B, 0.992
040566 FE 00 00    0960*  	dl 0x0000FE ; 84.375 3C, 0.995
040569 FF 00 00    0961*  	dl 0x0000FF ; 85.781 3D, 0.997
04056C FF 00 00    0962*  	dl 0x0000FF ; 87.188 3E, 0.999
04056F FF 00 00    0963*  	dl 0x0000FF ; 88.594 3F, 1.000
040572 00 01 00    0964*  	dl 0x000100 ; 90.000 40, 1.000
040575 FF 00 00    0965*  	dl 0x0000FF ; 91.406 41, 1.000
040578 FF 00 00    0966*  	dl 0x0000FF ; 92.813 42, 0.999
04057B FF 00 00    0967*  	dl 0x0000FF ; 94.219 43, 0.997
04057E FE 00 00    0968*  	dl 0x0000FE ; 95.625 44, 0.995
040581 FE 00 00    0969*  	dl 0x0000FE ; 97.031 45, 0.992
040584 FD 00 00    0970*  	dl 0x0000FD ; 98.438 46, 0.989
040587 FC 00 00    0971*  	dl 0x0000FC ; 99.844 47, 0.985
04058A FB 00 00    0972*  	dl 0x0000FB ; 101.250 48, 0.981
04058D F9 00 00    0973*  	dl 0x0000F9 ; 102.656 49, 0.976
040590 F8 00 00    0974*  	dl 0x0000F8 ; 104.063 4A, 0.970
040593 F6 00 00    0975*  	dl 0x0000F6 ; 105.469 4B, 0.964
040596 F4 00 00    0976*  	dl 0x0000F4 ; 106.875 4C, 0.957
040599 F3 00 00    0977*  	dl 0x0000F3 ; 108.281 4D, 0.950
04059C F1 00 00    0978*  	dl 0x0000F1 ; 109.688 4E, 0.942
04059F EE 00 00    0979*  	dl 0x0000EE ; 111.094 4F, 0.933
0405A2 EC 00 00    0980*  	dl 0x0000EC ; 112.500 50, 0.924
0405A5 EA 00 00    0981*  	dl 0x0000EA ; 113.906 51, 0.914
0405A8 E7 00 00    0982*  	dl 0x0000E7 ; 115.313 52, 0.904
0405AB E4 00 00    0983*  	dl 0x0000E4 ; 116.719 53, 0.893
0405AE E1 00 00    0984*  	dl 0x0000E1 ; 118.125 54, 0.882
0405B1 DE 00 00    0985*  	dl 0x0000DE ; 119.531 55, 0.870
0405B4 DB 00 00    0986*  	dl 0x0000DB ; 120.938 56, 0.858
0405B7 D8 00 00    0987*  	dl 0x0000D8 ; 122.344 57, 0.845
0405BA D4 00 00    0988*  	dl 0x0000D4 ; 123.750 58, 0.831
0405BD D1 00 00    0989*  	dl 0x0000D1 ; 125.156 59, 0.818
0405C0 CD 00 00    0990*  	dl 0x0000CD ; 126.563 5A, 0.803
0405C3 C9 00 00    0991*  	dl 0x0000C9 ; 127.969 5B, 0.788
0405C6 C5 00 00    0992*  	dl 0x0000C5 ; 129.375 5C, 0.773
0405C9 C1 00 00    0993*  	dl 0x0000C1 ; 130.781 5D, 0.757
0405CC BD 00 00    0994*  	dl 0x0000BD ; 132.188 5E, 0.741
0405CF B9 00 00    0995*  	dl 0x0000B9 ; 133.594 5F, 0.724
0405D2 B5 00 00    0996*  	dl 0x0000B5 ; 135.000 60, 0.707
0405D5 B0 00 00    0997*  	dl 0x0000B0 ; 136.406 61, 0.690
0405D8 AB 00 00    0998*  	dl 0x0000AB ; 137.813 62, 0.672
0405DB A7 00 00    0999*  	dl 0x0000A7 ; 139.219 63, 0.653
0405DE A2 00 00    1000*  	dl 0x0000A2 ; 140.625 64, 0.634
0405E1 9D 00 00    1001*  	dl 0x00009D ; 142.031 65, 0.615
0405E4 98 00 00    1002*  	dl 0x000098 ; 143.438 66, 0.596
0405E7 93 00 00    1003*  	dl 0x000093 ; 144.844 67, 0.576
0405EA 8E 00 00    1004*  	dl 0x00008E ; 146.250 68, 0.556
0405ED 88 00 00    1005*  	dl 0x000088 ; 147.656 69, 0.535
0405F0 83 00 00    1006*  	dl 0x000083 ; 149.063 6A, 0.514
0405F3 7E 00 00    1007*  	dl 0x00007E ; 150.469 6B, 0.493
0405F6 78 00 00    1008*  	dl 0x000078 ; 151.875 6C, 0.471
0405F9 73 00 00    1009*  	dl 0x000073 ; 153.281 6D, 0.450
0405FC 6D 00 00    1010*  	dl 0x00006D ; 154.688 6E, 0.428
0405FF 67 00 00    1011*  	dl 0x000067 ; 156.094 6F, 0.405
040602 61 00 00    1012*  	dl 0x000061 ; 157.500 70, 0.383
040605 5C 00 00    1013*  	dl 0x00005C ; 158.906 71, 0.360
040608 56 00 00    1014*  	dl 0x000056 ; 160.313 72, 0.337
04060B 50 00 00    1015*  	dl 0x000050 ; 161.719 73, 0.314
04060E 4A 00 00    1016*  	dl 0x00004A ; 163.125 74, 0.290
040611 44 00 00    1017*  	dl 0x000044 ; 164.531 75, 0.267
040614 3E 00 00    1018*  	dl 0x00003E ; 165.938 76, 0.243
040617 38 00 00    1019*  	dl 0x000038 ; 167.344 77, 0.219
04061A 31 00 00    1020*  	dl 0x000031 ; 168.750 78, 0.195
04061D 2B 00 00    1021*  	dl 0x00002B ; 170.156 79, 0.171
040620 25 00 00    1022*  	dl 0x000025 ; 171.563 7A, 0.147
040623 1F 00 00    1023*  	dl 0x00001F ; 172.969 7B, 0.122
040626 19 00 00    1024*  	dl 0x000019 ; 174.375 7C, 0.098
040629 12 00 00    1025*  	dl 0x000012 ; 175.781 7D, 0.074
04062C 0C 00 00    1026*  	dl 0x00000C ; 177.188 7E, 0.049
04062F 06 00 00    1027*  	dl 0x000006 ; 178.594 7F, 0.025
040632 00 00 00    1028*  	dl 0x000000 ; 180.000 80, 0.000
040635 FA FF FF    1029*  	dl 0xFFFFFA ; 181.406 81, -0.025
040638 F4 FF FF    1030*  	dl 0xFFFFF4 ; 182.813 82, -0.049
04063B EE FF FF    1031*  	dl 0xFFFFEE ; 184.219 83, -0.074
04063E E7 FF FF    1032*  	dl 0xFFFFE7 ; 185.625 84, -0.098
040641 E1 FF FF    1033*  	dl 0xFFFFE1 ; 187.031 85, -0.122
040644 DB FF FF    1034*  	dl 0xFFFFDB ; 188.438 86, -0.147
040647 D5 FF FF    1035*  	dl 0xFFFFD5 ; 189.844 87, -0.171
04064A CF FF FF    1036*  	dl 0xFFFFCF ; 191.250 88, -0.195
04064D C8 FF FF    1037*  	dl 0xFFFFC8 ; 192.656 89, -0.219
040650 C2 FF FF    1038*  	dl 0xFFFFC2 ; 194.063 8A, -0.243
040653 BC FF FF    1039*  	dl 0xFFFFBC ; 195.469 8B, -0.267
040656 B6 FF FF    1040*  	dl 0xFFFFB6 ; 196.875 8C, -0.290
040659 B0 FF FF    1041*  	dl 0xFFFFB0 ; 198.281 8D, -0.314
04065C AA FF FF    1042*  	dl 0xFFFFAA ; 199.688 8E, -0.337
04065F A4 FF FF    1043*  	dl 0xFFFFA4 ; 201.094 8F, -0.360
040662 9F FF FF    1044*  	dl 0xFFFF9F ; 202.500 90, -0.383
040665 99 FF FF    1045*  	dl 0xFFFF99 ; 203.906 91, -0.405
040668 93 FF FF    1046*  	dl 0xFFFF93 ; 205.313 92, -0.428
04066B 8D FF FF    1047*  	dl 0xFFFF8D ; 206.719 93, -0.450
04066E 88 FF FF    1048*  	dl 0xFFFF88 ; 208.125 94, -0.471
040671 82 FF FF    1049*  	dl 0xFFFF82 ; 209.531 95, -0.493
040674 7D FF FF    1050*  	dl 0xFFFF7D ; 210.938 96, -0.514
040677 78 FF FF    1051*  	dl 0xFFFF78 ; 212.344 97, -0.535
04067A 72 FF FF    1052*  	dl 0xFFFF72 ; 213.750 98, -0.556
04067D 6D FF FF    1053*  	dl 0xFFFF6D ; 215.156 99, -0.576
040680 68 FF FF    1054*  	dl 0xFFFF68 ; 216.563 9A, -0.596
040683 63 FF FF    1055*  	dl 0xFFFF63 ; 217.969 9B, -0.615
040686 5E FF FF    1056*  	dl 0xFFFF5E ; 219.375 9C, -0.634
040689 59 FF FF    1057*  	dl 0xFFFF59 ; 220.781 9D, -0.653
04068C 55 FF FF    1058*  	dl 0xFFFF55 ; 222.188 9E, -0.672
04068F 50 FF FF    1059*  	dl 0xFFFF50 ; 223.594 9F, -0.690
040692 4B FF FF    1060*  	dl 0xFFFF4B ; 225.000 A0, -0.707
040695 47 FF FF    1061*  	dl 0xFFFF47 ; 226.406 A1, -0.724
040698 43 FF FF    1062*  	dl 0xFFFF43 ; 227.813 A2, -0.741
04069B 3F FF FF    1063*  	dl 0xFFFF3F ; 229.219 A3, -0.757
04069E 3B FF FF    1064*  	dl 0xFFFF3B ; 230.625 A4, -0.773
0406A1 37 FF FF    1065*  	dl 0xFFFF37 ; 232.031 A5, -0.788
0406A4 33 FF FF    1066*  	dl 0xFFFF33 ; 233.438 A6, -0.803
0406A7 2F FF FF    1067*  	dl 0xFFFF2F ; 234.844 A7, -0.818
0406AA 2C FF FF    1068*  	dl 0xFFFF2C ; 236.250 A8, -0.831
0406AD 28 FF FF    1069*  	dl 0xFFFF28 ; 237.656 A9, -0.845
0406B0 25 FF FF    1070*  	dl 0xFFFF25 ; 239.063 AA, -0.858
0406B3 22 FF FF    1071*  	dl 0xFFFF22 ; 240.469 AB, -0.870
0406B6 1F FF FF    1072*  	dl 0xFFFF1F ; 241.875 AC, -0.882
0406B9 1C FF FF    1073*  	dl 0xFFFF1C ; 243.281 AD, -0.893
0406BC 19 FF FF    1074*  	dl 0xFFFF19 ; 244.688 AE, -0.904
0406BF 16 FF FF    1075*  	dl 0xFFFF16 ; 246.094 AF, -0.914
0406C2 14 FF FF    1076*  	dl 0xFFFF14 ; 247.500 B0, -0.924
0406C5 12 FF FF    1077*  	dl 0xFFFF12 ; 248.906 B1, -0.933
0406C8 0F FF FF    1078*  	dl 0xFFFF0F ; 250.313 B2, -0.942
0406CB 0D FF FF    1079*  	dl 0xFFFF0D ; 251.719 B3, -0.950
0406CE 0C FF FF    1080*  	dl 0xFFFF0C ; 253.125 B4, -0.957
0406D1 0A FF FF    1081*  	dl 0xFFFF0A ; 254.531 B5, -0.964
0406D4 08 FF FF    1082*  	dl 0xFFFF08 ; 255.938 B6, -0.970
0406D7 07 FF FF    1083*  	dl 0xFFFF07 ; 257.344 B7, -0.976
0406DA 05 FF FF    1084*  	dl 0xFFFF05 ; 258.750 B8, -0.981
0406DD 04 FF FF    1085*  	dl 0xFFFF04 ; 260.156 B9, -0.985
0406E0 03 FF FF    1086*  	dl 0xFFFF03 ; 261.563 BA, -0.989
0406E3 02 FF FF    1087*  	dl 0xFFFF02 ; 262.969 BB, -0.992
0406E6 02 FF FF    1088*  	dl 0xFFFF02 ; 264.375 BC, -0.995
0406E9 01 FF FF    1089*  	dl 0xFFFF01 ; 265.781 BD, -0.997
0406EC 01 FF FF    1090*  	dl 0xFFFF01 ; 267.188 BE, -0.999
0406EF 01 FF FF    1091*  	dl 0xFFFF01 ; 268.594 BF, -1.000
0406F2 00 FF FF    1092*  	dl 0xFFFF00 ; 270.000 C0, -1.000
0406F5 01 FF FF    1093*  	dl 0xFFFF01 ; 271.406 C1, -1.000
0406F8 01 FF FF    1094*  	dl 0xFFFF01 ; 272.813 C2, -0.999
0406FB 01 FF FF    1095*  	dl 0xFFFF01 ; 274.219 C3, -0.997
0406FE 02 FF FF    1096*  	dl 0xFFFF02 ; 275.625 C4, -0.995
040701 02 FF FF    1097*  	dl 0xFFFF02 ; 277.031 C5, -0.992
040704 03 FF FF    1098*  	dl 0xFFFF03 ; 278.438 C6, -0.989
040707 04 FF FF    1099*  	dl 0xFFFF04 ; 279.844 C7, -0.985
04070A 05 FF FF    1100*  	dl 0xFFFF05 ; 281.250 C8, -0.981
04070D 07 FF FF    1101*  	dl 0xFFFF07 ; 282.656 C9, -0.976
040710 08 FF FF    1102*  	dl 0xFFFF08 ; 284.063 CA, -0.970
040713 0A FF FF    1103*  	dl 0xFFFF0A ; 285.469 CB, -0.964
040716 0C FF FF    1104*  	dl 0xFFFF0C ; 286.875 CC, -0.957
040719 0D FF FF    1105*  	dl 0xFFFF0D ; 288.281 CD, -0.950
04071C 0F FF FF    1106*  	dl 0xFFFF0F ; 289.688 CE, -0.942
04071F 12 FF FF    1107*  	dl 0xFFFF12 ; 291.094 CF, -0.933
040722 14 FF FF    1108*  	dl 0xFFFF14 ; 292.500 D0, -0.924
040725 16 FF FF    1109*  	dl 0xFFFF16 ; 293.906 D1, -0.914
040728 19 FF FF    1110*  	dl 0xFFFF19 ; 295.313 D2, -0.904
04072B 1C FF FF    1111*  	dl 0xFFFF1C ; 296.719 D3, -0.893
04072E 1F FF FF    1112*  	dl 0xFFFF1F ; 298.125 D4, -0.882
040731 22 FF FF    1113*  	dl 0xFFFF22 ; 299.531 D5, -0.870
040734 25 FF FF    1114*  	dl 0xFFFF25 ; 300.938 D6, -0.858
040737 28 FF FF    1115*  	dl 0xFFFF28 ; 302.344 D7, -0.845
04073A 2C FF FF    1116*  	dl 0xFFFF2C ; 303.750 D8, -0.831
04073D 2F FF FF    1117*  	dl 0xFFFF2F ; 305.156 D9, -0.818
040740 33 FF FF    1118*  	dl 0xFFFF33 ; 306.563 DA, -0.803
040743 37 FF FF    1119*  	dl 0xFFFF37 ; 307.969 DB, -0.788
040746 3B FF FF    1120*  	dl 0xFFFF3B ; 309.375 DC, -0.773
040749 3F FF FF    1121*  	dl 0xFFFF3F ; 310.781 DD, -0.757
04074C 43 FF FF    1122*  	dl 0xFFFF43 ; 312.188 DE, -0.741
04074F 47 FF FF    1123*  	dl 0xFFFF47 ; 313.594 DF, -0.724
040752 4B FF FF    1124*  	dl 0xFFFF4B ; 315.000 E0, -0.707
040755 50 FF FF    1125*  	dl 0xFFFF50 ; 316.406 E1, -0.690
040758 55 FF FF    1126*  	dl 0xFFFF55 ; 317.813 E2, -0.672
04075B 59 FF FF    1127*  	dl 0xFFFF59 ; 319.219 E3, -0.653
04075E 5E FF FF    1128*  	dl 0xFFFF5E ; 320.625 E4, -0.634
040761 63 FF FF    1129*  	dl 0xFFFF63 ; 322.031 E5, -0.615
040764 68 FF FF    1130*  	dl 0xFFFF68 ; 323.438 E6, -0.596
040767 6D FF FF    1131*  	dl 0xFFFF6D ; 324.844 E7, -0.576
04076A 72 FF FF    1132*  	dl 0xFFFF72 ; 326.250 E8, -0.556
04076D 78 FF FF    1133*  	dl 0xFFFF78 ; 327.656 E9, -0.535
040770 7D FF FF    1134*  	dl 0xFFFF7D ; 329.063 EA, -0.514
040773 82 FF FF    1135*  	dl 0xFFFF82 ; 330.469 EB, -0.493
040776 88 FF FF    1136*  	dl 0xFFFF88 ; 331.875 EC, -0.471
040779 8D FF FF    1137*  	dl 0xFFFF8D ; 333.281 ED, -0.450
04077C 93 FF FF    1138*  	dl 0xFFFF93 ; 334.688 EE, -0.428
04077F 99 FF FF    1139*  	dl 0xFFFF99 ; 336.094 EF, -0.405
040782 9F FF FF    1140*  	dl 0xFFFF9F ; 337.500 F0, -0.383
040785 A4 FF FF    1141*  	dl 0xFFFFA4 ; 338.906 F1, -0.360
040788 AA FF FF    1142*  	dl 0xFFFFAA ; 340.313 F2, -0.337
04078B B0 FF FF    1143*  	dl 0xFFFFB0 ; 341.719 F3, -0.314
04078E B6 FF FF    1144*  	dl 0xFFFFB6 ; 343.125 F4, -0.290
040791 BC FF FF    1145*  	dl 0xFFFFBC ; 344.531 F5, -0.267
040794 C2 FF FF    1146*  	dl 0xFFFFC2 ; 345.938 F6, -0.243
040797 C8 FF FF    1147*  	dl 0xFFFFC8 ; 347.344 F7, -0.219
04079A CF FF FF    1148*  	dl 0xFFFFCF ; 348.750 F8, -0.195
04079D D5 FF FF    1149*  	dl 0xFFFFD5 ; 350.156 F9, -0.171
0407A0 DB FF FF    1150*  	dl 0xFFFFDB ; 351.563 FA, -0.147
0407A3 E1 FF FF    1151*  	dl 0xFFFFE1 ; 352.969 FB, -0.122
0407A6 E7 FF FF    1152*  	dl 0xFFFFE7 ; 354.375 FC, -0.098
0407A9 EE FF FF    1153*  	dl 0xFFFFEE ; 355.781 FD, -0.074
0407AC F4 FF FF    1154*  	dl 0xFFFFF4 ; 357.188 FE, -0.049
0407AF FA FF FF    1155*  	dl 0xFFFFFA ; 358.594 FF, -0.025
0407B2 00 00 00    1156*  	dl 0x000000 ; 0.000 00, 0.000 for interpolation
0407B5             1157*  
0407B5             1158*  atan_lut_168:
0407B5 00 00 00    1159*  	dl 0x000000 ; 000000, 0.000
0407B8 28 00 00    1160*  	dl 0x000028 ; 000001, 0.224
0407BB 51 00 00    1161*  	dl 0x000051 ; 000002, 0.448
0407BE 7A 00 00    1162*  	dl 0x00007A ; 000003, 0.671
0407C1 A2 00 00    1163*  	dl 0x0000A2 ; 000004, 0.895
0407C4 CB 00 00    1164*  	dl 0x0000CB ; 000005, 1.119
0407C7 F4 00 00    1165*  	dl 0x0000F4 ; 000006, 1.343
0407CA 1D 01 00    1166*  	dl 0x00011D ; 000007, 1.566
0407CD 45 01 00    1167*  	dl 0x000145 ; 000008, 1.790
0407D0 6E 01 00    1168*  	dl 0x00016E ; 000009, 2.013
0407D3 97 01 00    1169*  	dl 0x000197 ; 00000A, 2.237
0407D6 BF 01 00    1170*  	dl 0x0001BF ; 00000B, 2.460
0407D9 E8 01 00    1171*  	dl 0x0001E8 ; 00000C, 2.684
0407DC 11 02 00    1172*  	dl 0x000211 ; 00000D, 2.907
0407DF 39 02 00    1173*  	dl 0x000239 ; 00000E, 3.130
0407E2 62 02 00    1174*  	dl 0x000262 ; 00000F, 3.353
0407E5 8B 02 00    1175*  	dl 0x00028B ; 000010, 3.576
0407E8 B3 02 00    1176*  	dl 0x0002B3 ; 000011, 3.799
0407EB DC 02 00    1177*  	dl 0x0002DC ; 000012, 4.022
0407EE 04 03 00    1178*  	dl 0x000304 ; 000013, 4.245
0407F1 2D 03 00    1179*  	dl 0x00032D ; 000014, 4.467
0407F4 55 03 00    1180*  	dl 0x000355 ; 000015, 4.690
0407F7 7E 03 00    1181*  	dl 0x00037E ; 000016, 4.912
0407FA A6 03 00    1182*  	dl 0x0003A6 ; 000017, 5.134
0407FD CE 03 00    1183*  	dl 0x0003CE ; 000018, 5.356
040800 F7 03 00    1184*  	dl 0x0003F7 ; 000019, 5.578
040803 1F 04 00    1185*  	dl 0x00041F ; 00001A, 5.799
040806 48 04 00    1186*  	dl 0x000448 ; 00001B, 6.021
040809 70 04 00    1187*  	dl 0x000470 ; 00001C, 6.242
04080C 98 04 00    1188*  	dl 0x000498 ; 00001D, 6.463
04080F C0 04 00    1189*  	dl 0x0004C0 ; 00001E, 6.684
040812 E8 04 00    1190*  	dl 0x0004E8 ; 00001F, 6.905
040815 11 05 00    1191*  	dl 0x000511 ; 000020, 7.125
040818 39 05 00    1192*  	dl 0x000539 ; 000021, 7.345
04081B 61 05 00    1193*  	dl 0x000561 ; 000022, 7.565
04081E 89 05 00    1194*  	dl 0x000589 ; 000023, 7.785
040821 B1 05 00    1195*  	dl 0x0005B1 ; 000024, 8.005
040824 D9 05 00    1196*  	dl 0x0005D9 ; 000025, 8.224
040827 01 06 00    1197*  	dl 0x000601 ; 000026, 8.443
04082A 28 06 00    1198*  	dl 0x000628 ; 000027, 8.662
04082D 50 06 00    1199*  	dl 0x000650 ; 000028, 8.881
040830 78 06 00    1200*  	dl 0x000678 ; 000029, 9.099
040833 A0 06 00    1201*  	dl 0x0006A0 ; 00002A, 9.317
040836 C7 06 00    1202*  	dl 0x0006C7 ; 00002B, 9.535
040839 EF 06 00    1203*  	dl 0x0006EF ; 00002C, 9.752
04083C 16 07 00    1204*  	dl 0x000716 ; 00002D, 9.970
04083F 3E 07 00    1205*  	dl 0x00073E ; 00002E, 10.187
040842 65 07 00    1206*  	dl 0x000765 ; 00002F, 10.403
040845 8D 07 00    1207*  	dl 0x00078D ; 000030, 10.620
040848 B4 07 00    1208*  	dl 0x0007B4 ; 000031, 10.836
04084B DB 07 00    1209*  	dl 0x0007DB ; 000032, 11.051
04084E 03 08 00    1210*  	dl 0x000803 ; 000033, 11.267
040851 2A 08 00    1211*  	dl 0x00082A ; 000034, 11.482
040854 51 08 00    1212*  	dl 0x000851 ; 000035, 11.697
040857 78 08 00    1213*  	dl 0x000878 ; 000036, 11.911
04085A 9F 08 00    1214*  	dl 0x00089F ; 000037, 12.125
04085D C6 08 00    1215*  	dl 0x0008C6 ; 000038, 12.339
040860 ED 08 00    1216*  	dl 0x0008ED ; 000039, 12.553
040863 13 09 00    1217*  	dl 0x000913 ; 00003A, 12.766
040866 3A 09 00    1218*  	dl 0x00093A ; 00003B, 12.978
040869 61 09 00    1219*  	dl 0x000961 ; 00003C, 13.191
04086C 87 09 00    1220*  	dl 0x000987 ; 00003D, 13.403
04086F AE 09 00    1221*  	dl 0x0009AE ; 00003E, 13.614
040872 D4 09 00    1222*  	dl 0x0009D4 ; 00003F, 13.825
040875 FB 09 00    1223*  	dl 0x0009FB ; 000040, 14.036
040878 21 0A 00    1224*  	dl 0x000A21 ; 000041, 14.247
04087B 47 0A 00    1225*  	dl 0x000A47 ; 000042, 14.457
04087E 6D 0A 00    1226*  	dl 0x000A6D ; 000043, 14.666
040881 94 0A 00    1227*  	dl 0x000A94 ; 000044, 14.876
040884 BA 0A 00    1228*  	dl 0x000ABA ; 000045, 15.085
040887 E0 0A 00    1229*  	dl 0x000AE0 ; 000046, 15.293
04088A 05 0B 00    1230*  	dl 0x000B05 ; 000047, 15.501
04088D 2B 0B 00    1231*  	dl 0x000B2B ; 000048, 15.709
040890 51 0B 00    1232*  	dl 0x000B51 ; 000049, 15.916
040893 77 0B 00    1233*  	dl 0x000B77 ; 00004A, 16.123
040896 9C 0B 00    1234*  	dl 0x000B9C ; 00004B, 16.329
040899 C2 0B 00    1235*  	dl 0x000BC2 ; 00004C, 16.535
04089C E7 0B 00    1236*  	dl 0x000BE7 ; 00004D, 16.740
04089F 0C 0C 00    1237*  	dl 0x000C0C ; 00004E, 16.945
0408A2 32 0C 00    1238*  	dl 0x000C32 ; 00004F, 17.150
0408A5 57 0C 00    1239*  	dl 0x000C57 ; 000050, 17.354
0408A8 7C 0C 00    1240*  	dl 0x000C7C ; 000051, 17.558
0408AB A1 0C 00    1241*  	dl 0x000CA1 ; 000052, 17.761
0408AE C6 0C 00    1242*  	dl 0x000CC6 ; 000053, 17.964
0408B1 EB 0C 00    1243*  	dl 0x000CEB ; 000054, 18.166
0408B4 0F 0D 00    1244*  	dl 0x000D0F ; 000055, 18.368
0408B7 34 0D 00    1245*  	dl 0x000D34 ; 000056, 18.569
0408BA 58 0D 00    1246*  	dl 0x000D58 ; 000057, 18.770
0408BD 7D 0D 00    1247*  	dl 0x000D7D ; 000058, 18.970
0408C0 A1 0D 00    1248*  	dl 0x000DA1 ; 000059, 19.170
0408C3 C6 0D 00    1249*  	dl 0x000DC6 ; 00005A, 19.370
0408C6 EA 0D 00    1250*  	dl 0x000DEA ; 00005B, 19.569
0408C9 0E 0E 00    1251*  	dl 0x000E0E ; 00005C, 19.767
0408CC 32 0E 00    1252*  	dl 0x000E32 ; 00005D, 19.965
0408CF 56 0E 00    1253*  	dl 0x000E56 ; 00005E, 20.163
0408D2 7A 0E 00    1254*  	dl 0x000E7A ; 00005F, 20.360
0408D5 9E 0E 00    1255*  	dl 0x000E9E ; 000060, 20.556
0408D8 C1 0E 00    1256*  	dl 0x000EC1 ; 000061, 20.752
0408DB E5 0E 00    1257*  	dl 0x000EE5 ; 000062, 20.947
0408DE 08 0F 00    1258*  	dl 0x000F08 ; 000063, 21.142
0408E1 2C 0F 00    1259*  	dl 0x000F2C ; 000064, 21.337
0408E4 4F 0F 00    1260*  	dl 0x000F4F ; 000065, 21.531
0408E7 72 0F 00    1261*  	dl 0x000F72 ; 000066, 21.724
0408EA 95 0F 00    1262*  	dl 0x000F95 ; 000067, 21.917
0408ED B8 0F 00    1263*  	dl 0x000FB8 ; 000068, 22.109
0408F0 DB 0F 00    1264*  	dl 0x000FDB ; 000069, 22.301
0408F3 FE 0F 00    1265*  	dl 0x000FFE ; 00006A, 22.493
0408F6 21 10 00    1266*  	dl 0x001021 ; 00006B, 22.683
0408F9 44 10 00    1267*  	dl 0x001044 ; 00006C, 22.874
0408FC 66 10 00    1268*  	dl 0x001066 ; 00006D, 23.063
0408FF 89 10 00    1269*  	dl 0x001089 ; 00006E, 23.253
040902 AB 10 00    1270*  	dl 0x0010AB ; 00006F, 23.441
040905 CD 10 00    1271*  	dl 0x0010CD ; 000070, 23.629
040908 EF 10 00    1272*  	dl 0x0010EF ; 000071, 23.817
04090B 11 11 00    1273*  	dl 0x001111 ; 000072, 24.004
04090E 33 11 00    1274*  	dl 0x001133 ; 000073, 24.191
040911 55 11 00    1275*  	dl 0x001155 ; 000074, 24.376
040914 77 11 00    1276*  	dl 0x001177 ; 000075, 24.562
040917 99 11 00    1277*  	dl 0x001199 ; 000076, 24.747
04091A BA 11 00    1278*  	dl 0x0011BA ; 000077, 24.931
04091D DC 11 00    1279*  	dl 0x0011DC ; 000078, 25.115
040920 FD 11 00    1280*  	dl 0x0011FD ; 000079, 25.298
040923 1E 12 00    1281*  	dl 0x00121E ; 00007A, 25.481
040926 3F 12 00    1282*  	dl 0x00123F ; 00007B, 25.663
040929 60 12 00    1283*  	dl 0x001260 ; 00007C, 25.844
04092C 81 12 00    1284*  	dl 0x001281 ; 00007D, 26.025
04092F A2 12 00    1285*  	dl 0x0012A2 ; 00007E, 26.206
040932 C3 12 00    1286*  	dl 0x0012C3 ; 00007F, 26.386
040935 E4 12 00    1287*  	dl 0x0012E4 ; 000080, 26.565
040938 04 13 00    1288*  	dl 0x001304 ; 000081, 26.744
04093B 25 13 00    1289*  	dl 0x001325 ; 000082, 26.922
04093E 45 13 00    1290*  	dl 0x001345 ; 000083, 27.100
040941 65 13 00    1291*  	dl 0x001365 ; 000084, 27.277
040944 85 13 00    1292*  	dl 0x001385 ; 000085, 27.453
040947 A5 13 00    1293*  	dl 0x0013A5 ; 000086, 27.629
04094A C5 13 00    1294*  	dl 0x0013C5 ; 000087, 27.805
04094D E5 13 00    1295*  	dl 0x0013E5 ; 000088, 27.979
040950 05 14 00    1296*  	dl 0x001405 ; 000089, 28.154
040953 24 14 00    1297*  	dl 0x001424 ; 00008A, 28.327
040956 44 14 00    1298*  	dl 0x001444 ; 00008B, 28.501
040959 63 14 00    1299*  	dl 0x001463 ; 00008C, 28.673
04095C 83 14 00    1300*  	dl 0x001483 ; 00008D, 28.845
04095F A2 14 00    1301*  	dl 0x0014A2 ; 00008E, 29.017
040962 C1 14 00    1302*  	dl 0x0014C1 ; 00008F, 29.187
040965 E0 14 00    1303*  	dl 0x0014E0 ; 000090, 29.358
040968 FF 14 00    1304*  	dl 0x0014FF ; 000091, 29.527
04096B 1E 15 00    1305*  	dl 0x00151E ; 000092, 29.697
04096E 3C 15 00    1306*  	dl 0x00153C ; 000093, 29.865
040971 5B 15 00    1307*  	dl 0x00155B ; 000094, 30.033
040974 79 15 00    1308*  	dl 0x001579 ; 000095, 30.201
040977 98 15 00    1309*  	dl 0x001598 ; 000096, 30.368
04097A B6 15 00    1310*  	dl 0x0015B6 ; 000097, 30.534
04097D D4 15 00    1311*  	dl 0x0015D4 ; 000098, 30.700
040980 F2 15 00    1312*  	dl 0x0015F2 ; 000099, 30.865
040983 10 16 00    1313*  	dl 0x001610 ; 00009A, 31.030
040986 2E 16 00    1314*  	dl 0x00162E ; 00009B, 31.194
040989 4C 16 00    1315*  	dl 0x00164C ; 00009C, 31.357
04098C 6A 16 00    1316*  	dl 0x00166A ; 00009D, 31.520
04098F 87 16 00    1317*  	dl 0x001687 ; 00009E, 31.682
040992 A5 16 00    1318*  	dl 0x0016A5 ; 00009F, 31.844
040995 C2 16 00    1319*  	dl 0x0016C2 ; 0000A0, 32.005
040998 DF 16 00    1320*  	dl 0x0016DF ; 0000A1, 32.166
04099B FC 16 00    1321*  	dl 0x0016FC ; 0000A2, 32.326
04099E 19 17 00    1322*  	dl 0x001719 ; 0000A3, 32.486
0409A1 36 17 00    1323*  	dl 0x001736 ; 0000A4, 32.645
0409A4 53 17 00    1324*  	dl 0x001753 ; 0000A5, 32.803
0409A7 70 17 00    1325*  	dl 0x001770 ; 0000A6, 32.961
0409AA 8C 17 00    1326*  	dl 0x00178C ; 0000A7, 33.118
0409AD A9 17 00    1327*  	dl 0x0017A9 ; 0000A8, 33.275
0409B0 C5 17 00    1328*  	dl 0x0017C5 ; 0000A9, 33.431
0409B3 E2 17 00    1329*  	dl 0x0017E2 ; 0000AA, 33.587
0409B6 FE 17 00    1330*  	dl 0x0017FE ; 0000AB, 33.742
0409B9 1A 18 00    1331*  	dl 0x00181A ; 0000AC, 33.896
0409BC 36 18 00    1332*  	dl 0x001836 ; 0000AD, 34.050
0409BF 52 18 00    1333*  	dl 0x001852 ; 0000AE, 34.203
0409C2 6E 18 00    1334*  	dl 0x00186E ; 0000AF, 34.356
0409C5 8A 18 00    1335*  	dl 0x00188A ; 0000B0, 34.509
0409C8 A5 18 00    1336*  	dl 0x0018A5 ; 0000B1, 34.660
0409CB C1 18 00    1337*  	dl 0x0018C1 ; 0000B2, 34.811
0409CE DC 18 00    1338*  	dl 0x0018DC ; 0000B3, 34.962
0409D1 F7 18 00    1339*  	dl 0x0018F7 ; 0000B4, 35.112
0409D4 13 19 00    1340*  	dl 0x001913 ; 0000B5, 35.262
0409D7 2E 19 00    1341*  	dl 0x00192E ; 0000B6, 35.410
0409DA 49 19 00    1342*  	dl 0x001949 ; 0000B7, 35.559
0409DD 64 19 00    1343*  	dl 0x001964 ; 0000B8, 35.707
0409E0 7F 19 00    1344*  	dl 0x00197F ; 0000B9, 35.854
0409E3 99 19 00    1345*  	dl 0x001999 ; 0000BA, 36.001
0409E6 B4 19 00    1346*  	dl 0x0019B4 ; 0000BB, 36.147
0409E9 CE 19 00    1347*  	dl 0x0019CE ; 0000BC, 36.293
0409EC E9 19 00    1348*  	dl 0x0019E9 ; 0000BD, 36.438
0409EF 03 1A 00    1349*  	dl 0x001A03 ; 0000BE, 36.582
0409F2 1D 1A 00    1350*  	dl 0x001A1D ; 0000BF, 36.726
0409F5 37 1A 00    1351*  	dl 0x001A37 ; 0000C0, 36.870
0409F8 51 1A 00    1352*  	dl 0x001A51 ; 0000C1, 37.013
0409FB 6B 1A 00    1353*  	dl 0x001A6B ; 0000C2, 37.155
0409FE 85 1A 00    1354*  	dl 0x001A85 ; 0000C3, 37.297
040A01 9F 1A 00    1355*  	dl 0x001A9F ; 0000C4, 37.439
040A04 B9 1A 00    1356*  	dl 0x001AB9 ; 0000C5, 37.579
040A07 D2 1A 00    1357*  	dl 0x001AD2 ; 0000C6, 37.720
040A0A EC 1A 00    1358*  	dl 0x001AEC ; 0000C7, 37.859
040A0D 05 1B 00    1359*  	dl 0x001B05 ; 0000C8, 37.999
040A10 1E 1B 00    1360*  	dl 0x001B1E ; 0000C9, 38.137
040A13 37 1B 00    1361*  	dl 0x001B37 ; 0000CA, 38.276
040A16 50 1B 00    1362*  	dl 0x001B50 ; 0000CB, 38.413
040A19 69 1B 00    1363*  	dl 0x001B69 ; 0000CC, 38.550
040A1C 82 1B 00    1364*  	dl 0x001B82 ; 0000CD, 38.687
040A1F 9B 1B 00    1365*  	dl 0x001B9B ; 0000CE, 38.823
040A22 B4 1B 00    1366*  	dl 0x001BB4 ; 0000CF, 38.959
040A25 CC 1B 00    1367*  	dl 0x001BCC ; 0000D0, 39.094
040A28 E5 1B 00    1368*  	dl 0x001BE5 ; 0000D1, 39.228
040A2B FD 1B 00    1369*  	dl 0x001BFD ; 0000D2, 39.362
040A2E 16 1C 00    1370*  	dl 0x001C16 ; 0000D3, 39.496
040A31 2E 1C 00    1371*  	dl 0x001C2E ; 0000D4, 39.629
040A34 46 1C 00    1372*  	dl 0x001C46 ; 0000D5, 39.762
040A37 5E 1C 00    1373*  	dl 0x001C5E ; 0000D6, 39.894
040A3A 76 1C 00    1374*  	dl 0x001C76 ; 0000D7, 40.025
040A3D 8E 1C 00    1375*  	dl 0x001C8E ; 0000D8, 40.156
040A40 A5 1C 00    1376*  	dl 0x001CA5 ; 0000D9, 40.286
040A43 BD 1C 00    1377*  	dl 0x001CBD ; 0000DA, 40.416
040A46 D5 1C 00    1378*  	dl 0x001CD5 ; 0000DB, 40.546
040A49 EC 1C 00    1379*  	dl 0x001CEC ; 0000DC, 40.675
040A4C 04 1D 00    1380*  	dl 0x001D04 ; 0000DD, 40.803
040A4F 1B 1D 00    1381*  	dl 0x001D1B ; 0000DE, 40.931
040A52 32 1D 00    1382*  	dl 0x001D32 ; 0000DF, 41.059
040A55 49 1D 00    1383*  	dl 0x001D49 ; 0000E0, 41.186
040A58 60 1D 00    1384*  	dl 0x001D60 ; 0000E1, 41.312
040A5B 77 1D 00    1385*  	dl 0x001D77 ; 0000E2, 41.438
040A5E 8E 1D 00    1386*  	dl 0x001D8E ; 0000E3, 41.564
040A61 A5 1D 00    1387*  	dl 0x001DA5 ; 0000E4, 41.689
040A64 BB 1D 00    1388*  	dl 0x001DBB ; 0000E5, 41.814
040A67 D2 1D 00    1389*  	dl 0x001DD2 ; 0000E6, 41.938
040A6A E9 1D 00    1390*  	dl 0x001DE9 ; 0000E7, 42.061
040A6D FF 1D 00    1391*  	dl 0x001DFF ; 0000E8, 42.184
040A70 15 1E 00    1392*  	dl 0x001E15 ; 0000E9, 42.307
040A73 2C 1E 00    1393*  	dl 0x001E2C ; 0000EA, 42.429
040A76 42 1E 00    1394*  	dl 0x001E42 ; 0000EB, 42.551
040A79 58 1E 00    1395*  	dl 0x001E58 ; 0000EC, 42.672
040A7C 6E 1E 00    1396*  	dl 0x001E6E ; 0000ED, 42.793
040A7F 84 1E 00    1397*  	dl 0x001E84 ; 0000EE, 42.913
040A82 99 1E 00    1398*  	dl 0x001E99 ; 0000EF, 43.033
040A85 AF 1E 00    1399*  	dl 0x001EAF ; 0000F0, 43.152
040A88 C5 1E 00    1400*  	dl 0x001EC5 ; 0000F1, 43.271
040A8B DA 1E 00    1401*  	dl 0x001EDA ; 0000F2, 43.390
040A8E F0 1E 00    1402*  	dl 0x001EF0 ; 0000F3, 43.508
040A91 05 1F 00    1403*  	dl 0x001F05 ; 0000F4, 43.625
040A94 1B 1F 00    1404*  	dl 0x001F1B ; 0000F5, 43.742
040A97 30 1F 00    1405*  	dl 0x001F30 ; 0000F6, 43.859
040A9A 45 1F 00    1406*  	dl 0x001F45 ; 0000F7, 43.975
040A9D 5A 1F 00    1407*  	dl 0x001F5A ; 0000F8, 44.091
040AA0 6F 1F 00    1408*  	dl 0x001F6F ; 0000F9, 44.206
040AA3 84 1F 00    1409*  	dl 0x001F84 ; 0000FA, 44.321
040AA6 99 1F 00    1410*  	dl 0x001F99 ; 0000FB, 44.435
040AA9 AD 1F 00    1411*  	dl 0x001FAD ; 0000FC, 44.549
040AAC C2 1F 00    1412*  	dl 0x001FC2 ; 0000FD, 44.662
040AAF D7 1F 00    1413*  	dl 0x001FD7 ; 0000FE, 44.775
040AB2 EB 1F 00    1414*  	dl 0x001FEB ; 0000FF, 44.888
040AB5 00 20 00    1415*  	dl 0x002000 ; 000100, 45.000 only needed for interpolation
040AB8             1416*  
040AB8             1417*  	; include "functions.inc"
040AB8             1418*  
040AB8             1419*      MACRO printChar char
040AB8             1420*          LD A, char
040AB8             1421*          RST.LIL 10h
040AB8             1422*      ENDMACRO
040AB8             1423*  
040AB8             1424*  ; put the value in HLU into the accumulator
040AB8             1425*  ; destroys: af
040AB8             1426*      MACRO HLU_TO_A
040AB8             1427*          push hl ; 4 cycles
040AB8             1428*          inc sp ; 1 cycle
040AB8             1429*          pop af  ; 4 cycles
040AB8             1430*          dec sp ; 1 cycle
040AB8             1431*                 ; 10 cycles total
040AB8             1432*      ENDMACRO
040AB8             1433*  
040AB8             1434*  ; put the value in the accumulator into HLU
040AB8             1435*  ; destroys a
040AB8             1436*  A_TO_HLU:
040AB8             1437*      ; call is 7 cycles
040AB8 22 C5 0A 04 1438*      ld (@scratch),hl ; 7 cycles
040ABC 32 C7 0A 04 1439*      ld (@scratch+2),a ; 5 cycles
040AC0 2A C5 0A 04 1440*      ld hl,(@scratch) ; 7 cycles
040AC4 C9          1441*      ret ; 6 cycles
040AC5             1442*          ; 25 cycles total
040AC5 00 00 00    1443*  @scratch: dl 0
040AC8             1444*  
040AC8             1445*  
040AC8             1446*  ; Print a zero-terminated string inline with code, e.g.:
040AC8             1447*  ;
040AC8             1448*  ;    call printInline
040AC8             1449*  ;    ASCIZ "Hello, world!\r\n"
040AC8             1450*  ;
040AC8             1451*  ; Destroys: HL,AF
040AC8             1452*  printInline:
040AC8 E1          1453*      pop hl ; get the return address = pointer to start of string
040AC9 CD CF 0A 04 1454*      call printString ; HL advances to end of string
040ACD E5          1455*      push hl ; restore the return address = pointer to end of string
040ACE C9          1456*      ret
040ACF             1457*  
040ACF             1458*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
040ACF             1459*  ; Print a zero-terminated string
040ACF             1460*  ; HL: Pointer to string
040ACF             1461*  printString:
040ACF C5          1462*  	PUSH	BC
040AD0 01 00 00 00 1463*  	LD		BC,0
040AD4 3E 00       1464*  	LD 	 	A,0
040AD6 5B DF       1465*  	RST.LIL 18h
040AD8 C1          1466*  	POP		BC
040AD9 C9          1467*  	RET
040ADA             1468*  ; print a VDU sequence
040ADA             1469*  ; HL: Pointer to VDU sequence - <1 byte length> <data>
040ADA             1470*  sendVDUsequence:
040ADA C5          1471*  	PUSH	BC
040ADB 01 00 00 00 1472*  	LD		BC, 0
040ADF 4E          1473*  	LD		C, (HL)
040AE0 5B DF       1474*  	RST.LIL	18h
040AE2 C1          1475*  	POP		BC
040AE3 C9          1476*  	RET
040AE4             1477*  ; Print Newline sequence to VDP
040AE4             1478*  printNewLine:
040AE4 F5          1479*      push af ; for some reason rst.lil 10h sets carry flag
040AE5 3E 0D       1480*  	LD	A, '\r'
040AE7 5B D7       1481*  	RST.LIL 10h
040AE9 3E 0A       1482*  	LD	A, '\n'
040AEB 5B D7       1483*  	RST.LIL 10h
040AED F1          1484*      pop af
040AEE C9          1485*  	RET
040AEF             1486*  
040AEF             1487*  ; Print a 24-bit HEX number
040AEF             1488*  ; HLU: Number to print
040AEF             1489*  printHex24:
040AEF             1490*      HLU_TO_A
040AEF E5          0001*M         push hl ; 4 cycles
040AF0 33          0002*M         inc sp ; 1 cycle
040AF1 F1          0003*M         pop af  ; 4 cycles
040AF2 3B          0004*M         dec sp ; 1 cycle
040AF3             0005*M                ; 10 cycles total
040AF3 CD FD 0A 04 1491*  	CALL	printHex8
040AF7             1492*  ; Print a 16-bit HEX number
040AF7             1493*  ; HL: Number to print
040AF7             1494*  printHex16:
040AF7 7C          1495*  	LD		A,H
040AF8 CD FD 0A 04 1496*  	CALL	printHex8
040AFC 7D          1497*  	LD		A,L
040AFD             1498*  ; Print an 8-bit HEX number
040AFD             1499*  ; A: Number to print
040AFD             1500*  printHex8:
040AFD 4F          1501*  	LD		C,A
040AFE 1F          1502*  	RRA
040AFF 1F          1503*  	RRA
040B00 1F          1504*  	RRA
040B01 1F          1505*  	RRA
040B02 CD 07 0B 04 1506*  	CALL	@F
040B06 79          1507*  	LD		A,C
040B07             1508*  @@:
040B07 E6 0F       1509*  	AND		0Fh
040B09 C6 90       1510*  	ADD		A,90h
040B0B 27          1511*  	DAA
040B0C CE 40       1512*  	ADC		A,40h
040B0E 27          1513*  	DAA
040B0F 5B D7       1514*  	RST.LIL	10h
040B11 C9          1515*  	RET
040B12             1516*  
040B12             1517*  printHexUHL:
040B12 E5          1518*  	push hl
040B13 CD EF 0A 04 1519*  	call printHex24
040B17 E1          1520*  	pop hl
040B18 C9          1521*  	ret
040B19             1522*  
040B19             1523*  
040B19             1524*  ; print registers to screen in hexidecimal format
040B19             1525*  ; inputs: none
040B19             1526*  ; outputs: values of every register printed to screen
040B19             1527*  ;    values of each register in global scratch memory
040B19             1528*  ; destroys: nothing
040B19             1529*  dumpRegistersHex:
040B19             1530*  ; store everything in scratch
040B19 22 BE 0B 04 1531*      ld (@uhl),hl
040B1D ED 43 C1 0B 1532*      ld (@ubc),bc
       04          
040B22 ED 53 C4 0B 1533*      ld (@ude),de
       04          
040B27 DD 22 C7 0B 1534*      ld (@uix),ix
       04          
040B2C FD 22 CA 0B 1535*      ld (@uiy),iy
       04          
040B31 F5          1536*      push af
040B32 E1          1537*      pop hl
040B33 22 BB 0B 04 1538*      ld (@uaf),hl
040B37 F5          1539*      push af
040B38             1540*  
040B38             1541*  ; print each register
040B38 CD C8 0A 04 1542*      call printInline
040B3C 61 66 3D 00 1543*      asciz "af="
040B40 2A BB 0B 04 1544*      ld hl,(@uaf)
040B44 CD EF 0A 04 1545*      call printHex24
040B48             1546*  
040B48 CD C8 0A 04 1547*      call printInline
040B4C 20 68 6C 3D 1548*      asciz " hl="
       00          
040B51 2A BE 0B 04 1549*      ld hl,(@uhl)
040B55 CD EF 0A 04 1550*      call printHex24
040B59             1551*  
040B59 CD C8 0A 04 1552*      call printInline
040B5D 20 62 63 3D 1553*      asciz " bc="
       00          
040B62 2A C1 0B 04 1554*      ld hl,(@ubc)
040B66 CD EF 0A 04 1555*      call printHex24
040B6A             1556*  
040B6A CD C8 0A 04 1557*      call printInline
040B6E 20 64 65 3D 1558*      asciz " de="
       00          
040B73 2A C4 0B 04 1559*      ld hl,(@ude)
040B77 CD EF 0A 04 1560*      call printHex24
040B7B             1561*  
040B7B CD C8 0A 04 1562*      call printInline
040B7F 20 69 78 3D 1563*      asciz " ix="
       00          
040B84 2A C7 0B 04 1564*      ld hl,(@uix)
040B88 CD EF 0A 04 1565*      call printHex24
040B8C             1566*  
040B8C CD C8 0A 04 1567*      call printInline
040B90 20 69 79 3D 1568*      asciz " iy="
       00          
040B95 2A CA 0B 04 1569*      ld hl,(@uiy)
040B99 CD EF 0A 04 1570*      call printHex24
040B9D             1571*  
040B9D CD E4 0A 04 1572*      call printNewLine
040BA1             1573*  ; restore everything
040BA1 2A BE 0B 04 1574*      ld hl, (@uhl)
040BA5 ED 4B C1 0B 1575*      ld bc, (@ubc)
       04          
040BAA ED 5B C4 0B 1576*      ld de, (@ude)
       04          
040BAF DD 2A C7 0B 1577*      ld ix, (@uix)
       04          
040BB4 FD 2A CA 0B 1578*      ld iy, (@uiy)
       04          
040BB9 F1          1579*      pop af
040BBA             1580*  ; all done
040BBA C9          1581*      ret
040BBB             1582*  
040BBB 00 00 00    1583*  @uaf: dl 0
040BBE 00 00 00    1584*  @uhl: dl 0
040BC1 00 00 00    1585*  @ubc: dl 0
040BC4 00 00 00    1586*  @ude: dl 0
040BC7 00 00 00    1587*  @uix: dl 0
040BCA 00 00 00    1588*  @uiy: dl 0
040BCD             1589*  
040BCD             1590*  ; Prints the right justified decimal value in HL without leading zeroes
040BCD             1591*  ; HL : Value to print
040BCD             1592*  ; preserves all registers and flags
040BCD             1593*  printDec:
040BCD             1594*  ; BEGIN MY CODE
040BCD             1595*  ; back up all the things
040BCD F5          1596*      push af
040BCE C5          1597*      push bc
040BCF D5          1598*      push de
040BD0 E5          1599*      push hl
040BD1             1600*  ; END MY CODE
040BD1 11 F9 0B 04 1601*  	LD	 DE, _printDecBuffer
040BD5 CD 09 0C 04 1602*  	CALL u24_to_ascii
040BD9             1603*  ; BEGIN MY CODE
040BD9             1604*  ; replace leading zeroes with spaces
040BD9 21 F9 0B 04 1605*      LD	 HL, _printDecBuffer
040BDD 06 07       1606*      ld   B, 7 ; if HL was 0, we want to keep the final zero
040BDF             1607*  @loop:
040BDF 7E          1608*      LD	 A, (HL)
040BE0 FE 30       1609*      CP	 '0'
040BE2 C2 EC 0B 04 1610*      JP	 NZ, @done
040BE6 3E 20       1611*      LD   A, ' '
040BE8 77          1612*      LD	 (HL), A
040BE9 23          1613*      INC	 HL
040BEA             1614*      ; CALL vdu_cursor_forward
040BEA 10 F3       1615*      DJNZ @loop
040BEC             1616*  @done:
040BEC             1617*  ; END MY CODE
040BEC 21 F9 0B 04 1618*  	LD	 HL, _printDecBuffer
040BF0 CD CF 0A 04 1619*  	CALL printString
040BF4             1620*  ; BEGIN MY CODE
040BF4             1621*  ; restore all the things
040BF4 E1          1622*      pop hl
040BF5 D1          1623*      pop de
040BF6 C1          1624*      pop bc
040BF7 F1          1625*      pop af
040BF8             1626*  ; END MY CODE
040BF8 C9          1627*  	RET
040BF9 00 00 00 00 1628*  _printDecBuffer: blkb 16,0 ; a few bytes extra just to be sure
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040C09             1629*  
040C09             1630*  ; This routine converts the unsigned 24-bit value in HLU into it's ASCII representation,
040C09             1631*  ; starting to memory location pointing by DE, in decimal form and with leading zeroes
040C09             1632*  ; so it will allways be 8 characters length
040C09             1633*  ; HL : Value to convert to string
040C09             1634*  ; DE : pointer to buffer, at least 8 byte + 0
040C09             1635*  u24_to_ascii:
040C09 01 80 69 67 1636*  	LD	 BC,-10000000
040C0D CD 40 0C 04 1637*  	CALL @one_digit
040C11 01 C0 BD F0 1638*  	LD	 BC,-1000000
040C15 CD 40 0C 04 1639*  	CALL @one_digit
040C19 01 60 79 FE 1640*  	LD	 BC,-100000
040C1D CD 40 0C 04 1641*  	CALL @one_digit
040C21 01 F0 D8 FF 1642*  	LD   BC,-10000
040C25 CD 40 0C 04 1643*  	CALL @one_digit
040C29 01 18 FC FF 1644*  	LD   BC,-1000
040C2D CD 40 0C 04 1645*  	CALL @one_digit
040C31 01 9C FF FF 1646*  	LD   BC,-100
040C35 CD 40 0C 04 1647*  	CALL @one_digit
040C39 0E F6       1648*  	LD   C,-10
040C3B CD 40 0C 04 1649*  	CALL @one_digit
040C3F 48          1650*  	LD   C,B
040C40             1651*  @one_digit:
040C40 3E 2F       1652*  	LD   A,'0'-1
040C42             1653*  @divide_me:
040C42 3C          1654*  	INC  A
040C43 09          1655*  	ADD  HL,BC
040C44 38 FC       1656*  	JR   C,@divide_me
040C46 ED 42       1657*  	SBC  HL,BC
040C48 12          1658*  	LD   (DE),A
040C49 13          1659*  	INC  DE
040C4A C9          1660*  	RET
040C4B             1661*  
040C4B             1662*  print_u24:
040C4B D5          1663*      push de
040C4C E5          1664*      push hl
040C4D 11 F9 0B 04 1665*      ld de,_printDecBuffer
040C51 CD 09 0C 04 1666*      call u24_to_ascii
040C55 21 F9 0B 04 1667*      ld hl,_printDecBuffer
040C59 CD CF 0A 04 1668*      call printString
040C5D 3E 20       1669*      ld a,' '
040C5F 5B D7       1670*      rst.lil 10h
040C61 E1          1671*      pop hl
040C62 D1          1672*      pop de
040C63 C9          1673*      ret
040C64             1674*  
040C64             1675*  ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
040C64             1676*  ; HL : Value to convert to string (integer part in H, fractional part in L)
040C64             1677*  ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
040C64             1678*  u168_to_ascii:
040C64             1679*  ; add a leading space to make room for sign flag if needed
040C64 3E 20       1680*      ld a,' '
040C66 12          1681*      ld (de),a
040C67 13          1682*      inc de
040C68             1683*  ; Convert integer part
040C68 E5          1684*      push hl               ; Save HL (we’ll need the fractional part later)
040C69 CD 7B 00 04 1685*      call hlu_udiv256    ; Shift to get integer portion in HL
040C6D 01 F0 D8 FF 1686*      ld   bc, -10000
040C71 CD 94 0C 04 1687*      call @one_int
040C75 01 18 FC FF 1688*      ld   bc, -1000
040C79 CD 94 0C 04 1689*      call @one_int
040C7D 01 9C FF FF 1690*      ld   bc, -100
040C81 CD 94 0C 04 1691*      call @one_int
040C85 0E F6       1692*      ld   c, -10
040C87 CD 94 0C 04 1693*      call @one_int
040C8B 48          1694*      ld   c, b
040C8C CD 94 0C 04 1695*      call @one_int
040C90 C3 9F 0C 04 1696*      jp   @frac            ; Jump to fractional part conversion
040C94             1697*  @one_int:
040C94 3E 2F       1698*      ld   a, '0' - 1       ; Start ASCII character at '0'
040C96             1699*  @divide_me:
040C96 3C          1700*      inc  a
040C97 09          1701*      add  hl, bc           ; Accumulate until overflow
040C98 38 FC       1702*      jr   c, @divide_me
040C9A ED 42       1703*      sbc  hl, bc           ; Remove excess after overflow
040C9C 12          1704*      ld   (de), a          ; Store ASCII digit
040C9D 13          1705*      inc  de
040C9E C9          1706*      ret
040C9F             1707*  ; Convert fractional part
040C9F             1708*  @frac:
040C9F 3E 2E       1709*      ld   a, '.'           ; Decimal point
040CA1 12          1710*      ld   (de), a
040CA2 13          1711*      inc  de
040CA3 E1          1712*      pop  hl               ; Restore HL with original fraction
040CA4 06 03       1713*      ld   b, 3             ; Loop counter for 3 fractional digits
040CA6             1714*  @frac_loop:
040CA6 26 0A       1715*      ld   h, 10            ; Load multiplier for fractional part
040CA8 ED 6C       1716*      mlt  hl               ; Multiply by 10, result in HL (H holds the integer part)
040CAA 3E 30       1717*      ld   a, '0'
040CAC 84          1718*      add  a, h             ; Convert integer part to ASCII
040CAD 12          1719*      ld   (de), a
040CAE 13          1720*      inc  de
040CAF 10 F5       1721*      djnz @frac_loop       ; Repeat for each fractional digit
040CB1             1722*  ; Add null terminator
040CB1 AF          1723*      xor  a                ; Null terminator
040CB2 12          1724*      ld   (de), a
040CB3 C9          1725*      ret
040CB4             1726*  
040CB4             1727*  print_u168:
040CB4 D5          1728*      push de
040CB5 E5          1729*      push hl
040CB6 11 F9 0B 04 1730*      ld de,_printDecBuffer
040CBA CD 64 0C 04 1731*      call u168_to_ascii
040CBE 21 F9 0B 04 1732*      ld hl,_printDecBuffer
040CC2 CD CF 0A 04 1733*      call printString
040CC6 E1          1734*      pop hl
040CC7 D1          1735*      pop de
040CC8 C9          1736*      ret
040CC9             1737*  
040CC9             1738*  ; signed version of u168_to_ascii
040CC9             1739*  s168_to_ascii:
040CC9 D5          1740*      push de ; save starting address of buffer
040CCA CD 88 00 04 1741*      call hlu_abs
040CCE F5          1742*      push af ; save sign flag
040CCF CD 64 0C 04 1743*      call u168_to_ascii
040CD3 F1          1744*      pop af ; restore sign flag
040CD4 D1          1745*      pop de ; restore starting address of buffer
040CD5 F0          1746*      ret p ; hlu was positive so nothing to do
040CD6 3E 2D       1747*      ld a,'-'
040CD8 12          1748*      ld (de),a
040CD9 C9          1749*      ret
040CDA             1750*  
040CDA             1751*  print_s168:
040CDA D5          1752*      push de
040CDB E5          1753*      push hl
040CDC 11 F9 0B 04 1754*      ld de,_printDecBuffer
040CE0 CD C9 0C 04 1755*      call s168_to_ascii
040CE4 21 F9 0B 04 1756*      ld hl,_printDecBuffer
040CE8 CD CF 0A 04 1757*      call printString
040CEC E1          1758*      pop hl
040CED D1          1759*      pop de
040CEE C9          1760*      ret
040CEF             1761*  
040CEF             1762*  	; include "parse.inc"
040CEF             1763*  
040CEF             1764*  ;
040CEF             1765*  ; Title:	Number Parsing Functions
040CEF             1766*  ; Author:	Dean Belfield
040CEF             1767*  ; Created:	15/11/2022
040CEF             1768*  ; Last Updated:	15/11/2022
040CEF             1769*  ; Last Updated: 29/12/2022 Lennart Benchop adapt for 24-bit mode.
040CEF             1770*  ; Modinfo:
040CEF             1771*  ; 2024/04/08    Adapt for ez80asm
040CEF             1772*  
040CEF             1773*  ; Read a number and convert to binary
040CEF             1774*  ; If prefixed with &, will read as hex, otherwise decimal
040CEF             1775*  ;   Inputs: HL: Pointer in string buffer
040CEF             1776*  ;  Outputs: HL: Updated text pointer
040CEF             1777*  ;           DE: Value
040CEF             1778*  ;            A: Terminator (spaces skipped)
040CEF             1779*  ;            F: Carry set if valid number, otherwise reset
040CEF             1780*  ; Destroys: A,D,E,H,L,F
040CEF             1781*  ;
040CEF 11 00 00 00 1782*  ASC_TO_NUMBER:		LD		DE, 0			; Initialise DE
040CF3             1783*  			; CALL		_skip_spaces		; Skip whitespace
040CF3 7E          1784*  			LD		A, (HL)			; Read first character
040CF4 B7          1785*  			OR		A			; Check for end of string
040CF5 C8          1786*  			RET		Z			; Return with no carry if not
040CF6 C5          1787*  			PUSH		BC			; Preserve BC
040CF7 FE 26       1788*  			CP		'&'			; Is it prefixed with '&' (HEX number)?
040CF9 20 23       1789*  			JR		NZ, ASC_TO_NUMBER3	; Jump to decimal parser if not
040CFB 23          1790*  			INC		HL			; Otherwise fall through to ASC_TO_HEX
040CFC             1791*  ;
040CFC 7E          1792*  ASC_TO_NUMBER1:		LD		A, (HL)			; Fetch the character
040CFD CD 3F 0D 04 1793*  			CALL   	 	UPPRC			; Convert to uppercase
040D01 D6 30       1794*  			SUB		'0'			; Normalise to 0
040D03 38 37       1795*  			JR 		C, ASC_TO_NUMBER4	; Return if < ASCII '0'
040D05 FE 0A       1796*  			CP 		10			; Check if >= 10
040D07 38 06       1797*  			JR 		C, ASC_TO_NUMBER2	; No, so skip next bit
040D09 D6 07       1798*  			SUB 		7			; Adjust ASCII A-F to nibble
040D0B FE 10       1799*  			CP 		16			; Check for > F
040D0D 30 2D       1800*  			JR 		NC, ASC_TO_NUMBER4	; Return if out of range
040D0F             1801*  ;
040D0F E5          1802*  ASC_TO_NUMBER2:		PUSH		HL			; Stack HL
040D10 D5          1803*  			PUSH		DE			; LD HL, DE
040D11 E1          1804*  			POP		HL
040D12 29          1805*  			ADD		HL, HL
040D13 29          1806*  			ADD		HL, HL
040D14 29          1807*  			ADD		HL, HL
040D15 29          1808*  			ADD		HL, HL
040D16 E5          1809*  			PUSH		HL			; LD DE, HL
040D17 D1          1810*  			POP		DE
040D18 E1          1811*  			POP		HL			; Restore HL
040D19 B3          1812*  			OR      	E			; OR the new digit in to the least significant nibble
040D1A 5F          1813*  			LD      	E, A
040D1B             1814*  ;
040D1B 23          1815*  			INC		HL			; Onto the next character
040D1C 18 DE       1816*  			JR      	ASC_TO_NUMBER1		; And loop
040D1E             1817*  ;
040D1E 7E          1818*  ASC_TO_NUMBER3:		LD		A, (HL)
040D1F D6 30       1819*  			SUB		'0'			; Normalise to 0
040D21 38 19       1820*  			JR		C, ASC_TO_NUMBER4	; Return if < ASCII '0'
040D23 FE 0A       1821*  			CP		10			; Check if >= 10
040D25 30 15       1822*  			JR		NC, ASC_TO_NUMBER4	; Return if >= 10
040D27             1823*  ;
040D27 E5          1824*  			PUSH		HL			; Stack HL
040D28 D5          1825*  			PUSH		DE			; LD HL, DE
040D29 E1          1826*  			POP		HL
040D2A E5          1827*  			PUSH		HL			; LD BC, HL
040D2B C1          1828*  			POP		BC
040D2C 29          1829*  			ADD		HL, HL 			; x 2
040D2D 29          1830*  			ADD		HL, HL 			; x 4
040D2E 09          1831*  			ADD		HL, BC 			; x 5
040D2F 29          1832*  			ADD		HL, HL 			; x 10
040D30 01 00 00 00 1833*  			LD		BC, 0
040D34 4F          1834*  			LD 		C, A			; LD BCU, A
040D35 09          1835*  			ADD		HL, BC			; Add BCU to HL
040D36 E5          1836*  			PUSH		HL			; LD DE, HL
040D37 D1          1837*  			POP		DE
040D38 E1          1838*  			POP		HL			; Restore HL
040D39             1839*  ;
040D39 23          1840*  			INC		HL
040D3A 18 E2       1841*  			JR		ASC_TO_NUMBER3
040D3C C1          1842*  ASC_TO_NUMBER4:		POP		BC
040D3D 37          1843*  			SCF					; We have a valid number so set carry
040D3E C9          1844*  			RET
040D3F             1845*  
040D3F             1846*  
040D3F             1847*  ; Convert a character to upper case
040D3F             1848*  ;  A: Character to convert
040D3F             1849*  ;
040D3F E6 7F       1850*  UPPRC:  		AND     	7FH
040D41 FE 60       1851*  			CP      	'`'
040D43 D8          1852*  			RET     	C
040D44 E6 5F       1853*  			AND     	5FH			; Convert to upper case
040D46 C9          1854*  			RET
040D47             1855*  
040D47             1856*  ; -----------------------------------------------------------------------
040D47             1857*  ;
040D47             1858*  ; additional functions by Brandon R. Gates based on Dean's code
040D47             1859*  ;
040D47             1860*  ;------------------------------------------------------------------------
040D47             1861*  ; Read a number and convert to binary (decimal only)
040D47             1862*  ; Inputs: hl: Pointer in string buffer
040D47             1863*  ; Outputs: hl: Updated text pointer
040D47             1864*  ;         de: Value
040D47             1865*  ;         a: Terminator (spaces skipped)
040D47             1866*  ;         f: Carry set if valid number, otherwise reset
040D47             1867*  ; Destroys: a, d, e, h, l, f
040D47             1868*  ;------------------------------------------------------------------------
040D47             1869*  asc_to_s24:
040D47 3E 01       1870*      ld a,1 ; set sign flag
040D49 32 95 0D 04 1871*      ld (@sign),a ; store sign flag
040D4D             1872*  
040D4D 11 00 00 00 1873*      ld de, 0 ; initialise de
040D51             1874*      ; call _skip_spaces ; skip whitespace
040D51             1875*  
040D51 7E          1876*      ld a, (hl) ; read first character
040D52 B7          1877*      or a ; check for end of string
040D53 C8          1878*      ret z ; return with no carry if not
040D54             1879*  
040D54 C5          1880*      push bc ; preserve bc
040D55             1881*  
040D55 FE 2D       1882*      cp '-' ; check for negative number
040D57 C2 61 0D 04 1883*      jp nz,@loop ; number is positive, nothing more to do
040D5B AF          1884*      xor a ; sign flag to zero
040D5C 32 95 0D 04 1885*      ld (@sign),a ; store sign flag
040D60 23          1886*      inc hl ; skip '-'
040D61             1887*  
040D61             1888*  @loop:
040D61 7E          1889*      ld a, (hl)
040D62 D6 30       1890*      sub '0' ; normalise to 0
040D64 38 19       1891*      jr c, @integer_end ; return if < ascii '0'
040D66 FE 0A       1892*      cp 10 ; check if >= 10
040D68 30 15       1893*      jr nc, @integer_end ; return if >= 10
040D6A E5          1894*      push hl ; stack hl
040D6B D5          1895*      push de ; ld hl, de
040D6C E1          1896*      pop hl
040D6D E5          1897*      push hl ; ld bc, hl
040D6E C1          1898*      pop bc
040D6F 29          1899*      add hl, hl ; x 2
040D70 29          1900*      add hl, hl ; x 4
040D71 09          1901*      add hl, bc ; x 5
040D72 29          1902*      add hl, hl ; x 10
040D73 01 00 00 00 1903*      ld bc, 0
040D77 4F          1904*      ld c, a ; ld bcu, a
040D78 09          1905*      add hl, bc ; add bcu to hl
040D79 E5          1906*      push hl ; ld de, hl
040D7A D1          1907*      pop de
040D7B E1          1908*      pop hl ; restore hl
040D7C 23          1909*      inc hl
040D7D 18 E2       1910*      jr @loop
040D7F             1911*  
040D7F             1912*  @integer_end:
040D7F C1          1913*      pop bc ; send bc back how she came in
040D80 3A 95 0D 04 1914*      ld a, (@sign) ; get sign flag
040D84 3D          1915*      dec a ; check if negative
040D85 F2 93 0D 04 1916*      jp p,@pos ; positive number
040D89             1917*  
040D89             1918*  ; Negate de
040D89 E5          1919*      push hl ; save text pointer
040D8A 21 00 00 00 1920*      ld hl, 0
040D8E AF          1921*      xor a ; clear carry
040D8F ED 52       1922*      sbc hl, de ; subtract DE from HL
040D91 EB          1923*      ex de, hl ; DE = 0-HL
040D92 E1          1924*      pop hl ; restore text pointer
040D93             1925*  
040D93             1926*  @pos:
040D93 37          1927*      scf ; we have a valid number so set carry
040D94 C9          1928*      ret
040D95             1929*  
040D95 00          1930*  @sign: db 0 ; sign flag buffer
040D96             1931*  
040D96             1932*  
040D96             1933*  ;------------------------------------------------------------------------
040D96             1934*  ; Read a number and convert to binary (decimal only)
040D96             1935*  ; Inputs: hl: Pointer in string buffer
040D96             1936*  ; Outputs: hl: Updated text pointer
040D96             1937*  ;         de: Value
040D96             1938*  ;         a: Terminator (spaces skipped)
040D96             1939*  ;         f: Carry set if valid number, otherwise reset
040D96             1940*  ; Destroys: a, d, e, h, l, f
040D96             1941*  ;------------------------------------------------------------------------
040D96             1942*  asc_to_s168:
040D96 3E 01       1943*      ld a,1 ; set sign flag
040D98 32 55 0E 04 1944*      ld (@sign),a ; store sign flag
040D9C             1945*  
040D9C 11 00 00 00 1946*      ld de, 0 ; initialise de
040DA0 ED 53 4D 0E 1947*      ld (@result), de ; clear low bytes of result buffer
       04          
040DA5 ED 53 51 0E 1948*      ld (@scratch), de ; clear low bytes of scratch buffer
       04          
040DAA             1949*  
040DAA             1950*      ; call _skip_spaces ; skip whitespace
040DAA             1951*  
040DAA 7E          1952*      ld a, (hl) ; read first character
040DAB B7          1953*      or a ; check for end of string
040DAC C8          1954*      ret z ; return with no carry if not
040DAD             1955*  
040DAD C5          1956*      push bc ; preserve bc
040DAE             1957*  
040DAE FE 2D       1958*      cp '-' ; check for negative number
040DB0 C2 BA 0D 04 1959*      jp nz,@loop ; number is positive, nothing more to do
040DB4 AF          1960*      xor a ; sign flag to zero
040DB5 32 55 0E 04 1961*      ld (@sign),a ; store sign flag
040DB9 23          1962*      inc hl ; skip '-'
040DBA             1963*  
040DBA             1964*  @loop:
040DBA 7E          1965*      ld a, (hl)
040DBB             1966*  
040DBB             1967*  ; chcek for decimal point
040DBB FE 2E       1968*      cp '.' ; check for decimal point
040DBD CA FE 0D 04 1969*      jp z,@fractional_start ; jump to fractional part
040DC1             1970*  
040DC1             1971*  ; process integer part
040DC1 D6 30       1972*      sub '0' ; normalise to 0
040DC3 38 19       1973*      jr c, @integer_end ; return if < ascii '0'
040DC5 FE 0A       1974*      cp 10 ; check if >= 10
040DC7 30 15       1975*      jr nc, @integer_end ; return if >= 10
040DC9 E5          1976*      push hl ; stack hl
040DCA D5          1977*      push de ; ld hl, de
040DCB E1          1978*      pop hl
040DCC E5          1979*      push hl ; ld bc, hl
040DCD C1          1980*      pop bc
040DCE 29          1981*      add hl, hl ; x 2
040DCF 29          1982*      add hl, hl ; x 4
040DD0 09          1983*      add hl, bc ; x 5
040DD1 29          1984*      add hl, hl ; x 10
040DD2 01 00 00 00 1985*      ld bc, 0
040DD6 4F          1986*      ld c, a ; ld bcu, a
040DD7 09          1987*      add hl, bc ; add bcu to hl
040DD8 E5          1988*      push hl ; ld de, hl
040DD9 D1          1989*      pop de
040DDA E1          1990*      pop hl ; restore hl
040DDB 23          1991*      inc hl
040DDC 18 DC       1992*      jr @loop
040DDE             1993*  
040DDE             1994*  @integer_end:
040DDE ED 53 4E 0E 1995*      ld (@result+1), de      ; Store integer part in result buffer (shifted up one byte)
       04          
040DE3             1996*  
040DE3             1997*  @end:
040DE3 C1          1998*      pop bc ; send bc back how she came in
040DE4 ED 5B 4D 0E 1999*      ld de,(@result) ; will contain shifted integer part combined with any fractional value
       04          
040DE9 3A 55 0E 04 2000*      ld a, (@sign) ; get sign flag
040DED 3D          2001*      dec a ; check if negative
040DEE F2 FC 0D 04 2002*      jp p,@pos ; positive number
040DF2             2003*  
040DF2             2004*  ; Negate de
040DF2 E5          2005*      push hl ; save text pointer
040DF3 21 00 00 00 2006*      ld hl, 0
040DF7 AF          2007*      xor a ; clear carry
040DF8 ED 52       2008*      sbc hl, de ; subtract DE from HL
040DFA EB          2009*      ex de, hl ; DE = 0-HL
040DFB E1          2010*      pop hl ; restore text pointer
040DFC             2011*  
040DFC             2012*  @pos:
040DFC 37          2013*      scf ; we have a valid number so set carry
040DFD C9          2014*      ret
040DFE             2015*  
040DFE             2016*  @fractional_start:
040DFE DD E5       2017*      push ix                    ; preserve ix
040E00 ED 53 4E 0E 2018*      ld (@result+1), de         ; Store integer part in result buffer (shifted up one byte)
       04          
040E05 06 03       2019*      ld b, 3                    ; Set loop counter to 3 for up to three fractional digits
040E07 11 00 00 00 2020*      ld de, 0                   ; Initialize DE as the fractional accumulator
040E0B DD 21 56 0E 2021*      ld ix, powers_of_10        ; Point IX to the lookup table for the scaling factor based on digits
       04          
040E10 23          2022*      inc hl                     ; Skip decimal point
040E11             2023*  
040E11             2024*  @fractional_loop:
040E11 7E          2025*      ld a, (hl)                 ; Load next character
040E12 D6 30       2026*      sub '0'                    ; Normalize ASCII to decimal
040E14 38 1C       2027*      jr c, @end_fraction        ; Exit if < '0'
040E16 FE 0A       2028*      cp 10
040E18 30 18       2029*      jr nc, @end_fraction       ; Exit if >= 10
040E1A             2030*  
040E1A             2031*      ; Multiply the current fractional accumulator by 10
040E1A E5          2032*      push hl                    ; Save char pointer
040E1B F5          2033*      push af                    ; Save the digit
040E1C EB          2034*      ex de, hl
040E1D E5          2035*      push hl
040E1E 29          2036*      add hl,hl ; * 2
040E1F 29          2037*      add hl,hl ; * 4
040E20 D1          2038*      pop de
040E21 19          2039*      add hl,de ; * 5
040E22 29          2040*      add hl,hl ; * 10
040E23 11 00 00 00 2041*      ld de, 0                   ; Clear DEU
040E27 F1          2042*      pop af                     ; Restore the current digit
040E28 5F          2043*      ld e, a                    ; Load the digit into E
040E29 19          2044*      add hl, de                 ; Add the digit to the accumulator
040E2A EB          2045*      ex de, hl                  ; Result back to DE
040E2B ED 32 03    2046*      lea ix,ix+3                ; Advance IX to the next scaling factor
040E2E E1          2047*      pop hl                     ; Restore char pointer
040E2F 23          2048*      inc hl                     ; Move to the next character
040E30 10 DF       2049*      djnz @fractional_loop      ; Loop if more digits to process
040E32             2050*  
040E32             2051*  @end_fraction:
040E32             2052*  ; Final scaling based on number of fractional digits processed
040E32 ED 53 52 0E 2053*      ld (@scratch+1), de          ; Shift fractional part up a byte
       04          
040E37 2A 51 0E 04 2054*      ld hl,(@scratch)             ; Load the shifted fractional part into HL
040E3B             2055*  
040E3B DD 17 00    2056*      ld de, (ix)                ; Load final scaling factor from IX based on digit count
040E3E CD F8 01 04 2057*      call udiv24                ; Perform 24-bit division to scale down
040E42 7B          2058*      ld a, e                    ; Load the low byte (8-bit fractional part) into A
040E43 32 4D 0E 04 2059*      ld (@result), a            ; Store fractional part in result buffer
040E47 DD E1       2060*      pop ix                     ; Restore ix
040E49 C3 E3 0D 04 2061*      jp @end                    ; Final sign check and flag setup
040E4D             2062*  
040E4D             2063*  @result: ds 4                  ; 32-bit result buffer to shift integer part up one byte
040E51             2064*  @scratch: ds 4                 ; 32-bit scratch buffer for intermediate calculations
040E55 00          2065*  @sign: db 0                    ; Sign flag buffer
040E56             2066*  
040E56             2067*  powers_of_10:
040E56 01 00 00    2068*      dl 1                       ; 10^0
040E59 0A 00 00    2069*      dl 10                      ; 10^1
040E5C 64 00 00    2070*      dl 100                     ; 10^2
040E5F E8 03 00    2071*      dl 1000                    ; 10^3
040E62 10 27 00    2072*      dl 10000                   ; 10^4
040E65             0032   
040E65             0033   ; --- INITIALIZATION ---
040E65             0034   init:
040E65 C9          0035      ret
040E66             0036   
040E66             0037   ; --- MAIN PROGRAM ---
040E66             0038   main:
040E66 CD C8 0A 04 0039       call printInline
040E6A 72 6F 75 6E 0040       asciz "rounding error in print_u168: "
       64 69 6E 67 
       20 65 72 72 
       6F 72 20 69 
       6E 20 70 72 
       69 6E 74 5F 
       75 31 36 38 
       3A 20 00    
040E89 21 62 10 04 0041       ld hl,@arg1
040E8D CD 96 0D 04 0042       call asc_to_s168 ; de = @arg1
040E91 EB          0043       ex de,hl
040E92 CD 12 0B 04 0044       call printHexUHL
040E96 E5          0045       push hl
040E97 CD C8 0A 04 0046       call printInline
040E9B 20 2D 3E 20 0047       asciz " -> "
       00          
040EA0 E1          0048       pop hl
040EA1 CD B4 0C 04 0049       call print_u168
040EA5 CD C8 0A 04 0050       call printInline
040EA9 20 73 68 6F 0051       asciz " should be: "
       75 6C 64 20 
       62 65 3A 20 
       00          
040EB6 21 62 10 04 0052       ld hl,@arg1
040EBA CD CF 0A 04 0053       call printString
040EBE CD E4 0A 04 0054       call printNewLine
040EC2             0055   
040EC2 CD C8 0A 04 0056       call printInline
040EC6 73 69 67 6E 0057       asciz "sign overflow in print_u168: "
       20 6F 76 65 
       72 66 6C 6F 
       77 20 69 6E 
       20 70 72 69 
       6E 74 5F 75 
       31 36 38 3A 
       20 00       
040EE4 21 6C 10 04 0058       ld hl,@arg2
040EE8 CD 96 0D 04 0059       call asc_to_s168 ; de = @arg2
040EEC EB          0060       ex de,hl
040EED CD 12 0B 04 0061       call printHexUHL
040EF1 E5          0062       push hl
040EF2 CD C8 0A 04 0063       call printInline
040EF6 20 2D 3E 20 0064       asciz " -> "
       00          
040EFB E1          0065       pop hl
040EFC CD B4 0C 04 0066       call print_u168
040F00 CD C8 0A 04 0067       call printInline
040F04 20 73 68 6F 0068       asciz " should be: "
       75 6C 64 20 
       62 65 3A 20 
       00          
040F11 21 6C 10 04 0069       ld hl,@arg2
040F15 CD CF 0A 04 0070       call printString
040F19 CD E4 0A 04 0071       call printNewLine
040F1D             0072   
040F1D CD C8 0A 04 0073       call printInline
040F21 75 6E 73 69 0074       asciz "unsigned fixed place multiplication: e * pi = "
       67 6E 65 64 
       20 66 69 78 
       65 64 20 70 
       6C 61 63 65 
       20 6D 75 6C 
       74 69 70 6C 
       69 63 61 74 
       69 6F 6E 3A 
       20 65 20 2A 
       20 70 69 20 
       3D 20 00    
040F50 21 B7 02 00 0075       ld hl,0x0002B7 ; 2.718
040F54 11 24 03 00 0076       ld de,0x000324 ; 3.141
040F58 CD 64 01 04 0077       call umul168
040F5C CD B4 0C 04 0078       call print_u168
040F60 CD C8 0A 04 0079       call printInline
040F64 20 73 68 6F 0080       asciz " should be: 8.539\r\n"
       75 6C 64 20 
       62 65 3A 20 
       38 2E 35 33 
       39 0D 0A 00 
040F78             0081   
040F78 CD C8 0A 04 0082       call printInline
040F7C 75 6E 73 69 0083       asciz "unsigned fixed place division: e / pi = "
       67 6E 65 64 
       20 66 69 78 
       65 64 20 70 
       6C 61 63 65 
       20 64 69 76 
       69 73 69 6F 
       6E 3A 20 65 
       20 2F 20 70 
       69 20 3D 20 
       00          
040FA5 21 B7 02 00 0084       ld hl,0x0002B7 ; 2.718
040FA9 11 24 03 00 0085       ld de,0x000324 ; 3.141
040FAD CD 90 01 04 0086       call udiv168
040FB1 CD B4 0C 04 0087       call print_u168
040FB5 CD C8 0A 04 0088       call printInline
040FB9 20 73 68 6F 0089       asciz " should be: 0.864\r\n"
       75 6C 64 20 
       62 65 3A 20 
       30 2E 38 36 
       34 0D 0A 00 
040FCD             0090   
040FCD CD C8 0A 04 0091       call printInline
040FD1 0D 0A 64 69 0092       asciz "\r\ndistance between two points: "
       73 74 61 6E 
       63 65 20 62 
       65 74 77 65 
       65 6E 20 74 
       77 6F 20 70 
       6F 69 6E 74 
       73 3A 20 00 
040FF1 01 00 00 00 0093       ld bc,0x000000 ; x0 0
040FF5 11 00 00 00 0094       ld de,0x000000 ; y0 0
040FF9 DD 21 00 00 0095       ld ix,0x010000 ; x1 256
       01          
040FFE FD 21 00 00 0096       ld iy,0x010000 ; y1 256
       01          
041003 CD CC 02 04 0097       call distance168 ;
041007 CD DA 0C 04 0098       call print_s168
04100B CD C8 0A 04 0099       call printInline
04100F 20 73 68 6F 0100       asciz " should be: 0x016A09 362.039\r\n"
       75 6C 64 20 
       62 65 3A 20 
       30 78 30 31 
       36 41 30 39 
       20 33 36 32 
       2E 30 33 39 
       0D 0A 00    
04102E             0101   
04102E CD C8 0A 04 0102       call printInline
041032 74 61 72 67 0103       asciz "target bearing: "
       65 74 20 62 
       65 61 72 69 
       6E 67 3A 20 
       00          
041043 ED 4B C0 02 0104       ld bc,(dx168) ; populated by distance168 call above
       04          
041048 ED 5B C6 02 0105       ld de,(dy168) ; ditto
       04          
04104D CD 02 03 04 0106       call atan2_168fast ; uh.l = atan2(dx,-dy) in deg256
041051 CD 35 02 04 0107       call deg_256_to_360 ; convert to 360 degree circle
041055 CD DA 0C 04 0108       call print_s168
041059 CD E4 0A 04 0109       call printNewLine
04105D CD E4 0A 04 0110       call printNewLine
041061 C9          0111       ret
041062             0112   
041062 33 32 37 36 0113   @arg1: asciz "32767.999" ; 0x7FFFFF
       37 2E 39 39 
       39 00       
04106C 2D 33 32 37 0114   @arg2: asciz "-32768" ; 0x800000
       36 38 00    
