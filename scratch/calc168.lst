PC     Output      Line
040000             0001    ASSUME ADL = 1
040000             0002       ORG 0x0B0000 ; Is a moslet
0B0000             0003       ; include "mos_api.inc"
0B0000 C3 45 00 0B 0004       JP _start
0B0004             0005   
0B0004             0006   ; Storage for the argv array pointers
0B0004             0007   min_args: equ 1
0B0004             0008   argv_ptrs_max: EQU 16 ; Maximum number of arguments allowed in argv
0B0004 00 00 00 00 0009   argv_ptrs: BLKP argv_ptrs_max, 0
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0B0034             0010   
0B0034             0011   _exec_name:
0B0034 63 61 6C 63 0012       ASCIZ "calc168" ; The executable name, only used in argv
       31 36 38 00 
0B003C FF FF FF FF 0013       ALIGN 64
0B0040 4D 4F 53    0014       DB "MOS" ; Flag for MOS - to confirm this is a valid MOS command
0B0043 00          0015       DB 00h ; MOS header version 0
0B0044 01          0016       DB 01h ; Flag for run mode (0: Z80, 1: ADL)
0B0045             0017   
0B0045             0018   _start:
0B0045 F5          0019       PUSH AF ; Preserve the registers
0B0046 C5          0020       PUSH BC
0B0047 D5          0021       PUSH DE
0B0048 DD E5       0022       PUSH IX
0B004A FD E5       0023       PUSH IY
0B004C ED 6E       0024       LD A, MB ; Save MB
0B004E F5          0025       PUSH AF
0B004F AF          0026       XOR A
0B0050 ED 6D       0027       LD MB, A ; Clear to zero so MOS API calls know how to use 24-bit addresses.
0B0052 DD 21 04 00 0028       LD IX, argv_ptrs ; The argv array pointer address
       0B          
0B0057 DD E5       0029       PUSH IX
0B0059 CD A4 0F 0B 0030       CALL _parse_params ; Parse the parameters
0B005D DD E1       0031       POP IX ; IX: argv
0B005F 06 00       0032       LD B, 0 ; C: argc
0B0061             0033   
0B0061 CD A1 0E 0B 0034       CALL main ; Start user code
0B0065             0035   
0B0065 F1          0036       POP AF
0B0066 ED 6D       0037       LD MB, A
0B0068 FD E1       0038       POP IY ; Restore registers
0B006A DD E1       0039       POP IX
0B006C D1          0040       POP DE
0B006D C1          0041       POP BC
0B006E F1          0042       POP AF
0B006F C9          0043       RET
0B0070             0044   
0B0070             0045   _main_end_error:
0B0070 CD 04 0B 0B 0046       call printInline
0B0074 41 6E 20 65 0047       asciz "An error occurred!\r\n"
       72 72 6F 72 
       20 6F 63 63 
       75 72 72 65 
       64 21 0D 0A 
       00          
0B0089 21 13 00 00 0048       ld hl,19 ; return error code 19
0B008D C9          0049       ret
0B008E             0050   
0B008E             0051   _main_end_ok:
0B008E CD 04 0B 0B 0052       call printInline
0B0092 0D 0A 0D 0A 0053       asciz "\r\n\r\n"
       00          
0B0097 21 00 00 00 0054       ld hl,0 ; return 0 for success
0B009B C9          0055       ret
0B009C             0056   
0B009C             0057   ;--- APPLICATION INCLUDES ---
0B009C             0058       include "fixed168.inc"
0B009C             0001*  ; multiply HL by 256
0B009C             0002*  ; inputs: HL
0B009C             0003*  ; outputs: HL*256
0B009C             0004*  ; destroys: flags
0B009C             0005*      MACRO hlu_mul256
0B009C             0006*          add hl,hl ; * 2
0B009C             0007*          add hl,hl ; * 4
0B009C             0008*          add hl,hl ; * 8
0B009C             0009*          add hl,hl ; * 16
0B009C             0010*          add hl,hl ; * 32
0B009C             0011*          add hl,hl ; * 64
0B009C             0012*          add hl,hl ; * 128
0B009C             0013*          add hl,hl ; * 256
0B009C             0014*      ENDMACRO
0B009C             0015*  
0B009C             0016*  ; test the sign of HL
0B009C             0017*  ; inputs: HL obviously
0B009C             0018*  ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
0B009C             0019*  ; destroys: flags
0B009C             0020*      MACRO sign_hlu
0B009C             0021*          add hl,de
0B009C             0022*          or a
0B009C             0023*          sbc hl,de
0B009C             0024*      ENDMACRO
0B009C             0025*  
0B009C             0026*  ; hlu signed division by 256
0B009C             0027*  ; returns: hlu / 256
0B009C             0028*  ; destroys: af
0B009C             0029*  hlu_sdiv256:
0B009C AF          0030*      xor a ; assume hl is positive
0B009D 22 B3 00 0B 0031*      ld (@buffer),hl
0B00A1             0032*      sign_hlu
0B00A1 19          0001*M         add hl,de
0B00A2 B7          0002*M         or a
0B00A3 ED 52       0003*M         sbc hl,de
0B00A5 F2 AA 00 0B 0033*      jp p,@hl_pos
0B00A9 3D          0034*      dec a
0B00AA             0035*  @hl_pos:
0B00AA 32 B6 00 0B 0036*      ld (@buffer+3),a
0B00AE 2A B4 00 0B 0037*      ld hl,(@buffer+1)
0B00B2 C9          0038*      ret
0B00B3 00 00 00 00 0039*  @buffer: blkb 4,0
0B00B7             0040*  
0B00B7             0041*  ; hlu 1 byte right shift, unsigned
0B00B7             0042*  ; returns: hlu / 256
0B00B7             0043*  hlu_udiv256:
0B00B7 22 C0 00 0B 0044*  	ld (@buffer),hl
0B00BB 2A C1 00 0B 0045*  	ld hl,(@buffer+1)
0B00BF C9          0046*  	ret
0B00C0 00 00 00 00 0047*  @buffer: blkb 4,0
0B00C4             0048*  
0B00C4             0049*  ; absolute value of hlu
0B00C4             0050*  ; returns: abs(hlu), flags set according to the incoming sign of hlu:
0B00C4             0051*  ;         s1,z0,pv0,n1,c0 if hlu was negative
0B00C4             0052*  ;         s0,z1,pv0,n1,c0 if hlu was zero
0B00C4             0053*  ;         s0,z0,pv0,n1,c0 if hlu was positive
0B00C4             0054*  ; destroys: a
0B00C4             0055*  hlu_abs:
0B00C4 19          0056*      add hl,de
0B00C5 B7          0057*      or a
0B00C6 ED 52       0058*      sbc hl,de
0B00C8 FA CD 00 0B 0059*      jp m,@is_neg
0B00CC C9          0060*      ret         ; hlu is positive or zero so we're done
0B00CD             0061*  @is_neg:
0B00CD F5          0062*      push af     ; otherwise, save current flags for return
0B00CE CD D4 00 0B 0063*      call neg_hlu ; negate hlu
0B00D2 F1          0064*      pop af      ; get back flags
0B00D3 C9          0065*      ret
0B00D4             0066*  
0B00D4             0067*  ; flip the sign of hlu
0B00D4             0068*  ; inputs: hlu
0B00D4             0069*  ; returns: 0-hlu, flags set appropriately for the result:
0B00D4             0070*  ;         s1,z0,pv0,n1,c1 if result is negative
0B00D4             0071*  ;         s0,z1,pv0,n1,c0 if result is zero
0B00D4             0072*  ;         s0,z0,pv0,n1,c1 if result is positive
0B00D4             0073*  ; destroys a
0B00D4             0074*  neg_hlu:
0B00D4 D5          0075*      push de     ; save de
0B00D5 EB          0076*      ex de,hl    ; put hl into de
0B00D6 21 00 00 00 0077*      ld hl,0     ; clear hl
0B00DA AF          0078*      xor a       ; clear carry
0B00DB ED 52       0079*      sbc hl,de   ; 0-hlu = -hlu
0B00DD D1          0080*      pop de      ; get de back
0B00DE C9          0081*      ret         ; easy peasy
0B00DF             0082*  
0B00DF             0083*      ; include "fixed24.inc"
0B00DF             0084*  
0B00DF             0085*  ; multiply a signed 24-bit number by an unsigned 8-bit number giving a signed 24-bit result
0B00DF             0086*  ; uses EZ80 MLT instruction for speed
0B00DF             0087*  ; operation: UHL * A --> UHL
0B00DF             0088*  ; destroys: AF, HL
0B00DF             0089*  smul24x8:
0B00DF             0090*  ; make hl positive and store sign flag
0B00DF CD C4 00 0B 0091*  	call hlu_abs
0B00E3 F5          0092*  	push af
0B00E4             0093*  ; do the division
0B00E4 CD EF 00 0B 0094*      call mul24x8 ; hl = product
0B00E8             0095*  ; adjust sign of result
0B00E8 F1          0096*  	pop af ; sign de
0B00E9 F0          0097*  	ret p ; hl was positive, nothing to do
0B00EA CD D4 00 0B 0098*  	call neg_hlu ; result is negative
0B00EE C9          0099*  	ret
0B00EF             0100*  
0B00EF             0101*  ; unsigned multiplication of a 24-bit and 8-bit number giving a 32-bit result
0B00EF             0102*  ; uses EZ80 MLT instruction for speed
0B00EF             0103*  ; operation: UHL * A --> AUHL
0B00EF             0104*  ; destroys: AF, HL
0B00EF             0105*  mul24x8:
0B00EF D5          0106*  	push de ; preserve de
0B00F0             0107*  ; low byte
0B00F0 5D          0108*  	ld e,l
0B00F1 57          0109*  	ld d,a
0B00F2 ED 5C       0110*  	mlt de
0B00F4 6B          0111*  	ld l,e ; product low byte
0B00F5 08          0112*  	ex af,af' ; save multiplier
0B00F6 7A          0113*  	ld a,d ; carry
0B00F7 08          0114*  	ex af,af' ; save carry, restore multiplier
0B00F8             0115*  ; high byte
0B00F8 5C          0116*  	ld e,h
0B00F9 57          0117*  	ld d,a
0B00FA ED 5C       0118*  	mlt de
0B00FC 08          0119*  	ex af,af' ; save multiplier, restore carry
0B00FD 83          0120*  	add a,e ; add carry
0B00FE 67          0121*  	ld h,a ; product middle byte
0B00FF 7A          0122*  	ld a,d ; carry
0B0100 08          0123*  	ex af,af' ; save carry, restore multiplier
0B0101             0124*  ; upper byte
0B0101 22 1C 01 0B 0125*      ld (@scratch),hl ; 7 cycles
0B0105 5F          0126*  	ld e,a
0B0106 3A 1E 01 0B 0127*  	ld a,(@scratch+2)
0B010A 57          0128*  	ld d,a
0B010B ED 5C       0129*  	mlt de
0B010D 08          0130*  	ex af,af' ; restore carry
0B010E 8B          0131*  	adc a,e ; add carry
0B010F 32 1E 01 0B 0132*      ld (@scratch+2),a ; 5 cycles
0B0113 2A 1C 01 0B 0133*      ld hl,(@scratch) ; 7 cycles
0B0117             0134*  ; highest byte
0B0117 3E 00       0135*  	ld a,0 ; preserve carry flag
0B0119 8A          0136*  	adc a,d ; product highest byte
0B011A D1          0137*  	pop de ; restore de
0B011B C9          0138*  	ret
0B011C             0139*  @scratch: ds 3
0B011F             0140*  
0B011F 00 00 00 00 0141*  mul24out: blkb 6,0
       00 00       
0B0125             0142*  
0B0125             0143*  ; unsigned multiplication of two 24-bit numbers giving a 48-bit result
0B0125             0144*  ; operation: UHL * UDE --> mul24out
0B0125             0145*  mul24:
0B0125 DD E5       0146*  	push ix ; preserve
0B0127             0147*  ; point to output buffer and clear it
0B0127 DD 21 1F 01 0148*  	ld ix,mul24out
       0B          
0B012C C5          0149*  	push bc
0B012D 01 00 00 00 0150*  	ld bc,0
0B0131 DD 0F 00    0151*  	ld (ix),bc
0B0134 DD 0F 03    0152*  	ld (ix+3),bc
0B0137 C1          0153*  	pop bc
0B0138             0154*  ; STEP 1: UHL * E
0B0138 7B          0155*  	ld a,e
0B0139 E5          0156*  	push hl
0B013A CD EF 00 0B 0157*  	call mul24x8
0B013E DD 2F 00    0158*  	ld (ix+0),hl
0B0141 DD 77 03    0159*  	ld (ix+3),a
0B0144             0160*  ; STEP 2: UHL * D
0B0144 E1          0161*  	pop hl
0B0145 E5          0162*  	push hl
0B0146 7A          0163*  	ld a,d
0B0147 CD EF 00 0B 0164*  	call mul24x8
0B014B CD 64 01 0B 0165*  	call @accumulate
0B014F             0166*  ; STEP 3: UHL * DEU
0B014F E1          0167*  	pop hl
0B0150 ED 53 94 01 0168*  	ld (@de),de
       0B          
0B0155 3A 96 01 0B 0169*  	ld a,(@de+2)
0B0159 CD EF 00 0B 0170*  	call mul24x8
0B015D CD 64 01 0B 0171*  	call @accumulate
0B0161             0172*  ; all done
0B0161 DD E1       0173*  	pop ix ; restore
0B0163 C9          0174*  	ret
0B0164             0175*  @accumulate:
0B0164 DD 23       0176*  	inc ix
0B0166             0177*  ; highest byte of product to carry
0B0166 DD 77 03    0178*  	ld (ix+3),a
0B0169             0179*  ; low byte of product
0B0169 7D          0180*  	ld a,l
0B016A DD 86 00    0181*  	add a,(ix+0)
0B016D DD 77 00    0182*  	ld (ix+0),a
0B0170             0183*  ; high byte of product
0B0170 7C          0184*  	ld a,h
0B0171 DD 8E 01    0185*  	adc a,(ix+1)
0B0174 DD 77 01    0186*  	ld (ix+1),a
0B0177             0187*  ; uppper byte of product
0B0177 22 91 01 0B 0188*  	ld (@hl),hl
0B017B 3A 93 01 0B 0189*  	ld a,(@hl+2)
0B017F DD 8E 02    0190*  	adc a,(ix+2)
0B0182 DD 77 02    0191*  	ld (ix+2),a
0B0185             0192*  ; carry
0B0185 3E 00       0193*  	ld a,0 ; preserve flags
0B0187 DD 8E 03    0194*  	adc a,(ix+3)
0B018A DD 77 03    0195*  	ld (ix+3),a
0B018D C9          0196*  	ret
0B018E             0197*  
0B018E 00 00 00    0198*  @ix: dl 0
0B0191 00 00 00    0199*  @hl: dl 0
0B0194 00 00 00    0200*  @de: dl 0
0B0197             0201*  
0B0197             0202*  ; UHL * UDE --> UHL (unsigned)
0B0197             0203*  umul24:
0B0197 CD 25 01 0B 0204*  	call mul24
0B019B 2A 1F 01 0B 0205*  	ld hl,(mul24out)
0B019F C9          0206*  	ret
0B01A0             0207*  
0B01A0             0208*  ; UH.L = UH.L*UD.E (unsigned)
0B01A0             0209*  umul168:
0B01A0 CD 25 01 0B 0210*  	call mul24
0B01A4 2A 20 01 0B 0211*  	ld hl,(mul24out+1)
0B01A8 C9          0212*  	ret
0B01A9             0213*  
0B01A9             0214*  ; UH.L * UD.E --> UH.L (signed)
0B01A9             0215*  smul168:
0B01A9             0216*  ; make everything positive and store sign flags
0B01A9 CD C4 00 0B 0217*  	call hlu_abs
0B01AD F5          0218*  	push af
0B01AE EB          0219*  	ex de,hl
0B01AF CD C4 00 0B 0220*  	call hlu_abs
0B01B3 EB          0221*  	ex de,hl
0B01B4 F5          0222*  	push af
0B01B5             0223*  ; do the division
0B01B5 CD A0 01 0B 0224*      call umul168 ; hl = product
0B01B9             0225*  ; adjust sign of result
0B01B9 F1          0226*  	pop af ; sign de
0B01BA FA C5 01 0B 0227*  	jp m,@de_neg
0B01BE F1          0228*  	pop af ; sign hl
0B01BF F0          0229*  	ret p ; both positive, nothing to do
0B01C0             0230*  @hl_neg:
0B01C0 CD D4 00 0B 0231*      call neg_hlu ; de pos, hl neg, result is negative
0B01C4 C9          0232*      ret
0B01C5             0233*  @de_neg:
0B01C5 F1          0234*  	pop af
0B01C6 F8          0235*  	ret m ; both negative, nothing to do
0B01C7 CD D4 00 0B 0236*  	call neg_hlu ; result is negative
0B01CB C9          0237*  	ret
0B01CC             0238*  
0B01CC             0239*  ; UH.L / UD.E --> UD.E rem UHL (unsigned)
0B01CC             0240*  ; perform unsigned division of 16.8 fixed place values
0B01CC             0241*  ; with an unsigned 16.8 fixed place result and 24-bit remainder
0B01CC             0242*  udiv168:
0B01CC             0243*  ; back up divisor
0B01CC ED 53 03 02 0244*  	ld (@ude),de
       0B          
0B01D1             0245*  ; get the 16-bit integer part of the quotient
0B01D1 CD 34 02 0B 0246*      call udiv24 ; de = quotient, hl = remainder
0B01D5             0247*  ; load quotient to upper three bytes of output
0B01D5 ED 53 0A 02 0248*      ld (div168_out+1),de
       0B          
0B01DA             0249*  @div256:
0B01DA             0250*  ; multiply remainder by 256
0B01DA             0251*  	hlu_mul256
0B01DA 29          0001*M         add hl,hl ; * 2
0B01DB 29          0002*M         add hl,hl ; * 4
0B01DC 29          0003*M         add hl,hl ; * 8
0B01DD 29          0004*M         add hl,hl ; * 16
0B01DE 29          0005*M         add hl,hl ; * 32
0B01DF 29          0006*M         add hl,hl ; * 64
0B01E0 29          0007*M         add hl,hl ; * 128
0B01E1 29          0008*M         add hl,hl ; * 256
0B01E2             0252*  ; skip fractional computation if remainder is zero
0B01E2             0253*      sign_hlu
0B01E2 19          0001*M         add hl,de
0B01E3 B7          0002*M         or a
0B01E4 ED 52       0003*M         sbc hl,de
0B01E6 20 03       0254*      jr nz,@div_frac
0B01E8 AF          0255*      xor a
0B01E9 18 0A       0256*      jr @write_frac
0B01EB             0257*  ; now divide the shifted remainder by the divisor
0B01EB             0258*  @div_frac:
0B01EB ED 5B 03 02 0259*  	ld de,(@ude) ; get back divisor
       0B          
0B01F0 CD 34 02 0B 0260*      call udiv24 ; de = quotient, hl = remainder
0B01F4             0261*  ; load low byte of quotient to low byte of output
0B01F4 7B          0262*      ld a,e
0B01F5             0263*  @write_frac:
0B01F5 32 09 02 0B 0264*      ld (div168_out),a
0B01F9             0265*  ; load de with return value
0B01F9 ED 5B 09 02 0266*      ld de,(div168_out)
       0B          
0B01FE             0267*  ; load a with any overflow
0B01FE 3A 0C 02 0B 0268*      ld a,(div168_out+3)
0B0202 C9          0269*      ret ; ud.e is the 16.8 result
0B0203             0270*  @ude: ds 6
0B0209             0271*  div168_out: ds 4 ; the extra byte is for overflow
0B020D             0272*  
0B020D             0273*  ; UH.L / UD.E --> UD.E (signed) rem UHL (unsigned)
0B020D             0274*  ; perform signed division of 16.8 fixed place values
0B020D             0275*  ; with a signed 16.8 fixed place result and unsigned 24-bit remainder
0B020D             0276*  sdiv168:
0B020D             0277*  ; make everything positive and store sign flags
0B020D CD C4 00 0B 0278*  	call hlu_abs
0B0211 F5          0279*  	push af
0B0212 EB          0280*  	ex de,hl
0B0213 CD C4 00 0B 0281*  	call hlu_abs
0B0217 EB          0282*  	ex de,hl
0B0218 F5          0283*  	push af
0B0219             0284*  ; do the division
0B0219 CD CC 01 0B 0285*      call udiv168 ; de = quotient, hl = remainder
0B021D             0286*  ; adjust sign of result
0B021D F1          0287*  	pop af ; sign de
0B021E FA 2B 02 0B 0288*  	jp m,@de_neg
0B0222 F1          0289*  	pop af ; sign hl
0B0223 F0          0290*  	ret p ; both positive, nothing to do
0B0224             0291*  @hl_neg:
0B0224 EB          0292*      ex de,hl ; hl = quotient, de = remainder
0B0225 CD D4 00 0B 0293*      call neg_hlu ; de pos, hl neg, result is negative
0B0229 EB          0294*      ex de,hl ; de = negated quotient, hl = remainder
0B022A C9          0295*      ret
0B022B             0296*  @de_neg:
0B022B F1          0297*  	pop af
0B022C F8          0298*  	ret m ; both negative, nothing to do
0B022D EB          0299*      ex de,hl ; hl = quotient, de = remainder
0B022E CD D4 00 0B 0300*  	call neg_hlu ; result is negative
0B0232 EB          0301*      ex de,hl ; de = negated quotient, hl = remainder
0B0233 C9          0302*  	ret
0B0234             0303*  
0B0234             0304*  ;------------------------------------------------------------------------
0B0234             0305*  ;  arith24.asm
0B0234             0306*  ;  24-bit ez80 arithmetic routines
0B0234             0307*  ;  Copyright (c) Shawn Sijnstra 2024
0B0234             0308*  ;  MIT license
0B0234             0309*  ;
0B0234             0310*  ;  This library was created as a tool to help make ez80
0B0234             0311*  ;  24-bit native assembly routines for simple mathematical problems
0B0234             0312*  ;  more widely available.
0B0234             0313*  ;
0B0234             0314*  ;------------------------------------------------------------------------
0B0234             0315*  ;
0B0234             0316*  ;------------------------------------------------------------------------
0B0234             0317*  ; udiv24
0B0234             0318*  ; Unsigned 24-bit division
0B0234             0319*  ; Divides HLU by DEU. Gives result in DEU (and BC), remainder in HLU.
0B0234             0320*  ;
0B0234             0321*  ; Uses AF BC DE HL
0B0234             0322*  ; Uses Restoring Division algorithm
0B0234             0323*  ;------------------------------------------------------------------------
0B0234             0324*  
0B0234             0325*  udiv24:
0B0234 E5          0326*  	push	hl
0B0235 C1          0327*  	pop		bc	;move dividend to BCU
0B0236 21 00 00 00 0328*  	ld		hl,0	;result
0B023A A7          0329*  	and		a
0B023B ED 52       0330*  	sbc		hl,de	;test for div by 0
0B023D C8          0331*  	ret		z		;it's zero, carry flag is clear
0B023E 19          0332*  	add		hl,de	;HL is 0 again
0B023F 3E 18       0333*  	ld		a,24	;number of loops through.
0B0241             0334*  udiv1:
0B0241 C5          0335*  	push	bc	;complicated way of doing this because of lack of access to top bits
0B0242 E3          0336*  	ex		(sp),hl
0B0243 37          0337*  	scf
0B0244 ED 6A       0338*  	adc	hl,hl
0B0246 E3          0339*  	ex	(sp),hl
0B0247 C1          0340*  	pop	bc		;we now have bc = (bc * 2) + 1
0B0248             0341*  
0B0248 ED 6A       0342*  	adc	hl,hl
0B024A A7          0343*  	and	a		;is this the bug
0B024B ED 52       0344*  	sbc	hl,de
0B024D 30 02       0345*  	jr	nc,udiv2
0B024F 19          0346*  	add	hl,de
0B0250             0347*  ;	dec	c
0B0250 0B          0348*  	dec	bc
0B0251             0349*  udiv2:
0B0251 3D          0350*  	dec	a
0B0252 20 ED       0351*  	jr	nz,udiv1
0B0254 37          0352*  	scf		;flag used for div0 error
0B0255 C5          0353*  	push	bc
0B0256 D1          0354*  	pop		de	;remainder
0B0257 C9          0355*  	ret
0B0258             0356*  
0B0258             0357*  ;------------------------------------------------------------------------
0B0258             0358*  ;  END 24-bit ez80 arithmetic routines by Shawn Sijnstra
0B0258             0359*  ;------------------------------------------------------------------------
0B0258             0360*  
0B0258             0361*  
0B0258             0362*      ; include "trig24fast.inc"
0B0258             0363*  
0B0258             0364*  
0B0258             0365*  ; convert signed angles from a 360 to 256 degree circle
0B0258             0366*  ; inputs: uh.l is the angle360 in 16.8 fixed format
0B0258             0367*  ; outputs: uh.l is the angle256 in 16.8 fixed format
0B0258             0368*  ; destroys: TODO
0B0258             0369*  deg_360_to_256:
0B0258 D5          0370*  	push de ; preserve de
0B0259             0371*  ; make angle positive and store sign flag
0B0259 CD C4 00 0B 0372*  	call hlu_abs
0B025D F5          0373*  	push af
0B025E             0374*  ; multiply by coversion factor of 256/360
0B025E 11 B6 00 00 0375*  	ld de,0x0000B6 ; 0.711
0B0262 CD A0 01 0B 0376*  	call umul168 ; uh.l = uh.l * 0.711
0B0266             0377*  ; restore sign flag and adjust output accordingly
0B0266 F1          0378*  	pop af
0B0267 F2 6F 02 0B 0379*  	jp p,@pos ; positive number
0B026B CD D4 00 0B 0380*  	call neg_hlu
0B026F             0381*  @pos:
0B026F             0382*  ; restore de and return uh.l as the result
0B026F D1          0383*  	pop de
0B0270 C9          0384*  	ret
0B0271             0385*  
0B0271             0386*  ; convert signed angles from a 256 to 360 degree circle
0B0271             0387*  ; inputs: uh.l is the angle256 in 16.8 fixed format
0B0271             0388*  ; outputs: uh.l is the angle360 in 16.8 fixed format
0B0271             0389*  ; destroys: TODO
0B0271             0390*  deg_256_to_360:
0B0271 D5          0391*  	push de ; preserve de
0B0272             0392*  ; make angle positive and store sign flag
0B0272 CD C4 00 0B 0393*  	call hlu_abs
0B0276 F5          0394*  	push af
0B0277             0395*  ; multiply by coversion factor of 360/256
0B0277 11 68 01 00 0396*      ld de,0x000168 ; 1.406
0B027B CD A0 01 0B 0397*  	call umul168 ; uh.l = uh.l * 1.406
0B027F             0398*  ; restore sign flag and adjust output accordingly
0B027F F1          0399*  	pop af
0B0280 F2 88 02 0B 0400*  	jp p,@pos ; positive number
0B0284 CD D4 00 0B 0401*  	call neg_hlu
0B0288             0402*  @pos:
0B0288             0403*  ; restore de and return uh.l as the result
0B0288 D1          0404*  	pop de
0B0289 C9          0405*  	ret
0B028A             0406*  
0B028A             0407*  ; fixed 16.8 routine
0B028A             0408*  ; cos(uh.l) --> uh.l
0B028A             0409*  ; destroys: f, hl
0B028A             0410*  cos168:
0B028A D5          0411*      push de ; preserve de
0B028B             0412*  ; for cos we simply increment the angle by 90 degrees
0B028B             0413*  ; or 0x004000 in 16.8 degrees256
0B028B             0414*  ; which makes it a sin problem
0B028B 11 00 40 00 0415*      ld de,0x004000
0B028F 19          0416*      add hl,de ; modulo 256 happens below
0B0290 D1          0417*      pop de ; restore de
0B0291             0418*  ; fall through to sin168
0B0291             0419*  
0B0291             0420*  ; ---------------------
0B0291             0421*  ; fixed 16.8 routine
0B0291             0422*  ; sin(uh.l) --> uh.l
0B0291             0423*  ; destroys: f, hl
0B0291             0424*  sin168:
0B0291 D5          0425*  	push de
0B0292             0426*  ; handle negative angles appropriately
0B0292 CD C4 00 0B 0427*  	call hlu_abs
0B0296 F2 9F 02 0B 0428*  	jp p,@F
0B029A 11 00 00 FF 0429*  	ld de,-256*256
0B029E 19          0430*  	add hl,de
0B029F             0431*  @@:
0B029F 2E 03       0432*  	ld l,3 ; multiply by 3 to get our lookup index
0B02A1 ED 6C       0433*      mlt hl
0B02A3 11 EE 04 0B 0434*      ld de,sin_lut_168 ; grab the lut address
0B02A7 19          0435*      add hl,de ; bump hl by the index
0B02A8 ED 27       0436*      ld hl,(hl) ; don't try this on a z80!
0B02AA D1          0437*      pop de
0B02AB C9          0438*      ret
0B02AC             0439*  
0B02AC             0440*  ; 16.8 fixed inputs / outputs
0B02AC             0441*  ; takes: uh.l as angle in degrees 256
0B02AC             0442*  ;        ud.e as radius
0B02AC             0443*  ; returns ub.c as dx, ud.e as dy, uh.l as radius
0B02AC             0444*  ;        displacements from origin (0,0)
0B02AC             0445*  ; destroys: everything except indexes
0B02AC             0446*  polar_to_cartesian:
0B02AC             0447*  ; back up input parameters
0B02AC 22 DB 02 0B 0448*      ld (@angle), hl
0B02B0 ED 53 DE 02 0449*      ld (@radius), de
       0B          
0B02B5             0450*  ; compute dx = sin(uh.l) * ud.e
0B02B5 CD 91 02 0B 0451*      call sin168 ; uh.l = sin(uh.l)
0B02B9 ED 5B DE 02 0452*  	ld de,(@radius)
       0B          
0B02BE CD A9 01 0B 0453*  	call smul168 ; uh.l = dx
0B02C2 E5          0454*      push hl
0B02C3             0455*  ; compute dy = -cos(uh.l) * ud.e
0B02C3 2A DB 02 0B 0456*      ld hl,(@angle)
0B02C7 CD 8A 02 0B 0457*      call cos168 ; uh.l = cos(uh.l)
0B02CB ED 5B DE 02 0458*      ld de,(@radius)
       0B          
0B02D0 CD A9 01 0B 0459*      call smul168    ; uh.l = dy
0B02D4 CD D4 00 0B 0460*      call neg_hlu ; invert dy for screen coords convention
0B02D8 EB          0461*      ex de,hl       ; de = dy for output
0B02D9 C1          0462*      pop bc          ; bc = dx for output
0B02DA             0463*  ; and out
0B02DA C9          0464*      ret
0B02DB             0465*  @angle: ds 3
0B02DE             0466*  @radius: ds 3
0B02E1             0467*  
0B02E1             0468*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
0B02E1             0469*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
0B02E1             0470*  ; output: ub.c and ud.e are dx and dy in 16.8 fixed format
0B02E1             0471*  ;         also populates scratch locations dx168 and dy168
0B02E1             0472*  ; destroys: a,hl,bc,de
0B02E1             0473*  dxy168:
0B02E1             0474*  ; compute dx = x1-x0
0B02E1 AF          0475*      xor a ; clear carry
0B02E2 DD E5       0476*      push ix ; move ix to hl via the stack
0B02E4 E1          0477*      pop hl ; hl = x1
0B02E5 ED 42       0478*      sbc hl,bc ; hl = dx
0B02E7 22 FC 02 0B 0479*      ld (dx168),hl ; dx to scratch
0B02EB             0480*  ; compute dy = y1-y0
0B02EB AF          0481*      xor a ; clear carry
0B02EC FD E5       0482*      push iy ; move iy to hl via the stack
0B02EE E1          0483*      pop hl ; hl = y1
0B02EF ED 52       0484*      sbc hl,de ; hl = dy
0B02F1 22 02 03 0B 0485*      ld (dy168),hl ; dy to scratch
0B02F5             0486*  ; populate output registers and return
0B02F5 EB          0487*      ex de,hl        ; ud.e = dy
0B02F6 ED 4B FC 02 0488*      ld bc,(dx168)   ; ub.c = dx
       0B          
0B02FB C9          0489*      ret
0B02FC 00 00 00 00 0490*  dx168: blkb 6,0
       00 00       
0B0302 00 00 00 00 0491*  dy168: blkb 6,0
       00 00       
0B0308             0492*  
0B0308             0493*  ; compute the euclidian distance between two cartesian coordinates
0B0308             0494*  ; using the formula d = sqrt(dx^2+dy^2)
0B0308             0495*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
0B0308             0496*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
0B0308             0497*  ; output; uh.l is the 16.8 fixed format distance
0B0308             0498*  ;         also populates scratch locations dx168 and dy168
0B0308             0499*  ; destroys: a,hl,bc,de
0B0308             0500*  ; NOTE: rounds both deltas down to the nearest integer to avoid overflow when squaring,
0B0308             0501*  ;       thus the result will always be an integer, albeit in 16.8 format
0B0308             0502*  distance168:
0B0308 CD E1 02 0B 0503*  	call dxy168 ; ub.c = dx, ud.e = dy
0B030C             0504*  ; compute dy^2
0B030C EB          0505*  	ex de,hl
0B030D CD C4 00 0B 0506*  	call hlu_abs
0B0311 CD B7 00 0B 0507*  	call hlu_udiv256 ; make integer to avoid overflow
0B0315 E5          0508*  	push hl
0B0316 D1          0509*  	pop de
0B0317 CD 97 01 0B 0510*  	call umul24 ; hl = dy^2
0B031B E5          0511*  	push hl ; save dy^2
0B031C             0512*  ; compute dx^2
0B031C 2A FC 02 0B 0513*  	ld hl,(dx168)
0B0320 CD C4 00 0B 0514*  	call hlu_abs
0B0324 CD B7 00 0B 0515*  	call hlu_udiv256 ; make integer to avoid overflow
0B0328 E5          0516*  	push hl
0B0329 D1          0517*  	pop de
0B032A CD 97 01 0B 0518*  	call umul24 ; hl = dx^2
0B032E             0519*  ; add dx^2 and dy^2
0B032E D1          0520*  	pop de ; de = dy^2 (was hl)
0B032F 19          0521*  	add hl,de ; hl = dx^2 + dy^2
0B0330             0522*  ; compute the square root
0B0330 CD 09 04 0B 0523*  	call sqrt24 ; de = sqrt(dx^2 + dy^2)
0B0334 EB          0524*      ex de,hl ; hl = distance
0B0335             0525*      hlu_mul256 ; convert back to 16.8 fixed
0B0335 29          0001*M         add hl,hl ; * 2
0B0336 29          0002*M         add hl,hl ; * 4
0B0337 29          0003*M         add hl,hl ; * 8
0B0338 29          0004*M         add hl,hl ; * 16
0B0339 29          0005*M         add hl,hl ; * 32
0B033A 29          0006*M         add hl,hl ; * 64
0B033B 29          0007*M         add hl,hl ; * 128
0B033C 29          0008*M         add hl,hl ; * 256
0B033D C9          0526*  	ret
0B033E             0527*  
0B033E             0528*  ; atan2_(ub.c,ud.e) --> uh.l
0B033E             0529*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
0B033E             0530*  ;   whether inputs are integers or fractional doesn't matter
0B033E             0531*  ;   so long as the sign bit of the upper byte is correct
0B033E             0532*  ; output: uh.l is the 16.8 fixed angle in degrees 256
0B033E             0533*  ; angles are COMPASS HEADINGS based on
0B033E             0534*  ; screen coordinate conventions,where the y axis is flipped
0B033E             0535*  ; #E0 315      0       45 #20
0B033E             0536*  ;        -x,-y | +x,-y
0B033E             0537*  ; #C0 270------+------ 90 #40
0B033E             0538*  ;        -x,+y | +x,+y
0B033E             0539*  ; #A0 225   180 #80   135 #60
0B033E             0540*  atan2_168fast:
0B033E             0541*  ; get signs and make everything positive
0B033E             0542*  ; get abs(x) and store its original sign
0B033E C5          0543*      push bc
0B033F E1          0544*      pop hl
0B0340 CD C4 00 0B 0545*      call hlu_abs ; if x was negative this also sets the sign flag
0B0344 E5          0546*      push hl ; store abs(x)
0B0345 C1          0547*      pop bc ; bc = abs(x)
0B0346 F5          0548*      push af ; store sign of x
0B0347             0549*  ; get abs(y) and store its original sign
0B0347 EB          0550*      ex de,hl ; hl = y
0B0348 CD C4 00 0B 0551*      call hlu_abs ; if y was negative this also sets the sign flag
0B034C EB          0552*      ex de,hl ; de = abs(y)
0B034D F5          0553*      push af ; store sign of y
0B034E             0554*  ; if abs(bc) < abs(de),then we do bc/de,otherwise de/bc
0B034E             0555*  ; this ensures that our lookup value is between 0 and 1 inclusive
0B034E AF          0556*      xor a ; clear the carry flag
0B034F D5          0557*      push de
0B0350 E1          0558*      pop hl
0B0351 ED 42       0559*      sbc hl,bc
0B0353 F5          0560*      push af ; save sign of de - bc
0B0354 F2 5D 03 0B 0561*      jp p,@1 ; bc <= de, so we skip ahead
0B0358             0562*  ; otherwise we swap bc and de
0B0358 C5          0563*      push bc
0B0359 E1          0564*      pop hl
0B035A EB          0565*      ex de,hl
0B035B E5          0566*      push hl
0B035C C1          0567*      pop bc
0B035D             0568*  @1:
0B035D             0569*  ; now we're ready to snag our preliminary result
0B035D C5          0570*  	push bc
0B035E E1          0571*  	pop hl
0B035F CD CD 03 0B 0572*      call atan_168fast ; uh.l comes back with prelim result
0B0363             0573*  ; now we adjust uh.l based on sign of de - bc
0B0363 F1          0574*      pop af
0B0364 F2 70 03 0B 0575*      jp p,@2 ; bc <= de,so we skip ahead
0B0368 EB          0576*      ex de,hl
0B0369 21 00 40 00 0577*      ld hl,0x004000 ; 90 degrees
0B036D AF          0578*      xor a ; clear the carry flag
0B036E ED 52       0579*      sbc hl,de ; subtract result from 90 degrees
0B0370             0580*  @2:
0B0370             0581*  ; now the fun part of adjusting the result
0B0370             0582*  ; based on which quadrant (x,y) is in
0B0370             0583*  ; #E0 315      0       45 #20
0B0370             0584*  ;        -x,-y | +x,-y
0B0370             0585*  ; #C0 270------+------ 90 #40
0B0370             0586*  ;        -x,+y | +x,+y
0B0370             0587*  ; #A0 225   180 #80   135 #60
0B0370 F1          0588*      pop af ; sign of y
0B0371 CA AE 03 0B 0589*      jp z,@y_zero
0B0375 F2 8E 03 0B 0590*      jp p,@y_pos
0B0379             0591*  ; y neg,check x
0B0379 F1          0592*      pop af ; sign of x
0B037A CA 88 03 0B 0593*      jp z,@y_neg_x_zero
0B037E F2 8D 03 0B 0594*      jp p,@y_neg_x_pos
0B0382             0595*  ; y neg,x neg
0B0382             0596*  ; angle is 270-360
0B0382             0597*  ; negating the intermediate does the trick
0B0382 CD D4 00 0B 0598*      call neg_hlu
0B0386 18 31       0599*      jr @zero_hlu
0B0388             0600*  
0B0388             0601*  @y_neg_x_zero:
0B0388             0602*  ; y neg,x zero
0B0388             0603*  ; angle is 0
0B0388 21 00 00 00 0604*      ld hl,0
0B038C C9          0605*      ret
0B038D             0606*  @y_neg_x_pos:
0B038D             0607*  ; y neg,x pos
0B038D             0608*  ; angle is 0 to 90
0B038D             0609*  ; so we're good
0B038D C9          0610*      ret
0B038E             0611*  
0B038E             0612*  @y_pos:
0B038E F1          0613*      pop af ; sign of x
0B038F CA 9E 03 0B 0614*      jp z,@y_pos_x_zero
0B0393 F2 A3 03 0B 0615*      jp p,@y_pos_x_pos
0B0397             0616*  ; y pos,x neg
0B0397             0617*  ; angle is 180-270
0B0397             0618*  ; so we add 180 to intermediate
0B0397 11 00 80 00 0619*      ld de,0x008000
0B039B 19          0620*      add hl,de
0B039C 18 1B       0621*      jr @zero_hlu
0B039E             0622*  @y_pos_x_zero:
0B039E             0623*  ; y pos,x zero
0B039E             0624*  ; angle is 180
0B039E 21 00 80 00 0625*      ld hl,0x008000
0B03A2 C9          0626*      ret
0B03A3             0627*  @y_pos_x_pos:
0B03A3             0628*  ; y pos,x pos
0B03A3             0629*  ; angle is 90-180
0B03A3             0630*  ; neg the intermediate and add 180 degrees
0B03A3 CD D4 00 0B 0631*      call neg_hlu
0B03A7 11 00 80 00 0632*      ld de,0x008000
0B03AB 19          0633*      add hl,de
0B03AC 18 0B       0634*      jr @zero_hlu
0B03AE             0635*  
0B03AE             0636*  @y_zero:
0B03AE F1          0637*      pop af ; sign of x
0B03AF FA B4 03 0B 0638*      jp m,@y_zero_x_neg
0B03B3             0639*  ; y zero,x pos
0B03B3             0640*  ; angle is 90,nothing to do
0B03B3 C9          0641*      ret
0B03B4             0642*  @y_zero_x_neg:
0B03B4             0643*  ; y zero ,x neg
0B03B4             0644*  ; angle is 270
0B03B4 21 00 C0 00 0645*      ld hl,0x00C000
0B03B8 C9          0646*      ret
0B03B9             0647*  @zero_hlu:
0B03B9 AF          0648*      xor a
0B03BA 22 C7 03 0B 0649*      ld (@scratch),hl
0B03BE 32 C9 03 0B 0650*      ld (@scratch+2),a
0B03C2 2A C7 03 0B 0651*      ld hl,(@scratch)
0B03C6 C9          0652*      ret
0B03C7             0653*  @scratch: ds 6
0B03CD             0654*  
0B03CD             0655*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
0B03CD             0656*  ; output: uh.l is the 16.8 fixed format angle in degrees 256
0B03CD             0657*  ; destroys: a,hl,bc,de
0B03CD             0658*  ; note: only works for angles from 0 to 32 (45) degrees
0B03CD             0659*  ;   use atan2_168fast (which calls this proc) to handle the full 256 (360) degrees
0B03CD             0660*  atan_168fast:
0B03CD             0661*  ; because we use compass headings instead of geometric angles
0B03CD             0662*  ; we compute dx/dy which is 1/tan(theta) in the maths world
0B03CD             0663*  ; we can do faster unsigned division here because we know dx and dy are positive
0B03CD CD CC 01 0B 0664*  	call udiv168 ; ud.e = dx/dy
0B03D1 EB          0665*  	ex de,hl ; uh.l = dx/dy
0B03D2             0666*  ; test uh.l for 0
0B03D2 19          0667*      add hl,de
0B03D3 B7          0668*      or a
0B03D4 ED 52       0669*      sbc hl,de
0B03D6 28 22       0670*      jr z,@is_zero
0B03D8             0671*  ; test uh.l for 1
0B03D8 AF          0672*      xor a ; clear carry
0B03D9 EB          0673*      ex de,hl
0B03DA 21 00 01 00 0674*      ld hl,0x000100 ; 1 in 16.8 fixed format
0B03DE ED 52       0675*      sbc hl,de
0B03E0 28 13       0676*      jr z,@is_45
0B03E2 EB          0677*  	ex de,hl
0B03E3             0678*  ; no special cases so we move on
0B03E3             0679*  ; l contains the fractional portion of tan(uh.l)
0B03E3             0680*  ; we multiply it by three to get our lookup table index
0B03E3 26 03       0681*      ld h,3
0B03E5 ED 6C       0682*      mlt hl ; gosh that is handy
0B03E7 11 00 00 00 0683*      ld de,0 ; clear deu
0B03EB 54          0684*      ld d,h ; copy hl to de
0B03EC 5D          0685*      ld e,l ; de contains our index
0B03ED 21 F1 07 0B 0686*      ld hl,atan_lut_168 ; grab the lut address
0B03F1 19          0687*      add hl,de ; bump hl by the index
0B03F2 ED 27       0688*      ld hl,(hl) ; don't try this on a z80!
0B03F4 C9          0689*      ret ; and out
0B03F5             0690*  @is_45:
0B03F5 21 00 20 00 0691*      ld hl,0x002000 ; 45 degrees decimal
0B03F9 C9          0692*      ret
0B03FA             0693*  ; for the case tan(0)
0B03FA             0694*  @is_zero:
0B03FA 21 00 00 00 0695*      ld hl,0x000000
0B03FE C9          0696*      ret
0B03FF             0697*  
0B03FF             0698*  ; Expects  ADL mode
0B03FF             0699*  ; Inputs:  UH.L
0B03FF             0700*  ; Outputs: UH.L is the 16.8 square root
0B03FF             0701*  ;          UDE is the integer difference inputHL-DE^2
0B03FF             0702*  sqrt168:
0B03FF CD 09 04 0B 0703*      call sqrt24
0B0403 EB          0704*      ex de,hl
0B0404 29          0705*      add hl,hl
0B0405 29          0706*      add hl,hl
0B0406 29          0707*      add hl,hl
0B0407 29          0708*      add hl,hl
0B0408 C9          0709*      ret
0B0409             0710*  
0B0409             0711*  ; credit: xeda112358
0B0409             0712*  ; https://www.cemetech.net/forum/viewtopic.php?t=11178&postdays=0&postorder=asc&start=0
0B0409             0713*  sqrt24:
0B0409             0714*  ; Expects ADL mode
0B0409             0715*  ; Inputs: HL
0B0409             0716*  ; Outputs: DE is the integer square root
0B0409             0717*  ;  HL is the difference inputHL-DE^2
0B0409             0718*  ;  c flag reset
0B0409 01 00 00 00 0719*  	ld bc,0 ; clear bcu
0B040D 11 00 00 00 0720*  	ld de,0 ; clear deu
0B0411 AF          0721*      xor a
0B0412 45          0722*      ld b,l
0B0413 C5          0723*      push bc
0B0414 6F          0724*      ld l,a
0B0415             0725*  ; Iteration 1
0B0415 29          0726*      add hl,hl
0B0416 CB 11       0727*      rl c
0B0418 29          0728*      add hl,hl
0B0419 CB 11       0729*      rl c
0B041B 91          0730*      sub c
0B041C 30 04       0731*      jr nc,$+6
0B041E 1C          0732*      inc e
0B041F 1C          0733*      inc e
0B0420 2F          0734*      cpl
0B0421 4F          0735*      ld c,a
0B0422             0736*  ; Iteration 2
0B0422 29          0737*      add hl,hl
0B0423 CB 11       0738*      rl c
0B0425 29          0739*      add hl,hl
0B0426 CB 11       0740*      rl c
0B0428 CB 13       0741*      rl e
0B042A 7B          0742*      ld a,e
0B042B 91          0743*      sub c
0B042C 30 04       0744*      jr nc,$+6
0B042E 1C          0745*      inc e
0B042F 1C          0746*      inc e
0B0430 2F          0747*      cpl
0B0431 4F          0748*      ld c,a
0B0432             0749*  ; Iteration 3
0B0432 29          0750*      add hl,hl
0B0433 CB 11       0751*      rl c
0B0435 29          0752*      add hl,hl
0B0436 CB 11       0753*      rl c
0B0438 CB 13       0754*      rl e
0B043A 7B          0755*      ld a,e
0B043B 91          0756*      sub c
0B043C 30 04       0757*      jr nc,$+6
0B043E 1C          0758*      inc e
0B043F 1C          0759*      inc e
0B0440 2F          0760*      cpl
0B0441 4F          0761*      ld c,a
0B0442             0762*  ; Iteration 4
0B0442 29          0763*      add hl,hl
0B0443 CB 11       0764*      rl c
0B0445 29          0765*      add hl,hl
0B0446 CB 11       0766*      rl c
0B0448 CB 13       0767*      rl e
0B044A 7B          0768*      ld a,e
0B044B 91          0769*      sub c
0B044C 30 04       0770*      jr nc,$+6
0B044E 1C          0771*      inc e
0B044F 1C          0772*      inc e
0B0450 2F          0773*      cpl
0B0451 4F          0774*      ld c,a
0B0452             0775*  ; Iteration 5
0B0452 29          0776*      add hl,hl
0B0453 CB 11       0777*      rl c
0B0455 29          0778*      add hl,hl
0B0456 CB 11       0779*      rl c
0B0458 CB 13       0780*      rl e
0B045A 7B          0781*      ld a,e
0B045B 91          0782*      sub c
0B045C 30 04       0783*      jr nc,$+6
0B045E 1C          0784*      inc e
0B045F 1C          0785*      inc e
0B0460 2F          0786*      cpl
0B0461 4F          0787*      ld c,a
0B0462             0788*  ; Iteration 6
0B0462 29          0789*      add hl,hl
0B0463 CB 11       0790*      rl c
0B0465 29          0791*      add hl,hl
0B0466 CB 11       0792*      rl c
0B0468 CB 13       0793*      rl e
0B046A 7B          0794*      ld a,e
0B046B 91          0795*      sub c
0B046C 30 04       0796*      jr nc,$+6
0B046E 1C          0797*      inc e
0B046F 1C          0798*      inc e
0B0470 2F          0799*      cpl
0B0471 4F          0800*      ld c,a
0B0472             0801*  ; Iteration 7
0B0472 29          0802*      add hl,hl
0B0473 CB 11       0803*      rl c
0B0475 29          0804*      add hl,hl
0B0476 CB 11       0805*      rl c
0B0478 CB 10       0806*      rl b
0B047A EB          0807*      ex de,hl
0B047B 29          0808*      add hl,hl
0B047C E5          0809*      push hl
0B047D ED 42       0810*      sbc hl,bc
0B047F 30 06       0811*      jr nc,$+8
0B0481 7C          0812*      ld a,h
0B0482 2F          0813*      cpl
0B0483 47          0814*      ld b,a
0B0484 7D          0815*      ld a,l
0B0485 2F          0816*      cpl
0B0486 4F          0817*      ld c,a
0B0487 E1          0818*      pop hl
0B0488 30 02       0819*      jr nc,$+4
0B048A 23          0820*      inc hl
0B048B 23          0821*      inc hl
0B048C EB          0822*      ex de,hl
0B048D             0823*  ; Iteration 8
0B048D 29          0824*      add hl,hl
0B048E 69          0825*      ld l,c
0B048F 60          0826*      ld h,b
0B0490 ED 6A       0827*      adc hl,hl
0B0492 ED 6A       0828*      adc hl,hl
0B0494 EB          0829*      ex de,hl
0B0495 29          0830*      add hl,hl
0B0496 ED 52       0831*      sbc hl,de
0B0498 19          0832*      add hl,de
0B0499 EB          0833*      ex de,hl
0B049A 30 04       0834*      jr nc,$+6
0B049C ED 52       0835*      sbc hl,de
0B049E 13          0836*      inc de
0B049F 13          0837*      inc de
0B04A0             0838*  ; Iteration 9
0B04A0 F1          0839*      pop af
0B04A1 17          0840*      rla
0B04A2 ED 6A       0841*      adc hl,hl
0B04A4 17          0842*      rla
0B04A5 ED 6A       0843*      adc hl,hl
0B04A7 EB          0844*      ex de,hl
0B04A8 29          0845*      add hl,hl
0B04A9 ED 52       0846*      sbc hl,de
0B04AB 19          0847*      add hl,de
0B04AC EB          0848*      ex de,hl
0B04AD 30 04       0849*      jr nc,$+6
0B04AF ED 52       0850*      sbc hl,de
0B04B1 13          0851*      inc de
0B04B2 13          0852*      inc de
0B04B3             0853*  ; Iteration 10
0B04B3 17          0854*      rla
0B04B4 ED 6A       0855*      adc hl,hl
0B04B6 17          0856*      rla
0B04B7 ED 6A       0857*      adc hl,hl
0B04B9 EB          0858*      ex de,hl
0B04BA 29          0859*      add hl,hl
0B04BB ED 52       0860*      sbc hl,de
0B04BD 19          0861*      add hl,de
0B04BE EB          0862*      ex de,hl
0B04BF 30 04       0863*      jr nc,$+6
0B04C1 ED 52       0864*      sbc hl,de
0B04C3 13          0865*      inc de
0B04C4 13          0866*      inc de
0B04C5             0867*  ; Iteration 11
0B04C5 17          0868*      rla
0B04C6 ED 6A       0869*      adc hl,hl
0B04C8 17          0870*      rla
0B04C9 ED 6A       0871*      adc hl,hl
0B04CB EB          0872*      ex de,hl
0B04CC 29          0873*      add hl,hl
0B04CD ED 52       0874*      sbc hl,de
0B04CF 19          0875*      add hl,de
0B04D0 EB          0876*      ex de,hl
0B04D1 30 04       0877*      jr nc,$+6
0B04D3 ED 52       0878*      sbc hl,de
0B04D5 13          0879*      inc de
0B04D6 13          0880*      inc de
0B04D7             0881*  ; Iteration 12
0B04D7 17          0882*      rla
0B04D8 ED 6A       0883*      adc hl,hl
0B04DA 17          0884*      rla
0B04DB ED 6A       0885*      adc hl,hl
0B04DD EB          0886*      ex de,hl
0B04DE 29          0887*      add hl,hl
0B04DF ED 52       0888*      sbc hl,de
0B04E1 19          0889*      add hl,de
0B04E2 EB          0890*      ex de,hl
0B04E3 30 04       0891*      jr nc,$+6
0B04E5 ED 52       0892*      sbc hl,de
0B04E7 13          0893*      inc de
0B04E8 13          0894*      inc de
0B04E9 CB 1A       0895*      rr d
0B04EB CB 1B       0896*      rr e
0B04ED C9          0897*      ret
0B04EE             0898*  
0B04EE             0899*  sin_lut_168:
0B04EE 00 00 00    0900*  	dl 0x000000 ; 0.000 00, 0.000
0B04F1 06 00 00    0901*  	dl 0x000006 ; 1.406 01, 0.025
0B04F4 0C 00 00    0902*  	dl 0x00000C ; 2.813 02, 0.049
0B04F7 12 00 00    0903*  	dl 0x000012 ; 4.219 03, 0.074
0B04FA 19 00 00    0904*  	dl 0x000019 ; 5.625 04, 0.098
0B04FD 1F 00 00    0905*  	dl 0x00001F ; 7.031 05, 0.122
0B0500 25 00 00    0906*  	dl 0x000025 ; 8.438 06, 0.147
0B0503 2B 00 00    0907*  	dl 0x00002B ; 9.844 07, 0.171
0B0506 31 00 00    0908*  	dl 0x000031 ; 11.250 08, 0.195
0B0509 38 00 00    0909*  	dl 0x000038 ; 12.656 09, 0.219
0B050C 3E 00 00    0910*  	dl 0x00003E ; 14.063 0A, 0.243
0B050F 44 00 00    0911*  	dl 0x000044 ; 15.469 0B, 0.267
0B0512 4A 00 00    0912*  	dl 0x00004A ; 16.875 0C, 0.290
0B0515 50 00 00    0913*  	dl 0x000050 ; 18.281 0D, 0.314
0B0518 56 00 00    0914*  	dl 0x000056 ; 19.688 0E, 0.337
0B051B 5C 00 00    0915*  	dl 0x00005C ; 21.094 0F, 0.360
0B051E 61 00 00    0916*  	dl 0x000061 ; 22.500 10, 0.383
0B0521 67 00 00    0917*  	dl 0x000067 ; 23.906 11, 0.405
0B0524 6D 00 00    0918*  	dl 0x00006D ; 25.313 12, 0.428
0B0527 73 00 00    0919*  	dl 0x000073 ; 26.719 13, 0.450
0B052A 78 00 00    0920*  	dl 0x000078 ; 28.125 14, 0.471
0B052D 7E 00 00    0921*  	dl 0x00007E ; 29.531 15, 0.493
0B0530 83 00 00    0922*  	dl 0x000083 ; 30.938 16, 0.514
0B0533 88 00 00    0923*  	dl 0x000088 ; 32.344 17, 0.535
0B0536 8E 00 00    0924*  	dl 0x00008E ; 33.750 18, 0.556
0B0539 93 00 00    0925*  	dl 0x000093 ; 35.156 19, 0.576
0B053C 98 00 00    0926*  	dl 0x000098 ; 36.563 1A, 0.596
0B053F 9D 00 00    0927*  	dl 0x00009D ; 37.969 1B, 0.615
0B0542 A2 00 00    0928*  	dl 0x0000A2 ; 39.375 1C, 0.634
0B0545 A7 00 00    0929*  	dl 0x0000A7 ; 40.781 1D, 0.653
0B0548 AB 00 00    0930*  	dl 0x0000AB ; 42.188 1E, 0.672
0B054B B0 00 00    0931*  	dl 0x0000B0 ; 43.594 1F, 0.690
0B054E B5 00 00    0932*  	dl 0x0000B5 ; 45.000 20, 0.707
0B0551 B9 00 00    0933*  	dl 0x0000B9 ; 46.406 21, 0.724
0B0554 BD 00 00    0934*  	dl 0x0000BD ; 47.813 22, 0.741
0B0557 C1 00 00    0935*  	dl 0x0000C1 ; 49.219 23, 0.757
0B055A C5 00 00    0936*  	dl 0x0000C5 ; 50.625 24, 0.773
0B055D C9 00 00    0937*  	dl 0x0000C9 ; 52.031 25, 0.788
0B0560 CD 00 00    0938*  	dl 0x0000CD ; 53.438 26, 0.803
0B0563 D1 00 00    0939*  	dl 0x0000D1 ; 54.844 27, 0.818
0B0566 D4 00 00    0940*  	dl 0x0000D4 ; 56.250 28, 0.831
0B0569 D8 00 00    0941*  	dl 0x0000D8 ; 57.656 29, 0.845
0B056C DB 00 00    0942*  	dl 0x0000DB ; 59.063 2A, 0.858
0B056F DE 00 00    0943*  	dl 0x0000DE ; 60.469 2B, 0.870
0B0572 E1 00 00    0944*  	dl 0x0000E1 ; 61.875 2C, 0.882
0B0575 E4 00 00    0945*  	dl 0x0000E4 ; 63.281 2D, 0.893
0B0578 E7 00 00    0946*  	dl 0x0000E7 ; 64.688 2E, 0.904
0B057B EA 00 00    0947*  	dl 0x0000EA ; 66.094 2F, 0.914
0B057E EC 00 00    0948*  	dl 0x0000EC ; 67.500 30, 0.924
0B0581 EE 00 00    0949*  	dl 0x0000EE ; 68.906 31, 0.933
0B0584 F1 00 00    0950*  	dl 0x0000F1 ; 70.313 32, 0.942
0B0587 F3 00 00    0951*  	dl 0x0000F3 ; 71.719 33, 0.950
0B058A F4 00 00    0952*  	dl 0x0000F4 ; 73.125 34, 0.957
0B058D F6 00 00    0953*  	dl 0x0000F6 ; 74.531 35, 0.964
0B0590 F8 00 00    0954*  	dl 0x0000F8 ; 75.938 36, 0.970
0B0593 F9 00 00    0955*  	dl 0x0000F9 ; 77.344 37, 0.976
0B0596 FB 00 00    0956*  	dl 0x0000FB ; 78.750 38, 0.981
0B0599 FC 00 00    0957*  	dl 0x0000FC ; 80.156 39, 0.985
0B059C FD 00 00    0958*  	dl 0x0000FD ; 81.563 3A, 0.989
0B059F FE 00 00    0959*  	dl 0x0000FE ; 82.969 3B, 0.992
0B05A2 FE 00 00    0960*  	dl 0x0000FE ; 84.375 3C, 0.995
0B05A5 FF 00 00    0961*  	dl 0x0000FF ; 85.781 3D, 0.997
0B05A8 FF 00 00    0962*  	dl 0x0000FF ; 87.188 3E, 0.999
0B05AB FF 00 00    0963*  	dl 0x0000FF ; 88.594 3F, 1.000
0B05AE 00 01 00    0964*  	dl 0x000100 ; 90.000 40, 1.000
0B05B1 FF 00 00    0965*  	dl 0x0000FF ; 91.406 41, 1.000
0B05B4 FF 00 00    0966*  	dl 0x0000FF ; 92.813 42, 0.999
0B05B7 FF 00 00    0967*  	dl 0x0000FF ; 94.219 43, 0.997
0B05BA FE 00 00    0968*  	dl 0x0000FE ; 95.625 44, 0.995
0B05BD FE 00 00    0969*  	dl 0x0000FE ; 97.031 45, 0.992
0B05C0 FD 00 00    0970*  	dl 0x0000FD ; 98.438 46, 0.989
0B05C3 FC 00 00    0971*  	dl 0x0000FC ; 99.844 47, 0.985
0B05C6 FB 00 00    0972*  	dl 0x0000FB ; 101.250 48, 0.981
0B05C9 F9 00 00    0973*  	dl 0x0000F9 ; 102.656 49, 0.976
0B05CC F8 00 00    0974*  	dl 0x0000F8 ; 104.063 4A, 0.970
0B05CF F6 00 00    0975*  	dl 0x0000F6 ; 105.469 4B, 0.964
0B05D2 F4 00 00    0976*  	dl 0x0000F4 ; 106.875 4C, 0.957
0B05D5 F3 00 00    0977*  	dl 0x0000F3 ; 108.281 4D, 0.950
0B05D8 F1 00 00    0978*  	dl 0x0000F1 ; 109.688 4E, 0.942
0B05DB EE 00 00    0979*  	dl 0x0000EE ; 111.094 4F, 0.933
0B05DE EC 00 00    0980*  	dl 0x0000EC ; 112.500 50, 0.924
0B05E1 EA 00 00    0981*  	dl 0x0000EA ; 113.906 51, 0.914
0B05E4 E7 00 00    0982*  	dl 0x0000E7 ; 115.313 52, 0.904
0B05E7 E4 00 00    0983*  	dl 0x0000E4 ; 116.719 53, 0.893
0B05EA E1 00 00    0984*  	dl 0x0000E1 ; 118.125 54, 0.882
0B05ED DE 00 00    0985*  	dl 0x0000DE ; 119.531 55, 0.870
0B05F0 DB 00 00    0986*  	dl 0x0000DB ; 120.938 56, 0.858
0B05F3 D8 00 00    0987*  	dl 0x0000D8 ; 122.344 57, 0.845
0B05F6 D4 00 00    0988*  	dl 0x0000D4 ; 123.750 58, 0.831
0B05F9 D1 00 00    0989*  	dl 0x0000D1 ; 125.156 59, 0.818
0B05FC CD 00 00    0990*  	dl 0x0000CD ; 126.563 5A, 0.803
0B05FF C9 00 00    0991*  	dl 0x0000C9 ; 127.969 5B, 0.788
0B0602 C5 00 00    0992*  	dl 0x0000C5 ; 129.375 5C, 0.773
0B0605 C1 00 00    0993*  	dl 0x0000C1 ; 130.781 5D, 0.757
0B0608 BD 00 00    0994*  	dl 0x0000BD ; 132.188 5E, 0.741
0B060B B9 00 00    0995*  	dl 0x0000B9 ; 133.594 5F, 0.724
0B060E B5 00 00    0996*  	dl 0x0000B5 ; 135.000 60, 0.707
0B0611 B0 00 00    0997*  	dl 0x0000B0 ; 136.406 61, 0.690
0B0614 AB 00 00    0998*  	dl 0x0000AB ; 137.813 62, 0.672
0B0617 A7 00 00    0999*  	dl 0x0000A7 ; 139.219 63, 0.653
0B061A A2 00 00    1000*  	dl 0x0000A2 ; 140.625 64, 0.634
0B061D 9D 00 00    1001*  	dl 0x00009D ; 142.031 65, 0.615
0B0620 98 00 00    1002*  	dl 0x000098 ; 143.438 66, 0.596
0B0623 93 00 00    1003*  	dl 0x000093 ; 144.844 67, 0.576
0B0626 8E 00 00    1004*  	dl 0x00008E ; 146.250 68, 0.556
0B0629 88 00 00    1005*  	dl 0x000088 ; 147.656 69, 0.535
0B062C 83 00 00    1006*  	dl 0x000083 ; 149.063 6A, 0.514
0B062F 7E 00 00    1007*  	dl 0x00007E ; 150.469 6B, 0.493
0B0632 78 00 00    1008*  	dl 0x000078 ; 151.875 6C, 0.471
0B0635 73 00 00    1009*  	dl 0x000073 ; 153.281 6D, 0.450
0B0638 6D 00 00    1010*  	dl 0x00006D ; 154.688 6E, 0.428
0B063B 67 00 00    1011*  	dl 0x000067 ; 156.094 6F, 0.405
0B063E 61 00 00    1012*  	dl 0x000061 ; 157.500 70, 0.383
0B0641 5C 00 00    1013*  	dl 0x00005C ; 158.906 71, 0.360
0B0644 56 00 00    1014*  	dl 0x000056 ; 160.313 72, 0.337
0B0647 50 00 00    1015*  	dl 0x000050 ; 161.719 73, 0.314
0B064A 4A 00 00    1016*  	dl 0x00004A ; 163.125 74, 0.290
0B064D 44 00 00    1017*  	dl 0x000044 ; 164.531 75, 0.267
0B0650 3E 00 00    1018*  	dl 0x00003E ; 165.938 76, 0.243
0B0653 38 00 00    1019*  	dl 0x000038 ; 167.344 77, 0.219
0B0656 31 00 00    1020*  	dl 0x000031 ; 168.750 78, 0.195
0B0659 2B 00 00    1021*  	dl 0x00002B ; 170.156 79, 0.171
0B065C 25 00 00    1022*  	dl 0x000025 ; 171.563 7A, 0.147
0B065F 1F 00 00    1023*  	dl 0x00001F ; 172.969 7B, 0.122
0B0662 19 00 00    1024*  	dl 0x000019 ; 174.375 7C, 0.098
0B0665 12 00 00    1025*  	dl 0x000012 ; 175.781 7D, 0.074
0B0668 0C 00 00    1026*  	dl 0x00000C ; 177.188 7E, 0.049
0B066B 06 00 00    1027*  	dl 0x000006 ; 178.594 7F, 0.025
0B066E 00 00 00    1028*  	dl 0x000000 ; 180.000 80, 0.000
0B0671 FA FF FF    1029*  	dl 0xFFFFFA ; 181.406 81, -0.025
0B0674 F4 FF FF    1030*  	dl 0xFFFFF4 ; 182.813 82, -0.049
0B0677 EE FF FF    1031*  	dl 0xFFFFEE ; 184.219 83, -0.074
0B067A E7 FF FF    1032*  	dl 0xFFFFE7 ; 185.625 84, -0.098
0B067D E1 FF FF    1033*  	dl 0xFFFFE1 ; 187.031 85, -0.122
0B0680 DB FF FF    1034*  	dl 0xFFFFDB ; 188.438 86, -0.147
0B0683 D5 FF FF    1035*  	dl 0xFFFFD5 ; 189.844 87, -0.171
0B0686 CF FF FF    1036*  	dl 0xFFFFCF ; 191.250 88, -0.195
0B0689 C8 FF FF    1037*  	dl 0xFFFFC8 ; 192.656 89, -0.219
0B068C C2 FF FF    1038*  	dl 0xFFFFC2 ; 194.063 8A, -0.243
0B068F BC FF FF    1039*  	dl 0xFFFFBC ; 195.469 8B, -0.267
0B0692 B6 FF FF    1040*  	dl 0xFFFFB6 ; 196.875 8C, -0.290
0B0695 B0 FF FF    1041*  	dl 0xFFFFB0 ; 198.281 8D, -0.314
0B0698 AA FF FF    1042*  	dl 0xFFFFAA ; 199.688 8E, -0.337
0B069B A4 FF FF    1043*  	dl 0xFFFFA4 ; 201.094 8F, -0.360
0B069E 9F FF FF    1044*  	dl 0xFFFF9F ; 202.500 90, -0.383
0B06A1 99 FF FF    1045*  	dl 0xFFFF99 ; 203.906 91, -0.405
0B06A4 93 FF FF    1046*  	dl 0xFFFF93 ; 205.313 92, -0.428
0B06A7 8D FF FF    1047*  	dl 0xFFFF8D ; 206.719 93, -0.450
0B06AA 88 FF FF    1048*  	dl 0xFFFF88 ; 208.125 94, -0.471
0B06AD 82 FF FF    1049*  	dl 0xFFFF82 ; 209.531 95, -0.493
0B06B0 7D FF FF    1050*  	dl 0xFFFF7D ; 210.938 96, -0.514
0B06B3 78 FF FF    1051*  	dl 0xFFFF78 ; 212.344 97, -0.535
0B06B6 72 FF FF    1052*  	dl 0xFFFF72 ; 213.750 98, -0.556
0B06B9 6D FF FF    1053*  	dl 0xFFFF6D ; 215.156 99, -0.576
0B06BC 68 FF FF    1054*  	dl 0xFFFF68 ; 216.563 9A, -0.596
0B06BF 63 FF FF    1055*  	dl 0xFFFF63 ; 217.969 9B, -0.615
0B06C2 5E FF FF    1056*  	dl 0xFFFF5E ; 219.375 9C, -0.634
0B06C5 59 FF FF    1057*  	dl 0xFFFF59 ; 220.781 9D, -0.653
0B06C8 55 FF FF    1058*  	dl 0xFFFF55 ; 222.188 9E, -0.672
0B06CB 50 FF FF    1059*  	dl 0xFFFF50 ; 223.594 9F, -0.690
0B06CE 4B FF FF    1060*  	dl 0xFFFF4B ; 225.000 A0, -0.707
0B06D1 47 FF FF    1061*  	dl 0xFFFF47 ; 226.406 A1, -0.724
0B06D4 43 FF FF    1062*  	dl 0xFFFF43 ; 227.813 A2, -0.741
0B06D7 3F FF FF    1063*  	dl 0xFFFF3F ; 229.219 A3, -0.757
0B06DA 3B FF FF    1064*  	dl 0xFFFF3B ; 230.625 A4, -0.773
0B06DD 37 FF FF    1065*  	dl 0xFFFF37 ; 232.031 A5, -0.788
0B06E0 33 FF FF    1066*  	dl 0xFFFF33 ; 233.438 A6, -0.803
0B06E3 2F FF FF    1067*  	dl 0xFFFF2F ; 234.844 A7, -0.818
0B06E6 2C FF FF    1068*  	dl 0xFFFF2C ; 236.250 A8, -0.831
0B06E9 28 FF FF    1069*  	dl 0xFFFF28 ; 237.656 A9, -0.845
0B06EC 25 FF FF    1070*  	dl 0xFFFF25 ; 239.063 AA, -0.858
0B06EF 22 FF FF    1071*  	dl 0xFFFF22 ; 240.469 AB, -0.870
0B06F2 1F FF FF    1072*  	dl 0xFFFF1F ; 241.875 AC, -0.882
0B06F5 1C FF FF    1073*  	dl 0xFFFF1C ; 243.281 AD, -0.893
0B06F8 19 FF FF    1074*  	dl 0xFFFF19 ; 244.688 AE, -0.904
0B06FB 16 FF FF    1075*  	dl 0xFFFF16 ; 246.094 AF, -0.914
0B06FE 14 FF FF    1076*  	dl 0xFFFF14 ; 247.500 B0, -0.924
0B0701 12 FF FF    1077*  	dl 0xFFFF12 ; 248.906 B1, -0.933
0B0704 0F FF FF    1078*  	dl 0xFFFF0F ; 250.313 B2, -0.942
0B0707 0D FF FF    1079*  	dl 0xFFFF0D ; 251.719 B3, -0.950
0B070A 0C FF FF    1080*  	dl 0xFFFF0C ; 253.125 B4, -0.957
0B070D 0A FF FF    1081*  	dl 0xFFFF0A ; 254.531 B5, -0.964
0B0710 08 FF FF    1082*  	dl 0xFFFF08 ; 255.938 B6, -0.970
0B0713 07 FF FF    1083*  	dl 0xFFFF07 ; 257.344 B7, -0.976
0B0716 05 FF FF    1084*  	dl 0xFFFF05 ; 258.750 B8, -0.981
0B0719 04 FF FF    1085*  	dl 0xFFFF04 ; 260.156 B9, -0.985
0B071C 03 FF FF    1086*  	dl 0xFFFF03 ; 261.563 BA, -0.989
0B071F 02 FF FF    1087*  	dl 0xFFFF02 ; 262.969 BB, -0.992
0B0722 02 FF FF    1088*  	dl 0xFFFF02 ; 264.375 BC, -0.995
0B0725 01 FF FF    1089*  	dl 0xFFFF01 ; 265.781 BD, -0.997
0B0728 01 FF FF    1090*  	dl 0xFFFF01 ; 267.188 BE, -0.999
0B072B 01 FF FF    1091*  	dl 0xFFFF01 ; 268.594 BF, -1.000
0B072E 00 FF FF    1092*  	dl 0xFFFF00 ; 270.000 C0, -1.000
0B0731 01 FF FF    1093*  	dl 0xFFFF01 ; 271.406 C1, -1.000
0B0734 01 FF FF    1094*  	dl 0xFFFF01 ; 272.813 C2, -0.999
0B0737 01 FF FF    1095*  	dl 0xFFFF01 ; 274.219 C3, -0.997
0B073A 02 FF FF    1096*  	dl 0xFFFF02 ; 275.625 C4, -0.995
0B073D 02 FF FF    1097*  	dl 0xFFFF02 ; 277.031 C5, -0.992
0B0740 03 FF FF    1098*  	dl 0xFFFF03 ; 278.438 C6, -0.989
0B0743 04 FF FF    1099*  	dl 0xFFFF04 ; 279.844 C7, -0.985
0B0746 05 FF FF    1100*  	dl 0xFFFF05 ; 281.250 C8, -0.981
0B0749 07 FF FF    1101*  	dl 0xFFFF07 ; 282.656 C9, -0.976
0B074C 08 FF FF    1102*  	dl 0xFFFF08 ; 284.063 CA, -0.970
0B074F 0A FF FF    1103*  	dl 0xFFFF0A ; 285.469 CB, -0.964
0B0752 0C FF FF    1104*  	dl 0xFFFF0C ; 286.875 CC, -0.957
0B0755 0D FF FF    1105*  	dl 0xFFFF0D ; 288.281 CD, -0.950
0B0758 0F FF FF    1106*  	dl 0xFFFF0F ; 289.688 CE, -0.942
0B075B 12 FF FF    1107*  	dl 0xFFFF12 ; 291.094 CF, -0.933
0B075E 14 FF FF    1108*  	dl 0xFFFF14 ; 292.500 D0, -0.924
0B0761 16 FF FF    1109*  	dl 0xFFFF16 ; 293.906 D1, -0.914
0B0764 19 FF FF    1110*  	dl 0xFFFF19 ; 295.313 D2, -0.904
0B0767 1C FF FF    1111*  	dl 0xFFFF1C ; 296.719 D3, -0.893
0B076A 1F FF FF    1112*  	dl 0xFFFF1F ; 298.125 D4, -0.882
0B076D 22 FF FF    1113*  	dl 0xFFFF22 ; 299.531 D5, -0.870
0B0770 25 FF FF    1114*  	dl 0xFFFF25 ; 300.938 D6, -0.858
0B0773 28 FF FF    1115*  	dl 0xFFFF28 ; 302.344 D7, -0.845
0B0776 2C FF FF    1116*  	dl 0xFFFF2C ; 303.750 D8, -0.831
0B0779 2F FF FF    1117*  	dl 0xFFFF2F ; 305.156 D9, -0.818
0B077C 33 FF FF    1118*  	dl 0xFFFF33 ; 306.563 DA, -0.803
0B077F 37 FF FF    1119*  	dl 0xFFFF37 ; 307.969 DB, -0.788
0B0782 3B FF FF    1120*  	dl 0xFFFF3B ; 309.375 DC, -0.773
0B0785 3F FF FF    1121*  	dl 0xFFFF3F ; 310.781 DD, -0.757
0B0788 43 FF FF    1122*  	dl 0xFFFF43 ; 312.188 DE, -0.741
0B078B 47 FF FF    1123*  	dl 0xFFFF47 ; 313.594 DF, -0.724
0B078E 4B FF FF    1124*  	dl 0xFFFF4B ; 315.000 E0, -0.707
0B0791 50 FF FF    1125*  	dl 0xFFFF50 ; 316.406 E1, -0.690
0B0794 55 FF FF    1126*  	dl 0xFFFF55 ; 317.813 E2, -0.672
0B0797 59 FF FF    1127*  	dl 0xFFFF59 ; 319.219 E3, -0.653
0B079A 5E FF FF    1128*  	dl 0xFFFF5E ; 320.625 E4, -0.634
0B079D 63 FF FF    1129*  	dl 0xFFFF63 ; 322.031 E5, -0.615
0B07A0 68 FF FF    1130*  	dl 0xFFFF68 ; 323.438 E6, -0.596
0B07A3 6D FF FF    1131*  	dl 0xFFFF6D ; 324.844 E7, -0.576
0B07A6 72 FF FF    1132*  	dl 0xFFFF72 ; 326.250 E8, -0.556
0B07A9 78 FF FF    1133*  	dl 0xFFFF78 ; 327.656 E9, -0.535
0B07AC 7D FF FF    1134*  	dl 0xFFFF7D ; 329.063 EA, -0.514
0B07AF 82 FF FF    1135*  	dl 0xFFFF82 ; 330.469 EB, -0.493
0B07B2 88 FF FF    1136*  	dl 0xFFFF88 ; 331.875 EC, -0.471
0B07B5 8D FF FF    1137*  	dl 0xFFFF8D ; 333.281 ED, -0.450
0B07B8 93 FF FF    1138*  	dl 0xFFFF93 ; 334.688 EE, -0.428
0B07BB 99 FF FF    1139*  	dl 0xFFFF99 ; 336.094 EF, -0.405
0B07BE 9F FF FF    1140*  	dl 0xFFFF9F ; 337.500 F0, -0.383
0B07C1 A4 FF FF    1141*  	dl 0xFFFFA4 ; 338.906 F1, -0.360
0B07C4 AA FF FF    1142*  	dl 0xFFFFAA ; 340.313 F2, -0.337
0B07C7 B0 FF FF    1143*  	dl 0xFFFFB0 ; 341.719 F3, -0.314
0B07CA B6 FF FF    1144*  	dl 0xFFFFB6 ; 343.125 F4, -0.290
0B07CD BC FF FF    1145*  	dl 0xFFFFBC ; 344.531 F5, -0.267
0B07D0 C2 FF FF    1146*  	dl 0xFFFFC2 ; 345.938 F6, -0.243
0B07D3 C8 FF FF    1147*  	dl 0xFFFFC8 ; 347.344 F7, -0.219
0B07D6 CF FF FF    1148*  	dl 0xFFFFCF ; 348.750 F8, -0.195
0B07D9 D5 FF FF    1149*  	dl 0xFFFFD5 ; 350.156 F9, -0.171
0B07DC DB FF FF    1150*  	dl 0xFFFFDB ; 351.563 FA, -0.147
0B07DF E1 FF FF    1151*  	dl 0xFFFFE1 ; 352.969 FB, -0.122
0B07E2 E7 FF FF    1152*  	dl 0xFFFFE7 ; 354.375 FC, -0.098
0B07E5 EE FF FF    1153*  	dl 0xFFFFEE ; 355.781 FD, -0.074
0B07E8 F4 FF FF    1154*  	dl 0xFFFFF4 ; 357.188 FE, -0.049
0B07EB FA FF FF    1155*  	dl 0xFFFFFA ; 358.594 FF, -0.025
0B07EE 00 00 00    1156*  	dl 0x000000 ; 0.000 00, 0.000 for interpolation
0B07F1             1157*  
0B07F1             1158*  atan_lut_168:
0B07F1 00 00 00    1159*  	dl 0x000000 ; 000000, 0.000
0B07F4 28 00 00    1160*  	dl 0x000028 ; 000001, 0.224
0B07F7 51 00 00    1161*  	dl 0x000051 ; 000002, 0.448
0B07FA 7A 00 00    1162*  	dl 0x00007A ; 000003, 0.671
0B07FD A2 00 00    1163*  	dl 0x0000A2 ; 000004, 0.895
0B0800 CB 00 00    1164*  	dl 0x0000CB ; 000005, 1.119
0B0803 F4 00 00    1165*  	dl 0x0000F4 ; 000006, 1.343
0B0806 1D 01 00    1166*  	dl 0x00011D ; 000007, 1.566
0B0809 45 01 00    1167*  	dl 0x000145 ; 000008, 1.790
0B080C 6E 01 00    1168*  	dl 0x00016E ; 000009, 2.013
0B080F 97 01 00    1169*  	dl 0x000197 ; 00000A, 2.237
0B0812 BF 01 00    1170*  	dl 0x0001BF ; 00000B, 2.460
0B0815 E8 01 00    1171*  	dl 0x0001E8 ; 00000C, 2.684
0B0818 11 02 00    1172*  	dl 0x000211 ; 00000D, 2.907
0B081B 39 02 00    1173*  	dl 0x000239 ; 00000E, 3.130
0B081E 62 02 00    1174*  	dl 0x000262 ; 00000F, 3.353
0B0821 8B 02 00    1175*  	dl 0x00028B ; 000010, 3.576
0B0824 B3 02 00    1176*  	dl 0x0002B3 ; 000011, 3.799
0B0827 DC 02 00    1177*  	dl 0x0002DC ; 000012, 4.022
0B082A 04 03 00    1178*  	dl 0x000304 ; 000013, 4.245
0B082D 2D 03 00    1179*  	dl 0x00032D ; 000014, 4.467
0B0830 55 03 00    1180*  	dl 0x000355 ; 000015, 4.690
0B0833 7E 03 00    1181*  	dl 0x00037E ; 000016, 4.912
0B0836 A6 03 00    1182*  	dl 0x0003A6 ; 000017, 5.134
0B0839 CE 03 00    1183*  	dl 0x0003CE ; 000018, 5.356
0B083C F7 03 00    1184*  	dl 0x0003F7 ; 000019, 5.578
0B083F 1F 04 00    1185*  	dl 0x00041F ; 00001A, 5.799
0B0842 48 04 00    1186*  	dl 0x000448 ; 00001B, 6.021
0B0845 70 04 00    1187*  	dl 0x000470 ; 00001C, 6.242
0B0848 98 04 00    1188*  	dl 0x000498 ; 00001D, 6.463
0B084B C0 04 00    1189*  	dl 0x0004C0 ; 00001E, 6.684
0B084E E8 04 00    1190*  	dl 0x0004E8 ; 00001F, 6.905
0B0851 11 05 00    1191*  	dl 0x000511 ; 000020, 7.125
0B0854 39 05 00    1192*  	dl 0x000539 ; 000021, 7.345
0B0857 61 05 00    1193*  	dl 0x000561 ; 000022, 7.565
0B085A 89 05 00    1194*  	dl 0x000589 ; 000023, 7.785
0B085D B1 05 00    1195*  	dl 0x0005B1 ; 000024, 8.005
0B0860 D9 05 00    1196*  	dl 0x0005D9 ; 000025, 8.224
0B0863 01 06 00    1197*  	dl 0x000601 ; 000026, 8.443
0B0866 28 06 00    1198*  	dl 0x000628 ; 000027, 8.662
0B0869 50 06 00    1199*  	dl 0x000650 ; 000028, 8.881
0B086C 78 06 00    1200*  	dl 0x000678 ; 000029, 9.099
0B086F A0 06 00    1201*  	dl 0x0006A0 ; 00002A, 9.317
0B0872 C7 06 00    1202*  	dl 0x0006C7 ; 00002B, 9.535
0B0875 EF 06 00    1203*  	dl 0x0006EF ; 00002C, 9.752
0B0878 16 07 00    1204*  	dl 0x000716 ; 00002D, 9.970
0B087B 3E 07 00    1205*  	dl 0x00073E ; 00002E, 10.187
0B087E 65 07 00    1206*  	dl 0x000765 ; 00002F, 10.403
0B0881 8D 07 00    1207*  	dl 0x00078D ; 000030, 10.620
0B0884 B4 07 00    1208*  	dl 0x0007B4 ; 000031, 10.836
0B0887 DB 07 00    1209*  	dl 0x0007DB ; 000032, 11.051
0B088A 03 08 00    1210*  	dl 0x000803 ; 000033, 11.267
0B088D 2A 08 00    1211*  	dl 0x00082A ; 000034, 11.482
0B0890 51 08 00    1212*  	dl 0x000851 ; 000035, 11.697
0B0893 78 08 00    1213*  	dl 0x000878 ; 000036, 11.911
0B0896 9F 08 00    1214*  	dl 0x00089F ; 000037, 12.125
0B0899 C6 08 00    1215*  	dl 0x0008C6 ; 000038, 12.339
0B089C ED 08 00    1216*  	dl 0x0008ED ; 000039, 12.553
0B089F 13 09 00    1217*  	dl 0x000913 ; 00003A, 12.766
0B08A2 3A 09 00    1218*  	dl 0x00093A ; 00003B, 12.978
0B08A5 61 09 00    1219*  	dl 0x000961 ; 00003C, 13.191
0B08A8 87 09 00    1220*  	dl 0x000987 ; 00003D, 13.403
0B08AB AE 09 00    1221*  	dl 0x0009AE ; 00003E, 13.614
0B08AE D4 09 00    1222*  	dl 0x0009D4 ; 00003F, 13.825
0B08B1 FB 09 00    1223*  	dl 0x0009FB ; 000040, 14.036
0B08B4 21 0A 00    1224*  	dl 0x000A21 ; 000041, 14.247
0B08B7 47 0A 00    1225*  	dl 0x000A47 ; 000042, 14.457
0B08BA 6D 0A 00    1226*  	dl 0x000A6D ; 000043, 14.666
0B08BD 94 0A 00    1227*  	dl 0x000A94 ; 000044, 14.876
0B08C0 BA 0A 00    1228*  	dl 0x000ABA ; 000045, 15.085
0B08C3 E0 0A 00    1229*  	dl 0x000AE0 ; 000046, 15.293
0B08C6 05 0B 00    1230*  	dl 0x000B05 ; 000047, 15.501
0B08C9 2B 0B 00    1231*  	dl 0x000B2B ; 000048, 15.709
0B08CC 51 0B 00    1232*  	dl 0x000B51 ; 000049, 15.916
0B08CF 77 0B 00    1233*  	dl 0x000B77 ; 00004A, 16.123
0B08D2 9C 0B 00    1234*  	dl 0x000B9C ; 00004B, 16.329
0B08D5 C2 0B 00    1235*  	dl 0x000BC2 ; 00004C, 16.535
0B08D8 E7 0B 00    1236*  	dl 0x000BE7 ; 00004D, 16.740
0B08DB 0C 0C 00    1237*  	dl 0x000C0C ; 00004E, 16.945
0B08DE 32 0C 00    1238*  	dl 0x000C32 ; 00004F, 17.150
0B08E1 57 0C 00    1239*  	dl 0x000C57 ; 000050, 17.354
0B08E4 7C 0C 00    1240*  	dl 0x000C7C ; 000051, 17.558
0B08E7 A1 0C 00    1241*  	dl 0x000CA1 ; 000052, 17.761
0B08EA C6 0C 00    1242*  	dl 0x000CC6 ; 000053, 17.964
0B08ED EB 0C 00    1243*  	dl 0x000CEB ; 000054, 18.166
0B08F0 0F 0D 00    1244*  	dl 0x000D0F ; 000055, 18.368
0B08F3 34 0D 00    1245*  	dl 0x000D34 ; 000056, 18.569
0B08F6 58 0D 00    1246*  	dl 0x000D58 ; 000057, 18.770
0B08F9 7D 0D 00    1247*  	dl 0x000D7D ; 000058, 18.970
0B08FC A1 0D 00    1248*  	dl 0x000DA1 ; 000059, 19.170
0B08FF C6 0D 00    1249*  	dl 0x000DC6 ; 00005A, 19.370
0B0902 EA 0D 00    1250*  	dl 0x000DEA ; 00005B, 19.569
0B0905 0E 0E 00    1251*  	dl 0x000E0E ; 00005C, 19.767
0B0908 32 0E 00    1252*  	dl 0x000E32 ; 00005D, 19.965
0B090B 56 0E 00    1253*  	dl 0x000E56 ; 00005E, 20.163
0B090E 7A 0E 00    1254*  	dl 0x000E7A ; 00005F, 20.360
0B0911 9E 0E 00    1255*  	dl 0x000E9E ; 000060, 20.556
0B0914 C1 0E 00    1256*  	dl 0x000EC1 ; 000061, 20.752
0B0917 E5 0E 00    1257*  	dl 0x000EE5 ; 000062, 20.947
0B091A 08 0F 00    1258*  	dl 0x000F08 ; 000063, 21.142
0B091D 2C 0F 00    1259*  	dl 0x000F2C ; 000064, 21.337
0B0920 4F 0F 00    1260*  	dl 0x000F4F ; 000065, 21.531
0B0923 72 0F 00    1261*  	dl 0x000F72 ; 000066, 21.724
0B0926 95 0F 00    1262*  	dl 0x000F95 ; 000067, 21.917
0B0929 B8 0F 00    1263*  	dl 0x000FB8 ; 000068, 22.109
0B092C DB 0F 00    1264*  	dl 0x000FDB ; 000069, 22.301
0B092F FE 0F 00    1265*  	dl 0x000FFE ; 00006A, 22.493
0B0932 21 10 00    1266*  	dl 0x001021 ; 00006B, 22.683
0B0935 44 10 00    1267*  	dl 0x001044 ; 00006C, 22.874
0B0938 66 10 00    1268*  	dl 0x001066 ; 00006D, 23.063
0B093B 89 10 00    1269*  	dl 0x001089 ; 00006E, 23.253
0B093E AB 10 00    1270*  	dl 0x0010AB ; 00006F, 23.441
0B0941 CD 10 00    1271*  	dl 0x0010CD ; 000070, 23.629
0B0944 EF 10 00    1272*  	dl 0x0010EF ; 000071, 23.817
0B0947 11 11 00    1273*  	dl 0x001111 ; 000072, 24.004
0B094A 33 11 00    1274*  	dl 0x001133 ; 000073, 24.191
0B094D 55 11 00    1275*  	dl 0x001155 ; 000074, 24.376
0B0950 77 11 00    1276*  	dl 0x001177 ; 000075, 24.562
0B0953 99 11 00    1277*  	dl 0x001199 ; 000076, 24.747
0B0956 BA 11 00    1278*  	dl 0x0011BA ; 000077, 24.931
0B0959 DC 11 00    1279*  	dl 0x0011DC ; 000078, 25.115
0B095C FD 11 00    1280*  	dl 0x0011FD ; 000079, 25.298
0B095F 1E 12 00    1281*  	dl 0x00121E ; 00007A, 25.481
0B0962 3F 12 00    1282*  	dl 0x00123F ; 00007B, 25.663
0B0965 60 12 00    1283*  	dl 0x001260 ; 00007C, 25.844
0B0968 81 12 00    1284*  	dl 0x001281 ; 00007D, 26.025
0B096B A2 12 00    1285*  	dl 0x0012A2 ; 00007E, 26.206
0B096E C3 12 00    1286*  	dl 0x0012C3 ; 00007F, 26.386
0B0971 E4 12 00    1287*  	dl 0x0012E4 ; 000080, 26.565
0B0974 04 13 00    1288*  	dl 0x001304 ; 000081, 26.744
0B0977 25 13 00    1289*  	dl 0x001325 ; 000082, 26.922
0B097A 45 13 00    1290*  	dl 0x001345 ; 000083, 27.100
0B097D 65 13 00    1291*  	dl 0x001365 ; 000084, 27.277
0B0980 85 13 00    1292*  	dl 0x001385 ; 000085, 27.453
0B0983 A5 13 00    1293*  	dl 0x0013A5 ; 000086, 27.629
0B0986 C5 13 00    1294*  	dl 0x0013C5 ; 000087, 27.805
0B0989 E5 13 00    1295*  	dl 0x0013E5 ; 000088, 27.979
0B098C 05 14 00    1296*  	dl 0x001405 ; 000089, 28.154
0B098F 24 14 00    1297*  	dl 0x001424 ; 00008A, 28.327
0B0992 44 14 00    1298*  	dl 0x001444 ; 00008B, 28.501
0B0995 63 14 00    1299*  	dl 0x001463 ; 00008C, 28.673
0B0998 83 14 00    1300*  	dl 0x001483 ; 00008D, 28.845
0B099B A2 14 00    1301*  	dl 0x0014A2 ; 00008E, 29.017
0B099E C1 14 00    1302*  	dl 0x0014C1 ; 00008F, 29.187
0B09A1 E0 14 00    1303*  	dl 0x0014E0 ; 000090, 29.358
0B09A4 FF 14 00    1304*  	dl 0x0014FF ; 000091, 29.527
0B09A7 1E 15 00    1305*  	dl 0x00151E ; 000092, 29.697
0B09AA 3C 15 00    1306*  	dl 0x00153C ; 000093, 29.865
0B09AD 5B 15 00    1307*  	dl 0x00155B ; 000094, 30.033
0B09B0 79 15 00    1308*  	dl 0x001579 ; 000095, 30.201
0B09B3 98 15 00    1309*  	dl 0x001598 ; 000096, 30.368
0B09B6 B6 15 00    1310*  	dl 0x0015B6 ; 000097, 30.534
0B09B9 D4 15 00    1311*  	dl 0x0015D4 ; 000098, 30.700
0B09BC F2 15 00    1312*  	dl 0x0015F2 ; 000099, 30.865
0B09BF 10 16 00    1313*  	dl 0x001610 ; 00009A, 31.030
0B09C2 2E 16 00    1314*  	dl 0x00162E ; 00009B, 31.194
0B09C5 4C 16 00    1315*  	dl 0x00164C ; 00009C, 31.357
0B09C8 6A 16 00    1316*  	dl 0x00166A ; 00009D, 31.520
0B09CB 87 16 00    1317*  	dl 0x001687 ; 00009E, 31.682
0B09CE A5 16 00    1318*  	dl 0x0016A5 ; 00009F, 31.844
0B09D1 C2 16 00    1319*  	dl 0x0016C2 ; 0000A0, 32.005
0B09D4 DF 16 00    1320*  	dl 0x0016DF ; 0000A1, 32.166
0B09D7 FC 16 00    1321*  	dl 0x0016FC ; 0000A2, 32.326
0B09DA 19 17 00    1322*  	dl 0x001719 ; 0000A3, 32.486
0B09DD 36 17 00    1323*  	dl 0x001736 ; 0000A4, 32.645
0B09E0 53 17 00    1324*  	dl 0x001753 ; 0000A5, 32.803
0B09E3 70 17 00    1325*  	dl 0x001770 ; 0000A6, 32.961
0B09E6 8C 17 00    1326*  	dl 0x00178C ; 0000A7, 33.118
0B09E9 A9 17 00    1327*  	dl 0x0017A9 ; 0000A8, 33.275
0B09EC C5 17 00    1328*  	dl 0x0017C5 ; 0000A9, 33.431
0B09EF E2 17 00    1329*  	dl 0x0017E2 ; 0000AA, 33.587
0B09F2 FE 17 00    1330*  	dl 0x0017FE ; 0000AB, 33.742
0B09F5 1A 18 00    1331*  	dl 0x00181A ; 0000AC, 33.896
0B09F8 36 18 00    1332*  	dl 0x001836 ; 0000AD, 34.050
0B09FB 52 18 00    1333*  	dl 0x001852 ; 0000AE, 34.203
0B09FE 6E 18 00    1334*  	dl 0x00186E ; 0000AF, 34.356
0B0A01 8A 18 00    1335*  	dl 0x00188A ; 0000B0, 34.509
0B0A04 A5 18 00    1336*  	dl 0x0018A5 ; 0000B1, 34.660
0B0A07 C1 18 00    1337*  	dl 0x0018C1 ; 0000B2, 34.811
0B0A0A DC 18 00    1338*  	dl 0x0018DC ; 0000B3, 34.962
0B0A0D F7 18 00    1339*  	dl 0x0018F7 ; 0000B4, 35.112
0B0A10 13 19 00    1340*  	dl 0x001913 ; 0000B5, 35.262
0B0A13 2E 19 00    1341*  	dl 0x00192E ; 0000B6, 35.410
0B0A16 49 19 00    1342*  	dl 0x001949 ; 0000B7, 35.559
0B0A19 64 19 00    1343*  	dl 0x001964 ; 0000B8, 35.707
0B0A1C 7F 19 00    1344*  	dl 0x00197F ; 0000B9, 35.854
0B0A1F 99 19 00    1345*  	dl 0x001999 ; 0000BA, 36.001
0B0A22 B4 19 00    1346*  	dl 0x0019B4 ; 0000BB, 36.147
0B0A25 CE 19 00    1347*  	dl 0x0019CE ; 0000BC, 36.293
0B0A28 E9 19 00    1348*  	dl 0x0019E9 ; 0000BD, 36.438
0B0A2B 03 1A 00    1349*  	dl 0x001A03 ; 0000BE, 36.582
0B0A2E 1D 1A 00    1350*  	dl 0x001A1D ; 0000BF, 36.726
0B0A31 37 1A 00    1351*  	dl 0x001A37 ; 0000C0, 36.870
0B0A34 51 1A 00    1352*  	dl 0x001A51 ; 0000C1, 37.013
0B0A37 6B 1A 00    1353*  	dl 0x001A6B ; 0000C2, 37.155
0B0A3A 85 1A 00    1354*  	dl 0x001A85 ; 0000C3, 37.297
0B0A3D 9F 1A 00    1355*  	dl 0x001A9F ; 0000C4, 37.439
0B0A40 B9 1A 00    1356*  	dl 0x001AB9 ; 0000C5, 37.579
0B0A43 D2 1A 00    1357*  	dl 0x001AD2 ; 0000C6, 37.720
0B0A46 EC 1A 00    1358*  	dl 0x001AEC ; 0000C7, 37.859
0B0A49 05 1B 00    1359*  	dl 0x001B05 ; 0000C8, 37.999
0B0A4C 1E 1B 00    1360*  	dl 0x001B1E ; 0000C9, 38.137
0B0A4F 37 1B 00    1361*  	dl 0x001B37 ; 0000CA, 38.276
0B0A52 50 1B 00    1362*  	dl 0x001B50 ; 0000CB, 38.413
0B0A55 69 1B 00    1363*  	dl 0x001B69 ; 0000CC, 38.550
0B0A58 82 1B 00    1364*  	dl 0x001B82 ; 0000CD, 38.687
0B0A5B 9B 1B 00    1365*  	dl 0x001B9B ; 0000CE, 38.823
0B0A5E B4 1B 00    1366*  	dl 0x001BB4 ; 0000CF, 38.959
0B0A61 CC 1B 00    1367*  	dl 0x001BCC ; 0000D0, 39.094
0B0A64 E5 1B 00    1368*  	dl 0x001BE5 ; 0000D1, 39.228
0B0A67 FD 1B 00    1369*  	dl 0x001BFD ; 0000D2, 39.362
0B0A6A 16 1C 00    1370*  	dl 0x001C16 ; 0000D3, 39.496
0B0A6D 2E 1C 00    1371*  	dl 0x001C2E ; 0000D4, 39.629
0B0A70 46 1C 00    1372*  	dl 0x001C46 ; 0000D5, 39.762
0B0A73 5E 1C 00    1373*  	dl 0x001C5E ; 0000D6, 39.894
0B0A76 76 1C 00    1374*  	dl 0x001C76 ; 0000D7, 40.025
0B0A79 8E 1C 00    1375*  	dl 0x001C8E ; 0000D8, 40.156
0B0A7C A5 1C 00    1376*  	dl 0x001CA5 ; 0000D9, 40.286
0B0A7F BD 1C 00    1377*  	dl 0x001CBD ; 0000DA, 40.416
0B0A82 D5 1C 00    1378*  	dl 0x001CD5 ; 0000DB, 40.546
0B0A85 EC 1C 00    1379*  	dl 0x001CEC ; 0000DC, 40.675
0B0A88 04 1D 00    1380*  	dl 0x001D04 ; 0000DD, 40.803
0B0A8B 1B 1D 00    1381*  	dl 0x001D1B ; 0000DE, 40.931
0B0A8E 32 1D 00    1382*  	dl 0x001D32 ; 0000DF, 41.059
0B0A91 49 1D 00    1383*  	dl 0x001D49 ; 0000E0, 41.186
0B0A94 60 1D 00    1384*  	dl 0x001D60 ; 0000E1, 41.312
0B0A97 77 1D 00    1385*  	dl 0x001D77 ; 0000E2, 41.438
0B0A9A 8E 1D 00    1386*  	dl 0x001D8E ; 0000E3, 41.564
0B0A9D A5 1D 00    1387*  	dl 0x001DA5 ; 0000E4, 41.689
0B0AA0 BB 1D 00    1388*  	dl 0x001DBB ; 0000E5, 41.814
0B0AA3 D2 1D 00    1389*  	dl 0x001DD2 ; 0000E6, 41.938
0B0AA6 E9 1D 00    1390*  	dl 0x001DE9 ; 0000E7, 42.061
0B0AA9 FF 1D 00    1391*  	dl 0x001DFF ; 0000E8, 42.184
0B0AAC 15 1E 00    1392*  	dl 0x001E15 ; 0000E9, 42.307
0B0AAF 2C 1E 00    1393*  	dl 0x001E2C ; 0000EA, 42.429
0B0AB2 42 1E 00    1394*  	dl 0x001E42 ; 0000EB, 42.551
0B0AB5 58 1E 00    1395*  	dl 0x001E58 ; 0000EC, 42.672
0B0AB8 6E 1E 00    1396*  	dl 0x001E6E ; 0000ED, 42.793
0B0ABB 84 1E 00    1397*  	dl 0x001E84 ; 0000EE, 42.913
0B0ABE 99 1E 00    1398*  	dl 0x001E99 ; 0000EF, 43.033
0B0AC1 AF 1E 00    1399*  	dl 0x001EAF ; 0000F0, 43.152
0B0AC4 C5 1E 00    1400*  	dl 0x001EC5 ; 0000F1, 43.271
0B0AC7 DA 1E 00    1401*  	dl 0x001EDA ; 0000F2, 43.390
0B0ACA F0 1E 00    1402*  	dl 0x001EF0 ; 0000F3, 43.508
0B0ACD 05 1F 00    1403*  	dl 0x001F05 ; 0000F4, 43.625
0B0AD0 1B 1F 00    1404*  	dl 0x001F1B ; 0000F5, 43.742
0B0AD3 30 1F 00    1405*  	dl 0x001F30 ; 0000F6, 43.859
0B0AD6 45 1F 00    1406*  	dl 0x001F45 ; 0000F7, 43.975
0B0AD9 5A 1F 00    1407*  	dl 0x001F5A ; 0000F8, 44.091
0B0ADC 6F 1F 00    1408*  	dl 0x001F6F ; 0000F9, 44.206
0B0ADF 84 1F 00    1409*  	dl 0x001F84 ; 0000FA, 44.321
0B0AE2 99 1F 00    1410*  	dl 0x001F99 ; 0000FB, 44.435
0B0AE5 AD 1F 00    1411*  	dl 0x001FAD ; 0000FC, 44.549
0B0AE8 C2 1F 00    1412*  	dl 0x001FC2 ; 0000FD, 44.662
0B0AEB D7 1F 00    1413*  	dl 0x001FD7 ; 0000FE, 44.775
0B0AEE EB 1F 00    1414*  	dl 0x001FEB ; 0000FF, 44.888
0B0AF1 00 20 00    1415*  	dl 0x002000 ; 000100, 45.000 only needed for interpolation
0B0AF4             1416*  
0B0AF4             1417*  	; include "functions.inc"
0B0AF4             1418*  
0B0AF4             1419*      MACRO printChar char
0B0AF4             1420*          LD A, char
0B0AF4             1421*          RST.LIL 10h
0B0AF4             1422*      ENDMACRO
0B0AF4             1423*  
0B0AF4             1424*  ; put the value in HLU into the accumulator
0B0AF4             1425*  ; destroys: af
0B0AF4             1426*      MACRO HLU_TO_A
0B0AF4             1427*          push hl ; 4 cycles
0B0AF4             1428*          inc sp ; 1 cycle
0B0AF4             1429*          pop af  ; 4 cycles
0B0AF4             1430*          dec sp ; 1 cycle
0B0AF4             1431*                 ; 10 cycles total
0B0AF4             1432*      ENDMACRO
0B0AF4             1433*  
0B0AF4             1434*  ; put the value in the accumulator into HLU
0B0AF4             1435*  ; destroys a
0B0AF4             1436*  A_TO_HLU:
0B0AF4             1437*      ; call is 7 cycles
0B0AF4 22 01 0B 0B 1438*      ld (@scratch),hl ; 7 cycles
0B0AF8 32 03 0B 0B 1439*      ld (@scratch+2),a ; 5 cycles
0B0AFC 2A 01 0B 0B 1440*      ld hl,(@scratch) ; 7 cycles
0B0B00 C9          1441*      ret ; 6 cycles
0B0B01             1442*          ; 25 cycles total
0B0B01 00 00 00    1443*  @scratch: dl 0
0B0B04             1444*  
0B0B04             1445*  
0B0B04             1446*  ; Print a zero-terminated string inline with code, e.g.:
0B0B04             1447*  ;
0B0B04             1448*  ;    call printInline
0B0B04             1449*  ;    ASCIZ "Hello, world!\r\n"
0B0B04             1450*  ;
0B0B04             1451*  ; Destroys: HL,AF
0B0B04             1452*  printInline:
0B0B04 E1          1453*      pop hl ; get the return address = pointer to start of string
0B0B05 CD 0B 0B 0B 1454*      call printString ; HL advances to end of string
0B0B09 E5          1455*      push hl ; restore the return address = pointer to end of string
0B0B0A C9          1456*      ret
0B0B0B             1457*  
0B0B0B             1458*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
0B0B0B             1459*  ; Print a zero-terminated string
0B0B0B             1460*  ; HL: Pointer to string
0B0B0B             1461*  printString:
0B0B0B C5          1462*  	PUSH	BC
0B0B0C 01 00 00 00 1463*  	LD		BC,0
0B0B10 3E 00       1464*  	LD 	 	A,0
0B0B12 5B DF       1465*  	RST.LIL 18h
0B0B14 C1          1466*  	POP		BC
0B0B15 C9          1467*  	RET
0B0B16             1468*  ; print a VDU sequence
0B0B16             1469*  ; HL: Pointer to VDU sequence - <1 byte length> <data>
0B0B16             1470*  sendVDUsequence:
0B0B16 C5          1471*  	PUSH	BC
0B0B17 01 00 00 00 1472*  	LD		BC, 0
0B0B1B 4E          1473*  	LD		C, (HL)
0B0B1C 5B DF       1474*  	RST.LIL	18h
0B0B1E C1          1475*  	POP		BC
0B0B1F C9          1476*  	RET
0B0B20             1477*  ; Print Newline sequence to VDP
0B0B20             1478*  printNewLine:
0B0B20 F5          1479*      push af ; for some reason rst.lil 10h sets carry flag
0B0B21 3E 0D       1480*  	LD	A, '\r'
0B0B23 5B D7       1481*  	RST.LIL 10h
0B0B25 3E 0A       1482*  	LD	A, '\n'
0B0B27 5B D7       1483*  	RST.LIL 10h
0B0B29 F1          1484*      pop af
0B0B2A C9          1485*  	RET
0B0B2B             1486*  
0B0B2B             1487*  ; Print a 24-bit HEX number
0B0B2B             1488*  ; HLU: Number to print
0B0B2B             1489*  printHex24:
0B0B2B             1490*      HLU_TO_A
0B0B2B E5          0001*M         push hl ; 4 cycles
0B0B2C 33          0002*M         inc sp ; 1 cycle
0B0B2D F1          0003*M         pop af  ; 4 cycles
0B0B2E 3B          0004*M         dec sp ; 1 cycle
0B0B2F             0005*M                ; 10 cycles total
0B0B2F CD 39 0B 0B 1491*  	CALL	printHex8
0B0B33             1492*  ; Print a 16-bit HEX number
0B0B33             1493*  ; HL: Number to print
0B0B33             1494*  printHex16:
0B0B33 7C          1495*  	LD		A,H
0B0B34 CD 39 0B 0B 1496*  	CALL	printHex8
0B0B38 7D          1497*  	LD		A,L
0B0B39             1498*  ; Print an 8-bit HEX number
0B0B39             1499*  ; A: Number to print
0B0B39             1500*  printHex8:
0B0B39 4F          1501*  	LD		C,A
0B0B3A 1F          1502*  	RRA
0B0B3B 1F          1503*  	RRA
0B0B3C 1F          1504*  	RRA
0B0B3D 1F          1505*  	RRA
0B0B3E CD 43 0B 0B 1506*  	CALL	@F
0B0B42 79          1507*  	LD		A,C
0B0B43             1508*  @@:
0B0B43 E6 0F       1509*  	AND		0Fh
0B0B45 C6 90       1510*  	ADD		A,90h
0B0B47 27          1511*  	DAA
0B0B48 CE 40       1512*  	ADC		A,40h
0B0B4A 27          1513*  	DAA
0B0B4B 5B D7       1514*  	RST.LIL	10h
0B0B4D C9          1515*  	RET
0B0B4E             1516*  
0B0B4E             1517*  printHexUHL:
0B0B4E E5          1518*  	push hl
0B0B4F CD 2B 0B 0B 1519*  	call printHex24
0B0B53 E1          1520*  	pop hl
0B0B54 C9          1521*  	ret
0B0B55             1522*  
0B0B55             1523*  
0B0B55             1524*  ; print registers to screen in hexidecimal format
0B0B55             1525*  ; inputs: none
0B0B55             1526*  ; outputs: values of every register printed to screen
0B0B55             1527*  ;    values of each register in global scratch memory
0B0B55             1528*  ; destroys: nothing
0B0B55             1529*  dumpRegistersHex:
0B0B55             1530*  ; store everything in scratch
0B0B55 22 FA 0B 0B 1531*      ld (@uhl),hl
0B0B59 ED 43 FD 0B 1532*      ld (@ubc),bc
       0B          
0B0B5E ED 53 00 0C 1533*      ld (@ude),de
       0B          
0B0B63 DD 22 03 0C 1534*      ld (@uix),ix
       0B          
0B0B68 FD 22 06 0C 1535*      ld (@uiy),iy
       0B          
0B0B6D F5          1536*      push af
0B0B6E E1          1537*      pop hl
0B0B6F 22 F7 0B 0B 1538*      ld (@uaf),hl
0B0B73 F5          1539*      push af
0B0B74             1540*  
0B0B74             1541*  ; print each register
0B0B74 CD 04 0B 0B 1542*      call printInline
0B0B78 61 66 3D 00 1543*      asciz "af="
0B0B7C 2A F7 0B 0B 1544*      ld hl,(@uaf)
0B0B80 CD 2B 0B 0B 1545*      call printHex24
0B0B84             1546*  
0B0B84 CD 04 0B 0B 1547*      call printInline
0B0B88 20 68 6C 3D 1548*      asciz " hl="
       00          
0B0B8D 2A FA 0B 0B 1549*      ld hl,(@uhl)
0B0B91 CD 2B 0B 0B 1550*      call printHex24
0B0B95             1551*  
0B0B95 CD 04 0B 0B 1552*      call printInline
0B0B99 20 62 63 3D 1553*      asciz " bc="
       00          
0B0B9E 2A FD 0B 0B 1554*      ld hl,(@ubc)
0B0BA2 CD 2B 0B 0B 1555*      call printHex24
0B0BA6             1556*  
0B0BA6 CD 04 0B 0B 1557*      call printInline
0B0BAA 20 64 65 3D 1558*      asciz " de="
       00          
0B0BAF 2A 00 0C 0B 1559*      ld hl,(@ude)
0B0BB3 CD 2B 0B 0B 1560*      call printHex24
0B0BB7             1561*  
0B0BB7 CD 04 0B 0B 1562*      call printInline
0B0BBB 20 69 78 3D 1563*      asciz " ix="
       00          
0B0BC0 2A 03 0C 0B 1564*      ld hl,(@uix)
0B0BC4 CD 2B 0B 0B 1565*      call printHex24
0B0BC8             1566*  
0B0BC8 CD 04 0B 0B 1567*      call printInline
0B0BCC 20 69 79 3D 1568*      asciz " iy="
       00          
0B0BD1 2A 06 0C 0B 1569*      ld hl,(@uiy)
0B0BD5 CD 2B 0B 0B 1570*      call printHex24
0B0BD9             1571*  
0B0BD9 CD 20 0B 0B 1572*      call printNewLine
0B0BDD             1573*  ; restore everything
0B0BDD 2A FA 0B 0B 1574*      ld hl, (@uhl)
0B0BE1 ED 4B FD 0B 1575*      ld bc, (@ubc)
       0B          
0B0BE6 ED 5B 00 0C 1576*      ld de, (@ude)
       0B          
0B0BEB DD 2A 03 0C 1577*      ld ix, (@uix)
       0B          
0B0BF0 FD 2A 06 0C 1578*      ld iy, (@uiy)
       0B          
0B0BF5 F1          1579*      pop af
0B0BF6             1580*  ; all done
0B0BF6 C9          1581*      ret
0B0BF7             1582*  
0B0BF7 00 00 00    1583*  @uaf: dl 0
0B0BFA 00 00 00    1584*  @uhl: dl 0
0B0BFD 00 00 00    1585*  @ubc: dl 0
0B0C00 00 00 00    1586*  @ude: dl 0
0B0C03 00 00 00    1587*  @uix: dl 0
0B0C06 00 00 00    1588*  @uiy: dl 0
0B0C09             1589*  
0B0C09             1590*  ; Prints the right justified decimal value in HL without leading zeroes
0B0C09             1591*  ; HL : Value to print
0B0C09             1592*  ; preserves all registers and flags
0B0C09             1593*  printDec:
0B0C09             1594*  ; BEGIN MY CODE
0B0C09             1595*  ; back up all the things
0B0C09 F5          1596*      push af
0B0C0A C5          1597*      push bc
0B0C0B D5          1598*      push de
0B0C0C E5          1599*      push hl
0B0C0D             1600*  ; END MY CODE
0B0C0D 11 35 0C 0B 1601*  	LD	 DE, _printDecBuffer
0B0C11 CD 45 0C 0B 1602*  	CALL u24_to_ascii
0B0C15             1603*  ; BEGIN MY CODE
0B0C15             1604*  ; replace leading zeroes with spaces
0B0C15 21 35 0C 0B 1605*      LD	 HL, _printDecBuffer
0B0C19 06 07       1606*      ld   B, 7 ; if HL was 0, we want to keep the final zero
0B0C1B             1607*  @loop:
0B0C1B 7E          1608*      LD	 A, (HL)
0B0C1C FE 30       1609*      CP	 '0'
0B0C1E C2 28 0C 0B 1610*      JP	 NZ, @done
0B0C22 3E 20       1611*      LD   A, ' '
0B0C24 77          1612*      LD	 (HL), A
0B0C25 23          1613*      INC	 HL
0B0C26             1614*      ; CALL vdu_cursor_forward
0B0C26 10 F3       1615*      DJNZ @loop
0B0C28             1616*  @done:
0B0C28             1617*  ; END MY CODE
0B0C28 21 35 0C 0B 1618*  	LD	 HL, _printDecBuffer
0B0C2C CD 0B 0B 0B 1619*  	CALL printString
0B0C30             1620*  ; BEGIN MY CODE
0B0C30             1621*  ; restore all the things
0B0C30 E1          1622*      pop hl
0B0C31 D1          1623*      pop de
0B0C32 C1          1624*      pop bc
0B0C33 F1          1625*      pop af
0B0C34             1626*  ; END MY CODE
0B0C34 C9          1627*  	RET
0B0C35 00 00 00 00 1628*  _printDecBuffer: blkb 16,0 ; a few bytes extra just to be sure
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0B0C45             1629*  
0B0C45             1630*  ; This routine converts the unsigned 24-bit value in HLU into it's ASCII representation,
0B0C45             1631*  ; starting to memory location pointing by DE, in decimal form and with leading zeroes
0B0C45             1632*  ; so it will allways be 8 characters length
0B0C45             1633*  ; HL : Value to convert to string
0B0C45             1634*  ; DE : pointer to buffer, at least 8 byte + 0
0B0C45             1635*  u24_to_ascii:
0B0C45 01 80 69 67 1636*  	LD	 BC,-10000000
0B0C49 CD 7C 0C 0B 1637*  	CALL @one_digit
0B0C4D 01 C0 BD F0 1638*  	LD	 BC,-1000000
0B0C51 CD 7C 0C 0B 1639*  	CALL @one_digit
0B0C55 01 60 79 FE 1640*  	LD	 BC,-100000
0B0C59 CD 7C 0C 0B 1641*  	CALL @one_digit
0B0C5D 01 F0 D8 FF 1642*  	LD   BC,-10000
0B0C61 CD 7C 0C 0B 1643*  	CALL @one_digit
0B0C65 01 18 FC FF 1644*  	LD   BC,-1000
0B0C69 CD 7C 0C 0B 1645*  	CALL @one_digit
0B0C6D 01 9C FF FF 1646*  	LD   BC,-100
0B0C71 CD 7C 0C 0B 1647*  	CALL @one_digit
0B0C75 0E F6       1648*  	LD   C,-10
0B0C77 CD 7C 0C 0B 1649*  	CALL @one_digit
0B0C7B 48          1650*  	LD   C,B
0B0C7C             1651*  @one_digit:
0B0C7C 3E 2F       1652*  	LD   A,'0'-1
0B0C7E             1653*  @divide_me:
0B0C7E 3C          1654*  	INC  A
0B0C7F 09          1655*  	ADD  HL,BC
0B0C80 38 FC       1656*  	JR   C,@divide_me
0B0C82 ED 42       1657*  	SBC  HL,BC
0B0C84 12          1658*  	LD   (DE),A
0B0C85 13          1659*  	INC  DE
0B0C86 C9          1660*  	RET
0B0C87             1661*  
0B0C87             1662*  print_u24:
0B0C87 D5          1663*      push de
0B0C88 E5          1664*      push hl
0B0C89 11 35 0C 0B 1665*      ld de,_printDecBuffer
0B0C8D CD 45 0C 0B 1666*      call u24_to_ascii
0B0C91 21 35 0C 0B 1667*      ld hl,_printDecBuffer
0B0C95 CD 0B 0B 0B 1668*      call printString
0B0C99 3E 20       1669*      ld a,' '
0B0C9B 5B D7       1670*      rst.lil 10h
0B0C9D E1          1671*      pop hl
0B0C9E D1          1672*      pop de
0B0C9F C9          1673*      ret
0B0CA0             1674*  
0B0CA0             1675*  ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
0B0CA0             1676*  ; HL : Value to convert to string (integer part in H, fractional part in L)
0B0CA0             1677*  ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
0B0CA0             1678*  u168_to_ascii:
0B0CA0             1679*  ; add a leading space to make room for sign flag if needed
0B0CA0 3E 20       1680*      ld a,' '
0B0CA2 12          1681*      ld (de),a
0B0CA3 13          1682*      inc de
0B0CA4             1683*  ; Convert integer part
0B0CA4 E5          1684*      push hl               ; Save HL (we’ll need the fractional part later)
0B0CA5 CD B7 00 0B 1685*      call hlu_udiv256    ; Shift to get integer portion in HL
0B0CA9 01 F0 D8 FF 1686*      ld   bc, -10000
0B0CAD CD D0 0C 0B 1687*      call @one_int
0B0CB1 01 18 FC FF 1688*      ld   bc, -1000
0B0CB5 CD D0 0C 0B 1689*      call @one_int
0B0CB9 01 9C FF FF 1690*      ld   bc, -100
0B0CBD CD D0 0C 0B 1691*      call @one_int
0B0CC1 0E F6       1692*      ld   c, -10
0B0CC3 CD D0 0C 0B 1693*      call @one_int
0B0CC7 48          1694*      ld   c, b
0B0CC8 CD D0 0C 0B 1695*      call @one_int
0B0CCC C3 DB 0C 0B 1696*      jp   @frac            ; Jump to fractional part conversion
0B0CD0             1697*  @one_int:
0B0CD0 3E 2F       1698*      ld   a, '0' - 1       ; Start ASCII character at '0'
0B0CD2             1699*  @divide_me:
0B0CD2 3C          1700*      inc  a
0B0CD3 09          1701*      add  hl, bc           ; Accumulate until overflow
0B0CD4 38 FC       1702*      jr   c, @divide_me
0B0CD6 ED 42       1703*      sbc  hl, bc           ; Remove excess after overflow
0B0CD8 12          1704*      ld   (de), a          ; Store ASCII digit
0B0CD9 13          1705*      inc  de
0B0CDA C9          1706*      ret
0B0CDB             1707*  ; Convert fractional part
0B0CDB             1708*  @frac:
0B0CDB 3E 2E       1709*      ld   a, '.'           ; Decimal point
0B0CDD 12          1710*      ld   (de), a
0B0CDE 13          1711*      inc  de
0B0CDF E1          1712*      pop  hl               ; Restore HL with original fraction
0B0CE0 06 03       1713*      ld   b, 3             ; Loop counter for 3 fractional digits
0B0CE2             1714*  @frac_loop:
0B0CE2 26 0A       1715*      ld   h, 10            ; Load multiplier for fractional part
0B0CE4 ED 6C       1716*      mlt  hl               ; Multiply by 10, result in HL (H holds the integer part)
0B0CE6 3E 30       1717*      ld   a, '0'
0B0CE8 84          1718*      add  a, h             ; Convert integer part to ASCII
0B0CE9 12          1719*      ld   (de), a
0B0CEA 13          1720*      inc  de
0B0CEB 10 F5       1721*      djnz @frac_loop       ; Repeat for each fractional digit
0B0CED             1722*  ; Add null terminator
0B0CED AF          1723*      xor  a                ; Null terminator
0B0CEE 12          1724*      ld   (de), a
0B0CEF C9          1725*      ret
0B0CF0             1726*  
0B0CF0             1727*  print_u168:
0B0CF0 D5          1728*      push de
0B0CF1 E5          1729*      push hl
0B0CF2 11 35 0C 0B 1730*      ld de,_printDecBuffer
0B0CF6 CD A0 0C 0B 1731*      call u168_to_ascii
0B0CFA 21 35 0C 0B 1732*      ld hl,_printDecBuffer
0B0CFE CD 0B 0B 0B 1733*      call printString
0B0D02 E1          1734*      pop hl
0B0D03 D1          1735*      pop de
0B0D04 C9          1736*      ret
0B0D05             1737*  
0B0D05             1738*  ; signed version of u168_to_ascii
0B0D05             1739*  s168_to_ascii:
0B0D05 D5          1740*      push de ; save starting address of buffer
0B0D06 CD C4 00 0B 1741*      call hlu_abs
0B0D0A F5          1742*      push af ; save sign flag
0B0D0B CD A0 0C 0B 1743*      call u168_to_ascii
0B0D0F F1          1744*      pop af ; restore sign flag
0B0D10 D1          1745*      pop de ; restore starting address of buffer
0B0D11 F0          1746*      ret p ; hlu was positive so nothing to do
0B0D12 3E 2D       1747*      ld a,'-'
0B0D14 12          1748*      ld (de),a
0B0D15 C9          1749*      ret
0B0D16             1750*  
0B0D16             1751*  print_s168:
0B0D16 D5          1752*      push de
0B0D17 E5          1753*      push hl
0B0D18 11 35 0C 0B 1754*      ld de,_printDecBuffer
0B0D1C CD 05 0D 0B 1755*      call s168_to_ascii
0B0D20 21 35 0C 0B 1756*      ld hl,_printDecBuffer
0B0D24 CD 0B 0B 0B 1757*      call printString
0B0D28 E1          1758*      pop hl
0B0D29 D1          1759*      pop de
0B0D2A C9          1760*      ret
0B0D2B             1761*  
0B0D2B             1762*  	; include "parse.inc"
0B0D2B             1763*  
0B0D2B             1764*  ;
0B0D2B             1765*  ; Title:	Number Parsing Functions
0B0D2B             1766*  ; Author:	Dean Belfield
0B0D2B             1767*  ; Created:	15/11/2022
0B0D2B             1768*  ; Last Updated:	15/11/2022
0B0D2B             1769*  ; Last Updated: 29/12/2022 Lennart Benchop adapt for 24-bit mode.
0B0D2B             1770*  ; Modinfo:
0B0D2B             1771*  ; 2024/04/08    Adapt for ez80asm
0B0D2B             1772*  
0B0D2B             1773*  ; Read a number and convert to binary
0B0D2B             1774*  ; If prefixed with &, will read as hex, otherwise decimal
0B0D2B             1775*  ;   Inputs: HL: Pointer in string buffer
0B0D2B             1776*  ;  Outputs: HL: Updated text pointer
0B0D2B             1777*  ;           DE: Value
0B0D2B             1778*  ;            A: Terminator (spaces skipped)
0B0D2B             1779*  ;            F: Carry set if valid number, otherwise reset
0B0D2B             1780*  ; Destroys: A,D,E,H,L,F
0B0D2B             1781*  ;
0B0D2B 11 00 00 00 1782*  ASC_TO_NUMBER:		LD		DE, 0			; Initialise DE
0B0D2F             1783*  			; CALL		_skip_spaces		; Skip whitespace
0B0D2F 7E          1784*  			LD		A, (HL)			; Read first character
0B0D30 B7          1785*  			OR		A			; Check for end of string
0B0D31 C8          1786*  			RET		Z			; Return with no carry if not
0B0D32 C5          1787*  			PUSH		BC			; Preserve BC
0B0D33 FE 26       1788*  			CP		'&'			; Is it prefixed with '&' (HEX number)?
0B0D35 20 23       1789*  			JR		NZ, ASC_TO_NUMBER3	; Jump to decimal parser if not
0B0D37 23          1790*  			INC		HL			; Otherwise fall through to ASC_TO_HEX
0B0D38             1791*  ;
0B0D38 7E          1792*  ASC_TO_NUMBER1:		LD		A, (HL)			; Fetch the character
0B0D39 CD 7B 0D 0B 1793*  			CALL   	 	UPPRC			; Convert to uppercase
0B0D3D D6 30       1794*  			SUB		'0'			; Normalise to 0
0B0D3F 38 37       1795*  			JR 		C, ASC_TO_NUMBER4	; Return if < ASCII '0'
0B0D41 FE 0A       1796*  			CP 		10			; Check if >= 10
0B0D43 38 06       1797*  			JR 		C, ASC_TO_NUMBER2	; No, so skip next bit
0B0D45 D6 07       1798*  			SUB 		7			; Adjust ASCII A-F to nibble
0B0D47 FE 10       1799*  			CP 		16			; Check for > F
0B0D49 30 2D       1800*  			JR 		NC, ASC_TO_NUMBER4	; Return if out of range
0B0D4B             1801*  ;
0B0D4B E5          1802*  ASC_TO_NUMBER2:		PUSH		HL			; Stack HL
0B0D4C D5          1803*  			PUSH		DE			; LD HL, DE
0B0D4D E1          1804*  			POP		HL
0B0D4E 29          1805*  			ADD		HL, HL
0B0D4F 29          1806*  			ADD		HL, HL
0B0D50 29          1807*  			ADD		HL, HL
0B0D51 29          1808*  			ADD		HL, HL
0B0D52 E5          1809*  			PUSH		HL			; LD DE, HL
0B0D53 D1          1810*  			POP		DE
0B0D54 E1          1811*  			POP		HL			; Restore HL
0B0D55 B3          1812*  			OR      	E			; OR the new digit in to the least significant nibble
0B0D56 5F          1813*  			LD      	E, A
0B0D57             1814*  ;
0B0D57 23          1815*  			INC		HL			; Onto the next character
0B0D58 18 DE       1816*  			JR      	ASC_TO_NUMBER1		; And loop
0B0D5A             1817*  ;
0B0D5A 7E          1818*  ASC_TO_NUMBER3:		LD		A, (HL)
0B0D5B D6 30       1819*  			SUB		'0'			; Normalise to 0
0B0D5D 38 19       1820*  			JR		C, ASC_TO_NUMBER4	; Return if < ASCII '0'
0B0D5F FE 0A       1821*  			CP		10			; Check if >= 10
0B0D61 30 15       1822*  			JR		NC, ASC_TO_NUMBER4	; Return if >= 10
0B0D63             1823*  ;
0B0D63 E5          1824*  			PUSH		HL			; Stack HL
0B0D64 D5          1825*  			PUSH		DE			; LD HL, DE
0B0D65 E1          1826*  			POP		HL
0B0D66 E5          1827*  			PUSH		HL			; LD BC, HL
0B0D67 C1          1828*  			POP		BC
0B0D68 29          1829*  			ADD		HL, HL 			; x 2
0B0D69 29          1830*  			ADD		HL, HL 			; x 4
0B0D6A 09          1831*  			ADD		HL, BC 			; x 5
0B0D6B 29          1832*  			ADD		HL, HL 			; x 10
0B0D6C 01 00 00 00 1833*  			LD		BC, 0
0B0D70 4F          1834*  			LD 		C, A			; LD BCU, A
0B0D71 09          1835*  			ADD		HL, BC			; Add BCU to HL
0B0D72 E5          1836*  			PUSH		HL			; LD DE, HL
0B0D73 D1          1837*  			POP		DE
0B0D74 E1          1838*  			POP		HL			; Restore HL
0B0D75             1839*  ;
0B0D75 23          1840*  			INC		HL
0B0D76 18 E2       1841*  			JR		ASC_TO_NUMBER3
0B0D78 C1          1842*  ASC_TO_NUMBER4:		POP		BC
0B0D79 37          1843*  			SCF					; We have a valid number so set carry
0B0D7A C9          1844*  			RET
0B0D7B             1845*  
0B0D7B             1846*  
0B0D7B             1847*  ; Convert a character to upper case
0B0D7B             1848*  ;  A: Character to convert
0B0D7B             1849*  ;
0B0D7B E6 7F       1850*  UPPRC:  		AND     	7FH
0B0D7D FE 60       1851*  			CP      	'`'
0B0D7F D8          1852*  			RET     	C
0B0D80 E6 5F       1853*  			AND     	5FH			; Convert to upper case
0B0D82 C9          1854*  			RET
0B0D83             1855*  
0B0D83             1856*  ; -----------------------------------------------------------------------
0B0D83             1857*  ;
0B0D83             1858*  ; additional functions by Brandon R. Gates based on Dean's code
0B0D83             1859*  ;
0B0D83             1860*  ;------------------------------------------------------------------------
0B0D83             1861*  ; Read a number and convert to binary (decimal only)
0B0D83             1862*  ; Inputs: hl: Pointer in string buffer
0B0D83             1863*  ; Outputs: hl: Updated text pointer
0B0D83             1864*  ;         de: Value
0B0D83             1865*  ;         a: Terminator (spaces skipped)
0B0D83             1866*  ;         f: Carry set if valid number, otherwise reset
0B0D83             1867*  ; Destroys: a, d, e, h, l, f
0B0D83             1868*  ;------------------------------------------------------------------------
0B0D83             1869*  asc_to_s24:
0B0D83 3E 01       1870*      ld a,1 ; set sign flag
0B0D85 32 D1 0D 0B 1871*      ld (@sign),a ; store sign flag
0B0D89             1872*  
0B0D89 11 00 00 00 1873*      ld de, 0 ; initialise de
0B0D8D             1874*      ; call _skip_spaces ; skip whitespace
0B0D8D             1875*  
0B0D8D 7E          1876*      ld a, (hl) ; read first character
0B0D8E B7          1877*      or a ; check for end of string
0B0D8F C8          1878*      ret z ; return with no carry if not
0B0D90             1879*  
0B0D90 C5          1880*      push bc ; preserve bc
0B0D91             1881*  
0B0D91 FE 2D       1882*      cp '-' ; check for negative number
0B0D93 C2 9D 0D 0B 1883*      jp nz,@loop ; number is positive, nothing more to do
0B0D97 AF          1884*      xor a ; sign flag to zero
0B0D98 32 D1 0D 0B 1885*      ld (@sign),a ; store sign flag
0B0D9C 23          1886*      inc hl ; skip '-'
0B0D9D             1887*  
0B0D9D             1888*  @loop:
0B0D9D 7E          1889*      ld a, (hl)
0B0D9E D6 30       1890*      sub '0' ; normalise to 0
0B0DA0 38 19       1891*      jr c, @integer_end ; return if < ascii '0'
0B0DA2 FE 0A       1892*      cp 10 ; check if >= 10
0B0DA4 30 15       1893*      jr nc, @integer_end ; return if >= 10
0B0DA6 E5          1894*      push hl ; stack hl
0B0DA7 D5          1895*      push de ; ld hl, de
0B0DA8 E1          1896*      pop hl
0B0DA9 E5          1897*      push hl ; ld bc, hl
0B0DAA C1          1898*      pop bc
0B0DAB 29          1899*      add hl, hl ; x 2
0B0DAC 29          1900*      add hl, hl ; x 4
0B0DAD 09          1901*      add hl, bc ; x 5
0B0DAE 29          1902*      add hl, hl ; x 10
0B0DAF 01 00 00 00 1903*      ld bc, 0
0B0DB3 4F          1904*      ld c, a ; ld bcu, a
0B0DB4 09          1905*      add hl, bc ; add bcu to hl
0B0DB5 E5          1906*      push hl ; ld de, hl
0B0DB6 D1          1907*      pop de
0B0DB7 E1          1908*      pop hl ; restore hl
0B0DB8 23          1909*      inc hl
0B0DB9 18 E2       1910*      jr @loop
0B0DBB             1911*  
0B0DBB             1912*  @integer_end:
0B0DBB C1          1913*      pop bc ; send bc back how she came in
0B0DBC 3A D1 0D 0B 1914*      ld a, (@sign) ; get sign flag
0B0DC0 3D          1915*      dec a ; check if negative
0B0DC1 F2 CF 0D 0B 1916*      jp p,@pos ; positive number
0B0DC5             1917*  
0B0DC5             1918*  ; Negate de
0B0DC5 E5          1919*      push hl ; save text pointer
0B0DC6 21 00 00 00 1920*      ld hl, 0
0B0DCA AF          1921*      xor a ; clear carry
0B0DCB ED 52       1922*      sbc hl, de ; subtract DE from HL
0B0DCD EB          1923*      ex de, hl ; DE = 0-HL
0B0DCE E1          1924*      pop hl ; restore text pointer
0B0DCF             1925*  
0B0DCF             1926*  @pos:
0B0DCF 37          1927*      scf ; we have a valid number so set carry
0B0DD0 C9          1928*      ret
0B0DD1             1929*  
0B0DD1 00          1930*  @sign: db 0 ; sign flag buffer
0B0DD2             1931*  
0B0DD2             1932*  
0B0DD2             1933*  ;------------------------------------------------------------------------
0B0DD2             1934*  ; Read a number and convert to binary (decimal only)
0B0DD2             1935*  ; Inputs: hl: Pointer in string buffer
0B0DD2             1936*  ; Outputs: hl: Updated text pointer
0B0DD2             1937*  ;         de: Value
0B0DD2             1938*  ;         a: Terminator (spaces skipped)
0B0DD2             1939*  ;         f: Carry set if valid number, otherwise reset
0B0DD2             1940*  ; Destroys: a, d, e, h, l, f
0B0DD2             1941*  ;------------------------------------------------------------------------
0B0DD2             1942*  asc_to_s168:
0B0DD2 3E 01       1943*      ld a,1 ; set sign flag
0B0DD4 32 91 0E 0B 1944*      ld (@sign),a ; store sign flag
0B0DD8             1945*  
0B0DD8 11 00 00 00 1946*      ld de, 0 ; initialise de
0B0DDC ED 53 89 0E 1947*      ld (@result), de ; clear low bytes of result buffer
       0B          
0B0DE1 ED 53 8D 0E 1948*      ld (@scratch), de ; clear low bytes of scratch buffer
       0B          
0B0DE6             1949*  
0B0DE6             1950*      ; call _skip_spaces ; skip whitespace
0B0DE6             1951*  
0B0DE6 7E          1952*      ld a, (hl) ; read first character
0B0DE7 B7          1953*      or a ; check for end of string
0B0DE8 C8          1954*      ret z ; return with no carry if not
0B0DE9             1955*  
0B0DE9 C5          1956*      push bc ; preserve bc
0B0DEA             1957*  
0B0DEA FE 2D       1958*      cp '-' ; check for negative number
0B0DEC C2 F6 0D 0B 1959*      jp nz,@loop ; number is positive, nothing more to do
0B0DF0 AF          1960*      xor a ; sign flag to zero
0B0DF1 32 91 0E 0B 1961*      ld (@sign),a ; store sign flag
0B0DF5 23          1962*      inc hl ; skip '-'
0B0DF6             1963*  
0B0DF6             1964*  @loop:
0B0DF6 7E          1965*      ld a, (hl)
0B0DF7             1966*  
0B0DF7             1967*  ; chcek for decimal point
0B0DF7 FE 2E       1968*      cp '.' ; check for decimal point
0B0DF9 CA 3A 0E 0B 1969*      jp z,@fractional_start ; jump to fractional part
0B0DFD             1970*  
0B0DFD             1971*  ; process integer part
0B0DFD D6 30       1972*      sub '0' ; normalise to 0
0B0DFF 38 19       1973*      jr c, @integer_end ; return if < ascii '0'
0B0E01 FE 0A       1974*      cp 10 ; check if >= 10
0B0E03 30 15       1975*      jr nc, @integer_end ; return if >= 10
0B0E05 E5          1976*      push hl ; stack hl
0B0E06 D5          1977*      push de ; ld hl, de
0B0E07 E1          1978*      pop hl
0B0E08 E5          1979*      push hl ; ld bc, hl
0B0E09 C1          1980*      pop bc
0B0E0A 29          1981*      add hl, hl ; x 2
0B0E0B 29          1982*      add hl, hl ; x 4
0B0E0C 09          1983*      add hl, bc ; x 5
0B0E0D 29          1984*      add hl, hl ; x 10
0B0E0E 01 00 00 00 1985*      ld bc, 0
0B0E12 4F          1986*      ld c, a ; ld bcu, a
0B0E13 09          1987*      add hl, bc ; add bcu to hl
0B0E14 E5          1988*      push hl ; ld de, hl
0B0E15 D1          1989*      pop de
0B0E16 E1          1990*      pop hl ; restore hl
0B0E17 23          1991*      inc hl
0B0E18 18 DC       1992*      jr @loop
0B0E1A             1993*  
0B0E1A             1994*  @integer_end:
0B0E1A ED 53 8A 0E 1995*      ld (@result+1), de      ; Store integer part in result buffer (shifted up one byte)
       0B          
0B0E1F             1996*  
0B0E1F             1997*  @end:
0B0E1F C1          1998*      pop bc ; send bc back how she came in
0B0E20 ED 5B 89 0E 1999*      ld de,(@result) ; will contain shifted integer part combined with any fractional value
       0B          
0B0E25 3A 91 0E 0B 2000*      ld a, (@sign) ; get sign flag
0B0E29 3D          2001*      dec a ; check if negative
0B0E2A F2 38 0E 0B 2002*      jp p,@pos ; positive number
0B0E2E             2003*  
0B0E2E             2004*  ; Negate de
0B0E2E E5          2005*      push hl ; save text pointer
0B0E2F 21 00 00 00 2006*      ld hl, 0
0B0E33 AF          2007*      xor a ; clear carry
0B0E34 ED 52       2008*      sbc hl, de ; subtract DE from HL
0B0E36 EB          2009*      ex de, hl ; DE = 0-HL
0B0E37 E1          2010*      pop hl ; restore text pointer
0B0E38             2011*  
0B0E38             2012*  @pos:
0B0E38 37          2013*      scf ; we have a valid number so set carry
0B0E39 C9          2014*      ret
0B0E3A             2015*  
0B0E3A             2016*  @fractional_start:
0B0E3A DD E5       2017*      push ix                    ; preserve ix
0B0E3C ED 53 8A 0E 2018*      ld (@result+1), de         ; Store integer part in result buffer (shifted up one byte)
       0B          
0B0E41 06 03       2019*      ld b, 3                    ; Set loop counter to 3 for up to three fractional digits
0B0E43 11 00 00 00 2020*      ld de, 0                   ; Initialize DE as the fractional accumulator
0B0E47 DD 21 92 0E 2021*      ld ix, powers_of_10        ; Point IX to the lookup table for the scaling factor based on digits
       0B          
0B0E4C 23          2022*      inc hl                     ; Skip decimal point
0B0E4D             2023*  
0B0E4D             2024*  @fractional_loop:
0B0E4D 7E          2025*      ld a, (hl)                 ; Load next character
0B0E4E D6 30       2026*      sub '0'                    ; Normalize ASCII to decimal
0B0E50 38 1C       2027*      jr c, @end_fraction        ; Exit if < '0'
0B0E52 FE 0A       2028*      cp 10
0B0E54 30 18       2029*      jr nc, @end_fraction       ; Exit if >= 10
0B0E56             2030*  
0B0E56             2031*      ; Multiply the current fractional accumulator by 10
0B0E56 E5          2032*      push hl                    ; Save char pointer
0B0E57 F5          2033*      push af                    ; Save the digit
0B0E58 EB          2034*      ex de, hl
0B0E59 E5          2035*      push hl
0B0E5A 29          2036*      add hl,hl ; * 2
0B0E5B 29          2037*      add hl,hl ; * 4
0B0E5C D1          2038*      pop de
0B0E5D 19          2039*      add hl,de ; * 5
0B0E5E 29          2040*      add hl,hl ; * 10
0B0E5F 11 00 00 00 2041*      ld de, 0                   ; Clear DEU
0B0E63 F1          2042*      pop af                     ; Restore the current digit
0B0E64 5F          2043*      ld e, a                    ; Load the digit into E
0B0E65 19          2044*      add hl, de                 ; Add the digit to the accumulator
0B0E66 EB          2045*      ex de, hl                  ; Result back to DE
0B0E67 ED 32 03    2046*      lea ix,ix+3                ; Advance IX to the next scaling factor
0B0E6A E1          2047*      pop hl                     ; Restore char pointer
0B0E6B 23          2048*      inc hl                     ; Move to the next character
0B0E6C 10 DF       2049*      djnz @fractional_loop      ; Loop if more digits to process
0B0E6E             2050*  
0B0E6E             2051*  @end_fraction:
0B0E6E             2052*  ; Final scaling based on number of fractional digits processed
0B0E6E ED 53 8E 0E 2053*      ld (@scratch+1), de          ; Shift fractional part up a byte
       0B          
0B0E73 2A 8D 0E 0B 2054*      ld hl,(@scratch)             ; Load the shifted fractional part into HL
0B0E77             2055*  
0B0E77 DD 17 00    2056*      ld de, (ix)                ; Load final scaling factor from IX based on digit count
0B0E7A CD 34 02 0B 2057*      call udiv24                ; Perform 24-bit division to scale down
0B0E7E 7B          2058*      ld a, e                    ; Load the low byte (8-bit fractional part) into A
0B0E7F 32 89 0E 0B 2059*      ld (@result), a            ; Store fractional part in result buffer
0B0E83 DD E1       2060*      pop ix                     ; Restore ix
0B0E85 C3 1F 0E 0B 2061*      jp @end                    ; Final sign check and flag setup
0B0E89             2062*  
0B0E89             2063*  @result: ds 4                  ; 32-bit result buffer to shift integer part up one byte
0B0E8D             2064*  @scratch: ds 4                 ; 32-bit scratch buffer for intermediate calculations
0B0E91 00          2065*  @sign: db 0                    ; Sign flag buffer
0B0E92             2066*  
0B0E92             2067*  powers_of_10:
0B0E92 01 00 00    2068*      dl 1                       ; 10^0
0B0E95 0A 00 00    2069*      dl 10                      ; 10^1
0B0E98 64 00 00    2070*      dl 100                     ; 10^2
0B0E9B E8 03 00    2071*      dl 1000                    ; 10^3
0B0E9E 10 27 00    2072*      dl 10000                   ; 10^4
0B0EA1             0059   
0B0EA1             0060   ; --- MAIN PROGRAM ---
0B0EA1             0061   main:
0B0EA1 0D          0062       dec c ; decrement the argument count to skip the program name
0B0EA2             0063   
0B0EA2 CD 66 0F 0B 0064       call get_arg_s24
0B0EA6 ED 53 4E 0F 0065       ld (@arg1),de
       0B          
0B0EAB D5          0066       push de
0B0EAC E1          0067       pop hl
0B0EAD CD 97 01 0B 0068       call umul24
0B0EB1 CD 55 0B 0B 0069       call dumpRegistersHex
0B0EB5             0070   
0B0EB5 C3 8E 00 0B 0071       jp _main_end_ok
0B0EB9             0072   
0B0EB9             0073   ; compute distance between the origin and a point entered by the user
0B0EB9 CD 5B 0F 0B 0074       call get_arg_s168
0B0EBD ED 53 4E 0F 0075       ld (@arg1),de ; dx
       0B          
0B0EC2 CD 5B 0F 0B 0076       call get_arg_s168
0B0EC6 ED 53 51 0F 0077       ld (@arg2),de ; dy
       0B          
0B0ECB             0078   
0B0ECB             0079   ; echo the input
0B0ECB CD 04 0B 0B 0080       call printInline
0B0ECF 64 69 73 74 0081       asciz "distance to target at: "
       61 6E 63 65 
       20 74 6F 20 
       74 61 72 67 
       65 74 20 61 
       74 3A 20 00 
0B0EE7 2A 4E 0F 0B 0082       ld hl,(@arg1)
0B0EEB CD 16 0D 0B 0083       call print_s168
0B0EEF 3E 2C       0084       ld a,',' ; print a comma
0B0EF1 5B D7       0085       rst.lil 10h
0B0EF3 2A 51 0F 0B 0086       ld hl,(@arg2)
0B0EF7 CD 16 0D 0B 0087       call print_s168
0B0EFB CD 04 0B 0B 0088       call printInline
0B0EFF 20 3D 20 00 0089       asciz " = "
0B0F03             0090   
0B0F03             0091   ; compute the distance
0B0F03 DD 2A 4E 0F 0092       ld ix,(@arg1) ; x1
       0B          
0B0F08 FD 2A 51 0F 0093       ld iy,(@arg2) ; y1
       0B          
0B0F0D 01 00 00 00 0094       ld bc,0 ; x1 0
0B0F11 11 00 00 00 0095       ld de,0 ; y1 0
0B0F15 CD 08 03 0B 0096       call distance168
0B0F19 CD 16 0D 0B 0097       call print_s168
0B0F1D             0098   
0B0F1D             0099   ; compute angle between the origin and the point entered by the user
0B0F1D CD 04 0B 0B 0100       call printInline
0B0F21 0D 0A 74 61 0101       asciz "\r\ntarget bearing: "
       72 67 65 74 
       20 62 65 61 
       72 69 6E 67 
       3A 20 00    
0B0F34 ED 4B FC 02 0102       ld bc,(dx168)
       0B          
0B0F39 ED 5B 02 03 0103       ld de,(dy168)
       0B          
0B0F3E CD 3E 03 0B 0104       call atan2_168fast ; uh.l = atan2(dx,-dy) in deg256
0B0F42 CD 71 02 0B 0105       call deg_256_to_360 ; convert to 360 degree circle
0B0F46 CD 16 0D 0B 0106       call print_s168
0B0F4A             0107   
0B0F4A C3 8E 00 0B 0108       jp _main_end_ok
0B0F4E             0109   
0B0F4E             0110   ; ; test deg_360_to_256
0B0F4E             0111   ;     call get_arg_s168
0B0F4E             0112   ;     ld (@arg1),de
0B0F4E             0113   ;     ex de,hl
0B0F4E             0114   ;     call print_s168
0B0F4E             0115   ;     ld hl,(@arg1)
0B0F4E             0116   ;     call deg_360_to_256
0B0F4E             0117   ;     call print_s168
0B0F4E             0118   ;     call printNewLine
0B0F4E             0119   ;     jp _main_end_ok
0B0F4E             0120   
0B0F4E             0121   ; ; test deg_256_to_360
0B0F4E             0122   ;     call get_arg_s168
0B0F4E             0123   ;     ld (@arg1),de
0B0F4E             0124   ;     ex de,hl
0B0F4E             0125   ;     call print_s168
0B0F4E             0126   ;     ld hl,(@arg1)
0B0F4E             0127   ;     call deg_256_to_360
0B0F4E             0128   ;     call print_s168
0B0F4E             0129   ;     call printNewLine
0B0F4E             0130   ;     jp _main_end_ok
0B0F4E             0131   
0B0F4E 00 00 00    0132   @arg1: dl 0
0B0F51 00 00 00    0133   @arg2: dl 0
0B0F54             0134   
0B0F54             0135   ; ========== HELPER FUNCTIONS ==========
0B0F54             0136   ; get the next argument after ix as a string
0B0F54             0137   ; inputs: ix = pointer to the argument string
0B0F54             0138   ; outputs: HL = pointer to the argument string, ix points to the next argument
0B0F54             0139   ; destroys: a, h, l, f
0B0F54             0140   get_arg_text:
0B0F54 ED 32 03    0141       lea ix,ix+3 ; point to the next argument
0B0F57 DD 27 00    0142       ld hl,(ix) ; get the argument string
0B0F5A C9          0143       ret
0B0F5B             0144   
0B0F5B             0145   ; get the next argument after ix as a signed 16.8 fixed point number
0B0F5B             0146   ; inputs: ix = pointer to the argument string
0B0F5B             0147   ; outputs: ude = signed 16.8 fixed point number
0B0F5B             0148   ; destroys: a, d, e, h, l, f
0B0F5B             0149   get_arg_s168:
0B0F5B ED 32 03    0150       lea ix,ix+3 ; point to the next argument
0B0F5E DD 27 00    0151       ld hl,(ix) ; get the argument string
0B0F61 CD D2 0D 0B 0152       call asc_to_s168 ; convert the string to a number
0B0F65 C9          0153       ret ; return with the value in DE
0B0F66             0154   
0B0F66             0155   ; Inputs: ix = pointer to the argument string
0B0F66             0156   ; Outputs: ude = signed 24-bit integer
0B0F66             0157   ; Destroys: a, d, e, h, l, f
0B0F66             0158   get_arg_s24:
0B0F66 ED 32 03    0159       lea ix,ix+3 ; point to the next argument
0B0F69 DD 27 00    0160       ld hl,(ix) ; get the argument string
0B0F6C CD 83 0D 0B 0161       call asc_to_s24 ; convert the string to a number
0B0F70 C9          0162       ret ; return with the value in DE
0B0F71             0163   
0B0F71             0164   ; match the next argument after ix to the dispatch table at iy
0B0F71             0165   ; - arguments and dispatch entries are zero-terminated, case-sensitive strings
0B0F71             0166   ; - final entry of dispatch table must be a 3-byte zero or bad things will happen
0B0F71             0167   ; returns: NO MATCH: iy=dispatch list terminator a=1 and zero flag reset
0B0F71             0168   ; ON MATCH: iy=dispatch address, a=0 and zero flag set
0B0F71             0169   ; destroys: a, hl, de, ix, iy, flags
0B0F71             0170   match_next:
0B0F71 ED 32 03    0171       lea ix,ix+3 ; point to the next argument
0B0F74             0172   @loop:
0B0F74 FD 27 00    0173       ld hl,(iy) ; pointer argument dispatch record
0B0F77             0174       sign_hlu ; check for list terminator
0B0F77 19          0001M          add hl,de
0B0F78 B7          0002M          or a
0B0F79 ED 52       0003M          sbc hl,de
0B0F7B CA 93 0F 0B 0175       jp z,@no_match ; if a=0, return error
0B0F7F 23          0176       inc hl ; skip over jp instruction
0B0F80 23          0177       inc hl
0B0F81 DD 17 00    0178       ld de,(ix) ; pointer to the argument string
0B0F84 CD 99 0F 0B 0179       call str_equal ; compare the argument to the dispatch table entry
0B0F88 CA 95 0F 0B 0180       jp z,@match ; if equal, return success
0B0F8C ED 33 03    0181       lea iy,iy+3 ; if not equal, bump iy to next dispatch table entry
0B0F8F C3 74 0F 0B 0182       jp @loop ; and loop
0B0F93             0183   @no_match:
0B0F93 3C          0184       inc a ; no match so return a=1 and zero flag reset
0B0F94 C9          0185       ret
0B0F95             0186   @match:
0B0F95 FD 37 00    0187       ld iy,(iy) ; get the function pointer
0B0F98 C9          0188       ret ; return a=0 and zero flag set
0B0F99             0189   
0B0F99             0190   ; compare two zero-terminated strings for equality, case-sensitive
0B0F99             0191   ; hl: pointer to first string, de: pointer to second string
0B0F99             0192   ; returns: z if equal, nz if not equal
0B0F99             0193   ; destroys: a, hl, de
0B0F99             0194   str_equal:
0B0F99 1A          0195       ld a,(de) ; get the first character
0B0F9A BE          0196       cp (hl) ; compare to the second character
0B0F9B C0          0197       ret nz ; if not equal, return
0B0F9C B7          0198       or a
0B0F9D C8          0199       ret z ; if equal and zero, return
0B0F9E 23          0200       inc hl ; next character
0B0F9F 13          0201       inc de
0B0FA0 C3 99 0F 0B 0202       jp str_equal ; loop until end of string
0B0FA4             0203   
0B0FA4             0204   ; === BOILERPLATE MOSLET CODE ===
0B0FA4             0205   ; Parse the parameter string into a C array
0B0FA4             0206   ; Parameters
0B0FA4             0207   ; - HL: Address of parameter string
0B0FA4             0208   ; - IX: Address for array pointer storage
0B0FA4             0209   ; Returns:
0B0FA4             0210   ; - C: Number of parameters parsed
0B0FA4             0211   ;
0B0FA4 01 34 00 0B 0212   _parse_params: LD BC, _exec_name
0B0FA8 DD 0F 00    0213       LD (IX+0), BC ; ARGV[0] = the executable name
0B0FAB ED 32 03    0214       LEA IX, IX+3
0B0FAE CD E6 0F 0B 0215       CALL _skip_spaces ; Skip HL past any leading spaces
0B0FB2             0216   ;
0B0FB2 01 01 00 00 0217       LD BC, 1 ; C: ARGC = 1 - also clears out top 16 bits of BCU
0B0FB6 06 0F       0218       LD B, argv_ptrs_max - 1 ; B: Maximum number of argv_ptrs
0B0FB8             0219   ;
0B0FB8             0220   _parse_params_1:
0B0FB8 C5          0221       PUSH BC ; Stack ARGC
0B0FB9 E5          0222       PUSH HL ; Stack start address of token
0B0FBA CD D7 0F 0B 0223       CALL _get_token ; Get the next token
0B0FBE 79          0224       LD A, C ; A: Length of the token in characters
0B0FBF D1          0225       POP DE ; Start address of token (was in HL)
0B0FC0 C1          0226       POP BC ; ARGC
0B0FC1 B7          0227       OR A ; Check for A=0 (no token found) OR at end of string
0B0FC2 C8          0228       RET Z
0B0FC3             0229   ;
0B0FC3 DD 1F 00    0230       LD (IX+0), DE ; Store the pointer to the token
0B0FC6 E5          0231       PUSH HL ; DE=HL
0B0FC7 D1          0232       POP DE
0B0FC8 CD E6 0F 0B 0233       CALL _skip_spaces ; And skip HL past any spaces onto the next character
0B0FCC AF          0234       XOR A
0B0FCD 12          0235       LD (DE), A ; Zero-terminate the token
0B0FCE ED 32 03    0236       LEA IX, IX+3 ; Advance to next pointer position
0B0FD1 0C          0237       INC C ; Increment ARGC
0B0FD2 79          0238       LD A, C ; Check for C >= A
0B0FD3 B8          0239       CP B
0B0FD4 38 E2       0240       JR C, _parse_params_1 ; And loop
0B0FD6 C9          0241       RET
0B0FD7             0242   
0B0FD7             0243   ; Get the next token
0B0FD7             0244   ; Parameters:
0B0FD7             0245   ; - HL: Address of parameter string
0B0FD7             0246   ; Returns:
0B0FD7             0247   ; - HL: Address of first character after token
0B0FD7             0248   ; - C: Length of token (in characters)
0B0FD7             0249   ;
0B0FD7 0E 00       0250   _get_token: LD C, 0 ; Initialise length
0B0FD9 7E          0251   @@: LD A, (HL) ; Get the character from the parameter string
0B0FDA B7          0252       OR A ; Exit if 0 (end of parameter string in MOS)
0B0FDB C8          0253       RET Z
0B0FDC FE 0D       0254       CP 13 ; Exit if CR (end of parameter string in BBC BASIC)
0B0FDE C8          0255       RET Z
0B0FDF FE 20       0256       CP ' ' ; Exit if space (end of token)
0B0FE1 C8          0257       RET Z
0B0FE2 23          0258       INC HL ; Advance to next character
0B0FE3 0C          0259       INC C ; Increment length
0B0FE4 18 F3       0260       JR @B
0B0FE6             0261   
0B0FE6             0262   ; Skip spaces in the parameter string
0B0FE6             0263   ; Parameters:
0B0FE6             0264   ; - HL: Address of parameter string
0B0FE6             0265   ; Returns:
0B0FE6             0266   ; - HL: Address of next none-space character
0B0FE6             0267   ; F: Z if at end of string, otherwise NZ if there are more tokens to be parsed
0B0FE6             0268   ;
0B0FE6 7E          0269   _skip_spaces: LD A, (HL) ; Get the character from the parameter string
0B0FE7 FE 20       0270       CP ' ' ; Exit if not space
0B0FE9 C0          0271       RET NZ
0B0FEA 23          0272       INC HL ; Advance to next character
0B0FEB 18 F9       0273       JR _skip_spaces ; Increment length
