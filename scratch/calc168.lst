PC     Output      Line
040000             0001    ASSUME ADL = 1
040000             0002       ORG 0x0B0000 ; Is a moslet
0B0000             0003       ; include "mos_api.inc"
0B0000 C3 45 00 0B 0004       JP _start
0B0004             0005   
0B0004             0006   ; Storage for the argv array pointers
0B0004             0007   min_args: equ 1
0B0004             0008   argv_ptrs_max: EQU 16 ; Maximum number of arguments allowed in argv
0B0004 00 00 00 00 0009   argv_ptrs: BLKP argv_ptrs_max, 0
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0B0034             0010   
0B0034             0011   _exec_name:
0B0034 63 61 6C 63 0012       ASCIZ "calc168" ; The executable name, only used in argv
       31 36 38 00 
0B003C FF FF FF FF 0013       ALIGN 64
0B0040 4D 4F 53    0014       DB "MOS" ; Flag for MOS - to confirm this is a valid MOS command
0B0043 00          0015       DB 00h ; MOS header version 0
0B0044 01          0016       DB 01h ; Flag for run mode (0: Z80, 1: ADL)
0B0045             0017   
0B0045             0018   _start:
0B0045 F5          0019       PUSH AF ; Preserve the registers
0B0046 C5          0020       PUSH BC
0B0047 D5          0021       PUSH DE
0B0048 DD E5       0022       PUSH IX
0B004A FD E5       0023       PUSH IY
0B004C ED 6E       0024       LD A, MB ; Save MB
0B004E F5          0025       PUSH AF
0B004F AF          0026       XOR A
0B0050 ED 6D       0027       LD MB, A ; Clear to zero so MOS API calls know how to use 24-bit addresses.
0B0052 DD 21 04 00 0028       LD IX, argv_ptrs ; The argv array pointer address
       0B          
0B0057 DD E5       0029       PUSH IX
0B0059 CD 8E 0F 0B 0030       CALL _parse_params ; Parse the parameters
0B005D DD E1       0031       POP IX ; IX: argv
0B005F 06 00       0032       LD B, 0 ; C: argc
0B0061             0033   
0B0061 CD A2 0E 0B 0034       CALL main ; Start user code
0B0065             0035   
0B0065 F1          0036       POP AF
0B0066 ED 6D       0037       LD MB, A
0B0068 FD E1       0038       POP IY ; Restore registers
0B006A DD E1       0039       POP IX
0B006C D1          0040       POP DE
0B006D C1          0041       POP BC
0B006E F1          0042       POP AF
0B006F C9          0043       RET
0B0070             0044   
0B0070             0045   _main_end_error:
0B0070 CD 05 0B 0B 0046       call printInline
0B0074 41 6E 20 65 0047       asciz "An error occurred!\r\n"
       72 72 6F 72 
       20 6F 63 63 
       75 72 72 65 
       64 21 0D 0A 
       00          
0B0089 21 13 00 00 0048       ld hl,19 ; return error code 19
0B008D C9          0049       ret
0B008E             0050   
0B008E             0051   _main_end_ok:
0B008E CD 05 0B 0B 0052       call printInline
0B0092 0D 0A 0D 0A 0053       asciz "\r\n\r\n"
       00          
0B0097 21 00 00 00 0054       ld hl,0 ; return 0 for success
0B009B C9          0055       ret
0B009C             0056   
0B009C             0057   ;--- APPLICATION INCLUDES ---
0B009C             0058       include "fixed168.inc"
0B009C             0001*  ; multiply HL by 256
0B009C             0002*  ; inputs: HL
0B009C             0003*  ; outputs: HL*256
0B009C             0004*  ; destroys: flags
0B009C             0005*      MACRO hlu_mul256
0B009C             0006*          add hl,hl ; * 2
0B009C             0007*          add hl,hl ; * 4
0B009C             0008*          add hl,hl ; * 8
0B009C             0009*          add hl,hl ; * 16
0B009C             0010*          add hl,hl ; * 32
0B009C             0011*          add hl,hl ; * 64
0B009C             0012*          add hl,hl ; * 128
0B009C             0013*          add hl,hl ; * 256
0B009C             0014*      ENDMACRO
0B009C             0015*  
0B009C             0016*  ; test the sign of HL
0B009C             0017*  ; inputs: HL obviously
0B009C             0018*  ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
0B009C             0019*  ; destroys: flags
0B009C             0020*      MACRO sign_hlu
0B009C             0021*          add hl,de
0B009C             0022*          or a
0B009C             0023*          sbc hl,de
0B009C             0024*      ENDMACRO
0B009C             0025*  
0B009C             0026*  ; hlu signed division by 256
0B009C             0027*  ; returns: hlu / 256
0B009C             0028*  ; destroys: af
0B009C             0029*  hlu_sdiv256:
0B009C AF          0030*      xor a ; assume hl is positive
0B009D 22 B3 00 0B 0031*      ld (@buffer),hl
0B00A1             0032*      sign_hlu
0B00A1 19          0001*M         add hl,de
0B00A2 B7          0002*M         or a
0B00A3 ED 52       0003*M         sbc hl,de
0B00A5 F2 AA 00 0B 0033*      jp p,@hl_pos
0B00A9 3D          0034*      dec a
0B00AA             0035*  @hl_pos:
0B00AA 32 B6 00 0B 0036*      ld (@buffer+3),a
0B00AE 2A B4 00 0B 0037*      ld hl,(@buffer+1)
0B00B2 C9          0038*      ret
0B00B3 00 00 00 00 0039*  @buffer: blkb 4,0
0B00B7             0040*  
0B00B7             0041*  ; hlu 1 byte right shift, unsigned
0B00B7             0042*  ; returns: hlu / 256
0B00B7             0043*  hlu_udiv256:
0B00B7 22 C0 00 0B 0044*  	ld (@buffer),hl
0B00BB 2A C1 00 0B 0045*  	ld hl,(@buffer+1)
0B00BF C9          0046*  	ret
0B00C0 00 00 00 00 0047*  @buffer: blkb 4,0
0B00C4             0048*  
0B00C4             0049*  ; absolute value of hlu
0B00C4             0050*  ; returns: abs(hlu), flags set according to the incoming sign of hlu:
0B00C4             0051*  ;         s1,z0,pv0,n1,c0 if hlu was negative
0B00C4             0052*  ;         s0,z1,pv0,n1,c0 if hlu was zero
0B00C4             0053*  ;         s0,z0,pv0,n1,c0 if hlu was positive
0B00C4             0054*  ; destroys: a
0B00C4             0055*  hlu_abs:
0B00C4 19          0056*      add hl,de
0B00C5 B7          0057*      or a
0B00C6 ED 52       0058*      sbc hl,de
0B00C8 FA CD 00 0B 0059*      jp m,@is_neg
0B00CC C9          0060*      ret         ; hlu is positive or zero so we're done
0B00CD             0061*  @is_neg:
0B00CD F5          0062*      push af     ; otherwise, save current flags for return
0B00CE CD D4 00 0B 0063*      call neg_hlu ; negate hlu
0B00D2 F1          0064*      pop af      ; get back flags
0B00D3 C9          0065*      ret
0B00D4             0066*  
0B00D4             0067*  ; flip the sign of hlu
0B00D4             0068*  ; inputs: hlu
0B00D4             0069*  ; returns: 0-hlu, flags set appropriately for the result:
0B00D4             0070*  ;         s1,z0,pv0,n1,c1 if result is negative
0B00D4             0071*  ;         s0,z1,pv0,n1,c0 if result is zero
0B00D4             0072*  ;         s0,z0,pv0,n1,c1 if result is positive
0B00D4             0073*  ; destroys a
0B00D4             0074*  neg_hlu:
0B00D4 D5          0075*      push de     ; save de
0B00D5 EB          0076*      ex de,hl    ; put hl into de
0B00D6 21 00 00 00 0077*      ld hl,0     ; clear hl
0B00DA AF          0078*      xor a       ; clear carry
0B00DB ED 52       0079*      sbc hl,de   ; 0-hlu = -hlu
0B00DD D1          0080*      pop de      ; get de back
0B00DE C9          0081*      ret         ; easy peasy
0B00DF             0082*  
0B00DF             0083*      ; include "fixed24.inc"
0B00DF             0084*  
0B00DF             0085*  ; multiply a signed 24-bit number by an unsigned 8-bit number giving a signed 24-bit result
0B00DF             0086*  ; uses EZ80 MLT instruction for speed
0B00DF             0087*  ; operation: UHL * A --> UHL
0B00DF             0088*  ; destroys: AF, HL
0B00DF             0089*  smul24x8:
0B00DF             0090*  ; make hl positive and store sign flag
0B00DF CD C4 00 0B 0091*  	call hlu_abs
0B00E3 F5          0092*  	push af
0B00E4             0093*  ; do the division
0B00E4 CD EF 00 0B 0094*      call mul24x8 ; hl = product
0B00E8             0095*  ; adjust sign of result
0B00E8 F1          0096*  	pop af ; sign de
0B00E9 F0          0097*  	ret p ; hl was positive, nothing to do
0B00EA CD D4 00 0B 0098*  	call neg_hlu ; result is negative
0B00EE C9          0099*  	ret
0B00EF             0100*  
0B00EF             0101*  ; unsigned multiplication of a 24-bit and 8-bit number giving a 32-bit result
0B00EF             0102*  ; uses EZ80 MLT instruction for speed
0B00EF             0103*  ; operation: UHL * A --> AUHL
0B00EF             0104*  ; destroys: AF, HL
0B00EF             0105*  mul24x8:
0B00EF D5          0106*  	push de ; preserve de
0B00F0             0107*  ; low byte
0B00F0 5D          0108*  	ld e,l
0B00F1 57          0109*  	ld d,a
0B00F2 ED 5C       0110*  	mlt de
0B00F4 6B          0111*  	ld l,e ; product low byte
0B00F5 08          0112*  	ex af,af' ; save multiplier
0B00F6 7A          0113*  	ld a,d ; carry
0B00F7 08          0114*  	ex af,af' ; save carry, restore multiplier
0B00F8             0115*  ; high byte
0B00F8 5C          0116*  	ld e,h
0B00F9 57          0117*  	ld d,a
0B00FA ED 5C       0118*  	mlt de
0B00FC 08          0119*  	ex af,af' ; save multiplier, restore carry
0B00FD 83          0120*  	add a,e ; add carry
0B00FE 67          0121*  	ld h,a ; product middle byte
0B00FF 7A          0122*  	ld a,d ; carry
0B0100 08          0123*  	ex af,af' ; save carry, restore multiplier
0B0101             0124*  ; upper byte
0B0101 22 1C 01 0B 0125*      ld (@scratch),hl ; 7 cycles
0B0105 5F          0126*  	ld e,a
0B0106 3A 1E 01 0B 0127*  	ld a,(@scratch+2)
0B010A 57          0128*  	ld d,a
0B010B ED 5C       0129*  	mlt de
0B010D 08          0130*  	ex af,af' ; restore carry
0B010E 8B          0131*  	adc a,e ; add carry
0B010F 32 1E 01 0B 0132*      ld (@scratch+2),a ; 5 cycles
0B0113 2A 1C 01 0B 0133*      ld hl,(@scratch) ; 7 cycles
0B0117             0134*  ; highest byte
0B0117 3E 00       0135*  	ld a,0 ; preserve carry flag
0B0119 8A          0136*  	adc a,d ; product highest byte
0B011A D1          0137*  	pop de ; restore de
0B011B C9          0138*  	ret
0B011C             0139*  @scratch: ds 3
0B011F             0140*  
0B011F 00 00 00 00 0141*  mul24out: blkb 6,0
       00 00       
0B0125             0142*  
0B0125             0143*  ; unsigned multiplication of two 24-bit numbers giving a 48-bit result
0B0125             0144*  ; operation: UHL * UDE --> mul24out
0B0125             0145*  mul24:
0B0125 DD E5       0146*  	push ix ; preserve
0B0127             0147*  ; point to output buffer and clear it
0B0127 DD 21 1F 01 0148*  	ld ix,mul24out
       0B          
0B012C C5          0149*  	push bc
0B012D 01 00 00 00 0150*  	ld bc,0
0B0131 DD 0F 00    0151*  	ld (ix),bc
0B0134 DD 0F 03    0152*  	ld (ix+3),bc
0B0137 C1          0153*  	pop bc
0B0138             0154*  ; STEP 1: UHL * E
0B0138 7B          0155*  	ld a,e
0B0139 E5          0156*  	push hl
0B013A CD EF 00 0B 0157*  	call mul24x8
0B013E DD 2F 00    0158*  	ld (ix+0),hl
0B0141 DD 77 03    0159*  	ld (ix+3),a
0B0144             0160*  ; STEP 2: UHL * D
0B0144 E1          0161*  	pop hl
0B0145 E5          0162*  	push hl
0B0146 7A          0163*  	ld a,d
0B0147 CD EF 00 0B 0164*  	call mul24x8
0B014B CD 64 01 0B 0165*  	call @accumulate
0B014F             0166*  ; STEP 3: UHL * DEU
0B014F E1          0167*  	pop hl
0B0150 ED 53 94 01 0168*  	ld (@de),de
       0B          
0B0155 3A 96 01 0B 0169*  	ld a,(@de+2)
0B0159 CD EF 00 0B 0170*  	call mul24x8
0B015D CD 64 01 0B 0171*  	call @accumulate
0B0161             0172*  ; all done
0B0161 DD E1       0173*  	pop ix ; restore
0B0163 C9          0174*  	ret
0B0164             0175*  @accumulate:
0B0164 DD 23       0176*  	inc ix
0B0166             0177*  ; highest byte of product to carry
0B0166 DD 77 03    0178*  	ld (ix+3),a
0B0169             0179*  ; low byte of product
0B0169 7D          0180*  	ld a,l
0B016A DD 86 00    0181*  	add a,(ix+0)
0B016D DD 77 00    0182*  	ld (ix+0),a
0B0170             0183*  ; high byte of product
0B0170 7C          0184*  	ld a,h
0B0171 DD 8E 01    0185*  	adc a,(ix+1)
0B0174 DD 77 01    0186*  	ld (ix+1),a
0B0177             0187*  ; uppper byte of product
0B0177 22 91 01 0B 0188*  	ld (@hl),hl
0B017B 3A 93 01 0B 0189*  	ld a,(@hl+2)
0B017F DD 8E 02    0190*  	adc a,(ix+2)
0B0182 DD 77 02    0191*  	ld (ix+2),a
0B0185             0192*  ; carry
0B0185 3E 00       0193*  	ld a,0 ; preserve flags
0B0187 DD 8E 03    0194*  	adc a,(ix+3)
0B018A DD 77 03    0195*  	ld (ix+3),a
0B018D C9          0196*  	ret
0B018E             0197*  
0B018E 00 00 00    0198*  @ix: dl 0
0B0191 00 00 00    0199*  @hl: dl 0
0B0194 00 00 00    0200*  @de: dl 0
0B0197             0201*  
0B0197             0202*  ; UHL * UDE --> UHL (unsigned)
0B0197             0203*  umul24:
0B0197 CD 25 01 0B 0204*  	call mul24
0B019B 2A 1F 01 0B 0205*  	ld hl,(mul24out)
0B019F C9          0206*  	ret
0B01A0             0207*  
0B01A0             0208*  ; UH.L = UH.L*UD.E (unsigned)
0B01A0             0209*  umul168:
0B01A0 CD 25 01 0B 0210*  	call mul24
0B01A4 2A 20 01 0B 0211*  	ld hl,(mul24out+1)
0B01A8 C9          0212*  	ret
0B01A9             0213*  
0B01A9             0214*  ; UH.L * UD.E --> UH.L (signed)
0B01A9             0215*  smul168:
0B01A9             0216*  ; make everything positive and store sign flags
0B01A9 CD C4 00 0B 0217*  	call hlu_abs
0B01AD F5          0218*  	push af
0B01AE EB          0219*  	ex de,hl
0B01AF CD C4 00 0B 0220*  	call hlu_abs
0B01B3 EB          0221*  	ex de,hl
0B01B4 F5          0222*  	push af
0B01B5             0223*  ; do the division
0B01B5 CD A0 01 0B 0224*      call umul168 ; hl = product
0B01B9             0225*  ; adjust sign of result
0B01B9 F1          0226*  	pop af ; sign de
0B01BA FA C5 01 0B 0227*  	jp m,@de_neg
0B01BE F1          0228*  	pop af ; sign hl
0B01BF F0          0229*  	ret p ; both positive, nothing to do
0B01C0             0230*  @hl_neg:
0B01C0 CD D4 00 0B 0231*      call neg_hlu ; de pos, hl neg, result is negative
0B01C4 C9          0232*      ret
0B01C5             0233*  @de_neg:
0B01C5 F1          0234*  	pop af
0B01C6 F8          0235*  	ret m ; both negative, nothing to do
0B01C7 CD D4 00 0B 0236*  	call neg_hlu ; result is negative
0B01CB C9          0237*  	ret
0B01CC             0238*  
0B01CC             0239*  ; UH.L / UD.E --> UD.E rem UHL (unsigned)
0B01CC             0240*  ; perform unsigned division of 16.8 fixed place values
0B01CC             0241*  ; with an unsigned 16.8 fixed place result and 24-bit remainder
0B01CC             0242*  udiv168:
0B01CC             0243*  ; back up divisor
0B01CC ED 53 03 02 0244*  	ld (@ude),de
       0B          
0B01D1             0245*  ; get the 16-bit integer part of the quotient
0B01D1 CD 34 02 0B 0246*      call udiv24 ; de = quotient, hl = remainder
0B01D5             0247*  ; load quotient to upper three bytes of output
0B01D5 ED 53 0A 02 0248*      ld (div168_out+1),de
       0B          
0B01DA             0249*  @div256:
0B01DA             0250*  ; multiply remainder by 256
0B01DA             0251*  	hlu_mul256
0B01DA 29          0001*M         add hl,hl ; * 2
0B01DB 29          0002*M         add hl,hl ; * 4
0B01DC 29          0003*M         add hl,hl ; * 8
0B01DD 29          0004*M         add hl,hl ; * 16
0B01DE 29          0005*M         add hl,hl ; * 32
0B01DF 29          0006*M         add hl,hl ; * 64
0B01E0 29          0007*M         add hl,hl ; * 128
0B01E1 29          0008*M         add hl,hl ; * 256
0B01E2             0252*  ; skip fractional computation if remainder is zero
0B01E2             0253*      sign_hlu
0B01E2 19          0001*M         add hl,de
0B01E3 B7          0002*M         or a
0B01E4 ED 52       0003*M         sbc hl,de
0B01E6 20 03       0254*      jr nz,@div_frac
0B01E8 AF          0255*      xor a
0B01E9 18 0A       0256*      jr @write_frac
0B01EB             0257*  ; now divide the shifted remainder by the divisor
0B01EB             0258*  @div_frac:
0B01EB ED 5B 03 02 0259*  	ld de,(@ude) ; get back divisor
       0B          
0B01F0 CD 34 02 0B 0260*      call udiv24 ; de = quotient, hl = remainder
0B01F4             0261*  ; load low byte of quotient to low byte of output
0B01F4 7B          0262*      ld a,e
0B01F5             0263*  @write_frac:
0B01F5 32 09 02 0B 0264*      ld (div168_out),a
0B01F9             0265*  ; load de with return value
0B01F9 ED 5B 09 02 0266*      ld de,(div168_out)
       0B          
0B01FE             0267*  ; load a with any overflow
0B01FE 3A 0C 02 0B 0268*      ld a,(div168_out+3)
0B0202 C9          0269*      ret ; ud.e is the 16.8 result
0B0203             0270*  @ude: ds 6
0B0209             0271*  div168_out: ds 4 ; the extra byte is for overflow
0B020D             0272*  
0B020D             0273*  ; UH.L / UD.E --> UD.E (signed) rem UHL (unsigned)
0B020D             0274*  ; perform signed division of 16.8 fixed place values
0B020D             0275*  ; with a signed 16.8 fixed place result and unsigned 24-bit remainder
0B020D             0276*  sdiv168:
0B020D             0277*  ; make everything positive and store sign flags
0B020D CD C4 00 0B 0278*  	call hlu_abs
0B0211 F5          0279*  	push af
0B0212 EB          0280*  	ex de,hl
0B0213 CD C4 00 0B 0281*  	call hlu_abs
0B0217 EB          0282*  	ex de,hl
0B0218 F5          0283*  	push af
0B0219             0284*  ; do the division
0B0219 CD CC 01 0B 0285*      call udiv168 ; de = quotient, hl = remainder
0B021D             0286*  ; adjust sign of result
0B021D F1          0287*  	pop af ; sign de
0B021E FA 2B 02 0B 0288*  	jp m,@de_neg
0B0222 F1          0289*  	pop af ; sign hl
0B0223 F0          0290*  	ret p ; both positive, nothing to do
0B0224             0291*  @hl_neg:
0B0224 EB          0292*      ex de,hl ; hl = quotient, de = remainder
0B0225 CD D4 00 0B 0293*      call neg_hlu ; de pos, hl neg, result is negative
0B0229 EB          0294*      ex de,hl ; de = negated quotient, hl = remainder
0B022A C9          0295*      ret
0B022B             0296*  @de_neg:
0B022B F1          0297*  	pop af
0B022C F8          0298*  	ret m ; both negative, nothing to do
0B022D EB          0299*      ex de,hl ; hl = quotient, de = remainder
0B022E CD D4 00 0B 0300*  	call neg_hlu ; result is negative
0B0232 EB          0301*      ex de,hl ; de = negated quotient, hl = remainder
0B0233 C9          0302*  	ret
0B0234             0303*  
0B0234             0304*  ;------------------------------------------------------------------------
0B0234             0305*  ;  arith24.asm
0B0234             0306*  ;  24-bit ez80 arithmetic routines
0B0234             0307*  ;  Copyright (c) Shawn Sijnstra 2024
0B0234             0308*  ;  MIT license
0B0234             0309*  ;
0B0234             0310*  ;  This library was created as a tool to help make ez80
0B0234             0311*  ;  24-bit native assembly routines for simple mathematical problems
0B0234             0312*  ;  more widely available.
0B0234             0313*  ;
0B0234             0314*  ;------------------------------------------------------------------------
0B0234             0315*  ;
0B0234             0316*  ;------------------------------------------------------------------------
0B0234             0317*  ; udiv24
0B0234             0318*  ; Unsigned 24-bit division
0B0234             0319*  ; Divides HLU by DEU. Gives result in DEU (and BC), remainder in HLU.
0B0234             0320*  ;
0B0234             0321*  ; Uses AF BC DE HL
0B0234             0322*  ; Uses Restoring Division algorithm
0B0234             0323*  ;------------------------------------------------------------------------
0B0234             0324*  
0B0234             0325*  udiv24:
0B0234 E5          0326*  	push	hl
0B0235 C1          0327*  	pop		bc	;move dividend to BCU
0B0236 21 00 00 00 0328*  	ld		hl,0	;result
0B023A A7          0329*  	and		a
0B023B ED 52       0330*  	sbc		hl,de	;test for div by 0
0B023D C8          0331*  	ret		z		;it's zero, carry flag is clear
0B023E 19          0332*  	add		hl,de	;HL is 0 again
0B023F 3E 18       0333*  	ld		a,24	;number of loops through.
0B0241             0334*  udiv1:
0B0241 C5          0335*  	push	bc	;complicated way of doing this because of lack of access to top bits
0B0242 E3          0336*  	ex		(sp),hl
0B0243 37          0337*  	scf
0B0244 ED 6A       0338*  	adc	hl,hl
0B0246 E3          0339*  	ex	(sp),hl
0B0247 C1          0340*  	pop	bc		;we now have bc = (bc * 2) + 1
0B0248             0341*  
0B0248 ED 6A       0342*  	adc	hl,hl
0B024A A7          0343*  	and	a		;is this the bug
0B024B ED 52       0344*  	sbc	hl,de
0B024D 30 02       0345*  	jr	nc,udiv2
0B024F 19          0346*  	add	hl,de
0B0250             0347*  ;	dec	c
0B0250 0B          0348*  	dec	bc
0B0251             0349*  udiv2:
0B0251 3D          0350*  	dec	a
0B0252 20 ED       0351*  	jr	nz,udiv1
0B0254 37          0352*  	scf		;flag used for div0 error
0B0255 C5          0353*  	push	bc
0B0256 D1          0354*  	pop		de	;remainder
0B0257 C9          0355*  	ret
0B0258             0356*  
0B0258             0357*  ;------------------------------------------------------------------------
0B0258             0358*  ;  END 24-bit ez80 arithmetic routines by Shawn Sijnstra
0B0258             0359*  ;------------------------------------------------------------------------
0B0258             0360*  
0B0258             0361*  
0B0258             0362*      ; include "trig24fast.inc"
0B0258             0363*  
0B0258             0364*  
0B0258             0365*  ; convert signed angles from a 360 to 256 degree circle
0B0258             0366*  ; inputs: uh.l is the angle360 in 16.8 fixed format
0B0258             0367*  ; outputs: uh.l is the angle256 in 16.8 fixed format
0B0258             0368*  ; destroys: TODO
0B0258             0369*  deg_360_to_256:
0B0258 D5          0370*  	push de ; preserve de
0B0259             0371*  ; make angle positive and store sign flag
0B0259 CD C4 00 0B 0372*  	call hlu_abs
0B025D F5          0373*  	push af
0B025E             0374*  ; multiply by coversion factor of 256/360
0B025E 11 B6 00 00 0375*  	ld de,0x0000B6 ; 0.711
0B0262 CD A0 01 0B 0376*  	call umul168 ; uh.l = uh.l * 0.711
0B0266             0377*  ; restore sign flag and adjust output accordingly
0B0266 F1          0378*  	pop af
0B0267 F2 6F 02 0B 0379*  	jp p,@pos ; positive number
0B026B CD D4 00 0B 0380*  	call neg_hlu
0B026F             0381*  @pos:
0B026F             0382*  ; restore de and return uh.l as the result
0B026F D1          0383*  	pop de
0B0270 C9          0384*  	ret
0B0271             0385*  
0B0271             0386*  ; convert signed angles from a 256 to 360 degree circle
0B0271             0387*  ; inputs: uh.l is the angle256 in 16.8 fixed format
0B0271             0388*  ; outputs: uh.l is the angle360 in 16.8 fixed format
0B0271             0389*  ; destroys: TODO
0B0271             0390*  deg_256_to_360:
0B0271 D5          0391*  	push de ; preserve de
0B0272             0392*  ; make angle positive and store sign flag
0B0272 CD C4 00 0B 0393*  	call hlu_abs
0B0276 F5          0394*  	push af
0B0277             0395*  ; multiply by coversion factor of 360/256
0B0277 11 68 01 00 0396*      ld de,0x000168 ; 1.406
0B027B CD A0 01 0B 0397*  	call umul168 ; uh.l = uh.l * 1.406
0B027F             0398*  ; restore sign flag and adjust output accordingly
0B027F F1          0399*  	pop af
0B0280 F2 88 02 0B 0400*  	jp p,@pos ; positive number
0B0284 CD D4 00 0B 0401*  	call neg_hlu
0B0288             0402*  @pos:
0B0288             0403*  ; restore de and return uh.l as the result
0B0288 D1          0404*  	pop de
0B0289 C9          0405*  	ret
0B028A             0406*  
0B028A             0407*  ; fixed 16.8 routine
0B028A             0408*  ; cos(uh.l) --> uh.l
0B028A             0409*  ; destroys: f, hl
0B028A             0410*  cos168:
0B028A D5          0411*      push de ; preserve de
0B028B             0412*  ; for cos we simply increment the angle by 90 degrees
0B028B             0413*  ; or 0x004000 in 16.8 degrees256
0B028B             0414*  ; which makes it a sin problem
0B028B 11 00 40 00 0415*      ld de,0x004000
0B028F 19          0416*      add hl,de ; modulo 256 happens below
0B0290 D1          0417*      pop de ; restore de
0B0291             0418*  ; fall through to sin168
0B0291             0419*  
0B0291             0420*  ; ---------------------
0B0291             0421*  ; fixed 16.8 routine
0B0291             0422*  ; sin(uh.l) --> uh.l
0B0291             0423*  ; destroys: f, hl
0B0291             0424*  sin168:
0B0291 D5          0425*  	push de
0B0292             0426*  ; handle negative angles appropriately
0B0292 CD C4 00 0B 0427*  	call hlu_abs
0B0296 F2 9F 02 0B 0428*  	jp p,@F
0B029A 11 00 00 FF 0429*  	ld de,-256*256
0B029E 19          0430*  	add hl,de
0B029F             0431*  @@:
0B029F 2E 03       0432*  	ld l,3 ; multiply by 3 to get our lookup index
0B02A1 ED 6C       0433*      mlt hl
0B02A3 11 EF 04 0B 0434*      ld de,sin_lut_168 ; grab the lut address
0B02A7 19          0435*      add hl,de ; bump hl by the index
0B02A8 ED 27       0436*      ld hl,(hl) ; don't try this on a z80!
0B02AA D1          0437*      pop de
0B02AB C9          0438*      ret
0B02AC             0439*  
0B02AC             0440*  ; 16.8 fixed inputs / outputs
0B02AC             0441*  ; takes: uh.l as angle in degrees 256
0B02AC             0442*  ;        ud.e as radius
0B02AC             0443*  ; returns ub.c as dx, ud.e as dy, uh.l as radius
0B02AC             0444*  ;        displacements from origin (0,0)
0B02AC             0445*  ; destroys: everything except indexes
0B02AC             0446*  polar_to_cartesian:
0B02AC             0447*  ; back up input parameters
0B02AC 22 DB 02 0B 0448*      ld (@angle), hl
0B02B0 ED 53 DE 02 0449*      ld (@radius), de
       0B          
0B02B5             0450*  ; compute dx = sin(uh.l) * ud.e
0B02B5 CD 91 02 0B 0451*      call sin168 ; uh.l = sin(uh.l)
0B02B9 ED 5B DE 02 0452*  	ld de,(@radius)
       0B          
0B02BE CD A9 01 0B 0453*  	call smul168 ; uh.l = dx
0B02C2 E5          0454*      push hl
0B02C3             0455*  ; compute dy = -cos(uh.l) * ud.e
0B02C3 2A DB 02 0B 0456*      ld hl,(@angle)
0B02C7 CD 8A 02 0B 0457*      call cos168 ; uh.l = cos(uh.l)
0B02CB ED 5B DE 02 0458*      ld de,(@radius)
       0B          
0B02D0 CD A9 01 0B 0459*      call smul168    ; uh.l = dy
0B02D4 CD D4 00 0B 0460*      call neg_hlu ; invert dy for screen coords convention
0B02D8 EB          0461*      ex de,hl       ; de = dy for output
0B02D9 C1          0462*      pop bc          ; bc = dx for output
0B02DA             0463*  ; and out
0B02DA C9          0464*      ret
0B02DB             0465*  @angle: ds 3
0B02DE             0466*  @radius: ds 3
0B02E1             0467*  
0B02E1             0468*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
0B02E1             0469*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
0B02E1             0470*  ; output: ub.c and ud.e are dx and dy in 16.8 fixed format
0B02E1             0471*  ;         also populates scratch locations dx168 and dy168
0B02E1             0472*  ; destroys: a,hl,bc,de
0B02E1             0473*  dxy168:
0B02E1             0474*  ; compute dx = x1-x0
0B02E1 AF          0475*      xor a ; clear carry
0B02E2 DD E5       0476*      push ix ; move ix to hl via the stack
0B02E4 E1          0477*      pop hl ; hl = x1
0B02E5 ED 42       0478*      sbc hl,bc ; hl = dx
0B02E7 22 FC 02 0B 0479*      ld (dx168),hl ; dx to scratch
0B02EB             0480*  ; compute dy = y1-y0
0B02EB AF          0481*      xor a ; clear carry
0B02EC FD E5       0482*      push iy ; move iy to hl via the stack
0B02EE E1          0483*      pop hl ; hl = y1
0B02EF ED 52       0484*      sbc hl,de ; hl = dy
0B02F1 22 02 03 0B 0485*      ld (dy168),hl ; dy to scratch
0B02F5             0486*  ; populate output registers and return
0B02F5 EB          0487*      ex de,hl        ; ud.e = dy
0B02F6 ED 4B FC 02 0488*      ld bc,(dx168)   ; ub.c = dx
       0B          
0B02FB C9          0489*      ret
0B02FC 00 00 00 00 0490*  dx168: blkb 6,0
       00 00       
0B0302 00 00 00 00 0491*  dy168: blkb 6,0
       00 00       
0B0308             0492*  
0B0308             0493*  ; compute the euclidian distance between two cartesian coordinates
0B0308             0494*  ; using the formula d = sqrt(dx^2+dy^2)
0B0308             0495*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
0B0308             0496*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
0B0308             0497*  ; output; uh.l is the 16.8 fixed format distance
0B0308             0498*  ;         also populates scratch locations dx168 and dy168
0B0308             0499*  ; destroys: a,hl,bc,de
0B0308             0500*  ; NOTE: rounds both deltas down to the nearest integer to avoid overflow when squaring,
0B0308             0501*  ;       thus the result will always be an integer, albeit in 16.8 format
0B0308             0502*  distance168:
0B0308 CD E1 02 0B 0503*  	call dxy168 ; ub.c = dx, ud.e = dy
0B030C             0504*  ; compute dy^2
0B030C EB          0505*  	ex de,hl
0B030D CD C4 00 0B 0506*  	call hlu_abs
0B0311 CD B7 00 0B 0507*  	call hlu_udiv256 ; make integer to avoid overflow
0B0315 E5          0508*  	push hl
0B0316 D1          0509*  	pop de
0B0317 CD 97 01 0B 0510*  	call umul24 ; hl = dy^2
0B031B E5          0511*  	push hl ; save dy^2
0B031C             0512*  ; compute dx^2
0B031C 2A FC 02 0B 0513*  	ld hl,(dx168)
0B0320 CD C4 00 0B 0514*  	call hlu_abs
0B0324 CD B7 00 0B 0515*  	call hlu_udiv256 ; make integer to avoid overflow
0B0328 E5          0516*  	push hl
0B0329 D1          0517*  	pop de
0B032A CD 97 01 0B 0518*  	call umul24 ; hl = dx^2
0B032E             0519*  ; add dx^2 and dy^2
0B032E D1          0520*  	pop de ; de = dy^2 (was hl)
0B032F 19          0521*  	add hl,de ; hl = dx^2 + dy^2
0B0330             0522*  ; compute the square root
0B0330 CD 09 04 0B 0523*  	call sqrt24 ; de = sqrt(dx^2 + dy^2)
0B0334 EB          0524*      ex de,hl ; hl = distance
0B0335             0525*      hlu_mul256 ; convert back to 16.8 fixed
0B0335 29          0001*M         add hl,hl ; * 2
0B0336 29          0002*M         add hl,hl ; * 4
0B0337 29          0003*M         add hl,hl ; * 8
0B0338 29          0004*M         add hl,hl ; * 16
0B0339 29          0005*M         add hl,hl ; * 32
0B033A 29          0006*M         add hl,hl ; * 64
0B033B 29          0007*M         add hl,hl ; * 128
0B033C 29          0008*M         add hl,hl ; * 256
0B033D C9          0526*  	ret
0B033E             0527*  
0B033E             0528*  ; atan2_(ub.c,ud.e) --> uh.l
0B033E             0529*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
0B033E             0530*  ;   whether inputs are integers or fractional doesn't matter
0B033E             0531*  ;   so long as the sign bit of the upper byte is correct
0B033E             0532*  ; output: uh.l is the 16.8 fixed angle in degrees 256
0B033E             0533*  ; angles are COMPASS HEADINGS based on
0B033E             0534*  ; screen coordinate conventions,where the y axis is flipped
0B033E             0535*  ; #E0 315      0       45 #20
0B033E             0536*  ;        -x,-y | +x,-y
0B033E             0537*  ; #C0 270------+------ 90 #40
0B033E             0538*  ;        -x,+y | +x,+y
0B033E             0539*  ; #A0 225   180 #80   135 #60
0B033E             0540*  atan2_168fast:
0B033E             0541*  ; get signs and make everything positive
0B033E             0542*  ; get abs(x) and store its original sign
0B033E C5          0543*      push bc
0B033F E1          0544*      pop hl
0B0340 CD C4 00 0B 0545*      call hlu_abs ; if x was negative this also sets the sign flag
0B0344 E5          0546*      push hl ; store abs(x)
0B0345 C1          0547*      pop bc ; bc = abs(x)
0B0346 F5          0548*      push af ; store sign of x
0B0347             0549*  ; get abs(y) and store its original sign
0B0347 EB          0550*      ex de,hl ; hl = y
0B0348 CD C4 00 0B 0551*      call hlu_abs ; if y was negative this also sets the sign flag
0B034C EB          0552*      ex de,hl ; de = abs(y)
0B034D F5          0553*      push af ; store sign of y
0B034E             0554*  ; if abs(bc) < abs(de),then we do bc/de,otherwise de/bc
0B034E             0555*  ; this ensures that our lookup value is between 0 and 1 inclusive
0B034E AF          0556*      xor a ; clear the carry flag
0B034F D5          0557*      push de
0B0350 E1          0558*      pop hl
0B0351 ED 42       0559*      sbc hl,bc
0B0353 F5          0560*      push af ; save sign of de - bc
0B0354 F2 5D 03 0B 0561*      jp p,@1 ; bc <= de, so we skip ahead
0B0358             0562*  ; otherwise we swap bc and de
0B0358 C5          0563*      push bc
0B0359 E1          0564*      pop hl
0B035A EB          0565*      ex de,hl
0B035B E5          0566*      push hl
0B035C C1          0567*      pop bc
0B035D             0568*  @1:
0B035D             0569*  ; now we're ready to snag our preliminary result
0B035D C5          0570*  	push bc
0B035E E1          0571*  	pop hl
0B035F CD CD 03 0B 0572*      call atan_168fast ; uh.l comes back with prelim result
0B0363             0573*  ; now we adjust uh.l based on sign of de - bc
0B0363 F1          0574*      pop af
0B0364 F2 70 03 0B 0575*      jp p,@2 ; bc <= de,so we skip ahead
0B0368 EB          0576*      ex de,hl
0B0369 21 00 40 00 0577*      ld hl,0x004000 ; 90 degrees
0B036D AF          0578*      xor a ; clear the carry flag
0B036E ED 52       0579*      sbc hl,de ; subtract result from 90 degrees
0B0370             0580*  @2:
0B0370             0581*  ; now the fun part of adjusting the result
0B0370             0582*  ; based on which quadrant (x,y) is in
0B0370             0583*  ; #E0 315      0       45 #20
0B0370             0584*  ;        -x,-y | +x,-y
0B0370             0585*  ; #C0 270------+------ 90 #40
0B0370             0586*  ;        -x,+y | +x,+y
0B0370             0587*  ; #A0 225   180 #80   135 #60
0B0370 F1          0588*      pop af ; sign of y
0B0371 CA AE 03 0B 0589*      jp z,@y_zero
0B0375 F2 8E 03 0B 0590*      jp p,@y_pos
0B0379             0591*  ; y neg,check x
0B0379 F1          0592*      pop af ; sign of x
0B037A CA 88 03 0B 0593*      jp z,@y_neg_x_zero
0B037E F2 8D 03 0B 0594*      jp p,@y_neg_x_pos
0B0382             0595*  ; y neg,x neg
0B0382             0596*  ; angle is 270-360
0B0382             0597*  ; negating the intermediate does the trick
0B0382 CD D4 00 0B 0598*      call neg_hlu
0B0386 18 31       0599*      jr @zero_hlu
0B0388             0600*  
0B0388             0601*  @y_neg_x_zero:
0B0388             0602*  ; y neg,x zero
0B0388             0603*  ; angle is 0
0B0388 21 00 00 00 0604*      ld hl,0
0B038C C9          0605*      ret
0B038D             0606*  @y_neg_x_pos:
0B038D             0607*  ; y neg,x pos
0B038D             0608*  ; angle is 0 to 90
0B038D             0609*  ; so we're good
0B038D C9          0610*      ret
0B038E             0611*  
0B038E             0612*  @y_pos:
0B038E F1          0613*      pop af ; sign of x
0B038F CA 9E 03 0B 0614*      jp z,@y_pos_x_zero
0B0393 F2 A3 03 0B 0615*      jp p,@y_pos_x_pos
0B0397             0616*  ; y pos,x neg
0B0397             0617*  ; angle is 180-270
0B0397             0618*  ; so we add 180 to intermediate
0B0397 11 00 80 00 0619*      ld de,0x008000
0B039B 19          0620*      add hl,de
0B039C 18 1B       0621*      jr @zero_hlu
0B039E             0622*  @y_pos_x_zero:
0B039E             0623*  ; y pos,x zero
0B039E             0624*  ; angle is 180
0B039E 21 00 80 00 0625*      ld hl,0x008000
0B03A2 C9          0626*      ret
0B03A3             0627*  @y_pos_x_pos:
0B03A3             0628*  ; y pos,x pos
0B03A3             0629*  ; angle is 90-180
0B03A3             0630*  ; neg the intermediate and add 180 degrees
0B03A3 CD D4 00 0B 0631*      call neg_hlu
0B03A7 11 00 80 00 0632*      ld de,0x008000
0B03AB 19          0633*      add hl,de
0B03AC 18 0B       0634*      jr @zero_hlu
0B03AE             0635*  
0B03AE             0636*  @y_zero:
0B03AE F1          0637*      pop af ; sign of x
0B03AF FA B4 03 0B 0638*      jp m,@y_zero_x_neg
0B03B3             0639*  ; y zero,x pos
0B03B3             0640*  ; angle is 90,nothing to do
0B03B3 C9          0641*      ret
0B03B4             0642*  @y_zero_x_neg:
0B03B4             0643*  ; y zero ,x neg
0B03B4             0644*  ; angle is 270
0B03B4 21 00 C0 00 0645*      ld hl,0x00C000
0B03B8 C9          0646*      ret
0B03B9             0647*  @zero_hlu:
0B03B9 AF          0648*      xor a
0B03BA 22 C7 03 0B 0649*      ld (@scratch),hl
0B03BE 32 C9 03 0B 0650*      ld (@scratch+2),a
0B03C2 2A C7 03 0B 0651*      ld hl,(@scratch)
0B03C6 C9          0652*      ret
0B03C7             0653*  @scratch: ds 6
0B03CD             0654*  
0B03CD             0655*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
0B03CD             0656*  ; output: uh.l is the 16.8 fixed format angle in degrees 256
0B03CD             0657*  ; destroys: a,hl,bc,de
0B03CD             0658*  ; note: only works for angles from 0 to 32 (45) degrees
0B03CD             0659*  ;   use atan2_168fast (which calls this proc) to handle the full 256 (360) degrees
0B03CD             0660*  atan_168fast:
0B03CD             0661*  ; because we use compass headings instead of geometric angles
0B03CD             0662*  ; we compute dx/dy which is 1/tan(theta) in the maths world
0B03CD             0663*  ; we can do faster unsigned division here because we know dx and dy are positive
0B03CD CD CC 01 0B 0664*  	call udiv168 ; ud.e = dx/dy
0B03D1 EB          0665*  	ex de,hl ; uh.l = dx/dy
0B03D2             0666*  ; test uh.l for 0
0B03D2 19          0667*      add hl,de
0B03D3 B7          0668*      or a
0B03D4 ED 52       0669*      sbc hl,de
0B03D6 28 22       0670*      jr z,@is_zero
0B03D8             0671*  ; test uh.l for 1
0B03D8 AF          0672*      xor a ; clear carry
0B03D9 EB          0673*      ex de,hl
0B03DA 21 00 01 00 0674*      ld hl,0x000100 ; 1 in 16.8 fixed format
0B03DE ED 52       0675*      sbc hl,de
0B03E0 28 13       0676*      jr z,@is_45
0B03E2 EB          0677*  	ex de,hl
0B03E3             0678*  ; no special cases so we move on
0B03E3             0679*  ; l contains the fractional portion of tan(uh.l)
0B03E3             0680*  ; we multiply it by three to get our lookup table index
0B03E3 26 03       0681*      ld h,3
0B03E5 ED 6C       0682*      mlt hl ; gosh that is handy
0B03E7 11 00 00 00 0683*      ld de,0 ; clear deu
0B03EB 54          0684*      ld d,h ; copy hl to de
0B03EC 5D          0685*      ld e,l ; de contains our index
0B03ED 21 F2 07 0B 0686*      ld hl,atan_lut_168 ; grab the lut address
0B03F1 19          0687*      add hl,de ; bump hl by the index
0B03F2 ED 27       0688*      ld hl,(hl) ; don't try this on a z80!
0B03F4 C9          0689*      ret ; and out
0B03F5             0690*  @is_45:
0B03F5 21 00 20 00 0691*      ld hl,0x002000 ; 45 degrees decimal
0B03F9 C9          0692*      ret
0B03FA             0693*  ; for the case tan(0)
0B03FA             0694*  @is_zero:
0B03FA 21 00 00 00 0695*      ld hl,0x000000
0B03FE C9          0696*      ret
0B03FF             0697*  
0B03FF             0698*  ; Expects  ADL mode
0B03FF             0699*  ; Inputs:  UH.L
0B03FF             0700*  ; Outputs: UH.L is the 16.8 square root
0B03FF             0701*  ;          UDE is the integer difference inputHL-DE^2
0B03FF             0702*  sqrt168:
0B03FF CD 09 04 0B 0703*      call sqrt24
0B0403 EB          0704*      ex de,hl
0B0404 29          0705*      add hl,hl
0B0405 29          0706*      add hl,hl
0B0406 29          0707*      add hl,hl
0B0407 29          0708*      add hl,hl
0B0408 C9          0709*      ret
0B0409             0710*  
0B0409             0711*  ; credit: xeda112358
0B0409             0712*  ; https://www.cemetech.net/forum/viewtopic.php?t=11178&postdays=0&postorder=asc&start=0
0B0409             0713*  sqrt24:
0B0409             0714*  ; Expects ADL mode
0B0409             0715*  ; Inputs: HL
0B0409             0716*  ; Outputs: DE is the integer square root
0B0409             0717*  ;  HL is the difference inputHL-DE^2
0B0409             0718*  ;  c flag reset
0B0409 01 00 00 00 0719*  	ld bc,0 ; clear bcu
0B040D 11 00 00 00 0720*  	ld de,0 ; clear deu
0B0411 AF          0721*      xor a
0B0412 45          0722*      ld b,l
0B0413 C5          0723*      push bc
0B0414 47          0724*      ld b,a
0B0415 6F          0725*      ld l,a
0B0416             0726*  ; Iteration 1
0B0416 29          0727*      add hl,hl
0B0417 CB 11       0728*      rl c
0B0419 29          0729*      add hl,hl
0B041A CB 11       0730*      rl c
0B041C 91          0731*      sub c
0B041D 30 04       0732*      jr nc,$+6
0B041F 1C          0733*      inc e
0B0420 1C          0734*      inc e
0B0421 2F          0735*      cpl
0B0422 4F          0736*      ld c,a
0B0423             0737*  ; Iteration 2
0B0423 29          0738*      add hl,hl
0B0424 CB 11       0739*      rl c
0B0426 29          0740*      add hl,hl
0B0427 CB 11       0741*      rl c
0B0429 CB 13       0742*      rl e
0B042B 7B          0743*      ld a,e
0B042C 91          0744*      sub c
0B042D 30 04       0745*      jr nc,$+6
0B042F 1C          0746*      inc e
0B0430 1C          0747*      inc e
0B0431 2F          0748*      cpl
0B0432 4F          0749*      ld c,a
0B0433             0750*  ; Iteration 3
0B0433 29          0751*      add hl,hl
0B0434 CB 11       0752*      rl c
0B0436 29          0753*      add hl,hl
0B0437 CB 11       0754*      rl c
0B0439 CB 13       0755*      rl e
0B043B 7B          0756*      ld a,e
0B043C 91          0757*      sub c
0B043D 30 04       0758*      jr nc,$+6
0B043F 1C          0759*      inc e
0B0440 1C          0760*      inc e
0B0441 2F          0761*      cpl
0B0442 4F          0762*      ld c,a
0B0443             0763*  ; Iteration 4
0B0443 29          0764*      add hl,hl
0B0444 CB 11       0765*      rl c
0B0446 29          0766*      add hl,hl
0B0447 CB 11       0767*      rl c
0B0449 CB 13       0768*      rl e
0B044B 7B          0769*      ld a,e
0B044C 91          0770*      sub c
0B044D 30 04       0771*      jr nc,$+6
0B044F 1C          0772*      inc e
0B0450 1C          0773*      inc e
0B0451 2F          0774*      cpl
0B0452 4F          0775*      ld c,a
0B0453             0776*  ; Iteration 5
0B0453 29          0777*      add hl,hl
0B0454 CB 11       0778*      rl c
0B0456 29          0779*      add hl,hl
0B0457 CB 11       0780*      rl c
0B0459 CB 13       0781*      rl e
0B045B 7B          0782*      ld a,e
0B045C 91          0783*      sub c
0B045D 30 04       0784*      jr nc,$+6
0B045F 1C          0785*      inc e
0B0460 1C          0786*      inc e
0B0461 2F          0787*      cpl
0B0462 4F          0788*      ld c,a
0B0463             0789*  ; Iteration 6
0B0463 29          0790*      add hl,hl
0B0464 CB 11       0791*      rl c
0B0466 29          0792*      add hl,hl
0B0467 CB 11       0793*      rl c
0B0469 CB 13       0794*      rl e
0B046B 7B          0795*      ld a,e
0B046C 91          0796*      sub c
0B046D 30 04       0797*      jr nc,$+6
0B046F 1C          0798*      inc e
0B0470 1C          0799*      inc e
0B0471 2F          0800*      cpl
0B0472 4F          0801*      ld c,a
0B0473             0802*  ; Iteration 7
0B0473 29          0803*      add hl,hl
0B0474 CB 11       0804*      rl c
0B0476 29          0805*      add hl,hl
0B0477 CB 11       0806*      rl c
0B0479 CB 10       0807*      rl b
0B047B EB          0808*      ex de,hl
0B047C 29          0809*      add hl,hl
0B047D E5          0810*      push hl
0B047E ED 42       0811*      sbc hl,bc
0B0480 30 06       0812*      jr nc,$+8
0B0482 7C          0813*      ld a,h
0B0483 2F          0814*      cpl
0B0484 47          0815*      ld b,a
0B0485 7D          0816*      ld a,l
0B0486 2F          0817*      cpl
0B0487 4F          0818*      ld c,a
0B0488 E1          0819*      pop hl
0B0489 30 02       0820*      jr nc,$+4
0B048B 23          0821*      inc hl
0B048C 23          0822*      inc hl
0B048D EB          0823*      ex de,hl
0B048E             0824*  ; Iteration 8
0B048E 29          0825*      add hl,hl
0B048F 69          0826*      ld l,c
0B0490 60          0827*      ld h,b
0B0491 ED 6A       0828*      adc hl,hl
0B0493 ED 6A       0829*      adc hl,hl
0B0495 EB          0830*      ex de,hl
0B0496 29          0831*      add hl,hl
0B0497 ED 52       0832*      sbc hl,de
0B0499 19          0833*      add hl,de
0B049A EB          0834*      ex de,hl
0B049B 30 04       0835*      jr nc,$+6
0B049D ED 52       0836*      sbc hl,de
0B049F 13          0837*      inc de
0B04A0 13          0838*      inc de
0B04A1             0839*  ; Iteration 9
0B04A1 F1          0840*      pop af
0B04A2 17          0841*      rla
0B04A3 ED 6A       0842*      adc hl,hl
0B04A5 17          0843*      rla
0B04A6 ED 6A       0844*      adc hl,hl
0B04A8 EB          0845*      ex de,hl
0B04A9 29          0846*      add hl,hl
0B04AA ED 52       0847*      sbc hl,de
0B04AC 19          0848*      add hl,de
0B04AD EB          0849*      ex de,hl
0B04AE 30 04       0850*      jr nc,$+6
0B04B0 ED 52       0851*      sbc hl,de
0B04B2 13          0852*      inc de
0B04B3 13          0853*      inc de
0B04B4             0854*  ; Iteration 10
0B04B4 17          0855*      rla
0B04B5 ED 6A       0856*      adc hl,hl
0B04B7 17          0857*      rla
0B04B8 ED 6A       0858*      adc hl,hl
0B04BA EB          0859*      ex de,hl
0B04BB 29          0860*      add hl,hl
0B04BC ED 52       0861*      sbc hl,de
0B04BE 19          0862*      add hl,de
0B04BF EB          0863*      ex de,hl
0B04C0 30 04       0864*      jr nc,$+6
0B04C2 ED 52       0865*      sbc hl,de
0B04C4 13          0866*      inc de
0B04C5 13          0867*      inc de
0B04C6             0868*  ; Iteration 11
0B04C6 17          0869*      rla
0B04C7 ED 6A       0870*      adc hl,hl
0B04C9 17          0871*      rla
0B04CA ED 6A       0872*      adc hl,hl
0B04CC EB          0873*      ex de,hl
0B04CD 29          0874*      add hl,hl
0B04CE ED 52       0875*      sbc hl,de
0B04D0 19          0876*      add hl,de
0B04D1 EB          0877*      ex de,hl
0B04D2 30 04       0878*      jr nc,$+6
0B04D4 ED 52       0879*      sbc hl,de
0B04D6 13          0880*      inc de
0B04D7 13          0881*      inc de
0B04D8             0882*  ; Iteration 12
0B04D8 17          0883*      rla
0B04D9 ED 6A       0884*      adc hl,hl
0B04DB 17          0885*      rla
0B04DC ED 6A       0886*      adc hl,hl
0B04DE EB          0887*      ex de,hl
0B04DF 29          0888*      add hl,hl
0B04E0 ED 52       0889*      sbc hl,de
0B04E2 19          0890*      add hl,de
0B04E3 EB          0891*      ex de,hl
0B04E4 30 04       0892*      jr nc,$+6
0B04E6 ED 52       0893*      sbc hl,de
0B04E8 13          0894*      inc de
0B04E9 13          0895*      inc de
0B04EA CB 1A       0896*      rr d
0B04EC CB 1B       0897*      rr e
0B04EE C9          0898*      ret
0B04EF             0899*  
0B04EF             0900*  sin_lut_168:
0B04EF 00 00 00    0901*  	dl 0x000000 ; 0.000 00, 0.000
0B04F2 06 00 00    0902*  	dl 0x000006 ; 1.406 01, 0.025
0B04F5 0C 00 00    0903*  	dl 0x00000C ; 2.813 02, 0.049
0B04F8 12 00 00    0904*  	dl 0x000012 ; 4.219 03, 0.074
0B04FB 19 00 00    0905*  	dl 0x000019 ; 5.625 04, 0.098
0B04FE 1F 00 00    0906*  	dl 0x00001F ; 7.031 05, 0.122
0B0501 25 00 00    0907*  	dl 0x000025 ; 8.438 06, 0.147
0B0504 2B 00 00    0908*  	dl 0x00002B ; 9.844 07, 0.171
0B0507 31 00 00    0909*  	dl 0x000031 ; 11.250 08, 0.195
0B050A 38 00 00    0910*  	dl 0x000038 ; 12.656 09, 0.219
0B050D 3E 00 00    0911*  	dl 0x00003E ; 14.063 0A, 0.243
0B0510 44 00 00    0912*  	dl 0x000044 ; 15.469 0B, 0.267
0B0513 4A 00 00    0913*  	dl 0x00004A ; 16.875 0C, 0.290
0B0516 50 00 00    0914*  	dl 0x000050 ; 18.281 0D, 0.314
0B0519 56 00 00    0915*  	dl 0x000056 ; 19.688 0E, 0.337
0B051C 5C 00 00    0916*  	dl 0x00005C ; 21.094 0F, 0.360
0B051F 61 00 00    0917*  	dl 0x000061 ; 22.500 10, 0.383
0B0522 67 00 00    0918*  	dl 0x000067 ; 23.906 11, 0.405
0B0525 6D 00 00    0919*  	dl 0x00006D ; 25.313 12, 0.428
0B0528 73 00 00    0920*  	dl 0x000073 ; 26.719 13, 0.450
0B052B 78 00 00    0921*  	dl 0x000078 ; 28.125 14, 0.471
0B052E 7E 00 00    0922*  	dl 0x00007E ; 29.531 15, 0.493
0B0531 83 00 00    0923*  	dl 0x000083 ; 30.938 16, 0.514
0B0534 88 00 00    0924*  	dl 0x000088 ; 32.344 17, 0.535
0B0537 8E 00 00    0925*  	dl 0x00008E ; 33.750 18, 0.556
0B053A 93 00 00    0926*  	dl 0x000093 ; 35.156 19, 0.576
0B053D 98 00 00    0927*  	dl 0x000098 ; 36.563 1A, 0.596
0B0540 9D 00 00    0928*  	dl 0x00009D ; 37.969 1B, 0.615
0B0543 A2 00 00    0929*  	dl 0x0000A2 ; 39.375 1C, 0.634
0B0546 A7 00 00    0930*  	dl 0x0000A7 ; 40.781 1D, 0.653
0B0549 AB 00 00    0931*  	dl 0x0000AB ; 42.188 1E, 0.672
0B054C B0 00 00    0932*  	dl 0x0000B0 ; 43.594 1F, 0.690
0B054F B5 00 00    0933*  	dl 0x0000B5 ; 45.000 20, 0.707
0B0552 B9 00 00    0934*  	dl 0x0000B9 ; 46.406 21, 0.724
0B0555 BD 00 00    0935*  	dl 0x0000BD ; 47.813 22, 0.741
0B0558 C1 00 00    0936*  	dl 0x0000C1 ; 49.219 23, 0.757
0B055B C5 00 00    0937*  	dl 0x0000C5 ; 50.625 24, 0.773
0B055E C9 00 00    0938*  	dl 0x0000C9 ; 52.031 25, 0.788
0B0561 CD 00 00    0939*  	dl 0x0000CD ; 53.438 26, 0.803
0B0564 D1 00 00    0940*  	dl 0x0000D1 ; 54.844 27, 0.818
0B0567 D4 00 00    0941*  	dl 0x0000D4 ; 56.250 28, 0.831
0B056A D8 00 00    0942*  	dl 0x0000D8 ; 57.656 29, 0.845
0B056D DB 00 00    0943*  	dl 0x0000DB ; 59.063 2A, 0.858
0B0570 DE 00 00    0944*  	dl 0x0000DE ; 60.469 2B, 0.870
0B0573 E1 00 00    0945*  	dl 0x0000E1 ; 61.875 2C, 0.882
0B0576 E4 00 00    0946*  	dl 0x0000E4 ; 63.281 2D, 0.893
0B0579 E7 00 00    0947*  	dl 0x0000E7 ; 64.688 2E, 0.904
0B057C EA 00 00    0948*  	dl 0x0000EA ; 66.094 2F, 0.914
0B057F EC 00 00    0949*  	dl 0x0000EC ; 67.500 30, 0.924
0B0582 EE 00 00    0950*  	dl 0x0000EE ; 68.906 31, 0.933
0B0585 F1 00 00    0951*  	dl 0x0000F1 ; 70.313 32, 0.942
0B0588 F3 00 00    0952*  	dl 0x0000F3 ; 71.719 33, 0.950
0B058B F4 00 00    0953*  	dl 0x0000F4 ; 73.125 34, 0.957
0B058E F6 00 00    0954*  	dl 0x0000F6 ; 74.531 35, 0.964
0B0591 F8 00 00    0955*  	dl 0x0000F8 ; 75.938 36, 0.970
0B0594 F9 00 00    0956*  	dl 0x0000F9 ; 77.344 37, 0.976
0B0597 FB 00 00    0957*  	dl 0x0000FB ; 78.750 38, 0.981
0B059A FC 00 00    0958*  	dl 0x0000FC ; 80.156 39, 0.985
0B059D FD 00 00    0959*  	dl 0x0000FD ; 81.563 3A, 0.989
0B05A0 FE 00 00    0960*  	dl 0x0000FE ; 82.969 3B, 0.992
0B05A3 FE 00 00    0961*  	dl 0x0000FE ; 84.375 3C, 0.995
0B05A6 FF 00 00    0962*  	dl 0x0000FF ; 85.781 3D, 0.997
0B05A9 FF 00 00    0963*  	dl 0x0000FF ; 87.188 3E, 0.999
0B05AC FF 00 00    0964*  	dl 0x0000FF ; 88.594 3F, 1.000
0B05AF 00 01 00    0965*  	dl 0x000100 ; 90.000 40, 1.000
0B05B2 FF 00 00    0966*  	dl 0x0000FF ; 91.406 41, 1.000
0B05B5 FF 00 00    0967*  	dl 0x0000FF ; 92.813 42, 0.999
0B05B8 FF 00 00    0968*  	dl 0x0000FF ; 94.219 43, 0.997
0B05BB FE 00 00    0969*  	dl 0x0000FE ; 95.625 44, 0.995
0B05BE FE 00 00    0970*  	dl 0x0000FE ; 97.031 45, 0.992
0B05C1 FD 00 00    0971*  	dl 0x0000FD ; 98.438 46, 0.989
0B05C4 FC 00 00    0972*  	dl 0x0000FC ; 99.844 47, 0.985
0B05C7 FB 00 00    0973*  	dl 0x0000FB ; 101.250 48, 0.981
0B05CA F9 00 00    0974*  	dl 0x0000F9 ; 102.656 49, 0.976
0B05CD F8 00 00    0975*  	dl 0x0000F8 ; 104.063 4A, 0.970
0B05D0 F6 00 00    0976*  	dl 0x0000F6 ; 105.469 4B, 0.964
0B05D3 F4 00 00    0977*  	dl 0x0000F4 ; 106.875 4C, 0.957
0B05D6 F3 00 00    0978*  	dl 0x0000F3 ; 108.281 4D, 0.950
0B05D9 F1 00 00    0979*  	dl 0x0000F1 ; 109.688 4E, 0.942
0B05DC EE 00 00    0980*  	dl 0x0000EE ; 111.094 4F, 0.933
0B05DF EC 00 00    0981*  	dl 0x0000EC ; 112.500 50, 0.924
0B05E2 EA 00 00    0982*  	dl 0x0000EA ; 113.906 51, 0.914
0B05E5 E7 00 00    0983*  	dl 0x0000E7 ; 115.313 52, 0.904
0B05E8 E4 00 00    0984*  	dl 0x0000E4 ; 116.719 53, 0.893
0B05EB E1 00 00    0985*  	dl 0x0000E1 ; 118.125 54, 0.882
0B05EE DE 00 00    0986*  	dl 0x0000DE ; 119.531 55, 0.870
0B05F1 DB 00 00    0987*  	dl 0x0000DB ; 120.938 56, 0.858
0B05F4 D8 00 00    0988*  	dl 0x0000D8 ; 122.344 57, 0.845
0B05F7 D4 00 00    0989*  	dl 0x0000D4 ; 123.750 58, 0.831
0B05FA D1 00 00    0990*  	dl 0x0000D1 ; 125.156 59, 0.818
0B05FD CD 00 00    0991*  	dl 0x0000CD ; 126.563 5A, 0.803
0B0600 C9 00 00    0992*  	dl 0x0000C9 ; 127.969 5B, 0.788
0B0603 C5 00 00    0993*  	dl 0x0000C5 ; 129.375 5C, 0.773
0B0606 C1 00 00    0994*  	dl 0x0000C1 ; 130.781 5D, 0.757
0B0609 BD 00 00    0995*  	dl 0x0000BD ; 132.188 5E, 0.741
0B060C B9 00 00    0996*  	dl 0x0000B9 ; 133.594 5F, 0.724
0B060F B5 00 00    0997*  	dl 0x0000B5 ; 135.000 60, 0.707
0B0612 B0 00 00    0998*  	dl 0x0000B0 ; 136.406 61, 0.690
0B0615 AB 00 00    0999*  	dl 0x0000AB ; 137.813 62, 0.672
0B0618 A7 00 00    1000*  	dl 0x0000A7 ; 139.219 63, 0.653
0B061B A2 00 00    1001*  	dl 0x0000A2 ; 140.625 64, 0.634
0B061E 9D 00 00    1002*  	dl 0x00009D ; 142.031 65, 0.615
0B0621 98 00 00    1003*  	dl 0x000098 ; 143.438 66, 0.596
0B0624 93 00 00    1004*  	dl 0x000093 ; 144.844 67, 0.576
0B0627 8E 00 00    1005*  	dl 0x00008E ; 146.250 68, 0.556
0B062A 88 00 00    1006*  	dl 0x000088 ; 147.656 69, 0.535
0B062D 83 00 00    1007*  	dl 0x000083 ; 149.063 6A, 0.514
0B0630 7E 00 00    1008*  	dl 0x00007E ; 150.469 6B, 0.493
0B0633 78 00 00    1009*  	dl 0x000078 ; 151.875 6C, 0.471
0B0636 73 00 00    1010*  	dl 0x000073 ; 153.281 6D, 0.450
0B0639 6D 00 00    1011*  	dl 0x00006D ; 154.688 6E, 0.428
0B063C 67 00 00    1012*  	dl 0x000067 ; 156.094 6F, 0.405
0B063F 61 00 00    1013*  	dl 0x000061 ; 157.500 70, 0.383
0B0642 5C 00 00    1014*  	dl 0x00005C ; 158.906 71, 0.360
0B0645 56 00 00    1015*  	dl 0x000056 ; 160.313 72, 0.337
0B0648 50 00 00    1016*  	dl 0x000050 ; 161.719 73, 0.314
0B064B 4A 00 00    1017*  	dl 0x00004A ; 163.125 74, 0.290
0B064E 44 00 00    1018*  	dl 0x000044 ; 164.531 75, 0.267
0B0651 3E 00 00    1019*  	dl 0x00003E ; 165.938 76, 0.243
0B0654 38 00 00    1020*  	dl 0x000038 ; 167.344 77, 0.219
0B0657 31 00 00    1021*  	dl 0x000031 ; 168.750 78, 0.195
0B065A 2B 00 00    1022*  	dl 0x00002B ; 170.156 79, 0.171
0B065D 25 00 00    1023*  	dl 0x000025 ; 171.563 7A, 0.147
0B0660 1F 00 00    1024*  	dl 0x00001F ; 172.969 7B, 0.122
0B0663 19 00 00    1025*  	dl 0x000019 ; 174.375 7C, 0.098
0B0666 12 00 00    1026*  	dl 0x000012 ; 175.781 7D, 0.074
0B0669 0C 00 00    1027*  	dl 0x00000C ; 177.188 7E, 0.049
0B066C 06 00 00    1028*  	dl 0x000006 ; 178.594 7F, 0.025
0B066F 00 00 00    1029*  	dl 0x000000 ; 180.000 80, 0.000
0B0672 FA FF FF    1030*  	dl 0xFFFFFA ; 181.406 81, -0.025
0B0675 F4 FF FF    1031*  	dl 0xFFFFF4 ; 182.813 82, -0.049
0B0678 EE FF FF    1032*  	dl 0xFFFFEE ; 184.219 83, -0.074
0B067B E7 FF FF    1033*  	dl 0xFFFFE7 ; 185.625 84, -0.098
0B067E E1 FF FF    1034*  	dl 0xFFFFE1 ; 187.031 85, -0.122
0B0681 DB FF FF    1035*  	dl 0xFFFFDB ; 188.438 86, -0.147
0B0684 D5 FF FF    1036*  	dl 0xFFFFD5 ; 189.844 87, -0.171
0B0687 CF FF FF    1037*  	dl 0xFFFFCF ; 191.250 88, -0.195
0B068A C8 FF FF    1038*  	dl 0xFFFFC8 ; 192.656 89, -0.219
0B068D C2 FF FF    1039*  	dl 0xFFFFC2 ; 194.063 8A, -0.243
0B0690 BC FF FF    1040*  	dl 0xFFFFBC ; 195.469 8B, -0.267
0B0693 B6 FF FF    1041*  	dl 0xFFFFB6 ; 196.875 8C, -0.290
0B0696 B0 FF FF    1042*  	dl 0xFFFFB0 ; 198.281 8D, -0.314
0B0699 AA FF FF    1043*  	dl 0xFFFFAA ; 199.688 8E, -0.337
0B069C A4 FF FF    1044*  	dl 0xFFFFA4 ; 201.094 8F, -0.360
0B069F 9F FF FF    1045*  	dl 0xFFFF9F ; 202.500 90, -0.383
0B06A2 99 FF FF    1046*  	dl 0xFFFF99 ; 203.906 91, -0.405
0B06A5 93 FF FF    1047*  	dl 0xFFFF93 ; 205.313 92, -0.428
0B06A8 8D FF FF    1048*  	dl 0xFFFF8D ; 206.719 93, -0.450
0B06AB 88 FF FF    1049*  	dl 0xFFFF88 ; 208.125 94, -0.471
0B06AE 82 FF FF    1050*  	dl 0xFFFF82 ; 209.531 95, -0.493
0B06B1 7D FF FF    1051*  	dl 0xFFFF7D ; 210.938 96, -0.514
0B06B4 78 FF FF    1052*  	dl 0xFFFF78 ; 212.344 97, -0.535
0B06B7 72 FF FF    1053*  	dl 0xFFFF72 ; 213.750 98, -0.556
0B06BA 6D FF FF    1054*  	dl 0xFFFF6D ; 215.156 99, -0.576
0B06BD 68 FF FF    1055*  	dl 0xFFFF68 ; 216.563 9A, -0.596
0B06C0 63 FF FF    1056*  	dl 0xFFFF63 ; 217.969 9B, -0.615
0B06C3 5E FF FF    1057*  	dl 0xFFFF5E ; 219.375 9C, -0.634
0B06C6 59 FF FF    1058*  	dl 0xFFFF59 ; 220.781 9D, -0.653
0B06C9 55 FF FF    1059*  	dl 0xFFFF55 ; 222.188 9E, -0.672
0B06CC 50 FF FF    1060*  	dl 0xFFFF50 ; 223.594 9F, -0.690
0B06CF 4B FF FF    1061*  	dl 0xFFFF4B ; 225.000 A0, -0.707
0B06D2 47 FF FF    1062*  	dl 0xFFFF47 ; 226.406 A1, -0.724
0B06D5 43 FF FF    1063*  	dl 0xFFFF43 ; 227.813 A2, -0.741
0B06D8 3F FF FF    1064*  	dl 0xFFFF3F ; 229.219 A3, -0.757
0B06DB 3B FF FF    1065*  	dl 0xFFFF3B ; 230.625 A4, -0.773
0B06DE 37 FF FF    1066*  	dl 0xFFFF37 ; 232.031 A5, -0.788
0B06E1 33 FF FF    1067*  	dl 0xFFFF33 ; 233.438 A6, -0.803
0B06E4 2F FF FF    1068*  	dl 0xFFFF2F ; 234.844 A7, -0.818
0B06E7 2C FF FF    1069*  	dl 0xFFFF2C ; 236.250 A8, -0.831
0B06EA 28 FF FF    1070*  	dl 0xFFFF28 ; 237.656 A9, -0.845
0B06ED 25 FF FF    1071*  	dl 0xFFFF25 ; 239.063 AA, -0.858
0B06F0 22 FF FF    1072*  	dl 0xFFFF22 ; 240.469 AB, -0.870
0B06F3 1F FF FF    1073*  	dl 0xFFFF1F ; 241.875 AC, -0.882
0B06F6 1C FF FF    1074*  	dl 0xFFFF1C ; 243.281 AD, -0.893
0B06F9 19 FF FF    1075*  	dl 0xFFFF19 ; 244.688 AE, -0.904
0B06FC 16 FF FF    1076*  	dl 0xFFFF16 ; 246.094 AF, -0.914
0B06FF 14 FF FF    1077*  	dl 0xFFFF14 ; 247.500 B0, -0.924
0B0702 12 FF FF    1078*  	dl 0xFFFF12 ; 248.906 B1, -0.933
0B0705 0F FF FF    1079*  	dl 0xFFFF0F ; 250.313 B2, -0.942
0B0708 0D FF FF    1080*  	dl 0xFFFF0D ; 251.719 B3, -0.950
0B070B 0C FF FF    1081*  	dl 0xFFFF0C ; 253.125 B4, -0.957
0B070E 0A FF FF    1082*  	dl 0xFFFF0A ; 254.531 B5, -0.964
0B0711 08 FF FF    1083*  	dl 0xFFFF08 ; 255.938 B6, -0.970
0B0714 07 FF FF    1084*  	dl 0xFFFF07 ; 257.344 B7, -0.976
0B0717 05 FF FF    1085*  	dl 0xFFFF05 ; 258.750 B8, -0.981
0B071A 04 FF FF    1086*  	dl 0xFFFF04 ; 260.156 B9, -0.985
0B071D 03 FF FF    1087*  	dl 0xFFFF03 ; 261.563 BA, -0.989
0B0720 02 FF FF    1088*  	dl 0xFFFF02 ; 262.969 BB, -0.992
0B0723 02 FF FF    1089*  	dl 0xFFFF02 ; 264.375 BC, -0.995
0B0726 01 FF FF    1090*  	dl 0xFFFF01 ; 265.781 BD, -0.997
0B0729 01 FF FF    1091*  	dl 0xFFFF01 ; 267.188 BE, -0.999
0B072C 01 FF FF    1092*  	dl 0xFFFF01 ; 268.594 BF, -1.000
0B072F 00 FF FF    1093*  	dl 0xFFFF00 ; 270.000 C0, -1.000
0B0732 01 FF FF    1094*  	dl 0xFFFF01 ; 271.406 C1, -1.000
0B0735 01 FF FF    1095*  	dl 0xFFFF01 ; 272.813 C2, -0.999
0B0738 01 FF FF    1096*  	dl 0xFFFF01 ; 274.219 C3, -0.997
0B073B 02 FF FF    1097*  	dl 0xFFFF02 ; 275.625 C4, -0.995
0B073E 02 FF FF    1098*  	dl 0xFFFF02 ; 277.031 C5, -0.992
0B0741 03 FF FF    1099*  	dl 0xFFFF03 ; 278.438 C6, -0.989
0B0744 04 FF FF    1100*  	dl 0xFFFF04 ; 279.844 C7, -0.985
0B0747 05 FF FF    1101*  	dl 0xFFFF05 ; 281.250 C8, -0.981
0B074A 07 FF FF    1102*  	dl 0xFFFF07 ; 282.656 C9, -0.976
0B074D 08 FF FF    1103*  	dl 0xFFFF08 ; 284.063 CA, -0.970
0B0750 0A FF FF    1104*  	dl 0xFFFF0A ; 285.469 CB, -0.964
0B0753 0C FF FF    1105*  	dl 0xFFFF0C ; 286.875 CC, -0.957
0B0756 0D FF FF    1106*  	dl 0xFFFF0D ; 288.281 CD, -0.950
0B0759 0F FF FF    1107*  	dl 0xFFFF0F ; 289.688 CE, -0.942
0B075C 12 FF FF    1108*  	dl 0xFFFF12 ; 291.094 CF, -0.933
0B075F 14 FF FF    1109*  	dl 0xFFFF14 ; 292.500 D0, -0.924
0B0762 16 FF FF    1110*  	dl 0xFFFF16 ; 293.906 D1, -0.914
0B0765 19 FF FF    1111*  	dl 0xFFFF19 ; 295.313 D2, -0.904
0B0768 1C FF FF    1112*  	dl 0xFFFF1C ; 296.719 D3, -0.893
0B076B 1F FF FF    1113*  	dl 0xFFFF1F ; 298.125 D4, -0.882
0B076E 22 FF FF    1114*  	dl 0xFFFF22 ; 299.531 D5, -0.870
0B0771 25 FF FF    1115*  	dl 0xFFFF25 ; 300.938 D6, -0.858
0B0774 28 FF FF    1116*  	dl 0xFFFF28 ; 302.344 D7, -0.845
0B0777 2C FF FF    1117*  	dl 0xFFFF2C ; 303.750 D8, -0.831
0B077A 2F FF FF    1118*  	dl 0xFFFF2F ; 305.156 D9, -0.818
0B077D 33 FF FF    1119*  	dl 0xFFFF33 ; 306.563 DA, -0.803
0B0780 37 FF FF    1120*  	dl 0xFFFF37 ; 307.969 DB, -0.788
0B0783 3B FF FF    1121*  	dl 0xFFFF3B ; 309.375 DC, -0.773
0B0786 3F FF FF    1122*  	dl 0xFFFF3F ; 310.781 DD, -0.757
0B0789 43 FF FF    1123*  	dl 0xFFFF43 ; 312.188 DE, -0.741
0B078C 47 FF FF    1124*  	dl 0xFFFF47 ; 313.594 DF, -0.724
0B078F 4B FF FF    1125*  	dl 0xFFFF4B ; 315.000 E0, -0.707
0B0792 50 FF FF    1126*  	dl 0xFFFF50 ; 316.406 E1, -0.690
0B0795 55 FF FF    1127*  	dl 0xFFFF55 ; 317.813 E2, -0.672
0B0798 59 FF FF    1128*  	dl 0xFFFF59 ; 319.219 E3, -0.653
0B079B 5E FF FF    1129*  	dl 0xFFFF5E ; 320.625 E4, -0.634
0B079E 63 FF FF    1130*  	dl 0xFFFF63 ; 322.031 E5, -0.615
0B07A1 68 FF FF    1131*  	dl 0xFFFF68 ; 323.438 E6, -0.596
0B07A4 6D FF FF    1132*  	dl 0xFFFF6D ; 324.844 E7, -0.576
0B07A7 72 FF FF    1133*  	dl 0xFFFF72 ; 326.250 E8, -0.556
0B07AA 78 FF FF    1134*  	dl 0xFFFF78 ; 327.656 E9, -0.535
0B07AD 7D FF FF    1135*  	dl 0xFFFF7D ; 329.063 EA, -0.514
0B07B0 82 FF FF    1136*  	dl 0xFFFF82 ; 330.469 EB, -0.493
0B07B3 88 FF FF    1137*  	dl 0xFFFF88 ; 331.875 EC, -0.471
0B07B6 8D FF FF    1138*  	dl 0xFFFF8D ; 333.281 ED, -0.450
0B07B9 93 FF FF    1139*  	dl 0xFFFF93 ; 334.688 EE, -0.428
0B07BC 99 FF FF    1140*  	dl 0xFFFF99 ; 336.094 EF, -0.405
0B07BF 9F FF FF    1141*  	dl 0xFFFF9F ; 337.500 F0, -0.383
0B07C2 A4 FF FF    1142*  	dl 0xFFFFA4 ; 338.906 F1, -0.360
0B07C5 AA FF FF    1143*  	dl 0xFFFFAA ; 340.313 F2, -0.337
0B07C8 B0 FF FF    1144*  	dl 0xFFFFB0 ; 341.719 F3, -0.314
0B07CB B6 FF FF    1145*  	dl 0xFFFFB6 ; 343.125 F4, -0.290
0B07CE BC FF FF    1146*  	dl 0xFFFFBC ; 344.531 F5, -0.267
0B07D1 C2 FF FF    1147*  	dl 0xFFFFC2 ; 345.938 F6, -0.243
0B07D4 C8 FF FF    1148*  	dl 0xFFFFC8 ; 347.344 F7, -0.219
0B07D7 CF FF FF    1149*  	dl 0xFFFFCF ; 348.750 F8, -0.195
0B07DA D5 FF FF    1150*  	dl 0xFFFFD5 ; 350.156 F9, -0.171
0B07DD DB FF FF    1151*  	dl 0xFFFFDB ; 351.563 FA, -0.147
0B07E0 E1 FF FF    1152*  	dl 0xFFFFE1 ; 352.969 FB, -0.122
0B07E3 E7 FF FF    1153*  	dl 0xFFFFE7 ; 354.375 FC, -0.098
0B07E6 EE FF FF    1154*  	dl 0xFFFFEE ; 355.781 FD, -0.074
0B07E9 F4 FF FF    1155*  	dl 0xFFFFF4 ; 357.188 FE, -0.049
0B07EC FA FF FF    1156*  	dl 0xFFFFFA ; 358.594 FF, -0.025
0B07EF 00 00 00    1157*  	dl 0x000000 ; 0.000 00, 0.000 for interpolation
0B07F2             1158*  
0B07F2             1159*  atan_lut_168:
0B07F2 00 00 00    1160*  	dl 0x000000 ; 000000, 0.000
0B07F5 28 00 00    1161*  	dl 0x000028 ; 000001, 0.224
0B07F8 51 00 00    1162*  	dl 0x000051 ; 000002, 0.448
0B07FB 7A 00 00    1163*  	dl 0x00007A ; 000003, 0.671
0B07FE A2 00 00    1164*  	dl 0x0000A2 ; 000004, 0.895
0B0801 CB 00 00    1165*  	dl 0x0000CB ; 000005, 1.119
0B0804 F4 00 00    1166*  	dl 0x0000F4 ; 000006, 1.343
0B0807 1D 01 00    1167*  	dl 0x00011D ; 000007, 1.566
0B080A 45 01 00    1168*  	dl 0x000145 ; 000008, 1.790
0B080D 6E 01 00    1169*  	dl 0x00016E ; 000009, 2.013
0B0810 97 01 00    1170*  	dl 0x000197 ; 00000A, 2.237
0B0813 BF 01 00    1171*  	dl 0x0001BF ; 00000B, 2.460
0B0816 E8 01 00    1172*  	dl 0x0001E8 ; 00000C, 2.684
0B0819 11 02 00    1173*  	dl 0x000211 ; 00000D, 2.907
0B081C 39 02 00    1174*  	dl 0x000239 ; 00000E, 3.130
0B081F 62 02 00    1175*  	dl 0x000262 ; 00000F, 3.353
0B0822 8B 02 00    1176*  	dl 0x00028B ; 000010, 3.576
0B0825 B3 02 00    1177*  	dl 0x0002B3 ; 000011, 3.799
0B0828 DC 02 00    1178*  	dl 0x0002DC ; 000012, 4.022
0B082B 04 03 00    1179*  	dl 0x000304 ; 000013, 4.245
0B082E 2D 03 00    1180*  	dl 0x00032D ; 000014, 4.467
0B0831 55 03 00    1181*  	dl 0x000355 ; 000015, 4.690
0B0834 7E 03 00    1182*  	dl 0x00037E ; 000016, 4.912
0B0837 A6 03 00    1183*  	dl 0x0003A6 ; 000017, 5.134
0B083A CE 03 00    1184*  	dl 0x0003CE ; 000018, 5.356
0B083D F7 03 00    1185*  	dl 0x0003F7 ; 000019, 5.578
0B0840 1F 04 00    1186*  	dl 0x00041F ; 00001A, 5.799
0B0843 48 04 00    1187*  	dl 0x000448 ; 00001B, 6.021
0B0846 70 04 00    1188*  	dl 0x000470 ; 00001C, 6.242
0B0849 98 04 00    1189*  	dl 0x000498 ; 00001D, 6.463
0B084C C0 04 00    1190*  	dl 0x0004C0 ; 00001E, 6.684
0B084F E8 04 00    1191*  	dl 0x0004E8 ; 00001F, 6.905
0B0852 11 05 00    1192*  	dl 0x000511 ; 000020, 7.125
0B0855 39 05 00    1193*  	dl 0x000539 ; 000021, 7.345
0B0858 61 05 00    1194*  	dl 0x000561 ; 000022, 7.565
0B085B 89 05 00    1195*  	dl 0x000589 ; 000023, 7.785
0B085E B1 05 00    1196*  	dl 0x0005B1 ; 000024, 8.005
0B0861 D9 05 00    1197*  	dl 0x0005D9 ; 000025, 8.224
0B0864 01 06 00    1198*  	dl 0x000601 ; 000026, 8.443
0B0867 28 06 00    1199*  	dl 0x000628 ; 000027, 8.662
0B086A 50 06 00    1200*  	dl 0x000650 ; 000028, 8.881
0B086D 78 06 00    1201*  	dl 0x000678 ; 000029, 9.099
0B0870 A0 06 00    1202*  	dl 0x0006A0 ; 00002A, 9.317
0B0873 C7 06 00    1203*  	dl 0x0006C7 ; 00002B, 9.535
0B0876 EF 06 00    1204*  	dl 0x0006EF ; 00002C, 9.752
0B0879 16 07 00    1205*  	dl 0x000716 ; 00002D, 9.970
0B087C 3E 07 00    1206*  	dl 0x00073E ; 00002E, 10.187
0B087F 65 07 00    1207*  	dl 0x000765 ; 00002F, 10.403
0B0882 8D 07 00    1208*  	dl 0x00078D ; 000030, 10.620
0B0885 B4 07 00    1209*  	dl 0x0007B4 ; 000031, 10.836
0B0888 DB 07 00    1210*  	dl 0x0007DB ; 000032, 11.051
0B088B 03 08 00    1211*  	dl 0x000803 ; 000033, 11.267
0B088E 2A 08 00    1212*  	dl 0x00082A ; 000034, 11.482
0B0891 51 08 00    1213*  	dl 0x000851 ; 000035, 11.697
0B0894 78 08 00    1214*  	dl 0x000878 ; 000036, 11.911
0B0897 9F 08 00    1215*  	dl 0x00089F ; 000037, 12.125
0B089A C6 08 00    1216*  	dl 0x0008C6 ; 000038, 12.339
0B089D ED 08 00    1217*  	dl 0x0008ED ; 000039, 12.553
0B08A0 13 09 00    1218*  	dl 0x000913 ; 00003A, 12.766
0B08A3 3A 09 00    1219*  	dl 0x00093A ; 00003B, 12.978
0B08A6 61 09 00    1220*  	dl 0x000961 ; 00003C, 13.191
0B08A9 87 09 00    1221*  	dl 0x000987 ; 00003D, 13.403
0B08AC AE 09 00    1222*  	dl 0x0009AE ; 00003E, 13.614
0B08AF D4 09 00    1223*  	dl 0x0009D4 ; 00003F, 13.825
0B08B2 FB 09 00    1224*  	dl 0x0009FB ; 000040, 14.036
0B08B5 21 0A 00    1225*  	dl 0x000A21 ; 000041, 14.247
0B08B8 47 0A 00    1226*  	dl 0x000A47 ; 000042, 14.457
0B08BB 6D 0A 00    1227*  	dl 0x000A6D ; 000043, 14.666
0B08BE 94 0A 00    1228*  	dl 0x000A94 ; 000044, 14.876
0B08C1 BA 0A 00    1229*  	dl 0x000ABA ; 000045, 15.085
0B08C4 E0 0A 00    1230*  	dl 0x000AE0 ; 000046, 15.293
0B08C7 05 0B 00    1231*  	dl 0x000B05 ; 000047, 15.501
0B08CA 2B 0B 00    1232*  	dl 0x000B2B ; 000048, 15.709
0B08CD 51 0B 00    1233*  	dl 0x000B51 ; 000049, 15.916
0B08D0 77 0B 00    1234*  	dl 0x000B77 ; 00004A, 16.123
0B08D3 9C 0B 00    1235*  	dl 0x000B9C ; 00004B, 16.329
0B08D6 C2 0B 00    1236*  	dl 0x000BC2 ; 00004C, 16.535
0B08D9 E7 0B 00    1237*  	dl 0x000BE7 ; 00004D, 16.740
0B08DC 0C 0C 00    1238*  	dl 0x000C0C ; 00004E, 16.945
0B08DF 32 0C 00    1239*  	dl 0x000C32 ; 00004F, 17.150
0B08E2 57 0C 00    1240*  	dl 0x000C57 ; 000050, 17.354
0B08E5 7C 0C 00    1241*  	dl 0x000C7C ; 000051, 17.558
0B08E8 A1 0C 00    1242*  	dl 0x000CA1 ; 000052, 17.761
0B08EB C6 0C 00    1243*  	dl 0x000CC6 ; 000053, 17.964
0B08EE EB 0C 00    1244*  	dl 0x000CEB ; 000054, 18.166
0B08F1 0F 0D 00    1245*  	dl 0x000D0F ; 000055, 18.368
0B08F4 34 0D 00    1246*  	dl 0x000D34 ; 000056, 18.569
0B08F7 58 0D 00    1247*  	dl 0x000D58 ; 000057, 18.770
0B08FA 7D 0D 00    1248*  	dl 0x000D7D ; 000058, 18.970
0B08FD A1 0D 00    1249*  	dl 0x000DA1 ; 000059, 19.170
0B0900 C6 0D 00    1250*  	dl 0x000DC6 ; 00005A, 19.370
0B0903 EA 0D 00    1251*  	dl 0x000DEA ; 00005B, 19.569
0B0906 0E 0E 00    1252*  	dl 0x000E0E ; 00005C, 19.767
0B0909 32 0E 00    1253*  	dl 0x000E32 ; 00005D, 19.965
0B090C 56 0E 00    1254*  	dl 0x000E56 ; 00005E, 20.163
0B090F 7A 0E 00    1255*  	dl 0x000E7A ; 00005F, 20.360
0B0912 9E 0E 00    1256*  	dl 0x000E9E ; 000060, 20.556
0B0915 C1 0E 00    1257*  	dl 0x000EC1 ; 000061, 20.752
0B0918 E5 0E 00    1258*  	dl 0x000EE5 ; 000062, 20.947
0B091B 08 0F 00    1259*  	dl 0x000F08 ; 000063, 21.142
0B091E 2C 0F 00    1260*  	dl 0x000F2C ; 000064, 21.337
0B0921 4F 0F 00    1261*  	dl 0x000F4F ; 000065, 21.531
0B0924 72 0F 00    1262*  	dl 0x000F72 ; 000066, 21.724
0B0927 95 0F 00    1263*  	dl 0x000F95 ; 000067, 21.917
0B092A B8 0F 00    1264*  	dl 0x000FB8 ; 000068, 22.109
0B092D DB 0F 00    1265*  	dl 0x000FDB ; 000069, 22.301
0B0930 FE 0F 00    1266*  	dl 0x000FFE ; 00006A, 22.493
0B0933 21 10 00    1267*  	dl 0x001021 ; 00006B, 22.683
0B0936 44 10 00    1268*  	dl 0x001044 ; 00006C, 22.874
0B0939 66 10 00    1269*  	dl 0x001066 ; 00006D, 23.063
0B093C 89 10 00    1270*  	dl 0x001089 ; 00006E, 23.253
0B093F AB 10 00    1271*  	dl 0x0010AB ; 00006F, 23.441
0B0942 CD 10 00    1272*  	dl 0x0010CD ; 000070, 23.629
0B0945 EF 10 00    1273*  	dl 0x0010EF ; 000071, 23.817
0B0948 11 11 00    1274*  	dl 0x001111 ; 000072, 24.004
0B094B 33 11 00    1275*  	dl 0x001133 ; 000073, 24.191
0B094E 55 11 00    1276*  	dl 0x001155 ; 000074, 24.376
0B0951 77 11 00    1277*  	dl 0x001177 ; 000075, 24.562
0B0954 99 11 00    1278*  	dl 0x001199 ; 000076, 24.747
0B0957 BA 11 00    1279*  	dl 0x0011BA ; 000077, 24.931
0B095A DC 11 00    1280*  	dl 0x0011DC ; 000078, 25.115
0B095D FD 11 00    1281*  	dl 0x0011FD ; 000079, 25.298
0B0960 1E 12 00    1282*  	dl 0x00121E ; 00007A, 25.481
0B0963 3F 12 00    1283*  	dl 0x00123F ; 00007B, 25.663
0B0966 60 12 00    1284*  	dl 0x001260 ; 00007C, 25.844
0B0969 81 12 00    1285*  	dl 0x001281 ; 00007D, 26.025
0B096C A2 12 00    1286*  	dl 0x0012A2 ; 00007E, 26.206
0B096F C3 12 00    1287*  	dl 0x0012C3 ; 00007F, 26.386
0B0972 E4 12 00    1288*  	dl 0x0012E4 ; 000080, 26.565
0B0975 04 13 00    1289*  	dl 0x001304 ; 000081, 26.744
0B0978 25 13 00    1290*  	dl 0x001325 ; 000082, 26.922
0B097B 45 13 00    1291*  	dl 0x001345 ; 000083, 27.100
0B097E 65 13 00    1292*  	dl 0x001365 ; 000084, 27.277
0B0981 85 13 00    1293*  	dl 0x001385 ; 000085, 27.453
0B0984 A5 13 00    1294*  	dl 0x0013A5 ; 000086, 27.629
0B0987 C5 13 00    1295*  	dl 0x0013C5 ; 000087, 27.805
0B098A E5 13 00    1296*  	dl 0x0013E5 ; 000088, 27.979
0B098D 05 14 00    1297*  	dl 0x001405 ; 000089, 28.154
0B0990 24 14 00    1298*  	dl 0x001424 ; 00008A, 28.327
0B0993 44 14 00    1299*  	dl 0x001444 ; 00008B, 28.501
0B0996 63 14 00    1300*  	dl 0x001463 ; 00008C, 28.673
0B0999 83 14 00    1301*  	dl 0x001483 ; 00008D, 28.845
0B099C A2 14 00    1302*  	dl 0x0014A2 ; 00008E, 29.017
0B099F C1 14 00    1303*  	dl 0x0014C1 ; 00008F, 29.187
0B09A2 E0 14 00    1304*  	dl 0x0014E0 ; 000090, 29.358
0B09A5 FF 14 00    1305*  	dl 0x0014FF ; 000091, 29.527
0B09A8 1E 15 00    1306*  	dl 0x00151E ; 000092, 29.697
0B09AB 3C 15 00    1307*  	dl 0x00153C ; 000093, 29.865
0B09AE 5B 15 00    1308*  	dl 0x00155B ; 000094, 30.033
0B09B1 79 15 00    1309*  	dl 0x001579 ; 000095, 30.201
0B09B4 98 15 00    1310*  	dl 0x001598 ; 000096, 30.368
0B09B7 B6 15 00    1311*  	dl 0x0015B6 ; 000097, 30.534
0B09BA D4 15 00    1312*  	dl 0x0015D4 ; 000098, 30.700
0B09BD F2 15 00    1313*  	dl 0x0015F2 ; 000099, 30.865
0B09C0 10 16 00    1314*  	dl 0x001610 ; 00009A, 31.030
0B09C3 2E 16 00    1315*  	dl 0x00162E ; 00009B, 31.194
0B09C6 4C 16 00    1316*  	dl 0x00164C ; 00009C, 31.357
0B09C9 6A 16 00    1317*  	dl 0x00166A ; 00009D, 31.520
0B09CC 87 16 00    1318*  	dl 0x001687 ; 00009E, 31.682
0B09CF A5 16 00    1319*  	dl 0x0016A5 ; 00009F, 31.844
0B09D2 C2 16 00    1320*  	dl 0x0016C2 ; 0000A0, 32.005
0B09D5 DF 16 00    1321*  	dl 0x0016DF ; 0000A1, 32.166
0B09D8 FC 16 00    1322*  	dl 0x0016FC ; 0000A2, 32.326
0B09DB 19 17 00    1323*  	dl 0x001719 ; 0000A3, 32.486
0B09DE 36 17 00    1324*  	dl 0x001736 ; 0000A4, 32.645
0B09E1 53 17 00    1325*  	dl 0x001753 ; 0000A5, 32.803
0B09E4 70 17 00    1326*  	dl 0x001770 ; 0000A6, 32.961
0B09E7 8C 17 00    1327*  	dl 0x00178C ; 0000A7, 33.118
0B09EA A9 17 00    1328*  	dl 0x0017A9 ; 0000A8, 33.275
0B09ED C5 17 00    1329*  	dl 0x0017C5 ; 0000A9, 33.431
0B09F0 E2 17 00    1330*  	dl 0x0017E2 ; 0000AA, 33.587
0B09F3 FE 17 00    1331*  	dl 0x0017FE ; 0000AB, 33.742
0B09F6 1A 18 00    1332*  	dl 0x00181A ; 0000AC, 33.896
0B09F9 36 18 00    1333*  	dl 0x001836 ; 0000AD, 34.050
0B09FC 52 18 00    1334*  	dl 0x001852 ; 0000AE, 34.203
0B09FF 6E 18 00    1335*  	dl 0x00186E ; 0000AF, 34.356
0B0A02 8A 18 00    1336*  	dl 0x00188A ; 0000B0, 34.509
0B0A05 A5 18 00    1337*  	dl 0x0018A5 ; 0000B1, 34.660
0B0A08 C1 18 00    1338*  	dl 0x0018C1 ; 0000B2, 34.811
0B0A0B DC 18 00    1339*  	dl 0x0018DC ; 0000B3, 34.962
0B0A0E F7 18 00    1340*  	dl 0x0018F7 ; 0000B4, 35.112
0B0A11 13 19 00    1341*  	dl 0x001913 ; 0000B5, 35.262
0B0A14 2E 19 00    1342*  	dl 0x00192E ; 0000B6, 35.410
0B0A17 49 19 00    1343*  	dl 0x001949 ; 0000B7, 35.559
0B0A1A 64 19 00    1344*  	dl 0x001964 ; 0000B8, 35.707
0B0A1D 7F 19 00    1345*  	dl 0x00197F ; 0000B9, 35.854
0B0A20 99 19 00    1346*  	dl 0x001999 ; 0000BA, 36.001
0B0A23 B4 19 00    1347*  	dl 0x0019B4 ; 0000BB, 36.147
0B0A26 CE 19 00    1348*  	dl 0x0019CE ; 0000BC, 36.293
0B0A29 E9 19 00    1349*  	dl 0x0019E9 ; 0000BD, 36.438
0B0A2C 03 1A 00    1350*  	dl 0x001A03 ; 0000BE, 36.582
0B0A2F 1D 1A 00    1351*  	dl 0x001A1D ; 0000BF, 36.726
0B0A32 37 1A 00    1352*  	dl 0x001A37 ; 0000C0, 36.870
0B0A35 51 1A 00    1353*  	dl 0x001A51 ; 0000C1, 37.013
0B0A38 6B 1A 00    1354*  	dl 0x001A6B ; 0000C2, 37.155
0B0A3B 85 1A 00    1355*  	dl 0x001A85 ; 0000C3, 37.297
0B0A3E 9F 1A 00    1356*  	dl 0x001A9F ; 0000C4, 37.439
0B0A41 B9 1A 00    1357*  	dl 0x001AB9 ; 0000C5, 37.579
0B0A44 D2 1A 00    1358*  	dl 0x001AD2 ; 0000C6, 37.720
0B0A47 EC 1A 00    1359*  	dl 0x001AEC ; 0000C7, 37.859
0B0A4A 05 1B 00    1360*  	dl 0x001B05 ; 0000C8, 37.999
0B0A4D 1E 1B 00    1361*  	dl 0x001B1E ; 0000C9, 38.137
0B0A50 37 1B 00    1362*  	dl 0x001B37 ; 0000CA, 38.276
0B0A53 50 1B 00    1363*  	dl 0x001B50 ; 0000CB, 38.413
0B0A56 69 1B 00    1364*  	dl 0x001B69 ; 0000CC, 38.550
0B0A59 82 1B 00    1365*  	dl 0x001B82 ; 0000CD, 38.687
0B0A5C 9B 1B 00    1366*  	dl 0x001B9B ; 0000CE, 38.823
0B0A5F B4 1B 00    1367*  	dl 0x001BB4 ; 0000CF, 38.959
0B0A62 CC 1B 00    1368*  	dl 0x001BCC ; 0000D0, 39.094
0B0A65 E5 1B 00    1369*  	dl 0x001BE5 ; 0000D1, 39.228
0B0A68 FD 1B 00    1370*  	dl 0x001BFD ; 0000D2, 39.362
0B0A6B 16 1C 00    1371*  	dl 0x001C16 ; 0000D3, 39.496
0B0A6E 2E 1C 00    1372*  	dl 0x001C2E ; 0000D4, 39.629
0B0A71 46 1C 00    1373*  	dl 0x001C46 ; 0000D5, 39.762
0B0A74 5E 1C 00    1374*  	dl 0x001C5E ; 0000D6, 39.894
0B0A77 76 1C 00    1375*  	dl 0x001C76 ; 0000D7, 40.025
0B0A7A 8E 1C 00    1376*  	dl 0x001C8E ; 0000D8, 40.156
0B0A7D A5 1C 00    1377*  	dl 0x001CA5 ; 0000D9, 40.286
0B0A80 BD 1C 00    1378*  	dl 0x001CBD ; 0000DA, 40.416
0B0A83 D5 1C 00    1379*  	dl 0x001CD5 ; 0000DB, 40.546
0B0A86 EC 1C 00    1380*  	dl 0x001CEC ; 0000DC, 40.675
0B0A89 04 1D 00    1381*  	dl 0x001D04 ; 0000DD, 40.803
0B0A8C 1B 1D 00    1382*  	dl 0x001D1B ; 0000DE, 40.931
0B0A8F 32 1D 00    1383*  	dl 0x001D32 ; 0000DF, 41.059
0B0A92 49 1D 00    1384*  	dl 0x001D49 ; 0000E0, 41.186
0B0A95 60 1D 00    1385*  	dl 0x001D60 ; 0000E1, 41.312
0B0A98 77 1D 00    1386*  	dl 0x001D77 ; 0000E2, 41.438
0B0A9B 8E 1D 00    1387*  	dl 0x001D8E ; 0000E3, 41.564
0B0A9E A5 1D 00    1388*  	dl 0x001DA5 ; 0000E4, 41.689
0B0AA1 BB 1D 00    1389*  	dl 0x001DBB ; 0000E5, 41.814
0B0AA4 D2 1D 00    1390*  	dl 0x001DD2 ; 0000E6, 41.938
0B0AA7 E9 1D 00    1391*  	dl 0x001DE9 ; 0000E7, 42.061
0B0AAA FF 1D 00    1392*  	dl 0x001DFF ; 0000E8, 42.184
0B0AAD 15 1E 00    1393*  	dl 0x001E15 ; 0000E9, 42.307
0B0AB0 2C 1E 00    1394*  	dl 0x001E2C ; 0000EA, 42.429
0B0AB3 42 1E 00    1395*  	dl 0x001E42 ; 0000EB, 42.551
0B0AB6 58 1E 00    1396*  	dl 0x001E58 ; 0000EC, 42.672
0B0AB9 6E 1E 00    1397*  	dl 0x001E6E ; 0000ED, 42.793
0B0ABC 84 1E 00    1398*  	dl 0x001E84 ; 0000EE, 42.913
0B0ABF 99 1E 00    1399*  	dl 0x001E99 ; 0000EF, 43.033
0B0AC2 AF 1E 00    1400*  	dl 0x001EAF ; 0000F0, 43.152
0B0AC5 C5 1E 00    1401*  	dl 0x001EC5 ; 0000F1, 43.271
0B0AC8 DA 1E 00    1402*  	dl 0x001EDA ; 0000F2, 43.390
0B0ACB F0 1E 00    1403*  	dl 0x001EF0 ; 0000F3, 43.508
0B0ACE 05 1F 00    1404*  	dl 0x001F05 ; 0000F4, 43.625
0B0AD1 1B 1F 00    1405*  	dl 0x001F1B ; 0000F5, 43.742
0B0AD4 30 1F 00    1406*  	dl 0x001F30 ; 0000F6, 43.859
0B0AD7 45 1F 00    1407*  	dl 0x001F45 ; 0000F7, 43.975
0B0ADA 5A 1F 00    1408*  	dl 0x001F5A ; 0000F8, 44.091
0B0ADD 6F 1F 00    1409*  	dl 0x001F6F ; 0000F9, 44.206
0B0AE0 84 1F 00    1410*  	dl 0x001F84 ; 0000FA, 44.321
0B0AE3 99 1F 00    1411*  	dl 0x001F99 ; 0000FB, 44.435
0B0AE6 AD 1F 00    1412*  	dl 0x001FAD ; 0000FC, 44.549
0B0AE9 C2 1F 00    1413*  	dl 0x001FC2 ; 0000FD, 44.662
0B0AEC D7 1F 00    1414*  	dl 0x001FD7 ; 0000FE, 44.775
0B0AEF EB 1F 00    1415*  	dl 0x001FEB ; 0000FF, 44.888
0B0AF2 00 20 00    1416*  	dl 0x002000 ; 000100, 45.000 only needed for interpolation
0B0AF5             1417*  
0B0AF5             1418*  	; include "functions.inc"
0B0AF5             1419*  
0B0AF5             1420*      MACRO printChar char
0B0AF5             1421*          LD A, char
0B0AF5             1422*          RST.LIL 10h
0B0AF5             1423*      ENDMACRO
0B0AF5             1424*  
0B0AF5             1425*  ; put the value in HLU into the accumulator
0B0AF5             1426*  ; destroys: af
0B0AF5             1427*      MACRO HLU_TO_A
0B0AF5             1428*          push hl ; 4 cycles
0B0AF5             1429*          inc sp ; 1 cycle
0B0AF5             1430*          pop af  ; 4 cycles
0B0AF5             1431*          dec sp ; 1 cycle
0B0AF5             1432*                 ; 10 cycles total
0B0AF5             1433*      ENDMACRO
0B0AF5             1434*  
0B0AF5             1435*  ; put the value in the accumulator into HLU
0B0AF5             1436*  ; destroys a
0B0AF5             1437*  A_TO_HLU:
0B0AF5             1438*      ; call is 7 cycles
0B0AF5 22 02 0B 0B 1439*      ld (@scratch),hl ; 7 cycles
0B0AF9 32 04 0B 0B 1440*      ld (@scratch+2),a ; 5 cycles
0B0AFD 2A 02 0B 0B 1441*      ld hl,(@scratch) ; 7 cycles
0B0B01 C9          1442*      ret ; 6 cycles
0B0B02             1443*          ; 25 cycles total
0B0B02 00 00 00    1444*  @scratch: dl 0
0B0B05             1445*  
0B0B05             1446*  
0B0B05             1447*  ; Print a zero-terminated string inline with code, e.g.:
0B0B05             1448*  ;
0B0B05             1449*  ;    call printInline
0B0B05             1450*  ;    ASCIZ "Hello, world!\r\n"
0B0B05             1451*  ;
0B0B05             1452*  ; Destroys: HL,AF
0B0B05             1453*  printInline:
0B0B05 E1          1454*      pop hl ; get the return address = pointer to start of string
0B0B06 CD 0C 0B 0B 1455*      call printString ; HL advances to end of string
0B0B0A E5          1456*      push hl ; restore the return address = pointer to end of string
0B0B0B C9          1457*      ret
0B0B0C             1458*  
0B0B0C             1459*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
0B0B0C             1460*  ; Print a zero-terminated string
0B0B0C             1461*  ; HL: Pointer to string
0B0B0C             1462*  printString:
0B0B0C C5          1463*  	PUSH	BC
0B0B0D 01 00 00 00 1464*  	LD		BC,0
0B0B11 3E 00       1465*  	LD 	 	A,0
0B0B13 5B DF       1466*  	RST.LIL 18h
0B0B15 C1          1467*  	POP		BC
0B0B16 C9          1468*  	RET
0B0B17             1469*  ; print a VDU sequence
0B0B17             1470*  ; HL: Pointer to VDU sequence - <1 byte length> <data>
0B0B17             1471*  sendVDUsequence:
0B0B17 C5          1472*  	PUSH	BC
0B0B18 01 00 00 00 1473*  	LD		BC, 0
0B0B1C 4E          1474*  	LD		C, (HL)
0B0B1D 5B DF       1475*  	RST.LIL	18h
0B0B1F C1          1476*  	POP		BC
0B0B20 C9          1477*  	RET
0B0B21             1478*  ; Print Newline sequence to VDP
0B0B21             1479*  printNewLine:
0B0B21 F5          1480*      push af ; for some reason rst.lil 10h sets carry flag
0B0B22 3E 0D       1481*  	LD	A, '\r'
0B0B24 5B D7       1482*  	RST.LIL 10h
0B0B26 3E 0A       1483*  	LD	A, '\n'
0B0B28 5B D7       1484*  	RST.LIL 10h
0B0B2A F1          1485*      pop af
0B0B2B C9          1486*  	RET
0B0B2C             1487*  
0B0B2C             1488*  ; Print a 24-bit HEX number
0B0B2C             1489*  ; HLU: Number to print
0B0B2C             1490*  printHex24:
0B0B2C             1491*      HLU_TO_A
0B0B2C E5          0001*M         push hl ; 4 cycles
0B0B2D 33          0002*M         inc sp ; 1 cycle
0B0B2E F1          0003*M         pop af  ; 4 cycles
0B0B2F 3B          0004*M         dec sp ; 1 cycle
0B0B30             0005*M                ; 10 cycles total
0B0B30 CD 3A 0B 0B 1492*  	CALL	printHex8
0B0B34             1493*  ; Print a 16-bit HEX number
0B0B34             1494*  ; HL: Number to print
0B0B34             1495*  printHex16:
0B0B34 7C          1496*  	LD		A,H
0B0B35 CD 3A 0B 0B 1497*  	CALL	printHex8
0B0B39 7D          1498*  	LD		A,L
0B0B3A             1499*  ; Print an 8-bit HEX number
0B0B3A             1500*  ; A: Number to print
0B0B3A             1501*  printHex8:
0B0B3A 4F          1502*  	LD		C,A
0B0B3B 1F          1503*  	RRA
0B0B3C 1F          1504*  	RRA
0B0B3D 1F          1505*  	RRA
0B0B3E 1F          1506*  	RRA
0B0B3F CD 44 0B 0B 1507*  	CALL	@F
0B0B43 79          1508*  	LD		A,C
0B0B44             1509*  @@:
0B0B44 E6 0F       1510*  	AND		0Fh
0B0B46 C6 90       1511*  	ADD		A,90h
0B0B48 27          1512*  	DAA
0B0B49 CE 40       1513*  	ADC		A,40h
0B0B4B 27          1514*  	DAA
0B0B4C 5B D7       1515*  	RST.LIL	10h
0B0B4E C9          1516*  	RET
0B0B4F             1517*  
0B0B4F             1518*  printHexUHL:
0B0B4F E5          1519*  	push hl
0B0B50 CD 2C 0B 0B 1520*  	call printHex24
0B0B54 E1          1521*  	pop hl
0B0B55 C9          1522*  	ret
0B0B56             1523*  
0B0B56             1524*  
0B0B56             1525*  ; print registers to screen in hexidecimal format
0B0B56             1526*  ; inputs: none
0B0B56             1527*  ; outputs: values of every register printed to screen
0B0B56             1528*  ;    values of each register in global scratch memory
0B0B56             1529*  ; destroys: nothing
0B0B56             1530*  dumpRegistersHex:
0B0B56             1531*  ; store everything in scratch
0B0B56 22 FB 0B 0B 1532*      ld (@uhl),hl
0B0B5A ED 43 FE 0B 1533*      ld (@ubc),bc
       0B          
0B0B5F ED 53 01 0C 1534*      ld (@ude),de
       0B          
0B0B64 DD 22 04 0C 1535*      ld (@uix),ix
       0B          
0B0B69 FD 22 07 0C 1536*      ld (@uiy),iy
       0B          
0B0B6E F5          1537*      push af
0B0B6F E1          1538*      pop hl
0B0B70 22 F8 0B 0B 1539*      ld (@uaf),hl
0B0B74 F5          1540*      push af
0B0B75             1541*  
0B0B75             1542*  ; print each register
0B0B75 CD 05 0B 0B 1543*      call printInline
0B0B79 61 66 3D 00 1544*      asciz "af="
0B0B7D 2A F8 0B 0B 1545*      ld hl,(@uaf)
0B0B81 CD 2C 0B 0B 1546*      call printHex24
0B0B85             1547*  
0B0B85 CD 05 0B 0B 1548*      call printInline
0B0B89 20 68 6C 3D 1549*      asciz " hl="
       00          
0B0B8E 2A FB 0B 0B 1550*      ld hl,(@uhl)
0B0B92 CD 2C 0B 0B 1551*      call printHex24
0B0B96             1552*  
0B0B96 CD 05 0B 0B 1553*      call printInline
0B0B9A 20 62 63 3D 1554*      asciz " bc="
       00          
0B0B9F 2A FE 0B 0B 1555*      ld hl,(@ubc)
0B0BA3 CD 2C 0B 0B 1556*      call printHex24
0B0BA7             1557*  
0B0BA7 CD 05 0B 0B 1558*      call printInline
0B0BAB 20 64 65 3D 1559*      asciz " de="
       00          
0B0BB0 2A 01 0C 0B 1560*      ld hl,(@ude)
0B0BB4 CD 2C 0B 0B 1561*      call printHex24
0B0BB8             1562*  
0B0BB8 CD 05 0B 0B 1563*      call printInline
0B0BBC 20 69 78 3D 1564*      asciz " ix="
       00          
0B0BC1 2A 04 0C 0B 1565*      ld hl,(@uix)
0B0BC5 CD 2C 0B 0B 1566*      call printHex24
0B0BC9             1567*  
0B0BC9 CD 05 0B 0B 1568*      call printInline
0B0BCD 20 69 79 3D 1569*      asciz " iy="
       00          
0B0BD2 2A 07 0C 0B 1570*      ld hl,(@uiy)
0B0BD6 CD 2C 0B 0B 1571*      call printHex24
0B0BDA             1572*  
0B0BDA CD 21 0B 0B 1573*      call printNewLine
0B0BDE             1574*  ; restore everything
0B0BDE 2A FB 0B 0B 1575*      ld hl, (@uhl)
0B0BE2 ED 4B FE 0B 1576*      ld bc, (@ubc)
       0B          
0B0BE7 ED 5B 01 0C 1577*      ld de, (@ude)
       0B          
0B0BEC DD 2A 04 0C 1578*      ld ix, (@uix)
       0B          
0B0BF1 FD 2A 07 0C 1579*      ld iy, (@uiy)
       0B          
0B0BF6 F1          1580*      pop af
0B0BF7             1581*  ; all done
0B0BF7 C9          1582*      ret
0B0BF8             1583*  
0B0BF8 00 00 00    1584*  @uaf: dl 0
0B0BFB 00 00 00    1585*  @uhl: dl 0
0B0BFE 00 00 00    1586*  @ubc: dl 0
0B0C01 00 00 00    1587*  @ude: dl 0
0B0C04 00 00 00    1588*  @uix: dl 0
0B0C07 00 00 00    1589*  @uiy: dl 0
0B0C0A             1590*  
0B0C0A             1591*  ; Prints the right justified decimal value in HL without leading zeroes
0B0C0A             1592*  ; HL : Value to print
0B0C0A             1593*  ; preserves all registers and flags
0B0C0A             1594*  printDec:
0B0C0A             1595*  ; BEGIN MY CODE
0B0C0A             1596*  ; back up all the things
0B0C0A F5          1597*      push af
0B0C0B C5          1598*      push bc
0B0C0C D5          1599*      push de
0B0C0D E5          1600*      push hl
0B0C0E             1601*  ; END MY CODE
0B0C0E 11 36 0C 0B 1602*  	LD	 DE, _printDecBuffer
0B0C12 CD 46 0C 0B 1603*  	CALL u24_to_ascii
0B0C16             1604*  ; BEGIN MY CODE
0B0C16             1605*  ; replace leading zeroes with spaces
0B0C16 21 36 0C 0B 1606*      LD	 HL, _printDecBuffer
0B0C1A 06 07       1607*      ld   B, 7 ; if HL was 0, we want to keep the final zero
0B0C1C             1608*  @loop:
0B0C1C 7E          1609*      LD	 A, (HL)
0B0C1D FE 30       1610*      CP	 '0'
0B0C1F C2 29 0C 0B 1611*      JP	 NZ, @done
0B0C23 3E 20       1612*      LD   A, ' '
0B0C25 77          1613*      LD	 (HL), A
0B0C26 23          1614*      INC	 HL
0B0C27             1615*      ; CALL vdu_cursor_forward
0B0C27 10 F3       1616*      DJNZ @loop
0B0C29             1617*  @done:
0B0C29             1618*  ; END MY CODE
0B0C29 21 36 0C 0B 1619*  	LD	 HL, _printDecBuffer
0B0C2D CD 0C 0B 0B 1620*  	CALL printString
0B0C31             1621*  ; BEGIN MY CODE
0B0C31             1622*  ; restore all the things
0B0C31 E1          1623*      pop hl
0B0C32 D1          1624*      pop de
0B0C33 C1          1625*      pop bc
0B0C34 F1          1626*      pop af
0B0C35             1627*  ; END MY CODE
0B0C35 C9          1628*  	RET
0B0C36 00 00 00 00 1629*  _printDecBuffer: blkb 16,0 ; a few bytes extra just to be sure
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0B0C46             1630*  
0B0C46             1631*  ; This routine converts the unsigned 24-bit value in HLU into it's ASCII representation,
0B0C46             1632*  ; starting to memory location pointing by DE, in decimal form and with leading zeroes
0B0C46             1633*  ; so it will allways be 8 characters length
0B0C46             1634*  ; HL : Value to convert to string
0B0C46             1635*  ; DE : pointer to buffer, at least 8 byte + 0
0B0C46             1636*  u24_to_ascii:
0B0C46 01 80 69 67 1637*  	LD	 BC,-10000000
0B0C4A CD 7D 0C 0B 1638*  	CALL @one_digit
0B0C4E 01 C0 BD F0 1639*  	LD	 BC,-1000000
0B0C52 CD 7D 0C 0B 1640*  	CALL @one_digit
0B0C56 01 60 79 FE 1641*  	LD	 BC,-100000
0B0C5A CD 7D 0C 0B 1642*  	CALL @one_digit
0B0C5E 01 F0 D8 FF 1643*  	LD   BC,-10000
0B0C62 CD 7D 0C 0B 1644*  	CALL @one_digit
0B0C66 01 18 FC FF 1645*  	LD   BC,-1000
0B0C6A CD 7D 0C 0B 1646*  	CALL @one_digit
0B0C6E 01 9C FF FF 1647*  	LD   BC,-100
0B0C72 CD 7D 0C 0B 1648*  	CALL @one_digit
0B0C76 0E F6       1649*  	LD   C,-10
0B0C78 CD 7D 0C 0B 1650*  	CALL @one_digit
0B0C7C 48          1651*  	LD   C,B
0B0C7D             1652*  @one_digit:
0B0C7D 3E 2F       1653*  	LD   A,'0'-1
0B0C7F             1654*  @divide_me:
0B0C7F 3C          1655*  	INC  A
0B0C80 09          1656*  	ADD  HL,BC
0B0C81 38 FC       1657*  	JR   C,@divide_me
0B0C83 ED 42       1658*  	SBC  HL,BC
0B0C85 12          1659*  	LD   (DE),A
0B0C86 13          1660*  	INC  DE
0B0C87 C9          1661*  	RET
0B0C88             1662*  
0B0C88             1663*  print_u24:
0B0C88 D5          1664*      push de
0B0C89 E5          1665*      push hl
0B0C8A 11 36 0C 0B 1666*      ld de,_printDecBuffer
0B0C8E CD 46 0C 0B 1667*      call u24_to_ascii
0B0C92 21 36 0C 0B 1668*      ld hl,_printDecBuffer
0B0C96 CD 0C 0B 0B 1669*      call printString
0B0C9A 3E 20       1670*      ld a,' '
0B0C9C 5B D7       1671*      rst.lil 10h
0B0C9E E1          1672*      pop hl
0B0C9F D1          1673*      pop de
0B0CA0 C9          1674*      ret
0B0CA1             1675*  
0B0CA1             1676*  ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
0B0CA1             1677*  ; HL : Value to convert to string (integer part in H, fractional part in L)
0B0CA1             1678*  ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
0B0CA1             1679*  u168_to_ascii:
0B0CA1             1680*  ; add a leading space to make room for sign flag if needed
0B0CA1 3E 20       1681*      ld a,' '
0B0CA3 12          1682*      ld (de),a
0B0CA4 13          1683*      inc de
0B0CA5             1684*  ; Convert integer part
0B0CA5 E5          1685*      push hl               ; Save HL (we’ll need the fractional part later)
0B0CA6 CD B7 00 0B 1686*      call hlu_udiv256    ; Shift to get integer portion in HL
0B0CAA 01 F0 D8 FF 1687*      ld   bc, -10000
0B0CAE CD D1 0C 0B 1688*      call @one_int
0B0CB2 01 18 FC FF 1689*      ld   bc, -1000
0B0CB6 CD D1 0C 0B 1690*      call @one_int
0B0CBA 01 9C FF FF 1691*      ld   bc, -100
0B0CBE CD D1 0C 0B 1692*      call @one_int
0B0CC2 0E F6       1693*      ld   c, -10
0B0CC4 CD D1 0C 0B 1694*      call @one_int
0B0CC8 48          1695*      ld   c, b
0B0CC9 CD D1 0C 0B 1696*      call @one_int
0B0CCD C3 DC 0C 0B 1697*      jp   @frac            ; Jump to fractional part conversion
0B0CD1             1698*  @one_int:
0B0CD1 3E 2F       1699*      ld   a, '0' - 1       ; Start ASCII character at '0'
0B0CD3             1700*  @divide_me:
0B0CD3 3C          1701*      inc  a
0B0CD4 09          1702*      add  hl, bc           ; Accumulate until overflow
0B0CD5 38 FC       1703*      jr   c, @divide_me
0B0CD7 ED 42       1704*      sbc  hl, bc           ; Remove excess after overflow
0B0CD9 12          1705*      ld   (de), a          ; Store ASCII digit
0B0CDA 13          1706*      inc  de
0B0CDB C9          1707*      ret
0B0CDC             1708*  ; Convert fractional part
0B0CDC             1709*  @frac:
0B0CDC 3E 2E       1710*      ld   a, '.'           ; Decimal point
0B0CDE 12          1711*      ld   (de), a
0B0CDF 13          1712*      inc  de
0B0CE0 E1          1713*      pop  hl               ; Restore HL with original fraction
0B0CE1 06 03       1714*      ld   b, 3             ; Loop counter for 3 fractional digits
0B0CE3             1715*  @frac_loop:
0B0CE3 26 0A       1716*      ld   h, 10            ; Load multiplier for fractional part
0B0CE5 ED 6C       1717*      mlt  hl               ; Multiply by 10, result in HL (H holds the integer part)
0B0CE7 3E 30       1718*      ld   a, '0'
0B0CE9 84          1719*      add  a, h             ; Convert integer part to ASCII
0B0CEA 12          1720*      ld   (de), a
0B0CEB 13          1721*      inc  de
0B0CEC 10 F5       1722*      djnz @frac_loop       ; Repeat for each fractional digit
0B0CEE             1723*  ; Add null terminator
0B0CEE AF          1724*      xor  a                ; Null terminator
0B0CEF 12          1725*      ld   (de), a
0B0CF0 C9          1726*      ret
0B0CF1             1727*  
0B0CF1             1728*  print_u168:
0B0CF1 D5          1729*      push de
0B0CF2 E5          1730*      push hl
0B0CF3 11 36 0C 0B 1731*      ld de,_printDecBuffer
0B0CF7 CD A1 0C 0B 1732*      call u168_to_ascii
0B0CFB 21 36 0C 0B 1733*      ld hl,_printDecBuffer
0B0CFF CD 0C 0B 0B 1734*      call printString
0B0D03 E1          1735*      pop hl
0B0D04 D1          1736*      pop de
0B0D05 C9          1737*      ret
0B0D06             1738*  
0B0D06             1739*  ; signed version of u168_to_ascii
0B0D06             1740*  s168_to_ascii:
0B0D06 D5          1741*      push de ; save starting address of buffer
0B0D07 CD C4 00 0B 1742*      call hlu_abs
0B0D0B F5          1743*      push af ; save sign flag
0B0D0C CD A1 0C 0B 1744*      call u168_to_ascii
0B0D10 F1          1745*      pop af ; restore sign flag
0B0D11 D1          1746*      pop de ; restore starting address of buffer
0B0D12 F0          1747*      ret p ; hlu was positive so nothing to do
0B0D13 3E 2D       1748*      ld a,'-'
0B0D15 12          1749*      ld (de),a
0B0D16 C9          1750*      ret
0B0D17             1751*  
0B0D17             1752*  print_s168:
0B0D17 D5          1753*      push de
0B0D18 E5          1754*      push hl
0B0D19 11 36 0C 0B 1755*      ld de,_printDecBuffer
0B0D1D CD 06 0D 0B 1756*      call s168_to_ascii
0B0D21 21 36 0C 0B 1757*      ld hl,_printDecBuffer
0B0D25 CD 0C 0B 0B 1758*      call printString
0B0D29 E1          1759*      pop hl
0B0D2A D1          1760*      pop de
0B0D2B C9          1761*      ret
0B0D2C             1762*  
0B0D2C             1763*  	; include "parse.inc"
0B0D2C             1764*  
0B0D2C             1765*  ;
0B0D2C             1766*  ; Title:	Number Parsing Functions
0B0D2C             1767*  ; Author:	Dean Belfield
0B0D2C             1768*  ; Created:	15/11/2022
0B0D2C             1769*  ; Last Updated:	15/11/2022
0B0D2C             1770*  ; Last Updated: 29/12/2022 Lennart Benchop adapt for 24-bit mode.
0B0D2C             1771*  ; Modinfo:
0B0D2C             1772*  ; 2024/04/08    Adapt for ez80asm
0B0D2C             1773*  
0B0D2C             1774*  ; Read a number and convert to binary
0B0D2C             1775*  ; If prefixed with &, will read as hex, otherwise decimal
0B0D2C             1776*  ;   Inputs: HL: Pointer in string buffer
0B0D2C             1777*  ;  Outputs: HL: Updated text pointer
0B0D2C             1778*  ;           DE: Value
0B0D2C             1779*  ;            A: Terminator (spaces skipped)
0B0D2C             1780*  ;            F: Carry set if valid number, otherwise reset
0B0D2C             1781*  ; Destroys: A,D,E,H,L,F
0B0D2C             1782*  ;
0B0D2C 11 00 00 00 1783*  ASC_TO_NUMBER:		LD		DE, 0			; Initialise DE
0B0D30             1784*  			; CALL		_skip_spaces		; Skip whitespace
0B0D30 7E          1785*  			LD		A, (HL)			; Read first character
0B0D31 B7          1786*  			OR		A			; Check for end of string
0B0D32 C8          1787*  			RET		Z			; Return with no carry if not
0B0D33 C5          1788*  			PUSH		BC			; Preserve BC
0B0D34 FE 26       1789*  			CP		'&'			; Is it prefixed with '&' (HEX number)?
0B0D36 20 23       1790*  			JR		NZ, ASC_TO_NUMBER3	; Jump to decimal parser if not
0B0D38 23          1791*  			INC		HL			; Otherwise fall through to ASC_TO_HEX
0B0D39             1792*  ;
0B0D39 7E          1793*  ASC_TO_NUMBER1:		LD		A, (HL)			; Fetch the character
0B0D3A CD 7C 0D 0B 1794*  			CALL   	 	UPPRC			; Convert to uppercase
0B0D3E D6 30       1795*  			SUB		'0'			; Normalise to 0
0B0D40 38 37       1796*  			JR 		C, ASC_TO_NUMBER4	; Return if < ASCII '0'
0B0D42 FE 0A       1797*  			CP 		10			; Check if >= 10
0B0D44 38 06       1798*  			JR 		C, ASC_TO_NUMBER2	; No, so skip next bit
0B0D46 D6 07       1799*  			SUB 		7			; Adjust ASCII A-F to nibble
0B0D48 FE 10       1800*  			CP 		16			; Check for > F
0B0D4A 30 2D       1801*  			JR 		NC, ASC_TO_NUMBER4	; Return if out of range
0B0D4C             1802*  ;
0B0D4C E5          1803*  ASC_TO_NUMBER2:		PUSH		HL			; Stack HL
0B0D4D D5          1804*  			PUSH		DE			; LD HL, DE
0B0D4E E1          1805*  			POP		HL
0B0D4F 29          1806*  			ADD		HL, HL
0B0D50 29          1807*  			ADD		HL, HL
0B0D51 29          1808*  			ADD		HL, HL
0B0D52 29          1809*  			ADD		HL, HL
0B0D53 E5          1810*  			PUSH		HL			; LD DE, HL
0B0D54 D1          1811*  			POP		DE
0B0D55 E1          1812*  			POP		HL			; Restore HL
0B0D56 B3          1813*  			OR      	E			; OR the new digit in to the least significant nibble
0B0D57 5F          1814*  			LD      	E, A
0B0D58             1815*  ;
0B0D58 23          1816*  			INC		HL			; Onto the next character
0B0D59 18 DE       1817*  			JR      	ASC_TO_NUMBER1		; And loop
0B0D5B             1818*  ;
0B0D5B 7E          1819*  ASC_TO_NUMBER3:		LD		A, (HL)
0B0D5C D6 30       1820*  			SUB		'0'			; Normalise to 0
0B0D5E 38 19       1821*  			JR		C, ASC_TO_NUMBER4	; Return if < ASCII '0'
0B0D60 FE 0A       1822*  			CP		10			; Check if >= 10
0B0D62 30 15       1823*  			JR		NC, ASC_TO_NUMBER4	; Return if >= 10
0B0D64             1824*  ;
0B0D64 E5          1825*  			PUSH		HL			; Stack HL
0B0D65 D5          1826*  			PUSH		DE			; LD HL, DE
0B0D66 E1          1827*  			POP		HL
0B0D67 E5          1828*  			PUSH		HL			; LD BC, HL
0B0D68 C1          1829*  			POP		BC
0B0D69 29          1830*  			ADD		HL, HL 			; x 2
0B0D6A 29          1831*  			ADD		HL, HL 			; x 4
0B0D6B 09          1832*  			ADD		HL, BC 			; x 5
0B0D6C 29          1833*  			ADD		HL, HL 			; x 10
0B0D6D 01 00 00 00 1834*  			LD		BC, 0
0B0D71 4F          1835*  			LD 		C, A			; LD BCU, A
0B0D72 09          1836*  			ADD		HL, BC			; Add BCU to HL
0B0D73 E5          1837*  			PUSH		HL			; LD DE, HL
0B0D74 D1          1838*  			POP		DE
0B0D75 E1          1839*  			POP		HL			; Restore HL
0B0D76             1840*  ;
0B0D76 23          1841*  			INC		HL
0B0D77 18 E2       1842*  			JR		ASC_TO_NUMBER3
0B0D79 C1          1843*  ASC_TO_NUMBER4:		POP		BC
0B0D7A 37          1844*  			SCF					; We have a valid number so set carry
0B0D7B C9          1845*  			RET
0B0D7C             1846*  
0B0D7C             1847*  
0B0D7C             1848*  ; Convert a character to upper case
0B0D7C             1849*  ;  A: Character to convert
0B0D7C             1850*  ;
0B0D7C E6 7F       1851*  UPPRC:  		AND     	7FH
0B0D7E FE 60       1852*  			CP      	'`'
0B0D80 D8          1853*  			RET     	C
0B0D81 E6 5F       1854*  			AND     	5FH			; Convert to upper case
0B0D83 C9          1855*  			RET
0B0D84             1856*  
0B0D84             1857*  ; -----------------------------------------------------------------------
0B0D84             1858*  ;
0B0D84             1859*  ; additional functions by Brandon R. Gates based on Dean's code
0B0D84             1860*  ;
0B0D84             1861*  ;------------------------------------------------------------------------
0B0D84             1862*  ; Read a number and convert to binary (decimal only)
0B0D84             1863*  ; Inputs: hl: Pointer in string buffer
0B0D84             1864*  ; Outputs: hl: Updated text pointer
0B0D84             1865*  ;         de: Value
0B0D84             1866*  ;         a: Terminator (spaces skipped)
0B0D84             1867*  ;         f: Carry set if valid number, otherwise reset
0B0D84             1868*  ; Destroys: a, d, e, h, l, f
0B0D84             1869*  ;------------------------------------------------------------------------
0B0D84             1870*  asc_to_s24:
0B0D84 3E 01       1871*      ld a,1 ; set sign flag
0B0D86 32 D2 0D 0B 1872*      ld (@sign),a ; store sign flag
0B0D8A             1873*  
0B0D8A 11 00 00 00 1874*      ld de, 0 ; initialise de
0B0D8E             1875*      ; call _skip_spaces ; skip whitespace
0B0D8E             1876*  
0B0D8E 7E          1877*      ld a, (hl) ; read first character
0B0D8F B7          1878*      or a ; check for end of string
0B0D90 C8          1879*      ret z ; return with no carry if not
0B0D91             1880*  
0B0D91 C5          1881*      push bc ; preserve bc
0B0D92             1882*  
0B0D92 FE 2D       1883*      cp '-' ; check for negative number
0B0D94 C2 9E 0D 0B 1884*      jp nz,@loop ; number is positive, nothing more to do
0B0D98 AF          1885*      xor a ; sign flag to zero
0B0D99 32 D2 0D 0B 1886*      ld (@sign),a ; store sign flag
0B0D9D 23          1887*      inc hl ; skip '-'
0B0D9E             1888*  
0B0D9E             1889*  @loop:
0B0D9E 7E          1890*      ld a, (hl)
0B0D9F D6 30       1891*      sub '0' ; normalise to 0
0B0DA1 38 19       1892*      jr c, @integer_end ; return if < ascii '0'
0B0DA3 FE 0A       1893*      cp 10 ; check if >= 10
0B0DA5 30 15       1894*      jr nc, @integer_end ; return if >= 10
0B0DA7 E5          1895*      push hl ; stack hl
0B0DA8 D5          1896*      push de ; ld hl, de
0B0DA9 E1          1897*      pop hl
0B0DAA E5          1898*      push hl ; ld bc, hl
0B0DAB C1          1899*      pop bc
0B0DAC 29          1900*      add hl, hl ; x 2
0B0DAD 29          1901*      add hl, hl ; x 4
0B0DAE 09          1902*      add hl, bc ; x 5
0B0DAF 29          1903*      add hl, hl ; x 10
0B0DB0 01 00 00 00 1904*      ld bc, 0
0B0DB4 4F          1905*      ld c, a ; ld bcu, a
0B0DB5 09          1906*      add hl, bc ; add bcu to hl
0B0DB6 E5          1907*      push hl ; ld de, hl
0B0DB7 D1          1908*      pop de
0B0DB8 E1          1909*      pop hl ; restore hl
0B0DB9 23          1910*      inc hl
0B0DBA 18 E2       1911*      jr @loop
0B0DBC             1912*  
0B0DBC             1913*  @integer_end:
0B0DBC C1          1914*      pop bc ; send bc back how she came in
0B0DBD 3A D2 0D 0B 1915*      ld a, (@sign) ; get sign flag
0B0DC1 3D          1916*      dec a ; check if negative
0B0DC2 F2 D0 0D 0B 1917*      jp p,@pos ; positive number
0B0DC6             1918*  
0B0DC6             1919*  ; Negate de
0B0DC6 E5          1920*      push hl ; save text pointer
0B0DC7 21 00 00 00 1921*      ld hl, 0
0B0DCB AF          1922*      xor a ; clear carry
0B0DCC ED 52       1923*      sbc hl, de ; subtract DE from HL
0B0DCE EB          1924*      ex de, hl ; DE = 0-HL
0B0DCF E1          1925*      pop hl ; restore text pointer
0B0DD0             1926*  
0B0DD0             1927*  @pos:
0B0DD0 37          1928*      scf ; we have a valid number so set carry
0B0DD1 C9          1929*      ret
0B0DD2             1930*  
0B0DD2 00          1931*  @sign: db 0 ; sign flag buffer
0B0DD3             1932*  
0B0DD3             1933*  
0B0DD3             1934*  ;------------------------------------------------------------------------
0B0DD3             1935*  ; Read a number and convert to binary (decimal only)
0B0DD3             1936*  ; Inputs: hl: Pointer in string buffer
0B0DD3             1937*  ; Outputs: hl: Updated text pointer
0B0DD3             1938*  ;         de: Value
0B0DD3             1939*  ;         a: Terminator (spaces skipped)
0B0DD3             1940*  ;         f: Carry set if valid number, otherwise reset
0B0DD3             1941*  ; Destroys: a, d, e, h, l, f
0B0DD3             1942*  ;------------------------------------------------------------------------
0B0DD3             1943*  asc_to_s168:
0B0DD3 3E 01       1944*      ld a,1 ; set sign flag
0B0DD5 32 92 0E 0B 1945*      ld (@sign),a ; store sign flag
0B0DD9             1946*  
0B0DD9 11 00 00 00 1947*      ld de, 0 ; initialise de
0B0DDD ED 53 8A 0E 1948*      ld (@result), de ; clear low bytes of result buffer
       0B          
0B0DE2 ED 53 8E 0E 1949*      ld (@scratch), de ; clear low bytes of scratch buffer
       0B          
0B0DE7             1950*  
0B0DE7             1951*      ; call _skip_spaces ; skip whitespace
0B0DE7             1952*  
0B0DE7 7E          1953*      ld a, (hl) ; read first character
0B0DE8 B7          1954*      or a ; check for end of string
0B0DE9 C8          1955*      ret z ; return with no carry if not
0B0DEA             1956*  
0B0DEA C5          1957*      push bc ; preserve bc
0B0DEB             1958*  
0B0DEB FE 2D       1959*      cp '-' ; check for negative number
0B0DED C2 F7 0D 0B 1960*      jp nz,@loop ; number is positive, nothing more to do
0B0DF1 AF          1961*      xor a ; sign flag to zero
0B0DF2 32 92 0E 0B 1962*      ld (@sign),a ; store sign flag
0B0DF6 23          1963*      inc hl ; skip '-'
0B0DF7             1964*  
0B0DF7             1965*  @loop:
0B0DF7 7E          1966*      ld a, (hl)
0B0DF8             1967*  
0B0DF8             1968*  ; chcek for decimal point
0B0DF8 FE 2E       1969*      cp '.' ; check for decimal point
0B0DFA CA 3B 0E 0B 1970*      jp z,@fractional_start ; jump to fractional part
0B0DFE             1971*  
0B0DFE             1972*  ; process integer part
0B0DFE D6 30       1973*      sub '0' ; normalise to 0
0B0E00 38 19       1974*      jr c, @integer_end ; return if < ascii '0'
0B0E02 FE 0A       1975*      cp 10 ; check if >= 10
0B0E04 30 15       1976*      jr nc, @integer_end ; return if >= 10
0B0E06 E5          1977*      push hl ; stack hl
0B0E07 D5          1978*      push de ; ld hl, de
0B0E08 E1          1979*      pop hl
0B0E09 E5          1980*      push hl ; ld bc, hl
0B0E0A C1          1981*      pop bc
0B0E0B 29          1982*      add hl, hl ; x 2
0B0E0C 29          1983*      add hl, hl ; x 4
0B0E0D 09          1984*      add hl, bc ; x 5
0B0E0E 29          1985*      add hl, hl ; x 10
0B0E0F 01 00 00 00 1986*      ld bc, 0
0B0E13 4F          1987*      ld c, a ; ld bcu, a
0B0E14 09          1988*      add hl, bc ; add bcu to hl
0B0E15 E5          1989*      push hl ; ld de, hl
0B0E16 D1          1990*      pop de
0B0E17 E1          1991*      pop hl ; restore hl
0B0E18 23          1992*      inc hl
0B0E19 18 DC       1993*      jr @loop
0B0E1B             1994*  
0B0E1B             1995*  @integer_end:
0B0E1B ED 53 8B 0E 1996*      ld (@result+1), de      ; Store integer part in result buffer (shifted up one byte)
       0B          
0B0E20             1997*  
0B0E20             1998*  @end:
0B0E20 C1          1999*      pop bc ; send bc back how she came in
0B0E21 ED 5B 8A 0E 2000*      ld de,(@result) ; will contain shifted integer part combined with any fractional value
       0B          
0B0E26 3A 92 0E 0B 2001*      ld a, (@sign) ; get sign flag
0B0E2A 3D          2002*      dec a ; check if negative
0B0E2B F2 39 0E 0B 2003*      jp p,@pos ; positive number
0B0E2F             2004*  
0B0E2F             2005*  ; Negate de
0B0E2F E5          2006*      push hl ; save text pointer
0B0E30 21 00 00 00 2007*      ld hl, 0
0B0E34 AF          2008*      xor a ; clear carry
0B0E35 ED 52       2009*      sbc hl, de ; subtract DE from HL
0B0E37 EB          2010*      ex de, hl ; DE = 0-HL
0B0E38 E1          2011*      pop hl ; restore text pointer
0B0E39             2012*  
0B0E39             2013*  @pos:
0B0E39 37          2014*      scf ; we have a valid number so set carry
0B0E3A C9          2015*      ret
0B0E3B             2016*  
0B0E3B             2017*  @fractional_start:
0B0E3B DD E5       2018*      push ix                    ; preserve ix
0B0E3D ED 53 8B 0E 2019*      ld (@result+1), de         ; Store integer part in result buffer (shifted up one byte)
       0B          
0B0E42 06 03       2020*      ld b, 3                    ; Set loop counter to 3 for up to three fractional digits
0B0E44 11 00 00 00 2021*      ld de, 0                   ; Initialize DE as the fractional accumulator
0B0E48 DD 21 93 0E 2022*      ld ix, powers_of_10        ; Point IX to the lookup table for the scaling factor based on digits
       0B          
0B0E4D 23          2023*      inc hl                     ; Skip decimal point
0B0E4E             2024*  
0B0E4E             2025*  @fractional_loop:
0B0E4E 7E          2026*      ld a, (hl)                 ; Load next character
0B0E4F D6 30       2027*      sub '0'                    ; Normalize ASCII to decimal
0B0E51 38 1C       2028*      jr c, @end_fraction        ; Exit if < '0'
0B0E53 FE 0A       2029*      cp 10
0B0E55 30 18       2030*      jr nc, @end_fraction       ; Exit if >= 10
0B0E57             2031*  
0B0E57             2032*      ; Multiply the current fractional accumulator by 10
0B0E57 E5          2033*      push hl                    ; Save char pointer
0B0E58 F5          2034*      push af                    ; Save the digit
0B0E59 EB          2035*      ex de, hl
0B0E5A E5          2036*      push hl
0B0E5B 29          2037*      add hl,hl ; * 2
0B0E5C 29          2038*      add hl,hl ; * 4
0B0E5D D1          2039*      pop de
0B0E5E 19          2040*      add hl,de ; * 5
0B0E5F 29          2041*      add hl,hl ; * 10
0B0E60 11 00 00 00 2042*      ld de, 0                   ; Clear DEU
0B0E64 F1          2043*      pop af                     ; Restore the current digit
0B0E65 5F          2044*      ld e, a                    ; Load the digit into E
0B0E66 19          2045*      add hl, de                 ; Add the digit to the accumulator
0B0E67 EB          2046*      ex de, hl                  ; Result back to DE
0B0E68 ED 32 03    2047*      lea ix,ix+3                ; Advance IX to the next scaling factor
0B0E6B E1          2048*      pop hl                     ; Restore char pointer
0B0E6C 23          2049*      inc hl                     ; Move to the next character
0B0E6D 10 DF       2050*      djnz @fractional_loop      ; Loop if more digits to process
0B0E6F             2051*  
0B0E6F             2052*  @end_fraction:
0B0E6F             2053*  ; Final scaling based on number of fractional digits processed
0B0E6F ED 53 8F 0E 2054*      ld (@scratch+1), de          ; Shift fractional part up a byte
       0B          
0B0E74 2A 8E 0E 0B 2055*      ld hl,(@scratch)             ; Load the shifted fractional part into HL
0B0E78             2056*  
0B0E78 DD 17 00    2057*      ld de, (ix)                ; Load final scaling factor from IX based on digit count
0B0E7B CD 34 02 0B 2058*      call udiv24                ; Perform 24-bit division to scale down
0B0E7F 7B          2059*      ld a, e                    ; Load the low byte (8-bit fractional part) into A
0B0E80 32 8A 0E 0B 2060*      ld (@result), a            ; Store fractional part in result buffer
0B0E84 DD E1       2061*      pop ix                     ; Restore ix
0B0E86 C3 20 0E 0B 2062*      jp @end                    ; Final sign check and flag setup
0B0E8A             2063*  
0B0E8A             2064*  @result: ds 4                  ; 32-bit result buffer to shift integer part up one byte
0B0E8E             2065*  @scratch: ds 4                 ; 32-bit scratch buffer for intermediate calculations
0B0E92 00          2066*  @sign: db 0                    ; Sign flag buffer
0B0E93             2067*  
0B0E93             2068*  powers_of_10:
0B0E93 01 00 00    2069*      dl 1                       ; 10^0
0B0E96 0A 00 00    2070*      dl 10                      ; 10^1
0B0E99 64 00 00    2071*      dl 100                     ; 10^2
0B0E9C E8 03 00    2072*      dl 1000                    ; 10^3
0B0E9F 10 27 00    2073*      dl 10000                   ; 10^4
0B0EA2             0059   
0B0EA2             0060   ; --- MAIN PROGRAM ---
0B0EA2             0061   main:
0B0EA2 0D          0062       dec c ; decrement the argument count to skip the program name
0B0EA3             0063   
0B0EA3             0064   ; compute distance between the origin and a point entered by the user
0B0EA3 CD 45 0F 0B 0065       call get_arg_s168
0B0EA7 ED 53 38 0F 0066       ld (@arg1),de ; dx
       0B          
0B0EAC CD 45 0F 0B 0067       call get_arg_s168
0B0EB0 ED 53 3B 0F 0068       ld (@arg2),de ; dy
       0B          
0B0EB5             0069   
0B0EB5             0070   ; echo the input
0B0EB5 CD 05 0B 0B 0071       call printInline
0B0EB9 64 69 73 74 0072       asciz "distance to target at: "
       61 6E 63 65 
       20 74 6F 20 
       74 61 72 67 
       65 74 20 61 
       74 3A 20 00 
0B0ED1 2A 38 0F 0B 0073       ld hl,(@arg1)
0B0ED5 CD 17 0D 0B 0074       call print_s168
0B0ED9 3E 2C       0075       ld a,',' ; print a comma
0B0EDB 5B D7       0076       rst.lil 10h
0B0EDD 2A 3B 0F 0B 0077       ld hl,(@arg2)
0B0EE1 CD 17 0D 0B 0078       call print_s168
0B0EE5 CD 05 0B 0B 0079       call printInline
0B0EE9 20 3D 20 00 0080       asciz " = "
0B0EED             0081   
0B0EED             0082   ; compute the distance
0B0EED DD 2A 38 0F 0083       ld ix,(@arg1) ; x1
       0B          
0B0EF2 FD 2A 3B 0F 0084       ld iy,(@arg2) ; y1
       0B          
0B0EF7 01 00 00 00 0085       ld bc,0 ; x1 0
0B0EFB 11 00 00 00 0086       ld de,0 ; y1 0
0B0EFF CD 08 03 0B 0087       call distance168
0B0F03 CD 17 0D 0B 0088       call print_s168
0B0F07             0089   
0B0F07             0090   ; compute angle between the origin and the point entered by the user
0B0F07 CD 05 0B 0B 0091       call printInline
0B0F0B 0D 0A 74 61 0092       asciz "\r\ntarget bearing: "
       72 67 65 74 
       20 62 65 61 
       72 69 6E 67 
       3A 20 00    
0B0F1E ED 4B FC 02 0093       ld bc,(dx168)
       0B          
0B0F23 ED 5B 02 03 0094       ld de,(dy168)
       0B          
0B0F28 CD 3E 03 0B 0095       call atan2_168fast ; uh.l = atan2(dx,-dy) in deg256
0B0F2C CD 71 02 0B 0096       call deg_256_to_360 ; convert to 360 degree circle
0B0F30 CD 17 0D 0B 0097       call print_s168
0B0F34             0098   
0B0F34 C3 8E 00 0B 0099       jp _main_end_ok
0B0F38             0100   
0B0F38             0101   ; ; test deg_360_to_256
0B0F38             0102   ;     call get_arg_s168
0B0F38             0103   ;     ld (@arg1),de
0B0F38             0104   ;     ex de,hl
0B0F38             0105   ;     call print_s168
0B0F38             0106   ;     ld hl,(@arg1)
0B0F38             0107   ;     call deg_360_to_256
0B0F38             0108   ;     call print_s168
0B0F38             0109   ;     call printNewLine
0B0F38             0110   ;     jp _main_end_ok
0B0F38             0111   
0B0F38             0112   ; ; test deg_256_to_360
0B0F38             0113   ;     call get_arg_s168
0B0F38             0114   ;     ld (@arg1),de
0B0F38             0115   ;     ex de,hl
0B0F38             0116   ;     call print_s168
0B0F38             0117   ;     ld hl,(@arg1)
0B0F38             0118   ;     call deg_256_to_360
0B0F38             0119   ;     call print_s168
0B0F38             0120   ;     call printNewLine
0B0F38             0121   ;     jp _main_end_ok
0B0F38             0122   
0B0F38 00 00 00    0123   @arg1: dl 0
0B0F3B 00 00 00    0124   @arg2: dl 0
0B0F3E             0125   
0B0F3E             0126   ; ========== HELPER FUNCTIONS ==========
0B0F3E             0127   ; get the next argument after ix as a string
0B0F3E             0128   ; inputs: ix = pointer to the argument string
0B0F3E             0129   ; outputs: HL = pointer to the argument string, ix points to the next argument
0B0F3E             0130   ; destroys: a, h, l, f
0B0F3E             0131   get_arg_text:
0B0F3E ED 32 03    0132       lea ix,ix+3 ; point to the next argument
0B0F41 DD 27 00    0133       ld hl,(ix) ; get the argument string
0B0F44 C9          0134       ret
0B0F45             0135   
0B0F45             0136   ; get the next argument after ix as a signed 16.8 fixed point number
0B0F45             0137   ; inputs: ix = pointer to the argument string
0B0F45             0138   ; outputs: ude = signed 16.8 fixed point number
0B0F45             0139   ; destroys: a, d, e, h, l, f
0B0F45             0140   get_arg_s168:
0B0F45 ED 32 03    0141       lea ix,ix+3 ; point to the next argument
0B0F48 DD 27 00    0142       ld hl,(ix) ; get the argument string
0B0F4B CD D3 0D 0B 0143       call asc_to_s168 ; convert the string to a number
0B0F4F C9          0144       ret ; return with the value in DE
0B0F50             0145   
0B0F50             0146   ; Inputs: ix = pointer to the argument string
0B0F50             0147   ; Outputs: ude = signed 24-bit integer
0B0F50             0148   ; Destroys: a, d, e, h, l, f
0B0F50             0149   get_arg_s24:
0B0F50 ED 32 03    0150       lea ix,ix+3 ; point to the next argument
0B0F53 DD 27 00    0151       ld hl,(ix) ; get the argument string
0B0F56 CD 84 0D 0B 0152       call asc_to_s24 ; convert the string to a number
0B0F5A C9          0153       ret ; return with the value in DE
0B0F5B             0154   
0B0F5B             0155   ; match the next argument after ix to the dispatch table at iy
0B0F5B             0156   ; - arguments and dispatch entries are zero-terminated, case-sensitive strings
0B0F5B             0157   ; - final entry of dispatch table must be a 3-byte zero or bad things will happen
0B0F5B             0158   ; returns: NO MATCH: iy=dispatch list terminator a=1 and zero flag reset
0B0F5B             0159   ; ON MATCH: iy=dispatch address, a=0 and zero flag set
0B0F5B             0160   ; destroys: a, hl, de, ix, iy, flags
0B0F5B             0161   match_next:
0B0F5B ED 32 03    0162       lea ix,ix+3 ; point to the next argument
0B0F5E             0163   @loop:
0B0F5E FD 27 00    0164       ld hl,(iy) ; pointer argument dispatch record
0B0F61             0165       sign_hlu ; check for list terminator
0B0F61 19          0001M          add hl,de
0B0F62 B7          0002M          or a
0B0F63 ED 52       0003M          sbc hl,de
0B0F65 CA 7D 0F 0B 0166       jp z,@no_match ; if a=0, return error
0B0F69 23          0167       inc hl ; skip over jp instruction
0B0F6A 23          0168       inc hl
0B0F6B DD 17 00    0169       ld de,(ix) ; pointer to the argument string
0B0F6E CD 83 0F 0B 0170       call str_equal ; compare the argument to the dispatch table entry
0B0F72 CA 7F 0F 0B 0171       jp z,@match ; if equal, return success
0B0F76 ED 33 03    0172       lea iy,iy+3 ; if not equal, bump iy to next dispatch table entry
0B0F79 C3 5E 0F 0B 0173       jp @loop ; and loop
0B0F7D             0174   @no_match:
0B0F7D 3C          0175       inc a ; no match so return a=1 and zero flag reset
0B0F7E C9          0176       ret
0B0F7F             0177   @match:
0B0F7F FD 37 00    0178       ld iy,(iy) ; get the function pointer
0B0F82 C9          0179       ret ; return a=0 and zero flag set
0B0F83             0180   
0B0F83             0181   ; compare two zero-terminated strings for equality, case-sensitive
0B0F83             0182   ; hl: pointer to first string, de: pointer to second string
0B0F83             0183   ; returns: z if equal, nz if not equal
0B0F83             0184   ; destroys: a, hl, de
0B0F83             0185   str_equal:
0B0F83 1A          0186       ld a,(de) ; get the first character
0B0F84 BE          0187       cp (hl) ; compare to the second character
0B0F85 C0          0188       ret nz ; if not equal, return
0B0F86 B7          0189       or a
0B0F87 C8          0190       ret z ; if equal and zero, return
0B0F88 23          0191       inc hl ; next character
0B0F89 13          0192       inc de
0B0F8A C3 83 0F 0B 0193       jp str_equal ; loop until end of string
0B0F8E             0194   
0B0F8E             0195   ; === BOILERPLATE MOSLET CODE ===
0B0F8E             0196   ; Parse the parameter string into a C array
0B0F8E             0197   ; Parameters
0B0F8E             0198   ; - HL: Address of parameter string
0B0F8E             0199   ; - IX: Address for array pointer storage
0B0F8E             0200   ; Returns:
0B0F8E             0201   ; - C: Number of parameters parsed
0B0F8E             0202   ;
0B0F8E 01 34 00 0B 0203   _parse_params: LD BC, _exec_name
0B0F92 DD 0F 00    0204       LD (IX+0), BC ; ARGV[0] = the executable name
0B0F95 ED 32 03    0205       LEA IX, IX+3
0B0F98 CD D0 0F 0B 0206       CALL _skip_spaces ; Skip HL past any leading spaces
0B0F9C             0207   ;
0B0F9C 01 01 00 00 0208       LD BC, 1 ; C: ARGC = 1 - also clears out top 16 bits of BCU
0B0FA0 06 0F       0209       LD B, argv_ptrs_max - 1 ; B: Maximum number of argv_ptrs
0B0FA2             0210   ;
0B0FA2             0211   _parse_params_1:
0B0FA2 C5          0212       PUSH BC ; Stack ARGC
0B0FA3 E5          0213       PUSH HL ; Stack start address of token
0B0FA4 CD C1 0F 0B 0214       CALL _get_token ; Get the next token
0B0FA8 79          0215       LD A, C ; A: Length of the token in characters
0B0FA9 D1          0216       POP DE ; Start address of token (was in HL)
0B0FAA C1          0217       POP BC ; ARGC
0B0FAB B7          0218       OR A ; Check for A=0 (no token found) OR at end of string
0B0FAC C8          0219       RET Z
0B0FAD             0220   ;
0B0FAD DD 1F 00    0221       LD (IX+0), DE ; Store the pointer to the token
0B0FB0 E5          0222       PUSH HL ; DE=HL
0B0FB1 D1          0223       POP DE
0B0FB2 CD D0 0F 0B 0224       CALL _skip_spaces ; And skip HL past any spaces onto the next character
0B0FB6 AF          0225       XOR A
0B0FB7 12          0226       LD (DE), A ; Zero-terminate the token
0B0FB8 ED 32 03    0227       LEA IX, IX+3 ; Advance to next pointer position
0B0FBB 0C          0228       INC C ; Increment ARGC
0B0FBC 79          0229       LD A, C ; Check for C >= A
0B0FBD B8          0230       CP B
0B0FBE 38 E2       0231       JR C, _parse_params_1 ; And loop
0B0FC0 C9          0232       RET
0B0FC1             0233   
0B0FC1             0234   ; Get the next token
0B0FC1             0235   ; Parameters:
0B0FC1             0236   ; - HL: Address of parameter string
0B0FC1             0237   ; Returns:
0B0FC1             0238   ; - HL: Address of first character after token
0B0FC1             0239   ; - C: Length of token (in characters)
0B0FC1             0240   ;
0B0FC1 0E 00       0241   _get_token: LD C, 0 ; Initialise length
0B0FC3 7E          0242   @@: LD A, (HL) ; Get the character from the parameter string
0B0FC4 B7          0243       OR A ; Exit if 0 (end of parameter string in MOS)
0B0FC5 C8          0244       RET Z
0B0FC6 FE 0D       0245       CP 13 ; Exit if CR (end of parameter string in BBC BASIC)
0B0FC8 C8          0246       RET Z
0B0FC9 FE 20       0247       CP ' ' ; Exit if space (end of token)
0B0FCB C8          0248       RET Z
0B0FCC 23          0249       INC HL ; Advance to next character
0B0FCD 0C          0250       INC C ; Increment length
0B0FCE 18 F3       0251       JR @B
0B0FD0             0252   
0B0FD0             0253   ; Skip spaces in the parameter string
0B0FD0             0254   ; Parameters:
0B0FD0             0255   ; - HL: Address of parameter string
0B0FD0             0256   ; Returns:
0B0FD0             0257   ; - HL: Address of next none-space character
0B0FD0             0258   ; F: Z if at end of string, otherwise NZ if there are more tokens to be parsed
0B0FD0             0259   ;
0B0FD0 7E          0260   _skip_spaces: LD A, (HL) ; Get the character from the parameter string
0B0FD1 FE 20       0261       CP ' ' ; Exit if not space
0B0FD3 C0          0262       RET NZ
0B0FD4 23          0263       INC HL ; Advance to next character
0B0FD5 18 F9       0264       JR _skip_spaces ; Increment length
