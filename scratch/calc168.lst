PC     Output      Line
040000             0001    ASSUME ADL = 1
040000             0002       ORG 0x0B0000 ; Is a moslet
0B0000             0003       ; include "mos_api.inc"
0B0000 C3 45 00 0B 0004       JP _start
0B0004             0005   
0B0004             0006   ; Storage for the argv array pointers
0B0004             0007   min_args: equ 1
0B0004             0008   argv_ptrs_max: EQU 16 ; Maximum number of arguments allowed in argv
0B0004 00 00 00 00 0009   argv_ptrs: BLKP argv_ptrs_max, 0
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0B0034             0010   
0B0034             0011   _exec_name:
0B0034 63 61 6C 63 0012       ASCIZ "calc168" ; The executable name, only used in argv
       31 36 38 00 
0B003C FF FF FF FF 0013       ALIGN 64
0B0040 4D 4F 53    0014       DB "MOS" ; Flag for MOS - to confirm this is a valid MOS command
0B0043 00          0015       DB 00h ; MOS header version 0
0B0044 01          0016       DB 01h ; Flag for run mode (0: Z80, 1: ADL)
0B0045             0017   
0B0045             0018   _start:
0B0045 F5          0019       PUSH AF ; Preserve the registers
0B0046 C5          0020       PUSH BC
0B0047 D5          0021       PUSH DE
0B0048 DD E5       0022       PUSH IX
0B004A FD E5       0023       PUSH IY
0B004C ED 6E       0024       LD A, MB ; Save MB
0B004E F5          0025       PUSH AF
0B004F AF          0026       XOR A
0B0050 ED 6D       0027       LD MB, A ; Clear to zero so MOS API calls know how to use 24-bit addresses.
0B0052 DD 21 04 00 0028       LD IX, argv_ptrs ; The argv array pointer address
       0B          
0B0057 DD E5       0029       PUSH IX
0B0059 CD 59 0F 0B 0030       CALL _parse_params ; Parse the parameters
0B005D DD E1       0031       POP IX ; IX: argv
0B005F 06 00       0032       LD B, 0 ; C: argc
0B0061             0033   
0B0061 CD 90 0E 0B 0034       CALL main ; Start user code
0B0065             0035   
0B0065 F1          0036       POP AF
0B0066 ED 6D       0037       LD MB, A
0B0068 FD E1       0038       POP IY ; Restore registers
0B006A DD E1       0039       POP IX
0B006C D1          0040       POP DE
0B006D C1          0041       POP BC
0B006E F1          0042       POP AF
0B006F C9          0043       RET
0B0070             0044   
0B0070             0045   _main_end_error:
0B0070 CD F3 0A 0B 0046       call printInline
0B0074 41 6E 20 65 0047       asciz "An error occurred!\r\n"
       72 72 6F 72 
       20 6F 63 63 
       75 72 72 65 
       64 21 0D 0A 
       00          
0B0089 21 13 00 00 0048       ld hl,19 ; return error code 19
0B008D C9          0049       ret
0B008E             0050   
0B008E             0051   _main_end_ok:
0B008E CD F3 0A 0B 0052       call printInline
0B0092 0D 0A 00    0053       asciz "\r\n"
0B0095 21 00 00 00 0054       ld hl,0 ; return 0 for success
0B0099 C9          0055       ret
0B009A             0056   
0B009A             0057   ;--- APPLICATION INCLUDES ---
0B009A             0058       include "fixed168.inc"
0B009A             0001*  ; multiply HL by 256
0B009A             0002*  ; inputs: HL
0B009A             0003*  ; outputs: HL*256
0B009A             0004*  ; destroys: flags
0B009A             0005*      MACRO hlu_mul256
0B009A             0006*          add hl,hl ; * 2
0B009A             0007*          add hl,hl ; * 4
0B009A             0008*          add hl,hl ; * 8
0B009A             0009*          add hl,hl ; * 16
0B009A             0010*          add hl,hl ; * 32
0B009A             0011*          add hl,hl ; * 64
0B009A             0012*          add hl,hl ; * 128
0B009A             0013*          add hl,hl ; * 256
0B009A             0014*      ENDMACRO
0B009A             0015*  
0B009A             0016*  ; test the sign of HL
0B009A             0017*  ; inputs: HL obviously
0B009A             0018*  ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
0B009A             0019*  ; destroys: flags
0B009A             0020*      MACRO sign_hlu
0B009A             0021*          add hl,de
0B009A             0022*          or a
0B009A             0023*          sbc hl,de
0B009A             0024*      ENDMACRO
0B009A             0025*  
0B009A             0026*  ; hlu signed division by 256
0B009A             0027*  ; returns: hlu / 256
0B009A             0028*  ; destroys: af
0B009A             0029*  hlu_sdiv256:
0B009A AF          0030*      xor a ; assume hl is positive
0B009B 22 B1 00 0B 0031*      ld (@buffer),hl
0B009F             0032*      sign_hlu
0B009F 19          0001*M         add hl,de
0B00A0 B7          0002*M         or a
0B00A1 ED 52       0003*M         sbc hl,de
0B00A3 F2 A8 00 0B 0033*      jp p,@hl_pos
0B00A7 3D          0034*      dec a
0B00A8             0035*  @hl_pos:
0B00A8 32 B4 00 0B 0036*      ld (@buffer+3),a
0B00AC 2A B2 00 0B 0037*      ld hl,(@buffer+1)
0B00B0 C9          0038*      ret
0B00B1 00 00 00 00 0039*  @buffer: blkb 4,0
0B00B5             0040*  
0B00B5             0041*  ; hlu 1 byte right shift, unsigned
0B00B5             0042*  ; returns: hlu / 256
0B00B5             0043*  hlu_udiv256:
0B00B5 22 BE 00 0B 0044*  	ld (@buffer),hl
0B00B9 2A BF 00 0B 0045*  	ld hl,(@buffer+1)
0B00BD C9          0046*  	ret
0B00BE 00 00 00 00 0047*  @buffer: blkb 4,0
0B00C2             0048*  
0B00C2             0049*  ; absolute value of hlu
0B00C2             0050*  ; returns: abs(hlu), flags set according to the incoming sign of hlu:
0B00C2             0051*  ;         s1,z0,pv0,n1,c0 if hlu was negative
0B00C2             0052*  ;         s0,z1,pv0,n1,c0 if hlu was zero
0B00C2             0053*  ;         s0,z0,pv0,n1,c0 if hlu was positive
0B00C2             0054*  ; destroys: a
0B00C2             0055*  hlu_abs:
0B00C2 19          0056*      add hl,de
0B00C3 B7          0057*      or a
0B00C4 ED 52       0058*      sbc hl,de
0B00C6 FA CB 00 0B 0059*      jp m,@is_neg
0B00CA C9          0060*      ret         ; hlu is positive or zero so we're done
0B00CB             0061*  @is_neg:
0B00CB F5          0062*      push af     ; otherwise, save current flags for return
0B00CC CD D2 00 0B 0063*      call neg_hlu ; negate hlu
0B00D0 F1          0064*      pop af      ; get back flags
0B00D1 C9          0065*      ret
0B00D2             0066*  
0B00D2             0067*  ; flip the sign of hlu
0B00D2             0068*  ; inputs: hlu
0B00D2             0069*  ; returns: 0-hlu, flags set appropriately for the result:
0B00D2             0070*  ;         s1,z0,pv0,n1,c1 if result is negative
0B00D2             0071*  ;         s0,z1,pv0,n1,c0 if result is zero
0B00D2             0072*  ;         s0,z0,pv0,n1,c1 if result is positive
0B00D2             0073*  ; destroys a
0B00D2             0074*  neg_hlu:
0B00D2 D5          0075*      push de     ; save de
0B00D3 EB          0076*      ex de,hl    ; put hl into de
0B00D4 21 00 00 00 0077*      ld hl,0     ; clear hl
0B00D8 AF          0078*      xor a       ; clear carry
0B00D9 ED 52       0079*      sbc hl,de   ; 0-hlu = -hlu
0B00DB D1          0080*      pop de      ; get de back
0B00DC C9          0081*      ret         ; easy peasy
0B00DD             0082*  
0B00DD             0083*      ; include "fixed24.inc"
0B00DD             0084*  
0B00DD             0085*  ; multiply a signed 24-bit number by an unsigned 8-bit number giving a signed 24-bit result
0B00DD             0086*  ; uses EZ80 MLT instruction for speed
0B00DD             0087*  ; operation: UHL * A --> UHL
0B00DD             0088*  ; destroys: AF, HL
0B00DD             0089*  smul24x8:
0B00DD             0090*  ; make hl positive and store sign flag
0B00DD CD C2 00 0B 0091*  	call hlu_abs
0B00E1 F5          0092*  	push af
0B00E2             0093*  ; do the division
0B00E2 CD ED 00 0B 0094*      call mul24x8 ; hl = product
0B00E6             0095*  ; adjust sign of result
0B00E6 F1          0096*  	pop af ; sign de
0B00E7 F0          0097*  	ret p ; hl was positive, nothing to do
0B00E8 CD D2 00 0B 0098*  	call neg_hlu ; result is negative
0B00EC C9          0099*  	ret
0B00ED             0100*  
0B00ED             0101*  ; unsigned multiplication of a 24-bit and 8-bit number giving a 32-bit result
0B00ED             0102*  ; uses EZ80 MLT instruction for speed
0B00ED             0103*  ; operation: UHL * A --> AUHL
0B00ED             0104*  ; destroys: AF, HL
0B00ED             0105*  mul24x8:
0B00ED D5          0106*  	push de ; preserve de
0B00EE             0107*  ; low byte
0B00EE 5D          0108*  	ld e,l
0B00EF 57          0109*  	ld d,a
0B00F0 ED 5C       0110*  	mlt de
0B00F2 6B          0111*  	ld l,e ; product low byte
0B00F3 08          0112*  	ex af,af' ; save multiplier
0B00F4 7A          0113*  	ld a,d ; carry
0B00F5 08          0114*  	ex af,af' ; save carry, restore multiplier
0B00F6             0115*  ; high byte
0B00F6 5C          0116*  	ld e,h
0B00F7 57          0117*  	ld d,a
0B00F8 ED 5C       0118*  	mlt de
0B00FA 08          0119*  	ex af,af' ; save multiplier, restore carry
0B00FB 83          0120*  	add a,e ; add carry
0B00FC 67          0121*  	ld h,a ; product middle byte
0B00FD 7A          0122*  	ld a,d ; carry
0B00FE 08          0123*  	ex af,af' ; save carry, restore multiplier
0B00FF             0124*  ; upper byte
0B00FF 22 1A 01 0B 0125*      ld (@scratch),hl ; 7 cycles
0B0103 5F          0126*  	ld e,a
0B0104 3A 1C 01 0B 0127*  	ld a,(@scratch+2)
0B0108 57          0128*  	ld d,a
0B0109 ED 5C       0129*  	mlt de
0B010B 08          0130*  	ex af,af' ; restore carry
0B010C 8B          0131*  	adc a,e ; add carry
0B010D 32 1C 01 0B 0132*      ld (@scratch+2),a ; 5 cycles
0B0111 2A 1A 01 0B 0133*      ld hl,(@scratch) ; 7 cycles
0B0115             0134*  ; highest byte
0B0115 3E 00       0135*  	ld a,0 ; preserve carry flag
0B0117 8A          0136*  	adc a,d ; product highest byte
0B0118 D1          0137*  	pop de ; restore de
0B0119 C9          0138*  	ret
0B011A             0139*  @scratch: ds 3
0B011D             0140*  
0B011D 00 00 00 00 0141*  mul24out: blkb 6,0
       00 00       
0B0123             0142*  
0B0123             0143*  ; unsigned multiplication of two 24-bit numbers giving a 48-bit result
0B0123             0144*  ; operation: UHL * UDE --> mul24out
0B0123             0145*  mul24:
0B0123 DD E5       0146*  	push ix ; preserve
0B0125             0147*  ; point to output buffer and clear it
0B0125 DD 21 1D 01 0148*  	ld ix,mul24out
       0B          
0B012A C5          0149*  	push bc
0B012B 01 00 00 00 0150*  	ld bc,0
0B012F DD 0F 00    0151*  	ld (ix),bc
0B0132 DD 0F 03    0152*  	ld (ix+3),bc
0B0135 C1          0153*  	pop bc
0B0136             0154*  ; STEP 1: UHL * E
0B0136 7B          0155*  	ld a,e
0B0137 E5          0156*  	push hl
0B0138 CD ED 00 0B 0157*  	call mul24x8
0B013C DD 2F 00    0158*  	ld (ix+0),hl
0B013F DD 77 03    0159*  	ld (ix+3),a
0B0142             0160*  ; STEP 2: UHL * D
0B0142 E1          0161*  	pop hl
0B0143 E5          0162*  	push hl
0B0144 7A          0163*  	ld a,d
0B0145 CD ED 00 0B 0164*  	call mul24x8
0B0149 CD 62 01 0B 0165*  	call @accumulate
0B014D             0166*  ; STEP 3: UHL * DEU
0B014D E1          0167*  	pop hl
0B014E ED 53 92 01 0168*  	ld (@de),de
       0B          
0B0153 3A 94 01 0B 0169*  	ld a,(@de+2)
0B0157 CD ED 00 0B 0170*  	call mul24x8
0B015B CD 62 01 0B 0171*  	call @accumulate
0B015F             0172*  ; all done
0B015F DD E1       0173*  	pop ix ; restore
0B0161 C9          0174*  	ret
0B0162             0175*  @accumulate:
0B0162 DD 23       0176*  	inc ix
0B0164             0177*  ; highest byte of product to carry
0B0164 DD 77 03    0178*  	ld (ix+3),a
0B0167             0179*  ; low byte of product
0B0167 7D          0180*  	ld a,l
0B0168 DD 86 00    0181*  	add a,(ix+0)
0B016B DD 77 00    0182*  	ld (ix+0),a
0B016E             0183*  ; high byte of product
0B016E 7C          0184*  	ld a,h
0B016F DD 8E 01    0185*  	adc a,(ix+1)
0B0172 DD 77 01    0186*  	ld (ix+1),a
0B0175             0187*  ; uppper byte of product
0B0175 22 8F 01 0B 0188*  	ld (@hl),hl
0B0179 3A 91 01 0B 0189*  	ld a,(@hl+2)
0B017D DD 8E 02    0190*  	adc a,(ix+2)
0B0180 DD 77 02    0191*  	ld (ix+2),a
0B0183             0192*  ; carry
0B0183 3E 00       0193*  	ld a,0 ; preserve flags
0B0185 DD 8E 03    0194*  	adc a,(ix+3)
0B0188 DD 77 03    0195*  	ld (ix+3),a
0B018B C9          0196*  	ret
0B018C             0197*  
0B018C 00 00 00    0198*  @ix: dl 0
0B018F 00 00 00    0199*  @hl: dl 0
0B0192 00 00 00    0200*  @de: dl 0
0B0195             0201*  
0B0195             0202*  ; UHL * UDE --> UHL (unsigned)
0B0195             0203*  umul24:
0B0195 CD 23 01 0B 0204*  	call mul24
0B0199 2A 1D 01 0B 0205*  	ld hl,(mul24out)
0B019D C9          0206*  	ret
0B019E             0207*  
0B019E             0208*  ; UH.L = UH.L*UD.E (unsigned)
0B019E             0209*  umul168:
0B019E CD 23 01 0B 0210*  	call mul24
0B01A2 2A 1E 01 0B 0211*  	ld hl,(mul24out+1)
0B01A6 C9          0212*  	ret
0B01A7             0213*  
0B01A7             0214*  ; UH.L * UD.E --> UH.L (signed)
0B01A7             0215*  smul168:
0B01A7             0216*  ; make everything positive and store sign flags
0B01A7 CD C2 00 0B 0217*  	call hlu_abs
0B01AB F5          0218*  	push af
0B01AC EB          0219*  	ex de,hl
0B01AD CD C2 00 0B 0220*  	call hlu_abs
0B01B1 EB          0221*  	ex de,hl
0B01B2 F5          0222*  	push af
0B01B3             0223*  ; do the division
0B01B3 CD 9E 01 0B 0224*      call umul168 ; hl = product
0B01B7             0225*  ; adjust sign of result
0B01B7 F1          0226*  	pop af ; sign de
0B01B8 FA C3 01 0B 0227*  	jp m,@de_neg
0B01BC F1          0228*  	pop af ; sign hl
0B01BD F0          0229*  	ret p ; both positive, nothing to do
0B01BE             0230*  @hl_neg:
0B01BE CD D2 00 0B 0231*      call neg_hlu ; de pos, hl neg, result is negative
0B01C2 C9          0232*      ret
0B01C3             0233*  @de_neg:
0B01C3 F1          0234*  	pop af
0B01C4 F8          0235*  	ret m ; both negative, nothing to do
0B01C5 CD D2 00 0B 0236*  	call neg_hlu ; result is negative
0B01C9 C9          0237*  	ret
0B01CA             0238*  
0B01CA             0239*  ; UH.L / UD.E --> UD.E rem UHL (unsigned)
0B01CA             0240*  ; perform unsigned division of 16.8 fixed place values
0B01CA             0241*  ; with an unsigned 16.8 fixed place result and 24-bit remainder
0B01CA             0242*  udiv168:
0B01CA             0243*  ; back up divisor
0B01CA ED 53 01 02 0244*  	ld (@ude),de
       0B          
0B01CF             0245*  ; get the 16-bit integer part of the quotient
0B01CF CD 32 02 0B 0246*      call udiv24 ; de = quotient, hl = remainder
0B01D3             0247*  ; load quotient to upper three bytes of output
0B01D3 ED 53 08 02 0248*      ld (div168_out+1),de
       0B          
0B01D8             0249*  @div256:
0B01D8             0250*  ; multiply remainder by 256
0B01D8             0251*  	hlu_mul256
0B01D8 29          0001*M         add hl,hl ; * 2
0B01D9 29          0002*M         add hl,hl ; * 4
0B01DA 29          0003*M         add hl,hl ; * 8
0B01DB 29          0004*M         add hl,hl ; * 16
0B01DC 29          0005*M         add hl,hl ; * 32
0B01DD 29          0006*M         add hl,hl ; * 64
0B01DE 29          0007*M         add hl,hl ; * 128
0B01DF 29          0008*M         add hl,hl ; * 256
0B01E0             0252*  ; skip fractional computation if remainder is zero
0B01E0             0253*      sign_hlu
0B01E0 19          0001*M         add hl,de
0B01E1 B7          0002*M         or a
0B01E2 ED 52       0003*M         sbc hl,de
0B01E4 20 03       0254*      jr nz,@div_frac
0B01E6 AF          0255*      xor a
0B01E7 18 0A       0256*      jr @write_frac
0B01E9             0257*  ; now divide the shifted remainder by the divisor
0B01E9             0258*  @div_frac:
0B01E9 ED 5B 01 02 0259*  	ld de,(@ude) ; get back divisor
       0B          
0B01EE CD 32 02 0B 0260*      call udiv24 ; de = quotient, hl = remainder
0B01F2             0261*  ; load low byte of quotient to low byte of output
0B01F2 7B          0262*      ld a,e
0B01F3             0263*  @write_frac:
0B01F3 32 07 02 0B 0264*      ld (div168_out),a
0B01F7             0265*  ; load de with return value
0B01F7 ED 5B 07 02 0266*      ld de,(div168_out)
       0B          
0B01FC             0267*  ; load a with any overflow
0B01FC 3A 0A 02 0B 0268*      ld a,(div168_out+3)
0B0200 C9          0269*      ret ; ud.e is the 16.8 result
0B0201             0270*  @ude: ds 6
0B0207             0271*  div168_out: ds 4 ; the extra byte is for overflow
0B020B             0272*  
0B020B             0273*  ; UH.L / UD.E --> UD.E (signed) rem UHL (unsigned)
0B020B             0274*  ; perform signed division of 16.8 fixed place values
0B020B             0275*  ; with a signed 16.8 fixed place result and unsigned 24-bit remainder
0B020B             0276*  sdiv168:
0B020B             0277*  ; make everything positive and store sign flags
0B020B CD C2 00 0B 0278*  	call hlu_abs
0B020F F5          0279*  	push af
0B0210 EB          0280*  	ex de,hl
0B0211 CD C2 00 0B 0281*  	call hlu_abs
0B0215 EB          0282*  	ex de,hl
0B0216 F5          0283*  	push af
0B0217             0284*  ; do the division
0B0217 CD CA 01 0B 0285*      call udiv168 ; de = quotient, hl = remainder
0B021B             0286*  ; adjust sign of result
0B021B F1          0287*  	pop af ; sign de
0B021C FA 29 02 0B 0288*  	jp m,@de_neg
0B0220 F1          0289*  	pop af ; sign hl
0B0221 F0          0290*  	ret p ; both positive, nothing to do
0B0222             0291*  @hl_neg:
0B0222 EB          0292*      ex de,hl ; hl = quotient, de = remainder
0B0223 CD D2 00 0B 0293*      call neg_hlu ; de pos, hl neg, result is negative
0B0227 EB          0294*      ex de,hl ; de = negated quotient, hl = remainder
0B0228 C9          0295*      ret
0B0229             0296*  @de_neg:
0B0229 F1          0297*  	pop af
0B022A F8          0298*  	ret m ; both negative, nothing to do
0B022B EB          0299*      ex de,hl ; hl = quotient, de = remainder
0B022C CD D2 00 0B 0300*  	call neg_hlu ; result is negative
0B0230 EB          0301*      ex de,hl ; de = negated quotient, hl = remainder
0B0231 C9          0302*  	ret
0B0232             0303*  
0B0232             0304*  ;------------------------------------------------------------------------
0B0232             0305*  ;  arith24.asm
0B0232             0306*  ;  24-bit ez80 arithmetic routines
0B0232             0307*  ;  Copyright (c) Shawn Sijnstra 2024
0B0232             0308*  ;  MIT license
0B0232             0309*  ;
0B0232             0310*  ;  This library was created as a tool to help make ez80
0B0232             0311*  ;  24-bit native assembly routines for simple mathematical problems
0B0232             0312*  ;  more widely available.
0B0232             0313*  ;
0B0232             0314*  ;------------------------------------------------------------------------
0B0232             0315*  ;
0B0232             0316*  ;------------------------------------------------------------------------
0B0232             0317*  ; udiv24
0B0232             0318*  ; Unsigned 24-bit division
0B0232             0319*  ; Divides HLU by DEU. Gives result in DEU (and BC), remainder in HLU.
0B0232             0320*  ;
0B0232             0321*  ; Uses AF BC DE HL
0B0232             0322*  ; Uses Restoring Division algorithm
0B0232             0323*  ;------------------------------------------------------------------------
0B0232             0324*  
0B0232             0325*  udiv24:
0B0232 E5          0326*  	push	hl
0B0233 C1          0327*  	pop		bc	;move dividend to BCU
0B0234 21 00 00 00 0328*  	ld		hl,0	;result
0B0238 A7          0329*  	and		a
0B0239 ED 52       0330*  	sbc		hl,de	;test for div by 0
0B023B C8          0331*  	ret		z		;it's zero, carry flag is clear
0B023C 19          0332*  	add		hl,de	;HL is 0 again
0B023D 3E 18       0333*  	ld		a,24	;number of loops through.
0B023F             0334*  udiv1:
0B023F C5          0335*  	push	bc	;complicated way of doing this because of lack of access to top bits
0B0240 E3          0336*  	ex		(sp),hl
0B0241 37          0337*  	scf
0B0242 ED 6A       0338*  	adc	hl,hl
0B0244 E3          0339*  	ex	(sp),hl
0B0245 C1          0340*  	pop	bc		;we now have bc = (bc * 2) + 1
0B0246             0341*  
0B0246 ED 6A       0342*  	adc	hl,hl
0B0248 A7          0343*  	and	a		;is this the bug
0B0249 ED 52       0344*  	sbc	hl,de
0B024B 30 02       0345*  	jr	nc,udiv2
0B024D 19          0346*  	add	hl,de
0B024E             0347*  ;	dec	c
0B024E 0B          0348*  	dec	bc
0B024F             0349*  udiv2:
0B024F 3D          0350*  	dec	a
0B0250 20 ED       0351*  	jr	nz,udiv1
0B0252 37          0352*  	scf		;flag used for div0 error
0B0253 C5          0353*  	push	bc
0B0254 D1          0354*  	pop		de	;remainder
0B0255 C9          0355*  	ret
0B0256             0356*  
0B0256             0357*  ;------------------------------------------------------------------------
0B0256             0358*  ;  END 24-bit ez80 arithmetic routines by Shawn Sijnstra
0B0256             0359*  ;------------------------------------------------------------------------
0B0256             0360*  
0B0256             0361*  
0B0256             0362*      ; include "trig24fast.inc"
0B0256             0363*  
0B0256             0364*  
0B0256             0365*  ; convert signed angles from a 360 to 256 degree circle
0B0256             0366*  ; inputs: uh.l is the angle360 in 16.8 fixed format
0B0256             0367*  ; outputs: uh.l is the angle256 in 16.8 fixed format
0B0256             0368*  ; destroys: TODO
0B0256             0369*  deg_360_to_256:
0B0256 D5          0370*  	push de ; preserve de
0B0257             0371*  ; make angle positive and store sign flag
0B0257 CD C2 00 0B 0372*  	call hlu_abs
0B025B F5          0373*  	push af
0B025C             0374*  ; multiply by 256 first to keep precision
0B025C             0375*  	hlu_mul256 ; uh.l = uh.l * 256
0B025C 29          0001*M         add hl,hl ; * 2
0B025D 29          0002*M         add hl,hl ; * 4
0B025E 29          0003*M         add hl,hl ; * 8
0B025F 29          0004*M         add hl,hl ; * 16
0B0260 29          0005*M         add hl,hl ; * 32
0B0261 29          0006*M         add hl,hl ; * 64
0B0262 29          0007*M         add hl,hl ; * 128
0B0263 29          0008*M         add hl,hl ; * 256
0B0264             0376*  ; divide uh.l by 360
0B0264 11 68 01 00 0377*  	ld de,360
0B0268 CD 32 02 0B 0378*  	call udiv24 ; ud.e = degrees / 360
0B026C EB          0379*  	ex de,hl    ; uh.l = degrees / 360
0B026D             0380*  ; restore sign flag and adjust output accordingly
0B026D F1          0381*  	pop af
0B026E F2 76 02 0B 0382*  	jp p,@pos ; positive number
0B0272 CD D2 00 0B 0383*  	call neg_hlu
0B0276             0384*  @pos:
0B0276             0385*  ; restore de and return uh.l as the result
0B0276 D1          0386*  	pop de
0B0277 C9          0387*  	ret
0B0278             0388*  
0B0278             0389*  ; fixed 16.8 routine
0B0278             0390*  ; cos(uh.l) --> uh.l
0B0278             0391*  ; destroys: f, hl
0B0278             0392*  cos168:
0B0278 D5          0393*      push de ; preserve de
0B0279             0394*  ; for cos we simply increment the angle by 90 degrees
0B0279             0395*  ; or 0x004000 in 16.8 degrees256
0B0279             0396*  ; which makes it a sin problem
0B0279 11 00 40 00 0397*      ld de,0x004000
0B027D 19          0398*      add hl,de ; modulo 256 happens below
0B027E D1          0399*      pop de ; restore de
0B027F             0400*  ; fall through to sin168
0B027F             0401*  
0B027F             0402*  ; ---------------------
0B027F             0403*  ; fixed 16.8 routine
0B027F             0404*  ; sin(uh.l) --> uh.l
0B027F             0405*  ; destroys: f, hl
0B027F             0406*  sin168:
0B027F D5          0407*  	push de
0B0280             0408*  ; handle negative angles appropriately
0B0280 CD C2 00 0B 0409*  	call hlu_abs
0B0284 F2 8D 02 0B 0410*  	jp p,@F
0B0288 11 00 00 FF 0411*  	ld de,-256*256
0B028C 19          0412*  	add hl,de
0B028D             0413*  @@:
0B028D 2E 03       0414*  	ld l,3 ; multiply by 3 to get our lookup index
0B028F ED 6C       0415*      mlt hl
0B0291 11 DD 04 0B 0416*      ld de,sin_lut_168 ; grab the lut address
0B0295 19          0417*      add hl,de ; bump hl by the index
0B0296 ED 27       0418*      ld hl,(hl) ; don't try this on a z80!
0B0298 D1          0419*      pop de
0B0299 C9          0420*      ret
0B029A             0421*  
0B029A             0422*  ; 16.8 fixed inputs / outputs
0B029A             0423*  ; takes: uh.l as angle in degrees 256
0B029A             0424*  ;        ud.e as radius
0B029A             0425*  ; returns ub.c as dx, ud.e as dy, uh.l as radius
0B029A             0426*  ;        displacements from origin (0,0)
0B029A             0427*  ; destroys: everything except indexes
0B029A             0428*  polar_to_cartesian:
0B029A             0429*  ; back up input parameters
0B029A 22 C9 02 0B 0430*      ld (@angle), hl
0B029E ED 53 CC 02 0431*      ld (@radius), de
       0B          
0B02A3             0432*  ; compute dx = sin(uh.l) * ud.e
0B02A3 CD 7F 02 0B 0433*      call sin168 ; uh.l = sin(uh.l)
0B02A7 ED 5B CC 02 0434*  	ld de,(@radius)
       0B          
0B02AC CD A7 01 0B 0435*  	call smul168 ; uh.l = dx
0B02B0 E5          0436*      push hl
0B02B1             0437*  ; compute dy = -cos(uh.l) * ud.e
0B02B1 2A C9 02 0B 0438*      ld hl,(@angle)
0B02B5 CD 78 02 0B 0439*      call cos168 ; uh.l = cos(uh.l)
0B02B9 ED 5B CC 02 0440*      ld de,(@radius)
       0B          
0B02BE CD A7 01 0B 0441*      call smul168    ; uh.l = dy
0B02C2 CD D2 00 0B 0442*      call neg_hlu ; invert dy for screen coords convention
0B02C6 EB          0443*      ex de,hl       ; de = dy for output
0B02C7 C1          0444*      pop bc          ; bc = dx for output
0B02C8             0445*  ; and out
0B02C8 C9          0446*      ret
0B02C9             0447*  @angle: ds 3
0B02CC             0448*  @radius: ds 3
0B02CF             0449*  
0B02CF             0450*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
0B02CF             0451*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
0B02CF             0452*  ; output: ub.c and ud.e are dx and dy in 16.8 fixed format
0B02CF             0453*  ;         also populates scratch locations dx168 and dy168
0B02CF             0454*  ; destroys: a,hl,bc,de
0B02CF             0455*  dxy168:
0B02CF             0456*  ; compute dx = x1-x0
0B02CF AF          0457*      xor a ; clear carry
0B02D0 DD E5       0458*      push ix ; move ix to hl via the stack
0B02D2 E1          0459*      pop hl ; hl = x1
0B02D3 ED 42       0460*      sbc hl,bc ; hl = dx
0B02D5 22 EA 02 0B 0461*      ld (dx168),hl ; dx to scratch
0B02D9             0462*  ; compute dy = y1-y0
0B02D9 AF          0463*      xor a ; clear carry
0B02DA FD E5       0464*      push iy ; move iy to hl via the stack
0B02DC E1          0465*      pop hl ; hl = y1
0B02DD ED 52       0466*      sbc hl,de ; hl = dy
0B02DF 22 F0 02 0B 0467*      ld (dy168),hl ; dy to scratch
0B02E3             0468*  ; populate output registers and return
0B02E3 EB          0469*      ex de,hl        ; ud.e = dy
0B02E4 ED 4B EA 02 0470*      ld bc,(dx168)   ; ub.c = dx
       0B          
0B02E9 C9          0471*      ret
0B02EA 00 00 00 00 0472*  dx168: blkb 6,0
       00 00       
0B02F0 00 00 00 00 0473*  dy168: blkb 6,0
       00 00       
0B02F6             0474*  
0B02F6             0475*  ; compute the euclidian distance between two cartesian coordinates
0B02F6             0476*  ; using the formula d = sqrt(dx^2+dy^2)
0B02F6             0477*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
0B02F6             0478*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
0B02F6             0479*  ; output; uh.l is the 16.8 fixed format distance
0B02F6             0480*  ;         also populates scratch locations dx168 and dy168
0B02F6             0481*  ; destroys: a,hl,bc,de
0B02F6             0482*  ; NOTE: rounds both deltas down to the nearest integer to avoid overflow when squaring,
0B02F6             0483*  ;       thus the result will always be an integer, albeit in 16.8 format
0B02F6             0484*  distance168:
0B02F6 CD CF 02 0B 0485*  	call dxy168 ; ub.c = dx, ud.e = dy
0B02FA             0486*  ; compute dy^2
0B02FA EB          0487*  	ex de,hl
0B02FB CD C2 00 0B 0488*  	call hlu_abs
0B02FF CD B5 00 0B 0489*  	call hlu_udiv256 ; make integer to avoid overflow
0B0303 E5          0490*  	push hl
0B0304 D1          0491*  	pop de
0B0305 CD 95 01 0B 0492*  	call umul24 ; hl = dy^2
0B0309 E5          0493*  	push hl ; save dy^2
0B030A             0494*  ; compute dx^2
0B030A 2A EA 02 0B 0495*  	ld hl,(dx168)
0B030E CD C2 00 0B 0496*  	call hlu_abs
0B0312 CD B5 00 0B 0497*  	call hlu_udiv256 ; make integer to avoid overflow
0B0316 E5          0498*  	push hl
0B0317 D1          0499*  	pop de
0B0318 CD 95 01 0B 0500*  	call umul24 ; hl = dx^2
0B031C             0501*  ; add dx^2 and dy^2
0B031C D1          0502*  	pop de ; de = dy^2 (was hl)
0B031D 19          0503*  	add hl,de ; hl = dx^2 + dy^2
0B031E             0504*  ; compute the square root
0B031E CD F7 03 0B 0505*  	call sqrt24 ; de = sqrt(dx^2 + dy^2)
0B0322 EB          0506*      ex de,hl ; hl = distance
0B0323             0507*      hlu_mul256 ; convert back to 16.8 fixed
0B0323 29          0001*M         add hl,hl ; * 2
0B0324 29          0002*M         add hl,hl ; * 4
0B0325 29          0003*M         add hl,hl ; * 8
0B0326 29          0004*M         add hl,hl ; * 16
0B0327 29          0005*M         add hl,hl ; * 32
0B0328 29          0006*M         add hl,hl ; * 64
0B0329 29          0007*M         add hl,hl ; * 128
0B032A 29          0008*M         add hl,hl ; * 256
0B032B C9          0508*  	ret
0B032C             0509*  
0B032C             0510*  ; atan2_(ub.c,ud.e) --> uh.l
0B032C             0511*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
0B032C             0512*  ;   whether inputs are integers or fractional doesn't matter
0B032C             0513*  ;   so long as the sign bit of the upper byte is correct
0B032C             0514*  ; output: uh.l is the 16.8 fixed angle in degrees 256
0B032C             0515*  ; angles are COMPASS HEADINGS based on
0B032C             0516*  ; screen coordinate conventions,where the y axis is flipped
0B032C             0517*  ; #E0 315      0       45 #20
0B032C             0518*  ;        -x,-y | +x,-y
0B032C             0519*  ; #C0 270------+------ 90 #40
0B032C             0520*  ;        -x,+y | +x,+y
0B032C             0521*  ; #A0 225   180 #80   135 #60
0B032C             0522*  atan2_168fast:
0B032C             0523*  ; get signs and make everything positive
0B032C             0524*  ; get abs(x) and store its original sign
0B032C C5          0525*      push bc
0B032D E1          0526*      pop hl
0B032E CD C2 00 0B 0527*      call hlu_abs ; if x was negative this also sets the sign flag
0B0332 E5          0528*      push hl ; store abs(x)
0B0333 C1          0529*      pop bc ; bc = abs(x)
0B0334 F5          0530*      push af ; store sign of x
0B0335             0531*  ; get abs(y) and store its original sign
0B0335 EB          0532*      ex de,hl ; hl = y
0B0336 CD C2 00 0B 0533*      call hlu_abs ; if y was negative this also sets the sign flag
0B033A EB          0534*      ex de,hl ; de = abs(y)
0B033B F5          0535*      push af ; store sign of y
0B033C             0536*  ; if abs(bc) < abs(de),then we do bc/de,otherwise de/bc
0B033C             0537*  ; this ensures that our lookup value is between 0 and 1 inclusive
0B033C AF          0538*      xor a ; clear the carry flag
0B033D D5          0539*      push de
0B033E E1          0540*      pop hl
0B033F ED 42       0541*      sbc hl,bc
0B0341 F5          0542*      push af ; save sign of de - bc
0B0342 F2 4B 03 0B 0543*      jp p,@1 ; bc <= de, so we skip ahead
0B0346             0544*  ; otherwise we swap bc and de
0B0346 C5          0545*      push bc
0B0347 E1          0546*      pop hl
0B0348 EB          0547*      ex de,hl
0B0349 E5          0548*      push hl
0B034A C1          0549*      pop bc
0B034B             0550*  @1:
0B034B             0551*  ; now we're ready to snag our preliminary result
0B034B C5          0552*  	push bc
0B034C E1          0553*  	pop hl
0B034D CD BB 03 0B 0554*      call atan_168fast ; uh.l comes back with prelim result
0B0351             0555*  ; now we adjust uh.l based on sign of de - bc
0B0351 F1          0556*      pop af
0B0352 F2 5E 03 0B 0557*      jp p,@2 ; bc <= de,so we skip ahead
0B0356 EB          0558*      ex de,hl
0B0357 21 00 40 00 0559*      ld hl,0x004000 ; 90 degrees
0B035B AF          0560*      xor a ; clear the carry flag
0B035C ED 52       0561*      sbc hl,de ; subtract result from 90 degrees
0B035E             0562*  @2:
0B035E             0563*  ; now the fun part of adjusting the result
0B035E             0564*  ; based on which quadrant (x,y) is in
0B035E             0565*  ; #E0 315      0       45 #20
0B035E             0566*  ;        -x,-y | +x,-y
0B035E             0567*  ; #C0 270------+------ 90 #40
0B035E             0568*  ;        -x,+y | +x,+y
0B035E             0569*  ; #A0 225   180 #80   135 #60
0B035E F1          0570*      pop af ; sign of y
0B035F CA 9C 03 0B 0571*      jp z,@y_zero
0B0363 F2 7C 03 0B 0572*      jp p,@y_pos
0B0367             0573*  ; y neg,check x
0B0367 F1          0574*      pop af ; sign of x
0B0368 CA 76 03 0B 0575*      jp z,@y_neg_x_zero
0B036C F2 7B 03 0B 0576*      jp p,@y_neg_x_pos
0B0370             0577*  ; y neg,x neg
0B0370             0578*  ; angle is 270-360
0B0370             0579*  ; negating the intermediate does the trick
0B0370 CD D2 00 0B 0580*      call neg_hlu
0B0374 18 31       0581*      jr @zero_hlu
0B0376             0582*  
0B0376             0583*  @y_neg_x_zero:
0B0376             0584*  ; y neg,x zero
0B0376             0585*  ; angle is 0
0B0376 21 00 00 00 0586*      ld hl,0
0B037A C9          0587*      ret
0B037B             0588*  @y_neg_x_pos:
0B037B             0589*  ; y neg,x pos
0B037B             0590*  ; angle is 0 to 90
0B037B             0591*  ; so we're good
0B037B C9          0592*      ret
0B037C             0593*  
0B037C             0594*  @y_pos:
0B037C F1          0595*      pop af ; sign of x
0B037D CA 8C 03 0B 0596*      jp z,@y_pos_x_zero
0B0381 F2 91 03 0B 0597*      jp p,@y_pos_x_pos
0B0385             0598*  ; y pos,x neg
0B0385             0599*  ; angle is 180-270
0B0385             0600*  ; so we add 180 to intermediate
0B0385 11 00 80 00 0601*      ld de,0x008000
0B0389 19          0602*      add hl,de
0B038A 18 1B       0603*      jr @zero_hlu
0B038C             0604*  @y_pos_x_zero:
0B038C             0605*  ; y pos,x zero
0B038C             0606*  ; angle is 180
0B038C 21 00 80 00 0607*      ld hl,0x008000
0B0390 C9          0608*      ret
0B0391             0609*  @y_pos_x_pos:
0B0391             0610*  ; y pos,x pos
0B0391             0611*  ; angle is 90-180
0B0391             0612*  ; neg the intermediate and add 180 degrees
0B0391 CD D2 00 0B 0613*      call neg_hlu
0B0395 11 00 80 00 0614*      ld de,0x008000
0B0399 19          0615*      add hl,de
0B039A 18 0B       0616*      jr @zero_hlu
0B039C             0617*  
0B039C             0618*  @y_zero:
0B039C F1          0619*      pop af ; sign of x
0B039D FA A2 03 0B 0620*      jp m,@y_zero_x_neg
0B03A1             0621*  ; y zero,x pos
0B03A1             0622*  ; angle is 90,nothing to do
0B03A1 C9          0623*      ret
0B03A2             0624*  @y_zero_x_neg:
0B03A2             0625*  ; y zero ,x neg
0B03A2             0626*  ; angle is 270
0B03A2 21 00 C0 00 0627*      ld hl,0x00C000
0B03A6 C9          0628*      ret
0B03A7             0629*  @zero_hlu:
0B03A7 AF          0630*      xor a
0B03A8 22 B5 03 0B 0631*      ld (@scratch),hl
0B03AC 32 B7 03 0B 0632*      ld (@scratch+2),a
0B03B0 2A B5 03 0B 0633*      ld hl,(@scratch)
0B03B4 C9          0634*      ret
0B03B5             0635*  @scratch: ds 6
0B03BB             0636*  
0B03BB             0637*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
0B03BB             0638*  ; output: uh.l is the 16.8 fixed format angle in degrees 256
0B03BB             0639*  ; destroys: a,hl,bc,de
0B03BB             0640*  ; note: only works for angles from 0 to 32 (45) degrees
0B03BB             0641*  ;   use atan2_168fast (which calls this proc) to handle the full 256 (360) degrees
0B03BB             0642*  atan_168fast:
0B03BB             0643*  ; because we use compass headings instead of geometric angles
0B03BB             0644*  ; we compute dx/dy which is 1/tan(theta) in the maths world
0B03BB             0645*  ; we can do faster unsigned division here because we know dx and dy are positive
0B03BB CD CA 01 0B 0646*  	call udiv168 ; ud.e = dx/dy
0B03BF EB          0647*  	ex de,hl ; uh.l = dx/dy
0B03C0             0648*  ; test uh.l for 0
0B03C0 19          0649*      add hl,de
0B03C1 B7          0650*      or a
0B03C2 ED 52       0651*      sbc hl,de
0B03C4 28 22       0652*      jr z,@is_zero
0B03C6             0653*  ; test uh.l for 1
0B03C6 AF          0654*      xor a ; clear carry
0B03C7 EB          0655*      ex de,hl
0B03C8 21 00 01 00 0656*      ld hl,0x000100 ; 1 in 16.8 fixed format
0B03CC ED 52       0657*      sbc hl,de
0B03CE 28 13       0658*      jr z,@is_45
0B03D0 EB          0659*  	ex de,hl
0B03D1             0660*  ; no special cases so we move on
0B03D1             0661*  ; l contains the fractional portion of tan(uh.l)
0B03D1             0662*  ; we multiply it by three to get our lookup table index
0B03D1 26 03       0663*      ld h,3
0B03D3 ED 6C       0664*      mlt hl ; gosh that is handy
0B03D5 11 00 00 00 0665*      ld de,0 ; clear deu
0B03D9 54          0666*      ld d,h ; copy hl to de
0B03DA 5D          0667*      ld e,l ; de contains our index
0B03DB 21 E0 07 0B 0668*      ld hl,atan_lut_168 ; grab the lut address
0B03DF 19          0669*      add hl,de ; bump hl by the index
0B03E0 ED 27       0670*      ld hl,(hl) ; don't try this on a z80!
0B03E2 C9          0671*      ret ; and out
0B03E3             0672*  @is_45:
0B03E3 21 00 20 00 0673*      ld hl,0x002000 ; 45 degrees decimal
0B03E7 C9          0674*      ret
0B03E8             0675*  ; for the case tan(0)
0B03E8             0676*  @is_zero:
0B03E8 21 00 00 00 0677*      ld hl,0x000000
0B03EC C9          0678*      ret
0B03ED             0679*  
0B03ED             0680*  ; Expects  ADL mode
0B03ED             0681*  ; Inputs:  UH.L
0B03ED             0682*  ; Outputs: UH.L is the 16.8 square root
0B03ED             0683*  ;          UDE is the integer difference inputHL-DE^2
0B03ED             0684*  sqrt168:
0B03ED CD F7 03 0B 0685*      call sqrt24
0B03F1 EB          0686*      ex de,hl
0B03F2 29          0687*      add hl,hl
0B03F3 29          0688*      add hl,hl
0B03F4 29          0689*      add hl,hl
0B03F5 29          0690*      add hl,hl
0B03F6 C9          0691*      ret
0B03F7             0692*  
0B03F7             0693*  ; credit: xeda112358
0B03F7             0694*  ; https://www.cemetech.net/forum/viewtopic.php?t=11178&postdays=0&postorder=asc&start=0
0B03F7             0695*  sqrt24:
0B03F7             0696*  ; Expects ADL mode
0B03F7             0697*  ; Inputs: HL
0B03F7             0698*  ; Outputs: DE is the integer square root
0B03F7             0699*  ;  HL is the difference inputHL-DE^2
0B03F7             0700*  ;  c flag reset
0B03F7 01 00 00 00 0701*  	ld bc,0 ; clear bcu
0B03FB 11 00 00 00 0702*  	ld de,0 ; clear deu
0B03FF AF          0703*      xor a
0B0400 45          0704*      ld b,l
0B0401 C5          0705*      push bc
0B0402 47          0706*      ld b,a
0B0403 6F          0707*      ld l,a
0B0404             0708*  ; Iteration 1
0B0404 29          0709*      add hl,hl
0B0405 CB 11       0710*      rl c
0B0407 29          0711*      add hl,hl
0B0408 CB 11       0712*      rl c
0B040A 91          0713*      sub c
0B040B 30 04       0714*      jr nc,$+6
0B040D 1C          0715*      inc e
0B040E 1C          0716*      inc e
0B040F 2F          0717*      cpl
0B0410 4F          0718*      ld c,a
0B0411             0719*  ; Iteration 2
0B0411 29          0720*      add hl,hl
0B0412 CB 11       0721*      rl c
0B0414 29          0722*      add hl,hl
0B0415 CB 11       0723*      rl c
0B0417 CB 13       0724*      rl e
0B0419 7B          0725*      ld a,e
0B041A 91          0726*      sub c
0B041B 30 04       0727*      jr nc,$+6
0B041D 1C          0728*      inc e
0B041E 1C          0729*      inc e
0B041F 2F          0730*      cpl
0B0420 4F          0731*      ld c,a
0B0421             0732*  ; Iteration 3
0B0421 29          0733*      add hl,hl
0B0422 CB 11       0734*      rl c
0B0424 29          0735*      add hl,hl
0B0425 CB 11       0736*      rl c
0B0427 CB 13       0737*      rl e
0B0429 7B          0738*      ld a,e
0B042A 91          0739*      sub c
0B042B 30 04       0740*      jr nc,$+6
0B042D 1C          0741*      inc e
0B042E 1C          0742*      inc e
0B042F 2F          0743*      cpl
0B0430 4F          0744*      ld c,a
0B0431             0745*  ; Iteration 4
0B0431 29          0746*      add hl,hl
0B0432 CB 11       0747*      rl c
0B0434 29          0748*      add hl,hl
0B0435 CB 11       0749*      rl c
0B0437 CB 13       0750*      rl e
0B0439 7B          0751*      ld a,e
0B043A 91          0752*      sub c
0B043B 30 04       0753*      jr nc,$+6
0B043D 1C          0754*      inc e
0B043E 1C          0755*      inc e
0B043F 2F          0756*      cpl
0B0440 4F          0757*      ld c,a
0B0441             0758*  ; Iteration 5
0B0441 29          0759*      add hl,hl
0B0442 CB 11       0760*      rl c
0B0444 29          0761*      add hl,hl
0B0445 CB 11       0762*      rl c
0B0447 CB 13       0763*      rl e
0B0449 7B          0764*      ld a,e
0B044A 91          0765*      sub c
0B044B 30 04       0766*      jr nc,$+6
0B044D 1C          0767*      inc e
0B044E 1C          0768*      inc e
0B044F 2F          0769*      cpl
0B0450 4F          0770*      ld c,a
0B0451             0771*  ; Iteration 6
0B0451 29          0772*      add hl,hl
0B0452 CB 11       0773*      rl c
0B0454 29          0774*      add hl,hl
0B0455 CB 11       0775*      rl c
0B0457 CB 13       0776*      rl e
0B0459 7B          0777*      ld a,e
0B045A 91          0778*      sub c
0B045B 30 04       0779*      jr nc,$+6
0B045D 1C          0780*      inc e
0B045E 1C          0781*      inc e
0B045F 2F          0782*      cpl
0B0460 4F          0783*      ld c,a
0B0461             0784*  ; Iteration 7
0B0461 29          0785*      add hl,hl
0B0462 CB 11       0786*      rl c
0B0464 29          0787*      add hl,hl
0B0465 CB 11       0788*      rl c
0B0467 CB 10       0789*      rl b
0B0469 EB          0790*      ex de,hl
0B046A 29          0791*      add hl,hl
0B046B E5          0792*      push hl
0B046C ED 42       0793*      sbc hl,bc
0B046E 30 06       0794*      jr nc,$+8
0B0470 7C          0795*      ld a,h
0B0471 2F          0796*      cpl
0B0472 47          0797*      ld b,a
0B0473 7D          0798*      ld a,l
0B0474 2F          0799*      cpl
0B0475 4F          0800*      ld c,a
0B0476 E1          0801*      pop hl
0B0477 30 02       0802*      jr nc,$+4
0B0479 23          0803*      inc hl
0B047A 23          0804*      inc hl
0B047B EB          0805*      ex de,hl
0B047C             0806*  ; Iteration 8
0B047C 29          0807*      add hl,hl
0B047D 69          0808*      ld l,c
0B047E 60          0809*      ld h,b
0B047F ED 6A       0810*      adc hl,hl
0B0481 ED 6A       0811*      adc hl,hl
0B0483 EB          0812*      ex de,hl
0B0484 29          0813*      add hl,hl
0B0485 ED 52       0814*      sbc hl,de
0B0487 19          0815*      add hl,de
0B0488 EB          0816*      ex de,hl
0B0489 30 04       0817*      jr nc,$+6
0B048B ED 52       0818*      sbc hl,de
0B048D 13          0819*      inc de
0B048E 13          0820*      inc de
0B048F             0821*  ; Iteration 9
0B048F F1          0822*      pop af
0B0490 17          0823*      rla
0B0491 ED 6A       0824*      adc hl,hl
0B0493 17          0825*      rla
0B0494 ED 6A       0826*      adc hl,hl
0B0496 EB          0827*      ex de,hl
0B0497 29          0828*      add hl,hl
0B0498 ED 52       0829*      sbc hl,de
0B049A 19          0830*      add hl,de
0B049B EB          0831*      ex de,hl
0B049C 30 04       0832*      jr nc,$+6
0B049E ED 52       0833*      sbc hl,de
0B04A0 13          0834*      inc de
0B04A1 13          0835*      inc de
0B04A2             0836*  ; Iteration 10
0B04A2 17          0837*      rla
0B04A3 ED 6A       0838*      adc hl,hl
0B04A5 17          0839*      rla
0B04A6 ED 6A       0840*      adc hl,hl
0B04A8 EB          0841*      ex de,hl
0B04A9 29          0842*      add hl,hl
0B04AA ED 52       0843*      sbc hl,de
0B04AC 19          0844*      add hl,de
0B04AD EB          0845*      ex de,hl
0B04AE 30 04       0846*      jr nc,$+6
0B04B0 ED 52       0847*      sbc hl,de
0B04B2 13          0848*      inc de
0B04B3 13          0849*      inc de
0B04B4             0850*  ; Iteration 11
0B04B4 17          0851*      rla
0B04B5 ED 6A       0852*      adc hl,hl
0B04B7 17          0853*      rla
0B04B8 ED 6A       0854*      adc hl,hl
0B04BA EB          0855*      ex de,hl
0B04BB 29          0856*      add hl,hl
0B04BC ED 52       0857*      sbc hl,de
0B04BE 19          0858*      add hl,de
0B04BF EB          0859*      ex de,hl
0B04C0 30 04       0860*      jr nc,$+6
0B04C2 ED 52       0861*      sbc hl,de
0B04C4 13          0862*      inc de
0B04C5 13          0863*      inc de
0B04C6             0864*  ; Iteration 12
0B04C6 17          0865*      rla
0B04C7 ED 6A       0866*      adc hl,hl
0B04C9 17          0867*      rla
0B04CA ED 6A       0868*      adc hl,hl
0B04CC EB          0869*      ex de,hl
0B04CD 29          0870*      add hl,hl
0B04CE ED 52       0871*      sbc hl,de
0B04D0 19          0872*      add hl,de
0B04D1 EB          0873*      ex de,hl
0B04D2 30 04       0874*      jr nc,$+6
0B04D4 ED 52       0875*      sbc hl,de
0B04D6 13          0876*      inc de
0B04D7 13          0877*      inc de
0B04D8 CB 1A       0878*      rr d
0B04DA CB 1B       0879*      rr e
0B04DC C9          0880*      ret
0B04DD             0881*  
0B04DD             0882*  sin_lut_168:
0B04DD 00 00 00    0883*  	dl 0x000000 ; 0.000 00, 0.000
0B04E0 06 00 00    0884*  	dl 0x000006 ; 1.406 01, 0.025
0B04E3 0C 00 00    0885*  	dl 0x00000C ; 2.813 02, 0.049
0B04E6 12 00 00    0886*  	dl 0x000012 ; 4.219 03, 0.074
0B04E9 19 00 00    0887*  	dl 0x000019 ; 5.625 04, 0.098
0B04EC 1F 00 00    0888*  	dl 0x00001F ; 7.031 05, 0.122
0B04EF 25 00 00    0889*  	dl 0x000025 ; 8.438 06, 0.147
0B04F2 2B 00 00    0890*  	dl 0x00002B ; 9.844 07, 0.171
0B04F5 31 00 00    0891*  	dl 0x000031 ; 11.250 08, 0.195
0B04F8 38 00 00    0892*  	dl 0x000038 ; 12.656 09, 0.219
0B04FB 3E 00 00    0893*  	dl 0x00003E ; 14.063 0A, 0.243
0B04FE 44 00 00    0894*  	dl 0x000044 ; 15.469 0B, 0.267
0B0501 4A 00 00    0895*  	dl 0x00004A ; 16.875 0C, 0.290
0B0504 50 00 00    0896*  	dl 0x000050 ; 18.281 0D, 0.314
0B0507 56 00 00    0897*  	dl 0x000056 ; 19.688 0E, 0.337
0B050A 5C 00 00    0898*  	dl 0x00005C ; 21.094 0F, 0.360
0B050D 61 00 00    0899*  	dl 0x000061 ; 22.500 10, 0.383
0B0510 67 00 00    0900*  	dl 0x000067 ; 23.906 11, 0.405
0B0513 6D 00 00    0901*  	dl 0x00006D ; 25.313 12, 0.428
0B0516 73 00 00    0902*  	dl 0x000073 ; 26.719 13, 0.450
0B0519 78 00 00    0903*  	dl 0x000078 ; 28.125 14, 0.471
0B051C 7E 00 00    0904*  	dl 0x00007E ; 29.531 15, 0.493
0B051F 83 00 00    0905*  	dl 0x000083 ; 30.938 16, 0.514
0B0522 88 00 00    0906*  	dl 0x000088 ; 32.344 17, 0.535
0B0525 8E 00 00    0907*  	dl 0x00008E ; 33.750 18, 0.556
0B0528 93 00 00    0908*  	dl 0x000093 ; 35.156 19, 0.576
0B052B 98 00 00    0909*  	dl 0x000098 ; 36.563 1A, 0.596
0B052E 9D 00 00    0910*  	dl 0x00009D ; 37.969 1B, 0.615
0B0531 A2 00 00    0911*  	dl 0x0000A2 ; 39.375 1C, 0.634
0B0534 A7 00 00    0912*  	dl 0x0000A7 ; 40.781 1D, 0.653
0B0537 AB 00 00    0913*  	dl 0x0000AB ; 42.188 1E, 0.672
0B053A B0 00 00    0914*  	dl 0x0000B0 ; 43.594 1F, 0.690
0B053D B5 00 00    0915*  	dl 0x0000B5 ; 45.000 20, 0.707
0B0540 B9 00 00    0916*  	dl 0x0000B9 ; 46.406 21, 0.724
0B0543 BD 00 00    0917*  	dl 0x0000BD ; 47.813 22, 0.741
0B0546 C1 00 00    0918*  	dl 0x0000C1 ; 49.219 23, 0.757
0B0549 C5 00 00    0919*  	dl 0x0000C5 ; 50.625 24, 0.773
0B054C C9 00 00    0920*  	dl 0x0000C9 ; 52.031 25, 0.788
0B054F CD 00 00    0921*  	dl 0x0000CD ; 53.438 26, 0.803
0B0552 D1 00 00    0922*  	dl 0x0000D1 ; 54.844 27, 0.818
0B0555 D4 00 00    0923*  	dl 0x0000D4 ; 56.250 28, 0.831
0B0558 D8 00 00    0924*  	dl 0x0000D8 ; 57.656 29, 0.845
0B055B DB 00 00    0925*  	dl 0x0000DB ; 59.063 2A, 0.858
0B055E DE 00 00    0926*  	dl 0x0000DE ; 60.469 2B, 0.870
0B0561 E1 00 00    0927*  	dl 0x0000E1 ; 61.875 2C, 0.882
0B0564 E4 00 00    0928*  	dl 0x0000E4 ; 63.281 2D, 0.893
0B0567 E7 00 00    0929*  	dl 0x0000E7 ; 64.688 2E, 0.904
0B056A EA 00 00    0930*  	dl 0x0000EA ; 66.094 2F, 0.914
0B056D EC 00 00    0931*  	dl 0x0000EC ; 67.500 30, 0.924
0B0570 EE 00 00    0932*  	dl 0x0000EE ; 68.906 31, 0.933
0B0573 F1 00 00    0933*  	dl 0x0000F1 ; 70.313 32, 0.942
0B0576 F3 00 00    0934*  	dl 0x0000F3 ; 71.719 33, 0.950
0B0579 F4 00 00    0935*  	dl 0x0000F4 ; 73.125 34, 0.957
0B057C F6 00 00    0936*  	dl 0x0000F6 ; 74.531 35, 0.964
0B057F F8 00 00    0937*  	dl 0x0000F8 ; 75.938 36, 0.970
0B0582 F9 00 00    0938*  	dl 0x0000F9 ; 77.344 37, 0.976
0B0585 FB 00 00    0939*  	dl 0x0000FB ; 78.750 38, 0.981
0B0588 FC 00 00    0940*  	dl 0x0000FC ; 80.156 39, 0.985
0B058B FD 00 00    0941*  	dl 0x0000FD ; 81.563 3A, 0.989
0B058E FE 00 00    0942*  	dl 0x0000FE ; 82.969 3B, 0.992
0B0591 FE 00 00    0943*  	dl 0x0000FE ; 84.375 3C, 0.995
0B0594 FF 00 00    0944*  	dl 0x0000FF ; 85.781 3D, 0.997
0B0597 FF 00 00    0945*  	dl 0x0000FF ; 87.188 3E, 0.999
0B059A FF 00 00    0946*  	dl 0x0000FF ; 88.594 3F, 1.000
0B059D 00 01 00    0947*  	dl 0x000100 ; 90.000 40, 1.000
0B05A0 FF 00 00    0948*  	dl 0x0000FF ; 91.406 41, 1.000
0B05A3 FF 00 00    0949*  	dl 0x0000FF ; 92.813 42, 0.999
0B05A6 FF 00 00    0950*  	dl 0x0000FF ; 94.219 43, 0.997
0B05A9 FE 00 00    0951*  	dl 0x0000FE ; 95.625 44, 0.995
0B05AC FE 00 00    0952*  	dl 0x0000FE ; 97.031 45, 0.992
0B05AF FD 00 00    0953*  	dl 0x0000FD ; 98.438 46, 0.989
0B05B2 FC 00 00    0954*  	dl 0x0000FC ; 99.844 47, 0.985
0B05B5 FB 00 00    0955*  	dl 0x0000FB ; 101.250 48, 0.981
0B05B8 F9 00 00    0956*  	dl 0x0000F9 ; 102.656 49, 0.976
0B05BB F8 00 00    0957*  	dl 0x0000F8 ; 104.063 4A, 0.970
0B05BE F6 00 00    0958*  	dl 0x0000F6 ; 105.469 4B, 0.964
0B05C1 F4 00 00    0959*  	dl 0x0000F4 ; 106.875 4C, 0.957
0B05C4 F3 00 00    0960*  	dl 0x0000F3 ; 108.281 4D, 0.950
0B05C7 F1 00 00    0961*  	dl 0x0000F1 ; 109.688 4E, 0.942
0B05CA EE 00 00    0962*  	dl 0x0000EE ; 111.094 4F, 0.933
0B05CD EC 00 00    0963*  	dl 0x0000EC ; 112.500 50, 0.924
0B05D0 EA 00 00    0964*  	dl 0x0000EA ; 113.906 51, 0.914
0B05D3 E7 00 00    0965*  	dl 0x0000E7 ; 115.313 52, 0.904
0B05D6 E4 00 00    0966*  	dl 0x0000E4 ; 116.719 53, 0.893
0B05D9 E1 00 00    0967*  	dl 0x0000E1 ; 118.125 54, 0.882
0B05DC DE 00 00    0968*  	dl 0x0000DE ; 119.531 55, 0.870
0B05DF DB 00 00    0969*  	dl 0x0000DB ; 120.938 56, 0.858
0B05E2 D8 00 00    0970*  	dl 0x0000D8 ; 122.344 57, 0.845
0B05E5 D4 00 00    0971*  	dl 0x0000D4 ; 123.750 58, 0.831
0B05E8 D1 00 00    0972*  	dl 0x0000D1 ; 125.156 59, 0.818
0B05EB CD 00 00    0973*  	dl 0x0000CD ; 126.563 5A, 0.803
0B05EE C9 00 00    0974*  	dl 0x0000C9 ; 127.969 5B, 0.788
0B05F1 C5 00 00    0975*  	dl 0x0000C5 ; 129.375 5C, 0.773
0B05F4 C1 00 00    0976*  	dl 0x0000C1 ; 130.781 5D, 0.757
0B05F7 BD 00 00    0977*  	dl 0x0000BD ; 132.188 5E, 0.741
0B05FA B9 00 00    0978*  	dl 0x0000B9 ; 133.594 5F, 0.724
0B05FD B5 00 00    0979*  	dl 0x0000B5 ; 135.000 60, 0.707
0B0600 B0 00 00    0980*  	dl 0x0000B0 ; 136.406 61, 0.690
0B0603 AB 00 00    0981*  	dl 0x0000AB ; 137.813 62, 0.672
0B0606 A7 00 00    0982*  	dl 0x0000A7 ; 139.219 63, 0.653
0B0609 A2 00 00    0983*  	dl 0x0000A2 ; 140.625 64, 0.634
0B060C 9D 00 00    0984*  	dl 0x00009D ; 142.031 65, 0.615
0B060F 98 00 00    0985*  	dl 0x000098 ; 143.438 66, 0.596
0B0612 93 00 00    0986*  	dl 0x000093 ; 144.844 67, 0.576
0B0615 8E 00 00    0987*  	dl 0x00008E ; 146.250 68, 0.556
0B0618 88 00 00    0988*  	dl 0x000088 ; 147.656 69, 0.535
0B061B 83 00 00    0989*  	dl 0x000083 ; 149.063 6A, 0.514
0B061E 7E 00 00    0990*  	dl 0x00007E ; 150.469 6B, 0.493
0B0621 78 00 00    0991*  	dl 0x000078 ; 151.875 6C, 0.471
0B0624 73 00 00    0992*  	dl 0x000073 ; 153.281 6D, 0.450
0B0627 6D 00 00    0993*  	dl 0x00006D ; 154.688 6E, 0.428
0B062A 67 00 00    0994*  	dl 0x000067 ; 156.094 6F, 0.405
0B062D 61 00 00    0995*  	dl 0x000061 ; 157.500 70, 0.383
0B0630 5C 00 00    0996*  	dl 0x00005C ; 158.906 71, 0.360
0B0633 56 00 00    0997*  	dl 0x000056 ; 160.313 72, 0.337
0B0636 50 00 00    0998*  	dl 0x000050 ; 161.719 73, 0.314
0B0639 4A 00 00    0999*  	dl 0x00004A ; 163.125 74, 0.290
0B063C 44 00 00    1000*  	dl 0x000044 ; 164.531 75, 0.267
0B063F 3E 00 00    1001*  	dl 0x00003E ; 165.938 76, 0.243
0B0642 38 00 00    1002*  	dl 0x000038 ; 167.344 77, 0.219
0B0645 31 00 00    1003*  	dl 0x000031 ; 168.750 78, 0.195
0B0648 2B 00 00    1004*  	dl 0x00002B ; 170.156 79, 0.171
0B064B 25 00 00    1005*  	dl 0x000025 ; 171.563 7A, 0.147
0B064E 1F 00 00    1006*  	dl 0x00001F ; 172.969 7B, 0.122
0B0651 19 00 00    1007*  	dl 0x000019 ; 174.375 7C, 0.098
0B0654 12 00 00    1008*  	dl 0x000012 ; 175.781 7D, 0.074
0B0657 0C 00 00    1009*  	dl 0x00000C ; 177.188 7E, 0.049
0B065A 06 00 00    1010*  	dl 0x000006 ; 178.594 7F, 0.025
0B065D 00 00 00    1011*  	dl 0x000000 ; 180.000 80, 0.000
0B0660 FA FF FF    1012*  	dl 0xFFFFFA ; 181.406 81, -0.025
0B0663 F4 FF FF    1013*  	dl 0xFFFFF4 ; 182.813 82, -0.049
0B0666 EE FF FF    1014*  	dl 0xFFFFEE ; 184.219 83, -0.074
0B0669 E7 FF FF    1015*  	dl 0xFFFFE7 ; 185.625 84, -0.098
0B066C E1 FF FF    1016*  	dl 0xFFFFE1 ; 187.031 85, -0.122
0B066F DB FF FF    1017*  	dl 0xFFFFDB ; 188.438 86, -0.147
0B0672 D5 FF FF    1018*  	dl 0xFFFFD5 ; 189.844 87, -0.171
0B0675 CF FF FF    1019*  	dl 0xFFFFCF ; 191.250 88, -0.195
0B0678 C8 FF FF    1020*  	dl 0xFFFFC8 ; 192.656 89, -0.219
0B067B C2 FF FF    1021*  	dl 0xFFFFC2 ; 194.063 8A, -0.243
0B067E BC FF FF    1022*  	dl 0xFFFFBC ; 195.469 8B, -0.267
0B0681 B6 FF FF    1023*  	dl 0xFFFFB6 ; 196.875 8C, -0.290
0B0684 B0 FF FF    1024*  	dl 0xFFFFB0 ; 198.281 8D, -0.314
0B0687 AA FF FF    1025*  	dl 0xFFFFAA ; 199.688 8E, -0.337
0B068A A4 FF FF    1026*  	dl 0xFFFFA4 ; 201.094 8F, -0.360
0B068D 9F FF FF    1027*  	dl 0xFFFF9F ; 202.500 90, -0.383
0B0690 99 FF FF    1028*  	dl 0xFFFF99 ; 203.906 91, -0.405
0B0693 93 FF FF    1029*  	dl 0xFFFF93 ; 205.313 92, -0.428
0B0696 8D FF FF    1030*  	dl 0xFFFF8D ; 206.719 93, -0.450
0B0699 88 FF FF    1031*  	dl 0xFFFF88 ; 208.125 94, -0.471
0B069C 82 FF FF    1032*  	dl 0xFFFF82 ; 209.531 95, -0.493
0B069F 7D FF FF    1033*  	dl 0xFFFF7D ; 210.938 96, -0.514
0B06A2 78 FF FF    1034*  	dl 0xFFFF78 ; 212.344 97, -0.535
0B06A5 72 FF FF    1035*  	dl 0xFFFF72 ; 213.750 98, -0.556
0B06A8 6D FF FF    1036*  	dl 0xFFFF6D ; 215.156 99, -0.576
0B06AB 68 FF FF    1037*  	dl 0xFFFF68 ; 216.563 9A, -0.596
0B06AE 63 FF FF    1038*  	dl 0xFFFF63 ; 217.969 9B, -0.615
0B06B1 5E FF FF    1039*  	dl 0xFFFF5E ; 219.375 9C, -0.634
0B06B4 59 FF FF    1040*  	dl 0xFFFF59 ; 220.781 9D, -0.653
0B06B7 55 FF FF    1041*  	dl 0xFFFF55 ; 222.188 9E, -0.672
0B06BA 50 FF FF    1042*  	dl 0xFFFF50 ; 223.594 9F, -0.690
0B06BD 4B FF FF    1043*  	dl 0xFFFF4B ; 225.000 A0, -0.707
0B06C0 47 FF FF    1044*  	dl 0xFFFF47 ; 226.406 A1, -0.724
0B06C3 43 FF FF    1045*  	dl 0xFFFF43 ; 227.813 A2, -0.741
0B06C6 3F FF FF    1046*  	dl 0xFFFF3F ; 229.219 A3, -0.757
0B06C9 3B FF FF    1047*  	dl 0xFFFF3B ; 230.625 A4, -0.773
0B06CC 37 FF FF    1048*  	dl 0xFFFF37 ; 232.031 A5, -0.788
0B06CF 33 FF FF    1049*  	dl 0xFFFF33 ; 233.438 A6, -0.803
0B06D2 2F FF FF    1050*  	dl 0xFFFF2F ; 234.844 A7, -0.818
0B06D5 2C FF FF    1051*  	dl 0xFFFF2C ; 236.250 A8, -0.831
0B06D8 28 FF FF    1052*  	dl 0xFFFF28 ; 237.656 A9, -0.845
0B06DB 25 FF FF    1053*  	dl 0xFFFF25 ; 239.063 AA, -0.858
0B06DE 22 FF FF    1054*  	dl 0xFFFF22 ; 240.469 AB, -0.870
0B06E1 1F FF FF    1055*  	dl 0xFFFF1F ; 241.875 AC, -0.882
0B06E4 1C FF FF    1056*  	dl 0xFFFF1C ; 243.281 AD, -0.893
0B06E7 19 FF FF    1057*  	dl 0xFFFF19 ; 244.688 AE, -0.904
0B06EA 16 FF FF    1058*  	dl 0xFFFF16 ; 246.094 AF, -0.914
0B06ED 14 FF FF    1059*  	dl 0xFFFF14 ; 247.500 B0, -0.924
0B06F0 12 FF FF    1060*  	dl 0xFFFF12 ; 248.906 B1, -0.933
0B06F3 0F FF FF    1061*  	dl 0xFFFF0F ; 250.313 B2, -0.942
0B06F6 0D FF FF    1062*  	dl 0xFFFF0D ; 251.719 B3, -0.950
0B06F9 0C FF FF    1063*  	dl 0xFFFF0C ; 253.125 B4, -0.957
0B06FC 0A FF FF    1064*  	dl 0xFFFF0A ; 254.531 B5, -0.964
0B06FF 08 FF FF    1065*  	dl 0xFFFF08 ; 255.938 B6, -0.970
0B0702 07 FF FF    1066*  	dl 0xFFFF07 ; 257.344 B7, -0.976
0B0705 05 FF FF    1067*  	dl 0xFFFF05 ; 258.750 B8, -0.981
0B0708 04 FF FF    1068*  	dl 0xFFFF04 ; 260.156 B9, -0.985
0B070B 03 FF FF    1069*  	dl 0xFFFF03 ; 261.563 BA, -0.989
0B070E 02 FF FF    1070*  	dl 0xFFFF02 ; 262.969 BB, -0.992
0B0711 02 FF FF    1071*  	dl 0xFFFF02 ; 264.375 BC, -0.995
0B0714 01 FF FF    1072*  	dl 0xFFFF01 ; 265.781 BD, -0.997
0B0717 01 FF FF    1073*  	dl 0xFFFF01 ; 267.188 BE, -0.999
0B071A 01 FF FF    1074*  	dl 0xFFFF01 ; 268.594 BF, -1.000
0B071D 00 FF FF    1075*  	dl 0xFFFF00 ; 270.000 C0, -1.000
0B0720 01 FF FF    1076*  	dl 0xFFFF01 ; 271.406 C1, -1.000
0B0723 01 FF FF    1077*  	dl 0xFFFF01 ; 272.813 C2, -0.999
0B0726 01 FF FF    1078*  	dl 0xFFFF01 ; 274.219 C3, -0.997
0B0729 02 FF FF    1079*  	dl 0xFFFF02 ; 275.625 C4, -0.995
0B072C 02 FF FF    1080*  	dl 0xFFFF02 ; 277.031 C5, -0.992
0B072F 03 FF FF    1081*  	dl 0xFFFF03 ; 278.438 C6, -0.989
0B0732 04 FF FF    1082*  	dl 0xFFFF04 ; 279.844 C7, -0.985
0B0735 05 FF FF    1083*  	dl 0xFFFF05 ; 281.250 C8, -0.981
0B0738 07 FF FF    1084*  	dl 0xFFFF07 ; 282.656 C9, -0.976
0B073B 08 FF FF    1085*  	dl 0xFFFF08 ; 284.063 CA, -0.970
0B073E 0A FF FF    1086*  	dl 0xFFFF0A ; 285.469 CB, -0.964
0B0741 0C FF FF    1087*  	dl 0xFFFF0C ; 286.875 CC, -0.957
0B0744 0D FF FF    1088*  	dl 0xFFFF0D ; 288.281 CD, -0.950
0B0747 0F FF FF    1089*  	dl 0xFFFF0F ; 289.688 CE, -0.942
0B074A 12 FF FF    1090*  	dl 0xFFFF12 ; 291.094 CF, -0.933
0B074D 14 FF FF    1091*  	dl 0xFFFF14 ; 292.500 D0, -0.924
0B0750 16 FF FF    1092*  	dl 0xFFFF16 ; 293.906 D1, -0.914
0B0753 19 FF FF    1093*  	dl 0xFFFF19 ; 295.313 D2, -0.904
0B0756 1C FF FF    1094*  	dl 0xFFFF1C ; 296.719 D3, -0.893
0B0759 1F FF FF    1095*  	dl 0xFFFF1F ; 298.125 D4, -0.882
0B075C 22 FF FF    1096*  	dl 0xFFFF22 ; 299.531 D5, -0.870
0B075F 25 FF FF    1097*  	dl 0xFFFF25 ; 300.938 D6, -0.858
0B0762 28 FF FF    1098*  	dl 0xFFFF28 ; 302.344 D7, -0.845
0B0765 2C FF FF    1099*  	dl 0xFFFF2C ; 303.750 D8, -0.831
0B0768 2F FF FF    1100*  	dl 0xFFFF2F ; 305.156 D9, -0.818
0B076B 33 FF FF    1101*  	dl 0xFFFF33 ; 306.563 DA, -0.803
0B076E 37 FF FF    1102*  	dl 0xFFFF37 ; 307.969 DB, -0.788
0B0771 3B FF FF    1103*  	dl 0xFFFF3B ; 309.375 DC, -0.773
0B0774 3F FF FF    1104*  	dl 0xFFFF3F ; 310.781 DD, -0.757
0B0777 43 FF FF    1105*  	dl 0xFFFF43 ; 312.188 DE, -0.741
0B077A 47 FF FF    1106*  	dl 0xFFFF47 ; 313.594 DF, -0.724
0B077D 4B FF FF    1107*  	dl 0xFFFF4B ; 315.000 E0, -0.707
0B0780 50 FF FF    1108*  	dl 0xFFFF50 ; 316.406 E1, -0.690
0B0783 55 FF FF    1109*  	dl 0xFFFF55 ; 317.813 E2, -0.672
0B0786 59 FF FF    1110*  	dl 0xFFFF59 ; 319.219 E3, -0.653
0B0789 5E FF FF    1111*  	dl 0xFFFF5E ; 320.625 E4, -0.634
0B078C 63 FF FF    1112*  	dl 0xFFFF63 ; 322.031 E5, -0.615
0B078F 68 FF FF    1113*  	dl 0xFFFF68 ; 323.438 E6, -0.596
0B0792 6D FF FF    1114*  	dl 0xFFFF6D ; 324.844 E7, -0.576
0B0795 72 FF FF    1115*  	dl 0xFFFF72 ; 326.250 E8, -0.556
0B0798 78 FF FF    1116*  	dl 0xFFFF78 ; 327.656 E9, -0.535
0B079B 7D FF FF    1117*  	dl 0xFFFF7D ; 329.063 EA, -0.514
0B079E 82 FF FF    1118*  	dl 0xFFFF82 ; 330.469 EB, -0.493
0B07A1 88 FF FF    1119*  	dl 0xFFFF88 ; 331.875 EC, -0.471
0B07A4 8D FF FF    1120*  	dl 0xFFFF8D ; 333.281 ED, -0.450
0B07A7 93 FF FF    1121*  	dl 0xFFFF93 ; 334.688 EE, -0.428
0B07AA 99 FF FF    1122*  	dl 0xFFFF99 ; 336.094 EF, -0.405
0B07AD 9F FF FF    1123*  	dl 0xFFFF9F ; 337.500 F0, -0.383
0B07B0 A4 FF FF    1124*  	dl 0xFFFFA4 ; 338.906 F1, -0.360
0B07B3 AA FF FF    1125*  	dl 0xFFFFAA ; 340.313 F2, -0.337
0B07B6 B0 FF FF    1126*  	dl 0xFFFFB0 ; 341.719 F3, -0.314
0B07B9 B6 FF FF    1127*  	dl 0xFFFFB6 ; 343.125 F4, -0.290
0B07BC BC FF FF    1128*  	dl 0xFFFFBC ; 344.531 F5, -0.267
0B07BF C2 FF FF    1129*  	dl 0xFFFFC2 ; 345.938 F6, -0.243
0B07C2 C8 FF FF    1130*  	dl 0xFFFFC8 ; 347.344 F7, -0.219
0B07C5 CF FF FF    1131*  	dl 0xFFFFCF ; 348.750 F8, -0.195
0B07C8 D5 FF FF    1132*  	dl 0xFFFFD5 ; 350.156 F9, -0.171
0B07CB DB FF FF    1133*  	dl 0xFFFFDB ; 351.563 FA, -0.147
0B07CE E1 FF FF    1134*  	dl 0xFFFFE1 ; 352.969 FB, -0.122
0B07D1 E7 FF FF    1135*  	dl 0xFFFFE7 ; 354.375 FC, -0.098
0B07D4 EE FF FF    1136*  	dl 0xFFFFEE ; 355.781 FD, -0.074
0B07D7 F4 FF FF    1137*  	dl 0xFFFFF4 ; 357.188 FE, -0.049
0B07DA FA FF FF    1138*  	dl 0xFFFFFA ; 358.594 FF, -0.025
0B07DD 00 00 00    1139*  	dl 0x000000 ; 0.000 00, 0.000 for interpolation
0B07E0             1140*  
0B07E0             1141*  atan_lut_168:
0B07E0 00 00 00    1142*  	dl 0x000000 ; 000000, 0.000
0B07E3 28 00 00    1143*  	dl 0x000028 ; 000001, 0.224
0B07E6 51 00 00    1144*  	dl 0x000051 ; 000002, 0.448
0B07E9 7A 00 00    1145*  	dl 0x00007A ; 000003, 0.671
0B07EC A2 00 00    1146*  	dl 0x0000A2 ; 000004, 0.895
0B07EF CB 00 00    1147*  	dl 0x0000CB ; 000005, 1.119
0B07F2 F4 00 00    1148*  	dl 0x0000F4 ; 000006, 1.343
0B07F5 1D 01 00    1149*  	dl 0x00011D ; 000007, 1.566
0B07F8 45 01 00    1150*  	dl 0x000145 ; 000008, 1.790
0B07FB 6E 01 00    1151*  	dl 0x00016E ; 000009, 2.013
0B07FE 97 01 00    1152*  	dl 0x000197 ; 00000A, 2.237
0B0801 BF 01 00    1153*  	dl 0x0001BF ; 00000B, 2.460
0B0804 E8 01 00    1154*  	dl 0x0001E8 ; 00000C, 2.684
0B0807 11 02 00    1155*  	dl 0x000211 ; 00000D, 2.907
0B080A 39 02 00    1156*  	dl 0x000239 ; 00000E, 3.130
0B080D 62 02 00    1157*  	dl 0x000262 ; 00000F, 3.353
0B0810 8B 02 00    1158*  	dl 0x00028B ; 000010, 3.576
0B0813 B3 02 00    1159*  	dl 0x0002B3 ; 000011, 3.799
0B0816 DC 02 00    1160*  	dl 0x0002DC ; 000012, 4.022
0B0819 04 03 00    1161*  	dl 0x000304 ; 000013, 4.245
0B081C 2D 03 00    1162*  	dl 0x00032D ; 000014, 4.467
0B081F 55 03 00    1163*  	dl 0x000355 ; 000015, 4.690
0B0822 7E 03 00    1164*  	dl 0x00037E ; 000016, 4.912
0B0825 A6 03 00    1165*  	dl 0x0003A6 ; 000017, 5.134
0B0828 CE 03 00    1166*  	dl 0x0003CE ; 000018, 5.356
0B082B F7 03 00    1167*  	dl 0x0003F7 ; 000019, 5.578
0B082E 1F 04 00    1168*  	dl 0x00041F ; 00001A, 5.799
0B0831 48 04 00    1169*  	dl 0x000448 ; 00001B, 6.021
0B0834 70 04 00    1170*  	dl 0x000470 ; 00001C, 6.242
0B0837 98 04 00    1171*  	dl 0x000498 ; 00001D, 6.463
0B083A C0 04 00    1172*  	dl 0x0004C0 ; 00001E, 6.684
0B083D E8 04 00    1173*  	dl 0x0004E8 ; 00001F, 6.905
0B0840 11 05 00    1174*  	dl 0x000511 ; 000020, 7.125
0B0843 39 05 00    1175*  	dl 0x000539 ; 000021, 7.345
0B0846 61 05 00    1176*  	dl 0x000561 ; 000022, 7.565
0B0849 89 05 00    1177*  	dl 0x000589 ; 000023, 7.785
0B084C B1 05 00    1178*  	dl 0x0005B1 ; 000024, 8.005
0B084F D9 05 00    1179*  	dl 0x0005D9 ; 000025, 8.224
0B0852 01 06 00    1180*  	dl 0x000601 ; 000026, 8.443
0B0855 28 06 00    1181*  	dl 0x000628 ; 000027, 8.662
0B0858 50 06 00    1182*  	dl 0x000650 ; 000028, 8.881
0B085B 78 06 00    1183*  	dl 0x000678 ; 000029, 9.099
0B085E A0 06 00    1184*  	dl 0x0006A0 ; 00002A, 9.317
0B0861 C7 06 00    1185*  	dl 0x0006C7 ; 00002B, 9.535
0B0864 EF 06 00    1186*  	dl 0x0006EF ; 00002C, 9.752
0B0867 16 07 00    1187*  	dl 0x000716 ; 00002D, 9.970
0B086A 3E 07 00    1188*  	dl 0x00073E ; 00002E, 10.187
0B086D 65 07 00    1189*  	dl 0x000765 ; 00002F, 10.403
0B0870 8D 07 00    1190*  	dl 0x00078D ; 000030, 10.620
0B0873 B4 07 00    1191*  	dl 0x0007B4 ; 000031, 10.836
0B0876 DB 07 00    1192*  	dl 0x0007DB ; 000032, 11.051
0B0879 03 08 00    1193*  	dl 0x000803 ; 000033, 11.267
0B087C 2A 08 00    1194*  	dl 0x00082A ; 000034, 11.482
0B087F 51 08 00    1195*  	dl 0x000851 ; 000035, 11.697
0B0882 78 08 00    1196*  	dl 0x000878 ; 000036, 11.911
0B0885 9F 08 00    1197*  	dl 0x00089F ; 000037, 12.125
0B0888 C6 08 00    1198*  	dl 0x0008C6 ; 000038, 12.339
0B088B ED 08 00    1199*  	dl 0x0008ED ; 000039, 12.553
0B088E 13 09 00    1200*  	dl 0x000913 ; 00003A, 12.766
0B0891 3A 09 00    1201*  	dl 0x00093A ; 00003B, 12.978
0B0894 61 09 00    1202*  	dl 0x000961 ; 00003C, 13.191
0B0897 87 09 00    1203*  	dl 0x000987 ; 00003D, 13.403
0B089A AE 09 00    1204*  	dl 0x0009AE ; 00003E, 13.614
0B089D D4 09 00    1205*  	dl 0x0009D4 ; 00003F, 13.825
0B08A0 FB 09 00    1206*  	dl 0x0009FB ; 000040, 14.036
0B08A3 21 0A 00    1207*  	dl 0x000A21 ; 000041, 14.247
0B08A6 47 0A 00    1208*  	dl 0x000A47 ; 000042, 14.457
0B08A9 6D 0A 00    1209*  	dl 0x000A6D ; 000043, 14.666
0B08AC 94 0A 00    1210*  	dl 0x000A94 ; 000044, 14.876
0B08AF BA 0A 00    1211*  	dl 0x000ABA ; 000045, 15.085
0B08B2 E0 0A 00    1212*  	dl 0x000AE0 ; 000046, 15.293
0B08B5 05 0B 00    1213*  	dl 0x000B05 ; 000047, 15.501
0B08B8 2B 0B 00    1214*  	dl 0x000B2B ; 000048, 15.709
0B08BB 51 0B 00    1215*  	dl 0x000B51 ; 000049, 15.916
0B08BE 77 0B 00    1216*  	dl 0x000B77 ; 00004A, 16.123
0B08C1 9C 0B 00    1217*  	dl 0x000B9C ; 00004B, 16.329
0B08C4 C2 0B 00    1218*  	dl 0x000BC2 ; 00004C, 16.535
0B08C7 E7 0B 00    1219*  	dl 0x000BE7 ; 00004D, 16.740
0B08CA 0C 0C 00    1220*  	dl 0x000C0C ; 00004E, 16.945
0B08CD 32 0C 00    1221*  	dl 0x000C32 ; 00004F, 17.150
0B08D0 57 0C 00    1222*  	dl 0x000C57 ; 000050, 17.354
0B08D3 7C 0C 00    1223*  	dl 0x000C7C ; 000051, 17.558
0B08D6 A1 0C 00    1224*  	dl 0x000CA1 ; 000052, 17.761
0B08D9 C6 0C 00    1225*  	dl 0x000CC6 ; 000053, 17.964
0B08DC EB 0C 00    1226*  	dl 0x000CEB ; 000054, 18.166
0B08DF 0F 0D 00    1227*  	dl 0x000D0F ; 000055, 18.368
0B08E2 34 0D 00    1228*  	dl 0x000D34 ; 000056, 18.569
0B08E5 58 0D 00    1229*  	dl 0x000D58 ; 000057, 18.770
0B08E8 7D 0D 00    1230*  	dl 0x000D7D ; 000058, 18.970
0B08EB A1 0D 00    1231*  	dl 0x000DA1 ; 000059, 19.170
0B08EE C6 0D 00    1232*  	dl 0x000DC6 ; 00005A, 19.370
0B08F1 EA 0D 00    1233*  	dl 0x000DEA ; 00005B, 19.569
0B08F4 0E 0E 00    1234*  	dl 0x000E0E ; 00005C, 19.767
0B08F7 32 0E 00    1235*  	dl 0x000E32 ; 00005D, 19.965
0B08FA 56 0E 00    1236*  	dl 0x000E56 ; 00005E, 20.163
0B08FD 7A 0E 00    1237*  	dl 0x000E7A ; 00005F, 20.360
0B0900 9E 0E 00    1238*  	dl 0x000E9E ; 000060, 20.556
0B0903 C1 0E 00    1239*  	dl 0x000EC1 ; 000061, 20.752
0B0906 E5 0E 00    1240*  	dl 0x000EE5 ; 000062, 20.947
0B0909 08 0F 00    1241*  	dl 0x000F08 ; 000063, 21.142
0B090C 2C 0F 00    1242*  	dl 0x000F2C ; 000064, 21.337
0B090F 4F 0F 00    1243*  	dl 0x000F4F ; 000065, 21.531
0B0912 72 0F 00    1244*  	dl 0x000F72 ; 000066, 21.724
0B0915 95 0F 00    1245*  	dl 0x000F95 ; 000067, 21.917
0B0918 B8 0F 00    1246*  	dl 0x000FB8 ; 000068, 22.109
0B091B DB 0F 00    1247*  	dl 0x000FDB ; 000069, 22.301
0B091E FE 0F 00    1248*  	dl 0x000FFE ; 00006A, 22.493
0B0921 21 10 00    1249*  	dl 0x001021 ; 00006B, 22.683
0B0924 44 10 00    1250*  	dl 0x001044 ; 00006C, 22.874
0B0927 66 10 00    1251*  	dl 0x001066 ; 00006D, 23.063
0B092A 89 10 00    1252*  	dl 0x001089 ; 00006E, 23.253
0B092D AB 10 00    1253*  	dl 0x0010AB ; 00006F, 23.441
0B0930 CD 10 00    1254*  	dl 0x0010CD ; 000070, 23.629
0B0933 EF 10 00    1255*  	dl 0x0010EF ; 000071, 23.817
0B0936 11 11 00    1256*  	dl 0x001111 ; 000072, 24.004
0B0939 33 11 00    1257*  	dl 0x001133 ; 000073, 24.191
0B093C 55 11 00    1258*  	dl 0x001155 ; 000074, 24.376
0B093F 77 11 00    1259*  	dl 0x001177 ; 000075, 24.562
0B0942 99 11 00    1260*  	dl 0x001199 ; 000076, 24.747
0B0945 BA 11 00    1261*  	dl 0x0011BA ; 000077, 24.931
0B0948 DC 11 00    1262*  	dl 0x0011DC ; 000078, 25.115
0B094B FD 11 00    1263*  	dl 0x0011FD ; 000079, 25.298
0B094E 1E 12 00    1264*  	dl 0x00121E ; 00007A, 25.481
0B0951 3F 12 00    1265*  	dl 0x00123F ; 00007B, 25.663
0B0954 60 12 00    1266*  	dl 0x001260 ; 00007C, 25.844
0B0957 81 12 00    1267*  	dl 0x001281 ; 00007D, 26.025
0B095A A2 12 00    1268*  	dl 0x0012A2 ; 00007E, 26.206
0B095D C3 12 00    1269*  	dl 0x0012C3 ; 00007F, 26.386
0B0960 E4 12 00    1270*  	dl 0x0012E4 ; 000080, 26.565
0B0963 04 13 00    1271*  	dl 0x001304 ; 000081, 26.744
0B0966 25 13 00    1272*  	dl 0x001325 ; 000082, 26.922
0B0969 45 13 00    1273*  	dl 0x001345 ; 000083, 27.100
0B096C 65 13 00    1274*  	dl 0x001365 ; 000084, 27.277
0B096F 85 13 00    1275*  	dl 0x001385 ; 000085, 27.453
0B0972 A5 13 00    1276*  	dl 0x0013A5 ; 000086, 27.629
0B0975 C5 13 00    1277*  	dl 0x0013C5 ; 000087, 27.805
0B0978 E5 13 00    1278*  	dl 0x0013E5 ; 000088, 27.979
0B097B 05 14 00    1279*  	dl 0x001405 ; 000089, 28.154
0B097E 24 14 00    1280*  	dl 0x001424 ; 00008A, 28.327
0B0981 44 14 00    1281*  	dl 0x001444 ; 00008B, 28.501
0B0984 63 14 00    1282*  	dl 0x001463 ; 00008C, 28.673
0B0987 83 14 00    1283*  	dl 0x001483 ; 00008D, 28.845
0B098A A2 14 00    1284*  	dl 0x0014A2 ; 00008E, 29.017
0B098D C1 14 00    1285*  	dl 0x0014C1 ; 00008F, 29.187
0B0990 E0 14 00    1286*  	dl 0x0014E0 ; 000090, 29.358
0B0993 FF 14 00    1287*  	dl 0x0014FF ; 000091, 29.527
0B0996 1E 15 00    1288*  	dl 0x00151E ; 000092, 29.697
0B0999 3C 15 00    1289*  	dl 0x00153C ; 000093, 29.865
0B099C 5B 15 00    1290*  	dl 0x00155B ; 000094, 30.033
0B099F 79 15 00    1291*  	dl 0x001579 ; 000095, 30.201
0B09A2 98 15 00    1292*  	dl 0x001598 ; 000096, 30.368
0B09A5 B6 15 00    1293*  	dl 0x0015B6 ; 000097, 30.534
0B09A8 D4 15 00    1294*  	dl 0x0015D4 ; 000098, 30.700
0B09AB F2 15 00    1295*  	dl 0x0015F2 ; 000099, 30.865
0B09AE 10 16 00    1296*  	dl 0x001610 ; 00009A, 31.030
0B09B1 2E 16 00    1297*  	dl 0x00162E ; 00009B, 31.194
0B09B4 4C 16 00    1298*  	dl 0x00164C ; 00009C, 31.357
0B09B7 6A 16 00    1299*  	dl 0x00166A ; 00009D, 31.520
0B09BA 87 16 00    1300*  	dl 0x001687 ; 00009E, 31.682
0B09BD A5 16 00    1301*  	dl 0x0016A5 ; 00009F, 31.844
0B09C0 C2 16 00    1302*  	dl 0x0016C2 ; 0000A0, 32.005
0B09C3 DF 16 00    1303*  	dl 0x0016DF ; 0000A1, 32.166
0B09C6 FC 16 00    1304*  	dl 0x0016FC ; 0000A2, 32.326
0B09C9 19 17 00    1305*  	dl 0x001719 ; 0000A3, 32.486
0B09CC 36 17 00    1306*  	dl 0x001736 ; 0000A4, 32.645
0B09CF 53 17 00    1307*  	dl 0x001753 ; 0000A5, 32.803
0B09D2 70 17 00    1308*  	dl 0x001770 ; 0000A6, 32.961
0B09D5 8C 17 00    1309*  	dl 0x00178C ; 0000A7, 33.118
0B09D8 A9 17 00    1310*  	dl 0x0017A9 ; 0000A8, 33.275
0B09DB C5 17 00    1311*  	dl 0x0017C5 ; 0000A9, 33.431
0B09DE E2 17 00    1312*  	dl 0x0017E2 ; 0000AA, 33.587
0B09E1 FE 17 00    1313*  	dl 0x0017FE ; 0000AB, 33.742
0B09E4 1A 18 00    1314*  	dl 0x00181A ; 0000AC, 33.896
0B09E7 36 18 00    1315*  	dl 0x001836 ; 0000AD, 34.050
0B09EA 52 18 00    1316*  	dl 0x001852 ; 0000AE, 34.203
0B09ED 6E 18 00    1317*  	dl 0x00186E ; 0000AF, 34.356
0B09F0 8A 18 00    1318*  	dl 0x00188A ; 0000B0, 34.509
0B09F3 A5 18 00    1319*  	dl 0x0018A5 ; 0000B1, 34.660
0B09F6 C1 18 00    1320*  	dl 0x0018C1 ; 0000B2, 34.811
0B09F9 DC 18 00    1321*  	dl 0x0018DC ; 0000B3, 34.962
0B09FC F7 18 00    1322*  	dl 0x0018F7 ; 0000B4, 35.112
0B09FF 13 19 00    1323*  	dl 0x001913 ; 0000B5, 35.262
0B0A02 2E 19 00    1324*  	dl 0x00192E ; 0000B6, 35.410
0B0A05 49 19 00    1325*  	dl 0x001949 ; 0000B7, 35.559
0B0A08 64 19 00    1326*  	dl 0x001964 ; 0000B8, 35.707
0B0A0B 7F 19 00    1327*  	dl 0x00197F ; 0000B9, 35.854
0B0A0E 99 19 00    1328*  	dl 0x001999 ; 0000BA, 36.001
0B0A11 B4 19 00    1329*  	dl 0x0019B4 ; 0000BB, 36.147
0B0A14 CE 19 00    1330*  	dl 0x0019CE ; 0000BC, 36.293
0B0A17 E9 19 00    1331*  	dl 0x0019E9 ; 0000BD, 36.438
0B0A1A 03 1A 00    1332*  	dl 0x001A03 ; 0000BE, 36.582
0B0A1D 1D 1A 00    1333*  	dl 0x001A1D ; 0000BF, 36.726
0B0A20 37 1A 00    1334*  	dl 0x001A37 ; 0000C0, 36.870
0B0A23 51 1A 00    1335*  	dl 0x001A51 ; 0000C1, 37.013
0B0A26 6B 1A 00    1336*  	dl 0x001A6B ; 0000C2, 37.155
0B0A29 85 1A 00    1337*  	dl 0x001A85 ; 0000C3, 37.297
0B0A2C 9F 1A 00    1338*  	dl 0x001A9F ; 0000C4, 37.439
0B0A2F B9 1A 00    1339*  	dl 0x001AB9 ; 0000C5, 37.579
0B0A32 D2 1A 00    1340*  	dl 0x001AD2 ; 0000C6, 37.720
0B0A35 EC 1A 00    1341*  	dl 0x001AEC ; 0000C7, 37.859
0B0A38 05 1B 00    1342*  	dl 0x001B05 ; 0000C8, 37.999
0B0A3B 1E 1B 00    1343*  	dl 0x001B1E ; 0000C9, 38.137
0B0A3E 37 1B 00    1344*  	dl 0x001B37 ; 0000CA, 38.276
0B0A41 50 1B 00    1345*  	dl 0x001B50 ; 0000CB, 38.413
0B0A44 69 1B 00    1346*  	dl 0x001B69 ; 0000CC, 38.550
0B0A47 82 1B 00    1347*  	dl 0x001B82 ; 0000CD, 38.687
0B0A4A 9B 1B 00    1348*  	dl 0x001B9B ; 0000CE, 38.823
0B0A4D B4 1B 00    1349*  	dl 0x001BB4 ; 0000CF, 38.959
0B0A50 CC 1B 00    1350*  	dl 0x001BCC ; 0000D0, 39.094
0B0A53 E5 1B 00    1351*  	dl 0x001BE5 ; 0000D1, 39.228
0B0A56 FD 1B 00    1352*  	dl 0x001BFD ; 0000D2, 39.362
0B0A59 16 1C 00    1353*  	dl 0x001C16 ; 0000D3, 39.496
0B0A5C 2E 1C 00    1354*  	dl 0x001C2E ; 0000D4, 39.629
0B0A5F 46 1C 00    1355*  	dl 0x001C46 ; 0000D5, 39.762
0B0A62 5E 1C 00    1356*  	dl 0x001C5E ; 0000D6, 39.894
0B0A65 76 1C 00    1357*  	dl 0x001C76 ; 0000D7, 40.025
0B0A68 8E 1C 00    1358*  	dl 0x001C8E ; 0000D8, 40.156
0B0A6B A5 1C 00    1359*  	dl 0x001CA5 ; 0000D9, 40.286
0B0A6E BD 1C 00    1360*  	dl 0x001CBD ; 0000DA, 40.416
0B0A71 D5 1C 00    1361*  	dl 0x001CD5 ; 0000DB, 40.546
0B0A74 EC 1C 00    1362*  	dl 0x001CEC ; 0000DC, 40.675
0B0A77 04 1D 00    1363*  	dl 0x001D04 ; 0000DD, 40.803
0B0A7A 1B 1D 00    1364*  	dl 0x001D1B ; 0000DE, 40.931
0B0A7D 32 1D 00    1365*  	dl 0x001D32 ; 0000DF, 41.059
0B0A80 49 1D 00    1366*  	dl 0x001D49 ; 0000E0, 41.186
0B0A83 60 1D 00    1367*  	dl 0x001D60 ; 0000E1, 41.312
0B0A86 77 1D 00    1368*  	dl 0x001D77 ; 0000E2, 41.438
0B0A89 8E 1D 00    1369*  	dl 0x001D8E ; 0000E3, 41.564
0B0A8C A5 1D 00    1370*  	dl 0x001DA5 ; 0000E4, 41.689
0B0A8F BB 1D 00    1371*  	dl 0x001DBB ; 0000E5, 41.814
0B0A92 D2 1D 00    1372*  	dl 0x001DD2 ; 0000E6, 41.938
0B0A95 E9 1D 00    1373*  	dl 0x001DE9 ; 0000E7, 42.061
0B0A98 FF 1D 00    1374*  	dl 0x001DFF ; 0000E8, 42.184
0B0A9B 15 1E 00    1375*  	dl 0x001E15 ; 0000E9, 42.307
0B0A9E 2C 1E 00    1376*  	dl 0x001E2C ; 0000EA, 42.429
0B0AA1 42 1E 00    1377*  	dl 0x001E42 ; 0000EB, 42.551
0B0AA4 58 1E 00    1378*  	dl 0x001E58 ; 0000EC, 42.672
0B0AA7 6E 1E 00    1379*  	dl 0x001E6E ; 0000ED, 42.793
0B0AAA 84 1E 00    1380*  	dl 0x001E84 ; 0000EE, 42.913
0B0AAD 99 1E 00    1381*  	dl 0x001E99 ; 0000EF, 43.033
0B0AB0 AF 1E 00    1382*  	dl 0x001EAF ; 0000F0, 43.152
0B0AB3 C5 1E 00    1383*  	dl 0x001EC5 ; 0000F1, 43.271
0B0AB6 DA 1E 00    1384*  	dl 0x001EDA ; 0000F2, 43.390
0B0AB9 F0 1E 00    1385*  	dl 0x001EF0 ; 0000F3, 43.508
0B0ABC 05 1F 00    1386*  	dl 0x001F05 ; 0000F4, 43.625
0B0ABF 1B 1F 00    1387*  	dl 0x001F1B ; 0000F5, 43.742
0B0AC2 30 1F 00    1388*  	dl 0x001F30 ; 0000F6, 43.859
0B0AC5 45 1F 00    1389*  	dl 0x001F45 ; 0000F7, 43.975
0B0AC8 5A 1F 00    1390*  	dl 0x001F5A ; 0000F8, 44.091
0B0ACB 6F 1F 00    1391*  	dl 0x001F6F ; 0000F9, 44.206
0B0ACE 84 1F 00    1392*  	dl 0x001F84 ; 0000FA, 44.321
0B0AD1 99 1F 00    1393*  	dl 0x001F99 ; 0000FB, 44.435
0B0AD4 AD 1F 00    1394*  	dl 0x001FAD ; 0000FC, 44.549
0B0AD7 C2 1F 00    1395*  	dl 0x001FC2 ; 0000FD, 44.662
0B0ADA D7 1F 00    1396*  	dl 0x001FD7 ; 0000FE, 44.775
0B0ADD EB 1F 00    1397*  	dl 0x001FEB ; 0000FF, 44.888
0B0AE0 00 20 00    1398*  	dl 0x002000 ; 000100, 45.000 only needed for interpolation
0B0AE3             1399*  
0B0AE3             1400*  	; include "functions.inc"
0B0AE3             1401*  
0B0AE3             1402*      MACRO printChar char
0B0AE3             1403*          LD A, char
0B0AE3             1404*          RST.LIL 10h
0B0AE3             1405*      ENDMACRO
0B0AE3             1406*  
0B0AE3             1407*  ; put the value in HLU into the accumulator
0B0AE3             1408*  ; destroys: af
0B0AE3             1409*      MACRO HLU_TO_A
0B0AE3             1410*          push hl ; 4 cycles
0B0AE3             1411*          inc sp ; 1 cycle
0B0AE3             1412*          pop af  ; 4 cycles
0B0AE3             1413*          dec sp ; 1 cycle
0B0AE3             1414*                 ; 10 cycles total
0B0AE3             1415*      ENDMACRO
0B0AE3             1416*  
0B0AE3             1417*  ; put the value in the accumulator into HLU
0B0AE3             1418*  ; destroys a
0B0AE3             1419*  A_TO_HLU:
0B0AE3             1420*      ; call is 7 cycles
0B0AE3 22 F0 0A 0B 1421*      ld (@scratch),hl ; 7 cycles
0B0AE7 32 F2 0A 0B 1422*      ld (@scratch+2),a ; 5 cycles
0B0AEB 2A F0 0A 0B 1423*      ld hl,(@scratch) ; 7 cycles
0B0AEF C9          1424*      ret ; 6 cycles
0B0AF0             1425*          ; 25 cycles total
0B0AF0 00 00 00    1426*  @scratch: dl 0
0B0AF3             1427*  
0B0AF3             1428*  
0B0AF3             1429*  ; Print a zero-terminated string inline with code, e.g.:
0B0AF3             1430*  ;
0B0AF3             1431*  ;    call printInline
0B0AF3             1432*  ;    ASCIZ "Hello, world!\r\n"
0B0AF3             1433*  ;
0B0AF3             1434*  ; Destroys: HL,AF
0B0AF3             1435*  printInline:
0B0AF3 E1          1436*      pop hl ; get the return address = pointer to start of string
0B0AF4 CD FA 0A 0B 1437*      call printString ; HL advances to end of string
0B0AF8 E5          1438*      push hl ; restore the return address = pointer to end of string
0B0AF9 C9          1439*      ret
0B0AFA             1440*  
0B0AFA             1441*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
0B0AFA             1442*  ; Print a zero-terminated string
0B0AFA             1443*  ; HL: Pointer to string
0B0AFA             1444*  printString:
0B0AFA C5          1445*  	PUSH	BC
0B0AFB 01 00 00 00 1446*  	LD		BC,0
0B0AFF 3E 00       1447*  	LD 	 	A,0
0B0B01 5B DF       1448*  	RST.LIL 18h
0B0B03 C1          1449*  	POP		BC
0B0B04 C9          1450*  	RET
0B0B05             1451*  ; print a VDU sequence
0B0B05             1452*  ; HL: Pointer to VDU sequence - <1 byte length> <data>
0B0B05             1453*  sendVDUsequence:
0B0B05 C5          1454*  	PUSH	BC
0B0B06 01 00 00 00 1455*  	LD		BC, 0
0B0B0A 4E          1456*  	LD		C, (HL)
0B0B0B 5B DF       1457*  	RST.LIL	18h
0B0B0D C1          1458*  	POP		BC
0B0B0E C9          1459*  	RET
0B0B0F             1460*  ; Print Newline sequence to VDP
0B0B0F             1461*  printNewLine:
0B0B0F F5          1462*      push af ; for some reason rst.lil 10h sets carry flag
0B0B10 3E 0D       1463*  	LD	A, '\r'
0B0B12 5B D7       1464*  	RST.LIL 10h
0B0B14 3E 0A       1465*  	LD	A, '\n'
0B0B16 5B D7       1466*  	RST.LIL 10h
0B0B18 F1          1467*      pop af
0B0B19 C9          1468*  	RET
0B0B1A             1469*  
0B0B1A             1470*  ; Print a 24-bit HEX number
0B0B1A             1471*  ; HLU: Number to print
0B0B1A             1472*  printHex24:
0B0B1A             1473*      HLU_TO_A
0B0B1A E5          0001*M         push hl ; 4 cycles
0B0B1B 33          0002*M         inc sp ; 1 cycle
0B0B1C F1          0003*M         pop af  ; 4 cycles
0B0B1D 3B          0004*M         dec sp ; 1 cycle
0B0B1E             0005*M                ; 10 cycles total
0B0B1E CD 28 0B 0B 1474*  	CALL	printHex8
0B0B22             1475*  ; Print a 16-bit HEX number
0B0B22             1476*  ; HL: Number to print
0B0B22             1477*  printHex16:
0B0B22 7C          1478*  	LD		A,H
0B0B23 CD 28 0B 0B 1479*  	CALL	printHex8
0B0B27 7D          1480*  	LD		A,L
0B0B28             1481*  ; Print an 8-bit HEX number
0B0B28             1482*  ; A: Number to print
0B0B28             1483*  printHex8:
0B0B28 4F          1484*  	LD		C,A
0B0B29 1F          1485*  	RRA
0B0B2A 1F          1486*  	RRA
0B0B2B 1F          1487*  	RRA
0B0B2C 1F          1488*  	RRA
0B0B2D CD 32 0B 0B 1489*  	CALL	@F
0B0B31 79          1490*  	LD		A,C
0B0B32             1491*  @@:
0B0B32 E6 0F       1492*  	AND		0Fh
0B0B34 C6 90       1493*  	ADD		A,90h
0B0B36 27          1494*  	DAA
0B0B37 CE 40       1495*  	ADC		A,40h
0B0B39 27          1496*  	DAA
0B0B3A 5B D7       1497*  	RST.LIL	10h
0B0B3C C9          1498*  	RET
0B0B3D             1499*  
0B0B3D             1500*  printHexUHL:
0B0B3D E5          1501*  	push hl
0B0B3E CD 1A 0B 0B 1502*  	call printHex24
0B0B42 E1          1503*  	pop hl
0B0B43 C9          1504*  	ret
0B0B44             1505*  
0B0B44             1506*  
0B0B44             1507*  ; print registers to screen in hexidecimal format
0B0B44             1508*  ; inputs: none
0B0B44             1509*  ; outputs: values of every register printed to screen
0B0B44             1510*  ;    values of each register in global scratch memory
0B0B44             1511*  ; destroys: nothing
0B0B44             1512*  dumpRegistersHex:
0B0B44             1513*  ; store everything in scratch
0B0B44 22 E9 0B 0B 1514*      ld (@uhl),hl
0B0B48 ED 43 EC 0B 1515*      ld (@ubc),bc
       0B          
0B0B4D ED 53 EF 0B 1516*      ld (@ude),de
       0B          
0B0B52 DD 22 F2 0B 1517*      ld (@uix),ix
       0B          
0B0B57 FD 22 F5 0B 1518*      ld (@uiy),iy
       0B          
0B0B5C F5          1519*      push af
0B0B5D E1          1520*      pop hl
0B0B5E 22 E6 0B 0B 1521*      ld (@uaf),hl
0B0B62 F5          1522*      push af
0B0B63             1523*  
0B0B63             1524*  ; print each register
0B0B63 CD F3 0A 0B 1525*      call printInline
0B0B67 61 66 3D 00 1526*      asciz "af="
0B0B6B 2A E6 0B 0B 1527*      ld hl,(@uaf)
0B0B6F CD 1A 0B 0B 1528*      call printHex24
0B0B73             1529*  
0B0B73 CD F3 0A 0B 1530*      call printInline
0B0B77 20 68 6C 3D 1531*      asciz " hl="
       00          
0B0B7C 2A E9 0B 0B 1532*      ld hl,(@uhl)
0B0B80 CD 1A 0B 0B 1533*      call printHex24
0B0B84             1534*  
0B0B84 CD F3 0A 0B 1535*      call printInline
0B0B88 20 62 63 3D 1536*      asciz " bc="
       00          
0B0B8D 2A EC 0B 0B 1537*      ld hl,(@ubc)
0B0B91 CD 1A 0B 0B 1538*      call printHex24
0B0B95             1539*  
0B0B95 CD F3 0A 0B 1540*      call printInline
0B0B99 20 64 65 3D 1541*      asciz " de="
       00          
0B0B9E 2A EF 0B 0B 1542*      ld hl,(@ude)
0B0BA2 CD 1A 0B 0B 1543*      call printHex24
0B0BA6             1544*  
0B0BA6 CD F3 0A 0B 1545*      call printInline
0B0BAA 20 69 78 3D 1546*      asciz " ix="
       00          
0B0BAF 2A F2 0B 0B 1547*      ld hl,(@uix)
0B0BB3 CD 1A 0B 0B 1548*      call printHex24
0B0BB7             1549*  
0B0BB7 CD F3 0A 0B 1550*      call printInline
0B0BBB 20 69 79 3D 1551*      asciz " iy="
       00          
0B0BC0 2A F5 0B 0B 1552*      ld hl,(@uiy)
0B0BC4 CD 1A 0B 0B 1553*      call printHex24
0B0BC8             1554*  
0B0BC8 CD 0F 0B 0B 1555*      call printNewLine
0B0BCC             1556*  ; restore everything
0B0BCC 2A E9 0B 0B 1557*      ld hl, (@uhl)
0B0BD0 ED 4B EC 0B 1558*      ld bc, (@ubc)
       0B          
0B0BD5 ED 5B EF 0B 1559*      ld de, (@ude)
       0B          
0B0BDA DD 2A F2 0B 1560*      ld ix, (@uix)
       0B          
0B0BDF FD 2A F5 0B 1561*      ld iy, (@uiy)
       0B          
0B0BE4 F1          1562*      pop af
0B0BE5             1563*  ; all done
0B0BE5 C9          1564*      ret
0B0BE6             1565*  
0B0BE6 00 00 00    1566*  @uaf: dl 0
0B0BE9 00 00 00    1567*  @uhl: dl 0
0B0BEC 00 00 00    1568*  @ubc: dl 0
0B0BEF 00 00 00    1569*  @ude: dl 0
0B0BF2 00 00 00    1570*  @uix: dl 0
0B0BF5 00 00 00    1571*  @uiy: dl 0
0B0BF8             1572*  
0B0BF8             1573*  ; Prints the right justified decimal value in HL without leading zeroes
0B0BF8             1574*  ; HL : Value to print
0B0BF8             1575*  ; preserves all registers and flags
0B0BF8             1576*  printDec:
0B0BF8             1577*  ; BEGIN MY CODE
0B0BF8             1578*  ; back up all the things
0B0BF8 F5          1579*      push af
0B0BF9 C5          1580*      push bc
0B0BFA D5          1581*      push de
0B0BFB E5          1582*      push hl
0B0BFC             1583*  ; END MY CODE
0B0BFC 11 24 0C 0B 1584*  	LD	 DE, _printDecBuffer
0B0C00 CD 34 0C 0B 1585*  	CALL u24_to_ascii
0B0C04             1586*  ; BEGIN MY CODE
0B0C04             1587*  ; replace leading zeroes with spaces
0B0C04 21 24 0C 0B 1588*      LD	 HL, _printDecBuffer
0B0C08 06 07       1589*      ld   B, 7 ; if HL was 0, we want to keep the final zero
0B0C0A             1590*  @loop:
0B0C0A 7E          1591*      LD	 A, (HL)
0B0C0B FE 30       1592*      CP	 '0'
0B0C0D C2 17 0C 0B 1593*      JP	 NZ, @done
0B0C11 3E 20       1594*      LD   A, ' '
0B0C13 77          1595*      LD	 (HL), A
0B0C14 23          1596*      INC	 HL
0B0C15             1597*      ; CALL vdu_cursor_forward
0B0C15 10 F3       1598*      DJNZ @loop
0B0C17             1599*  @done:
0B0C17             1600*  ; END MY CODE
0B0C17 21 24 0C 0B 1601*  	LD	 HL, _printDecBuffer
0B0C1B CD FA 0A 0B 1602*  	CALL printString
0B0C1F             1603*  ; BEGIN MY CODE
0B0C1F             1604*  ; restore all the things
0B0C1F E1          1605*      pop hl
0B0C20 D1          1606*      pop de
0B0C21 C1          1607*      pop bc
0B0C22 F1          1608*      pop af
0B0C23             1609*  ; END MY CODE
0B0C23 C9          1610*  	RET
0B0C24 00 00 00 00 1611*  _printDecBuffer: blkb 16,0 ; a few bytes extra just to be sure
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0B0C34             1612*  
0B0C34             1613*  ; This routine converts the unsigned 24-bit value in HLU into it's ASCII representation,
0B0C34             1614*  ; starting to memory location pointing by DE, in decimal form and with leading zeroes
0B0C34             1615*  ; so it will allways be 8 characters length
0B0C34             1616*  ; HL : Value to convert to string
0B0C34             1617*  ; DE : pointer to buffer, at least 8 byte + 0
0B0C34             1618*  u24_to_ascii:
0B0C34 01 80 69 67 1619*  	LD	 BC,-10000000
0B0C38 CD 6B 0C 0B 1620*  	CALL @one_digit
0B0C3C 01 C0 BD F0 1621*  	LD	 BC,-1000000
0B0C40 CD 6B 0C 0B 1622*  	CALL @one_digit
0B0C44 01 60 79 FE 1623*  	LD	 BC,-100000
0B0C48 CD 6B 0C 0B 1624*  	CALL @one_digit
0B0C4C 01 F0 D8 FF 1625*  	LD   BC,-10000
0B0C50 CD 6B 0C 0B 1626*  	CALL @one_digit
0B0C54 01 18 FC FF 1627*  	LD   BC,-1000
0B0C58 CD 6B 0C 0B 1628*  	CALL @one_digit
0B0C5C 01 9C FF FF 1629*  	LD   BC,-100
0B0C60 CD 6B 0C 0B 1630*  	CALL @one_digit
0B0C64 0E F6       1631*  	LD   C,-10
0B0C66 CD 6B 0C 0B 1632*  	CALL @one_digit
0B0C6A 48          1633*  	LD   C,B
0B0C6B             1634*  @one_digit:
0B0C6B 3E 2F       1635*  	LD   A,'0'-1
0B0C6D             1636*  @divide_me:
0B0C6D 3C          1637*  	INC  A
0B0C6E 09          1638*  	ADD  HL,BC
0B0C6F 38 FC       1639*  	JR   C,@divide_me
0B0C71 ED 42       1640*  	SBC  HL,BC
0B0C73 12          1641*  	LD   (DE),A
0B0C74 13          1642*  	INC  DE
0B0C75 C9          1643*  	RET
0B0C76             1644*  
0B0C76             1645*  print_u24:
0B0C76 D5          1646*      push de
0B0C77 E5          1647*      push hl
0B0C78 11 24 0C 0B 1648*      ld de,_printDecBuffer
0B0C7C CD 34 0C 0B 1649*      call u24_to_ascii
0B0C80 21 24 0C 0B 1650*      ld hl,_printDecBuffer
0B0C84 CD FA 0A 0B 1651*      call printString
0B0C88 3E 20       1652*      ld a,' '
0B0C8A 5B D7       1653*      rst.lil 10h
0B0C8C E1          1654*      pop hl
0B0C8D D1          1655*      pop de
0B0C8E C9          1656*      ret
0B0C8F             1657*  
0B0C8F             1658*  ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
0B0C8F             1659*  ; HL : Value to convert to string (integer part in H, fractional part in L)
0B0C8F             1660*  ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
0B0C8F             1661*  u168_to_ascii:
0B0C8F             1662*  ; add a leading space to make room for sign flag if needed
0B0C8F 3E 20       1663*      ld a,' '
0B0C91 12          1664*      ld (de),a
0B0C92 13          1665*      inc de
0B0C93             1666*  ; Convert integer part
0B0C93 E5          1667*      push hl               ; Save HL (we’ll need the fractional part later)
0B0C94 CD B5 00 0B 1668*      call hlu_udiv256    ; Shift to get integer portion in HL
0B0C98 01 F0 D8 FF 1669*      ld   bc, -10000
0B0C9C CD BF 0C 0B 1670*      call @one_int
0B0CA0 01 18 FC FF 1671*      ld   bc, -1000
0B0CA4 CD BF 0C 0B 1672*      call @one_int
0B0CA8 01 9C FF FF 1673*      ld   bc, -100
0B0CAC CD BF 0C 0B 1674*      call @one_int
0B0CB0 0E F6       1675*      ld   c, -10
0B0CB2 CD BF 0C 0B 1676*      call @one_int
0B0CB6 48          1677*      ld   c, b
0B0CB7 CD BF 0C 0B 1678*      call @one_int
0B0CBB C3 CA 0C 0B 1679*      jp   @frac            ; Jump to fractional part conversion
0B0CBF             1680*  @one_int:
0B0CBF 3E 2F       1681*      ld   a, '0' - 1       ; Start ASCII character at '0'
0B0CC1             1682*  @divide_me:
0B0CC1 3C          1683*      inc  a
0B0CC2 09          1684*      add  hl, bc           ; Accumulate until overflow
0B0CC3 38 FC       1685*      jr   c, @divide_me
0B0CC5 ED 42       1686*      sbc  hl, bc           ; Remove excess after overflow
0B0CC7 12          1687*      ld   (de), a          ; Store ASCII digit
0B0CC8 13          1688*      inc  de
0B0CC9 C9          1689*      ret
0B0CCA             1690*  ; Convert fractional part
0B0CCA             1691*  @frac:
0B0CCA 3E 2E       1692*      ld   a, '.'           ; Decimal point
0B0CCC 12          1693*      ld   (de), a
0B0CCD 13          1694*      inc  de
0B0CCE E1          1695*      pop  hl               ; Restore HL with original fraction
0B0CCF 06 03       1696*      ld   b, 3             ; Loop counter for 3 fractional digits
0B0CD1             1697*  @frac_loop:
0B0CD1 26 0A       1698*      ld   h, 10            ; Load multiplier for fractional part
0B0CD3 ED 6C       1699*      mlt  hl               ; Multiply by 10, result in HL (H holds the integer part)
0B0CD5 3E 30       1700*      ld   a, '0'
0B0CD7 84          1701*      add  a, h             ; Convert integer part to ASCII
0B0CD8 12          1702*      ld   (de), a
0B0CD9 13          1703*      inc  de
0B0CDA 10 F5       1704*      djnz @frac_loop       ; Repeat for each fractional digit
0B0CDC             1705*  ; Add null terminator
0B0CDC AF          1706*      xor  a                ; Null terminator
0B0CDD 12          1707*      ld   (de), a
0B0CDE C9          1708*      ret
0B0CDF             1709*  
0B0CDF             1710*  print_u168:
0B0CDF D5          1711*      push de
0B0CE0 E5          1712*      push hl
0B0CE1 11 24 0C 0B 1713*      ld de,_printDecBuffer
0B0CE5 CD 8F 0C 0B 1714*      call u168_to_ascii
0B0CE9 21 24 0C 0B 1715*      ld hl,_printDecBuffer
0B0CED CD FA 0A 0B 1716*      call printString
0B0CF1 E1          1717*      pop hl
0B0CF2 D1          1718*      pop de
0B0CF3 C9          1719*      ret
0B0CF4             1720*  
0B0CF4             1721*  ; signed version of u168_to_ascii
0B0CF4             1722*  s168_to_ascii:
0B0CF4 D5          1723*      push de ; save starting address of buffer
0B0CF5 CD C2 00 0B 1724*      call hlu_abs
0B0CF9 F5          1725*      push af ; save sign flag
0B0CFA CD 8F 0C 0B 1726*      call u168_to_ascii
0B0CFE F1          1727*      pop af ; restore sign flag
0B0CFF D1          1728*      pop de ; restore starting address of buffer
0B0D00 F0          1729*      ret p ; hlu was positive so nothing to do
0B0D01 3E 2D       1730*      ld a,'-'
0B0D03 12          1731*      ld (de),a
0B0D04 C9          1732*      ret
0B0D05             1733*  
0B0D05             1734*  print_s168:
0B0D05 D5          1735*      push de
0B0D06 E5          1736*      push hl
0B0D07 11 24 0C 0B 1737*      ld de,_printDecBuffer
0B0D0B CD F4 0C 0B 1738*      call s168_to_ascii
0B0D0F 21 24 0C 0B 1739*      ld hl,_printDecBuffer
0B0D13 CD FA 0A 0B 1740*      call printString
0B0D17 E1          1741*      pop hl
0B0D18 D1          1742*      pop de
0B0D19 C9          1743*      ret
0B0D1A             1744*  
0B0D1A             1745*  	; include "parse.inc"
0B0D1A             1746*  
0B0D1A             1747*  ;
0B0D1A             1748*  ; Title:	Number Parsing Functions
0B0D1A             1749*  ; Author:	Dean Belfield
0B0D1A             1750*  ; Created:	15/11/2022
0B0D1A             1751*  ; Last Updated:	15/11/2022
0B0D1A             1752*  ; Last Updated: 29/12/2022 Lennart Benchop adapt for 24-bit mode.
0B0D1A             1753*  ; Modinfo:
0B0D1A             1754*  ; 2024/04/08    Adapt for ez80asm
0B0D1A             1755*  
0B0D1A             1756*  ; Read a number and convert to binary
0B0D1A             1757*  ; If prefixed with &, will read as hex, otherwise decimal
0B0D1A             1758*  ;   Inputs: HL: Pointer in string buffer
0B0D1A             1759*  ;  Outputs: HL: Updated text pointer
0B0D1A             1760*  ;           DE: Value
0B0D1A             1761*  ;            A: Terminator (spaces skipped)
0B0D1A             1762*  ;            F: Carry set if valid number, otherwise reset
0B0D1A             1763*  ; Destroys: A,D,E,H,L,F
0B0D1A             1764*  ;
0B0D1A 11 00 00 00 1765*  ASC_TO_NUMBER:		LD		DE, 0			; Initialise DE
0B0D1E             1766*  			; CALL		_skip_spaces		; Skip whitespace
0B0D1E 7E          1767*  			LD		A, (HL)			; Read first character
0B0D1F B7          1768*  			OR		A			; Check for end of string
0B0D20 C8          1769*  			RET		Z			; Return with no carry if not
0B0D21 C5          1770*  			PUSH		BC			; Preserve BC
0B0D22 FE 26       1771*  			CP		'&'			; Is it prefixed with '&' (HEX number)?
0B0D24 20 23       1772*  			JR		NZ, ASC_TO_NUMBER3	; Jump to decimal parser if not
0B0D26 23          1773*  			INC		HL			; Otherwise fall through to ASC_TO_HEX
0B0D27             1774*  ;
0B0D27 7E          1775*  ASC_TO_NUMBER1:		LD		A, (HL)			; Fetch the character
0B0D28 CD 6A 0D 0B 1776*  			CALL   	 	UPPRC			; Convert to uppercase
0B0D2C D6 30       1777*  			SUB		'0'			; Normalise to 0
0B0D2E 38 37       1778*  			JR 		C, ASC_TO_NUMBER4	; Return if < ASCII '0'
0B0D30 FE 0A       1779*  			CP 		10			; Check if >= 10
0B0D32 38 06       1780*  			JR 		C, ASC_TO_NUMBER2	; No, so skip next bit
0B0D34 D6 07       1781*  			SUB 		7			; Adjust ASCII A-F to nibble
0B0D36 FE 10       1782*  			CP 		16			; Check for > F
0B0D38 30 2D       1783*  			JR 		NC, ASC_TO_NUMBER4	; Return if out of range
0B0D3A             1784*  ;
0B0D3A E5          1785*  ASC_TO_NUMBER2:		PUSH		HL			; Stack HL
0B0D3B D5          1786*  			PUSH		DE			; LD HL, DE
0B0D3C E1          1787*  			POP		HL
0B0D3D 29          1788*  			ADD		HL, HL
0B0D3E 29          1789*  			ADD		HL, HL
0B0D3F 29          1790*  			ADD		HL, HL
0B0D40 29          1791*  			ADD		HL, HL
0B0D41 E5          1792*  			PUSH		HL			; LD DE, HL
0B0D42 D1          1793*  			POP		DE
0B0D43 E1          1794*  			POP		HL			; Restore HL
0B0D44 B3          1795*  			OR      	E			; OR the new digit in to the least significant nibble
0B0D45 5F          1796*  			LD      	E, A
0B0D46             1797*  ;
0B0D46 23          1798*  			INC		HL			; Onto the next character
0B0D47 18 DE       1799*  			JR      	ASC_TO_NUMBER1		; And loop
0B0D49             1800*  ;
0B0D49 7E          1801*  ASC_TO_NUMBER3:		LD		A, (HL)
0B0D4A D6 30       1802*  			SUB		'0'			; Normalise to 0
0B0D4C 38 19       1803*  			JR		C, ASC_TO_NUMBER4	; Return if < ASCII '0'
0B0D4E FE 0A       1804*  			CP		10			; Check if >= 10
0B0D50 30 15       1805*  			JR		NC, ASC_TO_NUMBER4	; Return if >= 10
0B0D52             1806*  ;
0B0D52 E5          1807*  			PUSH		HL			; Stack HL
0B0D53 D5          1808*  			PUSH		DE			; LD HL, DE
0B0D54 E1          1809*  			POP		HL
0B0D55 E5          1810*  			PUSH		HL			; LD BC, HL
0B0D56 C1          1811*  			POP		BC
0B0D57 29          1812*  			ADD		HL, HL 			; x 2
0B0D58 29          1813*  			ADD		HL, HL 			; x 4
0B0D59 09          1814*  			ADD		HL, BC 			; x 5
0B0D5A 29          1815*  			ADD		HL, HL 			; x 10
0B0D5B 01 00 00 00 1816*  			LD		BC, 0
0B0D5F 4F          1817*  			LD 		C, A			; LD BCU, A
0B0D60 09          1818*  			ADD		HL, BC			; Add BCU to HL
0B0D61 E5          1819*  			PUSH		HL			; LD DE, HL
0B0D62 D1          1820*  			POP		DE
0B0D63 E1          1821*  			POP		HL			; Restore HL
0B0D64             1822*  ;
0B0D64 23          1823*  			INC		HL
0B0D65 18 E2       1824*  			JR		ASC_TO_NUMBER3
0B0D67 C1          1825*  ASC_TO_NUMBER4:		POP		BC
0B0D68 37          1826*  			SCF					; We have a valid number so set carry
0B0D69 C9          1827*  			RET
0B0D6A             1828*  
0B0D6A             1829*  
0B0D6A             1830*  ; Convert a character to upper case
0B0D6A             1831*  ;  A: Character to convert
0B0D6A             1832*  ;
0B0D6A E6 7F       1833*  UPPRC:  		AND     	7FH
0B0D6C FE 60       1834*  			CP      	'`'
0B0D6E D8          1835*  			RET     	C
0B0D6F E6 5F       1836*  			AND     	5FH			; Convert to upper case
0B0D71 C9          1837*  			RET
0B0D72             1838*  
0B0D72             1839*  ; -----------------------------------------------------------------------
0B0D72             1840*  ;
0B0D72             1841*  ; additional functions by Brandon R. Gates based on Dean's code
0B0D72             1842*  ;
0B0D72             1843*  ;------------------------------------------------------------------------
0B0D72             1844*  ; Read a number and convert to binary (decimal only)
0B0D72             1845*  ; Inputs: hl: Pointer in string buffer
0B0D72             1846*  ; Outputs: hl: Updated text pointer
0B0D72             1847*  ;         de: Value
0B0D72             1848*  ;         a: Terminator (spaces skipped)
0B0D72             1849*  ;         f: Carry set if valid number, otherwise reset
0B0D72             1850*  ; Destroys: a, d, e, h, l, f
0B0D72             1851*  ;------------------------------------------------------------------------
0B0D72             1852*  asc_to_s24:
0B0D72 3E 01       1853*      ld a,1 ; set sign flag
0B0D74 32 C0 0D 0B 1854*      ld (@sign),a ; store sign flag
0B0D78             1855*  
0B0D78 11 00 00 00 1856*      ld de, 0 ; initialise de
0B0D7C             1857*      ; call _skip_spaces ; skip whitespace
0B0D7C             1858*  
0B0D7C 7E          1859*      ld a, (hl) ; read first character
0B0D7D B7          1860*      or a ; check for end of string
0B0D7E C8          1861*      ret z ; return with no carry if not
0B0D7F             1862*  
0B0D7F C5          1863*      push bc ; preserve bc
0B0D80             1864*  
0B0D80 FE 2D       1865*      cp '-' ; check for negative number
0B0D82 C2 8C 0D 0B 1866*      jp nz,@loop ; number is positive, nothing more to do
0B0D86 AF          1867*      xor a ; sign flag to zero
0B0D87 32 C0 0D 0B 1868*      ld (@sign),a ; store sign flag
0B0D8B 23          1869*      inc hl ; skip '-'
0B0D8C             1870*  
0B0D8C             1871*  @loop:
0B0D8C 7E          1872*      ld a, (hl)
0B0D8D D6 30       1873*      sub '0' ; normalise to 0
0B0D8F 38 19       1874*      jr c, @integer_end ; return if < ascii '0'
0B0D91 FE 0A       1875*      cp 10 ; check if >= 10
0B0D93 30 15       1876*      jr nc, @integer_end ; return if >= 10
0B0D95 E5          1877*      push hl ; stack hl
0B0D96 D5          1878*      push de ; ld hl, de
0B0D97 E1          1879*      pop hl
0B0D98 E5          1880*      push hl ; ld bc, hl
0B0D99 C1          1881*      pop bc
0B0D9A 29          1882*      add hl, hl ; x 2
0B0D9B 29          1883*      add hl, hl ; x 4
0B0D9C 09          1884*      add hl, bc ; x 5
0B0D9D 29          1885*      add hl, hl ; x 10
0B0D9E 01 00 00 00 1886*      ld bc, 0
0B0DA2 4F          1887*      ld c, a ; ld bcu, a
0B0DA3 09          1888*      add hl, bc ; add bcu to hl
0B0DA4 E5          1889*      push hl ; ld de, hl
0B0DA5 D1          1890*      pop de
0B0DA6 E1          1891*      pop hl ; restore hl
0B0DA7 23          1892*      inc hl
0B0DA8 18 E2       1893*      jr @loop
0B0DAA             1894*  
0B0DAA             1895*  @integer_end:
0B0DAA C1          1896*      pop bc ; send bc back how she came in
0B0DAB 3A C0 0D 0B 1897*      ld a, (@sign) ; get sign flag
0B0DAF 3D          1898*      dec a ; check if negative
0B0DB0 F2 BE 0D 0B 1899*      jp p,@pos ; positive number
0B0DB4             1900*  
0B0DB4             1901*  ; Negate de
0B0DB4 E5          1902*      push hl ; save text pointer
0B0DB5 21 00 00 00 1903*      ld hl, 0
0B0DB9 AF          1904*      xor a ; clear carry
0B0DBA ED 52       1905*      sbc hl, de ; subtract DE from HL
0B0DBC EB          1906*      ex de, hl ; DE = 0-HL
0B0DBD E1          1907*      pop hl ; restore text pointer
0B0DBE             1908*  
0B0DBE             1909*  @pos:
0B0DBE 37          1910*      scf ; we have a valid number so set carry
0B0DBF C9          1911*      ret
0B0DC0             1912*  
0B0DC0 00          1913*  @sign: db 0 ; sign flag buffer
0B0DC1             1914*  
0B0DC1             1915*  
0B0DC1             1916*  ;------------------------------------------------------------------------
0B0DC1             1917*  ; Read a number and convert to binary (decimal only)
0B0DC1             1918*  ; Inputs: hl: Pointer in string buffer
0B0DC1             1919*  ; Outputs: hl: Updated text pointer
0B0DC1             1920*  ;         de: Value
0B0DC1             1921*  ;         a: Terminator (spaces skipped)
0B0DC1             1922*  ;         f: Carry set if valid number, otherwise reset
0B0DC1             1923*  ; Destroys: a, d, e, h, l, f
0B0DC1             1924*  ;------------------------------------------------------------------------
0B0DC1             1925*  asc_to_s168:
0B0DC1 3E 01       1926*      ld a,1 ; set sign flag
0B0DC3 32 80 0E 0B 1927*      ld (@sign),a ; store sign flag
0B0DC7             1928*  
0B0DC7 11 00 00 00 1929*      ld de, 0 ; initialise de
0B0DCB ED 53 78 0E 1930*      ld (@result), de ; clear low bytes of result buffer
       0B          
0B0DD0 ED 53 7C 0E 1931*      ld (@scratch), de ; clear low bytes of scratch buffer
       0B          
0B0DD5             1932*  
0B0DD5             1933*      ; call _skip_spaces ; skip whitespace
0B0DD5             1934*  
0B0DD5 7E          1935*      ld a, (hl) ; read first character
0B0DD6 B7          1936*      or a ; check for end of string
0B0DD7 C8          1937*      ret z ; return with no carry if not
0B0DD8             1938*  
0B0DD8 C5          1939*      push bc ; preserve bc
0B0DD9             1940*  
0B0DD9 FE 2D       1941*      cp '-' ; check for negative number
0B0DDB C2 E5 0D 0B 1942*      jp nz,@loop ; number is positive, nothing more to do
0B0DDF AF          1943*      xor a ; sign flag to zero
0B0DE0 32 80 0E 0B 1944*      ld (@sign),a ; store sign flag
0B0DE4 23          1945*      inc hl ; skip '-'
0B0DE5             1946*  
0B0DE5             1947*  @loop:
0B0DE5 7E          1948*      ld a, (hl)
0B0DE6             1949*  
0B0DE6             1950*  ; chcek for decimal point
0B0DE6 FE 2E       1951*      cp '.' ; check for decimal point
0B0DE8 CA 29 0E 0B 1952*      jp z,@fractional_start ; jump to fractional part
0B0DEC             1953*  
0B0DEC             1954*  ; process integer part
0B0DEC D6 30       1955*      sub '0' ; normalise to 0
0B0DEE 38 19       1956*      jr c, @integer_end ; return if < ascii '0'
0B0DF0 FE 0A       1957*      cp 10 ; check if >= 10
0B0DF2 30 15       1958*      jr nc, @integer_end ; return if >= 10
0B0DF4 E5          1959*      push hl ; stack hl
0B0DF5 D5          1960*      push de ; ld hl, de
0B0DF6 E1          1961*      pop hl
0B0DF7 E5          1962*      push hl ; ld bc, hl
0B0DF8 C1          1963*      pop bc
0B0DF9 29          1964*      add hl, hl ; x 2
0B0DFA 29          1965*      add hl, hl ; x 4
0B0DFB 09          1966*      add hl, bc ; x 5
0B0DFC 29          1967*      add hl, hl ; x 10
0B0DFD 01 00 00 00 1968*      ld bc, 0
0B0E01 4F          1969*      ld c, a ; ld bcu, a
0B0E02 09          1970*      add hl, bc ; add bcu to hl
0B0E03 E5          1971*      push hl ; ld de, hl
0B0E04 D1          1972*      pop de
0B0E05 E1          1973*      pop hl ; restore hl
0B0E06 23          1974*      inc hl
0B0E07 18 DC       1975*      jr @loop
0B0E09             1976*  
0B0E09             1977*  @integer_end:
0B0E09 ED 53 79 0E 1978*      ld (@result+1), de      ; Store integer part in result buffer (shifted up one byte)
       0B          
0B0E0E             1979*  
0B0E0E             1980*  @end:
0B0E0E C1          1981*      pop bc ; send bc back how she came in
0B0E0F ED 5B 78 0E 1982*      ld de,(@result) ; will contain shifted integer part combined with any fractional value
       0B          
0B0E14 3A 80 0E 0B 1983*      ld a, (@sign) ; get sign flag
0B0E18 3D          1984*      dec a ; check if negative
0B0E19 F2 27 0E 0B 1985*      jp p,@pos ; positive number
0B0E1D             1986*  
0B0E1D             1987*  ; Negate de
0B0E1D E5          1988*      push hl ; save text pointer
0B0E1E 21 00 00 00 1989*      ld hl, 0
0B0E22 AF          1990*      xor a ; clear carry
0B0E23 ED 52       1991*      sbc hl, de ; subtract DE from HL
0B0E25 EB          1992*      ex de, hl ; DE = 0-HL
0B0E26 E1          1993*      pop hl ; restore text pointer
0B0E27             1994*  
0B0E27             1995*  @pos:
0B0E27 37          1996*      scf ; we have a valid number so set carry
0B0E28 C9          1997*      ret
0B0E29             1998*  
0B0E29             1999*  @fractional_start:
0B0E29 DD E5       2000*      push ix                    ; preserve ix
0B0E2B ED 53 79 0E 2001*      ld (@result+1), de         ; Store integer part in result buffer (shifted up one byte)
       0B          
0B0E30 06 03       2002*      ld b, 3                    ; Set loop counter to 3 for up to three fractional digits
0B0E32 11 00 00 00 2003*      ld de, 0                   ; Initialize DE as the fractional accumulator
0B0E36 DD 21 81 0E 2004*      ld ix, powers_of_10        ; Point IX to the lookup table for the scaling factor based on digits
       0B          
0B0E3B 23          2005*      inc hl                     ; Skip decimal point
0B0E3C             2006*  
0B0E3C             2007*  @fractional_loop:
0B0E3C 7E          2008*      ld a, (hl)                 ; Load next character
0B0E3D D6 30       2009*      sub '0'                    ; Normalize ASCII to decimal
0B0E3F 38 1C       2010*      jr c, @end_fraction        ; Exit if < '0'
0B0E41 FE 0A       2011*      cp 10
0B0E43 30 18       2012*      jr nc, @end_fraction       ; Exit if >= 10
0B0E45             2013*  
0B0E45             2014*      ; Multiply the current fractional accumulator by 10
0B0E45 E5          2015*      push hl                    ; Save char pointer
0B0E46 F5          2016*      push af                    ; Save the digit
0B0E47 EB          2017*      ex de, hl
0B0E48 E5          2018*      push hl
0B0E49 29          2019*      add hl,hl ; * 2
0B0E4A 29          2020*      add hl,hl ; * 4
0B0E4B D1          2021*      pop de
0B0E4C 19          2022*      add hl,de ; * 5
0B0E4D 29          2023*      add hl,hl ; * 10
0B0E4E 11 00 00 00 2024*      ld de, 0                   ; Clear DEU
0B0E52 F1          2025*      pop af                     ; Restore the current digit
0B0E53 5F          2026*      ld e, a                    ; Load the digit into E
0B0E54 19          2027*      add hl, de                 ; Add the digit to the accumulator
0B0E55 EB          2028*      ex de, hl                  ; Result back to DE
0B0E56 ED 32 03    2029*      lea ix,ix+3                ; Advance IX to the next scaling factor
0B0E59 E1          2030*      pop hl                     ; Restore char pointer
0B0E5A 23          2031*      inc hl                     ; Move to the next character
0B0E5B 10 DF       2032*      djnz @fractional_loop      ; Loop if more digits to process
0B0E5D             2033*  
0B0E5D             2034*  @end_fraction:
0B0E5D             2035*  ; Final scaling based on number of fractional digits processed
0B0E5D ED 53 7D 0E 2036*      ld (@scratch+1), de          ; Shift fractional part up a byte
       0B          
0B0E62 2A 7C 0E 0B 2037*      ld hl,(@scratch)             ; Load the shifted fractional part into HL
0B0E66             2038*  
0B0E66 DD 17 00    2039*      ld de, (ix)                ; Load final scaling factor from IX based on digit count
0B0E69 CD 32 02 0B 2040*      call udiv24                ; Perform 24-bit division to scale down
0B0E6D 7B          2041*      ld a, e                    ; Load the low byte (8-bit fractional part) into A
0B0E6E 32 78 0E 0B 2042*      ld (@result), a            ; Store fractional part in result buffer
0B0E72 DD E1       2043*      pop ix                     ; Restore ix
0B0E74 C3 0E 0E 0B 2044*      jp @end                    ; Final sign check and flag setup
0B0E78             2045*  
0B0E78             2046*  @result: ds 4                  ; 32-bit result buffer to shift integer part up one byte
0B0E7C             2047*  @scratch: ds 4                 ; 32-bit scratch buffer for intermediate calculations
0B0E80 00          2048*  @sign: db 0                    ; Sign flag buffer
0B0E81             2049*  
0B0E81             2050*  powers_of_10:
0B0E81 01 00 00    2051*      dl 1                       ; 10^0
0B0E84 0A 00 00    2052*      dl 10                      ; 10^1
0B0E87 64 00 00    2053*      dl 100                     ; 10^2
0B0E8A E8 03 00    2054*      dl 1000                    ; 10^3
0B0E8D 10 27 00    2055*      dl 10000                   ; 10^4
0B0E90             0059   
0B0E90             0060   ; --- MAIN PROGRAM ---
0B0E90             0061   main:
0B0E90 0D          0062       dec c ; decrement the argument count to skip the program name
0B0E91             0063   
0B0E91 CD 10 0F 0B 0064       call get_arg_s168
0B0E95 ED 53 03 0F 0065       ld (@arg1),de
       0B          
0B0E9A CD 10 0F 0B 0066       call get_arg_s168
0B0E9E ED 53 06 0F 0067       ld (@arg2),de
       0B          
0B0EA3             0068   
0B0EA3 CD F3 0A 0B 0069       call printInline
0B0EA7 0D 0A 64 69 0070       asciz "\r\ndistance between two points: "
       73 74 61 6E 
       63 65 20 62 
       65 74 77 65 
       65 6E 20 74 
       77 6F 20 70 
       6F 69 6E 74 
       73 3A 20 00 
0B0EC7 2A 03 0F 0B 0071       ld hl,(@arg1)
0B0ECB CD 05 0D 0B 0072       call print_s168
0B0ECF 3E 2C       0073       ld a,',' ; print a comma
0B0ED1 5B D7       0074       rst.lil 10h
0B0ED3 2A 06 0F 0B 0075       ld hl,(@arg2)
0B0ED7 CD 05 0D 0B 0076       call print_s168
0B0EDB CD F3 0A 0B 0077       call printInline
0B0EDF 20 3D 20 00 0078       asciz " = "
0B0EE3             0079   
0B0EE3 ED 4B 03 0F 0080       ld bc,(@arg1)
       0B          
0B0EE8 ED 5B 06 0F 0081       ld de,(@arg2)
       0B          
0B0EED DD 21 00 00 0082       ld ix,0 ; x1 0
       00          
0B0EF2 FD 21 00 00 0083       ld iy,0 ; y1 0
       00          
0B0EF7 CD F6 02 0B 0084       call distance168
0B0EFB CD 05 0D 0B 0085       call print_s168
0B0EFF             0086   
0B0EFF             0087       ; call get_arg_s168
0B0EFF             0088       ; ld (@arg1),de
0B0EFF             0089       ; ex de,hl
0B0EFF             0090       ; call print_s168
0B0EFF             0091       ; ld hl,(@arg1)
0B0EFF             0092       ; call sqrt168
0B0EFF             0093       ; call print_s168
0B0EFF             0094       ; call printNewLine
0B0EFF             0095   
0B0EFF             0096       ; call get_arg_s24
0B0EFF             0097       ; ld (@arg1),de
0B0EFF             0098       ; ex de,hl
0B0EFF             0099       ; call printDec
0B0EFF             0100       ; ld hl,(@arg1)
0B0EFF             0101       ; call sqrt24
0B0EFF             0102       ; ex de,hl
0B0EFF             0103       ; call printDec
0B0EFF             0104       ; call printNewLine
0B0EFF             0105   
0B0EFF C3 8E 00 0B 0106       jp _main_end_ok
0B0F03             0107   
0B0F03 00 00 00    0108   @arg1: dl 0
0B0F06 00 00 00    0109   @arg2: dl 0
0B0F09             0110   
0B0F09             0111   ; ========== HELPER FUNCTIONS ==========
0B0F09             0112   ; get the next argument after ix as a string
0B0F09             0113   ; inputs: ix = pointer to the argument string
0B0F09             0114   ; outputs: HL = pointer to the argument string, ix points to the next argument
0B0F09             0115   ; destroys: a, h, l, f
0B0F09             0116   get_arg_text:
0B0F09 ED 32 03    0117       lea ix,ix+3 ; point to the next argument
0B0F0C DD 27 00    0118       ld hl,(ix) ; get the argument string
0B0F0F C9          0119       ret
0B0F10             0120   
0B0F10             0121   ; get the next argument after ix as a signed 16.8 fixed point number
0B0F10             0122   ; inputs: ix = pointer to the argument string
0B0F10             0123   ; outputs: ude = signed 16.8 fixed point number
0B0F10             0124   ; destroys: a, d, e, h, l, f
0B0F10             0125   get_arg_s168:
0B0F10 ED 32 03    0126       lea ix,ix+3 ; point to the next argument
0B0F13 DD 27 00    0127       ld hl,(ix) ; get the argument string
0B0F16 CD C1 0D 0B 0128       call asc_to_s168 ; convert the string to a number
0B0F1A C9          0129       ret ; return with the value in DE
0B0F1B             0130   
0B0F1B             0131   ; Inputs: ix = pointer to the argument string
0B0F1B             0132   ; Outputs: ude = signed 24-bit integer
0B0F1B             0133   ; Destroys: a, d, e, h, l, f
0B0F1B             0134   get_arg_s24:
0B0F1B ED 32 03    0135       lea ix,ix+3 ; point to the next argument
0B0F1E DD 27 00    0136       ld hl,(ix) ; get the argument string
0B0F21 CD 72 0D 0B 0137       call asc_to_s24 ; convert the string to a number
0B0F25 C9          0138       ret ; return with the value in DE
0B0F26             0139   
0B0F26             0140   ; match the next argument after ix to the dispatch table at iy
0B0F26             0141   ; - arguments and dispatch entries are zero-terminated, case-sensitive strings
0B0F26             0142   ; - final entry of dispatch table must be a 3-byte zero or bad things will happen
0B0F26             0143   ; returns: NO MATCH: iy=dispatch list terminator a=1 and zero flag reset
0B0F26             0144   ; ON MATCH: iy=dispatch address, a=0 and zero flag set
0B0F26             0145   ; destroys: a, hl, de, ix, iy, flags
0B0F26             0146   match_next:
0B0F26 ED 32 03    0147       lea ix,ix+3 ; point to the next argument
0B0F29             0148   @loop:
0B0F29 FD 27 00    0149       ld hl,(iy) ; pointer argument dispatch record
0B0F2C             0150       sign_hlu ; check for list terminator
0B0F2C 19          0001M          add hl,de
0B0F2D B7          0002M          or a
0B0F2E ED 52       0003M          sbc hl,de
0B0F30 CA 48 0F 0B 0151       jp z,@no_match ; if a=0, return error
0B0F34 23          0152       inc hl ; skip over jp instruction
0B0F35 23          0153       inc hl
0B0F36 DD 17 00    0154       ld de,(ix) ; pointer to the argument string
0B0F39 CD 4E 0F 0B 0155       call str_equal ; compare the argument to the dispatch table entry
0B0F3D CA 4A 0F 0B 0156       jp z,@match ; if equal, return success
0B0F41 ED 33 03    0157       lea iy,iy+3 ; if not equal, bump iy to next dispatch table entry
0B0F44 C3 29 0F 0B 0158       jp @loop ; and loop
0B0F48             0159   @no_match:
0B0F48 3C          0160       inc a ; no match so return a=1 and zero flag reset
0B0F49 C9          0161       ret
0B0F4A             0162   @match:
0B0F4A FD 37 00    0163       ld iy,(iy) ; get the function pointer
0B0F4D C9          0164       ret ; return a=0 and zero flag set
0B0F4E             0165   
0B0F4E             0166   ; compare two zero-terminated strings for equality, case-sensitive
0B0F4E             0167   ; hl: pointer to first string, de: pointer to second string
0B0F4E             0168   ; returns: z if equal, nz if not equal
0B0F4E             0169   ; destroys: a, hl, de
0B0F4E             0170   str_equal:
0B0F4E 1A          0171       ld a,(de) ; get the first character
0B0F4F BE          0172       cp (hl) ; compare to the second character
0B0F50 C0          0173       ret nz ; if not equal, return
0B0F51 B7          0174       or a
0B0F52 C8          0175       ret z ; if equal and zero, return
0B0F53 23          0176       inc hl ; next character
0B0F54 13          0177       inc de
0B0F55 C3 4E 0F 0B 0178       jp str_equal ; loop until end of string
0B0F59             0179   
0B0F59             0180   ; === BOILERPLATE MOSLET CODE ===
0B0F59             0181   ; Parse the parameter string into a C array
0B0F59             0182   ; Parameters
0B0F59             0183   ; - HL: Address of parameter string
0B0F59             0184   ; - IX: Address for array pointer storage
0B0F59             0185   ; Returns:
0B0F59             0186   ; - C: Number of parameters parsed
0B0F59             0187   ;
0B0F59 01 34 00 0B 0188   _parse_params: LD BC, _exec_name
0B0F5D DD 0F 00    0189       LD (IX+0), BC ; ARGV[0] = the executable name
0B0F60 ED 32 03    0190       LEA IX, IX+3
0B0F63 CD 9B 0F 0B 0191       CALL _skip_spaces ; Skip HL past any leading spaces
0B0F67             0192   ;
0B0F67 01 01 00 00 0193       LD BC, 1 ; C: ARGC = 1 - also clears out top 16 bits of BCU
0B0F6B 06 0F       0194       LD B, argv_ptrs_max - 1 ; B: Maximum number of argv_ptrs
0B0F6D             0195   ;
0B0F6D             0196   _parse_params_1:
0B0F6D C5          0197       PUSH BC ; Stack ARGC
0B0F6E E5          0198       PUSH HL ; Stack start address of token
0B0F6F CD 8C 0F 0B 0199       CALL _get_token ; Get the next token
0B0F73 79          0200       LD A, C ; A: Length of the token in characters
0B0F74 D1          0201       POP DE ; Start address of token (was in HL)
0B0F75 C1          0202       POP BC ; ARGC
0B0F76 B7          0203       OR A ; Check for A=0 (no token found) OR at end of string
0B0F77 C8          0204       RET Z
0B0F78             0205   ;
0B0F78 DD 1F 00    0206       LD (IX+0), DE ; Store the pointer to the token
0B0F7B E5          0207       PUSH HL ; DE=HL
0B0F7C D1          0208       POP DE
0B0F7D CD 9B 0F 0B 0209       CALL _skip_spaces ; And skip HL past any spaces onto the next character
0B0F81 AF          0210       XOR A
0B0F82 12          0211       LD (DE), A ; Zero-terminate the token
0B0F83 ED 32 03    0212       LEA IX, IX+3 ; Advance to next pointer position
0B0F86 0C          0213       INC C ; Increment ARGC
0B0F87 79          0214       LD A, C ; Check for C >= A
0B0F88 B8          0215       CP B
0B0F89 38 E2       0216       JR C, _parse_params_1 ; And loop
0B0F8B C9          0217       RET
0B0F8C             0218   
0B0F8C             0219   ; Get the next token
0B0F8C             0220   ; Parameters:
0B0F8C             0221   ; - HL: Address of parameter string
0B0F8C             0222   ; Returns:
0B0F8C             0223   ; - HL: Address of first character after token
0B0F8C             0224   ; - C: Length of token (in characters)
0B0F8C             0225   ;
0B0F8C 0E 00       0226   _get_token: LD C, 0 ; Initialise length
0B0F8E 7E          0227   @@: LD A, (HL) ; Get the character from the parameter string
0B0F8F B7          0228       OR A ; Exit if 0 (end of parameter string in MOS)
0B0F90 C8          0229       RET Z
0B0F91 FE 0D       0230       CP 13 ; Exit if CR (end of parameter string in BBC BASIC)
0B0F93 C8          0231       RET Z
0B0F94 FE 20       0232       CP ' ' ; Exit if space (end of token)
0B0F96 C8          0233       RET Z
0B0F97 23          0234       INC HL ; Advance to next character
0B0F98 0C          0235       INC C ; Increment length
0B0F99 18 F3       0236       JR @B
0B0F9B             0237   
0B0F9B             0238   ; Skip spaces in the parameter string
0B0F9B             0239   ; Parameters:
0B0F9B             0240   ; - HL: Address of parameter string
0B0F9B             0241   ; Returns:
0B0F9B             0242   ; - HL: Address of next none-space character
0B0F9B             0243   ; F: Z if at end of string, otherwise NZ if there are more tokens to be parsed
0B0F9B             0244   ;
0B0F9B 7E          0245   _skip_spaces: LD A, (HL) ; Get the character from the parameter string
0B0F9C FE 20       0246       CP ' ' ; Exit if not space
0B0F9E C0          0247       RET NZ
0B0F9F 23          0248       INC HL ; Advance to next character
0B0FA0 18 F9       0249       JR _skip_spaces ; Increment length
