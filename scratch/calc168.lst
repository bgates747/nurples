PC     Output      Line
040000             0001    ASSUME ADL = 1
040000             0002       ORG 0x0B0000 ; Is a moslet
0B0000             0003       ; include "mos_api.inc"
0B0000 C3 45 00 0B 0004       JP _start
0B0004             0005   
0B0004             0006   ; Storage for the argv array pointers
0B0004             0007   min_args: equ 1
0B0004             0008   argv_ptrs_max: EQU 16 ; Maximum number of arguments allowed in argv
0B0004 00 00 00 00 0009   argv_ptrs: BLKP argv_ptrs_max, 0
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0B0034             0010   
0B0034             0011   _exec_name:
0B0034 63 61 6C 63 0012       ASCIZ "calc168" ; The executable name, only used in argv
       31 36 38 00 
0B003C FF FF FF FF 0013       ALIGN 64
0B0040 4D 4F 53    0014       DB "MOS" ; Flag for MOS - to confirm this is a valid MOS command
0B0043 00          0015       DB 00h ; MOS header version 0
0B0044 01          0016       DB 01h ; Flag for run mode (0: Z80, 1: ADL)
0B0045             0017   
0B0045             0018   _start:
0B0045 F5          0019       PUSH AF ; Preserve the registers
0B0046 C5          0020       PUSH BC
0B0047 D5          0021       PUSH DE
0B0048 DD E5       0022       PUSH IX
0B004A FD E5       0023       PUSH IY
0B004C ED 6E       0024       LD A, MB ; Save MB
0B004E F5          0025       PUSH AF
0B004F AF          0026       XOR A
0B0050 ED 6D       0027       LD MB, A ; Clear to zero so MOS API calls know how to use 24-bit addresses.
0B0052 DD 21 04 00 0028       LD IX, argv_ptrs ; The argv array pointer address
       0B          
0B0057 DD E5       0029       PUSH IX
0B0059 CD 97 0F 0B 0030       CALL _parse_params ; Parse the parameters
0B005D DD E1       0031       POP IX ; IX: argv
0B005F 06 00       0032       LD B, 0 ; C: argc
0B0061             0033   
0B0061 CD AF 0E 0B 0034       CALL main ; Start user code
0B0065             0035   
0B0065 F1          0036       POP AF
0B0066 ED 6D       0037       LD MB, A
0B0068 FD E1       0038       POP IY ; Restore registers
0B006A DD E1       0039       POP IX
0B006C D1          0040       POP DE
0B006D C1          0041       POP BC
0B006E F1          0042       POP AF
0B006F C9          0043       RET
0B0070             0044   
0B0070             0045   _main_end_error:
0B0070 CD 12 0B 0B 0046       call printInline
0B0074 41 6E 20 65 0047       asciz "An error occurred!\r\n"
       72 72 6F 72 
       20 6F 63 63 
       75 72 72 65 
       64 21 0D 0A 
       00          
0B0089 21 13 00 00 0048       ld hl,19 ; return error code 19
0B008D C9          0049       ret
0B008E             0050   
0B008E             0051   _main_end_ok:
0B008E CD 12 0B 0B 0052       call printInline
0B0092 0D 0A 0D 0A 0053       asciz "\r\n\r\n"
       00          
0B0097 21 00 00 00 0054       ld hl,0 ; return 0 for success
0B009B C9          0055       ret
0B009C             0056   
0B009C             0057   ;--- APPLICATION INCLUDES ---
0B009C             0058       include "fixed168.inc"
0B009C             0001*  ; multiply HL by 256
0B009C             0002*  ; inputs: HL
0B009C             0003*  ; outputs: HL*256
0B009C             0004*  ; destroys: flags
0B009C             0005*      MACRO hlu_mul256
0B009C             0006*          add hl,hl ; * 2
0B009C             0007*          add hl,hl ; * 4
0B009C             0008*          add hl,hl ; * 8
0B009C             0009*          add hl,hl ; * 16
0B009C             0010*          add hl,hl ; * 32
0B009C             0011*          add hl,hl ; * 64
0B009C             0012*          add hl,hl ; * 128
0B009C             0013*          add hl,hl ; * 256
0B009C             0014*      ENDMACRO
0B009C             0015*  
0B009C             0016*  ; test the sign of HL
0B009C             0017*  ; inputs: HL obviously
0B009C             0018*  ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
0B009C             0019*  ; destroys: flags
0B009C             0020*      MACRO sign_hlu
0B009C             0021*          add hl,de
0B009C             0022*          or a
0B009C             0023*          sbc hl,de
0B009C             0024*      ENDMACRO
0B009C             0025*  
0B009C             0026*  ; hlu signed division by 256
0B009C             0027*  ; returns: hlu / 256
0B009C             0028*  ; destroys: af
0B009C             0029*  hlu_sdiv256:
0B009C AF          0030*      xor a ; assume hl is positive
0B009D 22 B3 00 0B 0031*      ld (@buffer),hl
0B00A1             0032*      sign_hlu
0B00A1 19          0001*M         add hl,de
0B00A2 B7          0002*M         or a
0B00A3 ED 52       0003*M         sbc hl,de
0B00A5 F2 AA 00 0B 0033*      jp p,@hl_pos
0B00A9 3D          0034*      dec a
0B00AA             0035*  @hl_pos:
0B00AA 32 B6 00 0B 0036*      ld (@buffer+3),a
0B00AE 2A B4 00 0B 0037*      ld hl,(@buffer+1)
0B00B2 C9          0038*      ret
0B00B3 00 00 00 00 0039*  @buffer: blkb 4,0
0B00B7             0040*  
0B00B7             0041*  ; hlu 1 byte right shift, unsigned
0B00B7             0042*  ; returns: hlu / 256
0B00B7             0043*  hlu_udiv256:
0B00B7 22 C0 00 0B 0044*  	ld (@buffer),hl
0B00BB 2A C1 00 0B 0045*  	ld hl,(@buffer+1)
0B00BF C9          0046*  	ret
0B00C0 00 00 00 00 0047*  @buffer: blkb 4,0
0B00C4             0048*  
0B00C4             0049*  ; absolute value of hlu
0B00C4             0050*  ; returns: abs(hlu), flags set according to the incoming sign of hlu:
0B00C4             0051*  ;         s1,z0,pv0,n1,c0 if hlu was negative
0B00C4             0052*  ;         s0,z1,pv0,n1,c0 if hlu was zero
0B00C4             0053*  ;         s0,z0,pv0,n1,c0 if hlu was positive
0B00C4             0054*  ; destroys: a
0B00C4             0055*  hlu_abs:
0B00C4 19          0056*      add hl,de
0B00C5 B7          0057*      or a
0B00C6 ED 52       0058*      sbc hl,de
0B00C8 FA CD 00 0B 0059*      jp m,@is_neg
0B00CC C9          0060*      ret         ; hlu is positive or zero so we're done
0B00CD             0061*  @is_neg:
0B00CD F5          0062*      push af     ; otherwise, save current flags for return
0B00CE CD D4 00 0B 0063*      call neg_hlu ; negate hlu
0B00D2 F1          0064*      pop af      ; get back flags
0B00D3 C9          0065*      ret
0B00D4             0066*  
0B00D4             0067*  ; flip the sign of hlu
0B00D4             0068*  ; inputs: hlu
0B00D4             0069*  ; returns: 0-hlu, flags set appropriately for the result:
0B00D4             0070*  ;         s1,z0,pv0,n1,c1 if result is negative
0B00D4             0071*  ;         s0,z1,pv0,n1,c0 if result is zero
0B00D4             0072*  ;         s0,z0,pv0,n1,c1 if result is positive
0B00D4             0073*  ; destroys a
0B00D4             0074*  neg_hlu:
0B00D4 D5          0075*      push de     ; save de
0B00D5 EB          0076*      ex de,hl    ; put hl into de
0B00D6 21 00 00 00 0077*      ld hl,0     ; clear hl
0B00DA AF          0078*      xor a       ; clear carry
0B00DB ED 52       0079*      sbc hl,de   ; 0-hlu = -hlu
0B00DD D1          0080*      pop de      ; get de back
0B00DE C9          0081*      ret         ; easy peasy
0B00DF             0082*  
0B00DF             0083*      ; include "fixed24.inc"
0B00DF             0084*  
0B00DF             0085*  ; multiply a signed 24-bit number by an unsigned 8-bit number giving a signed 24-bit result
0B00DF             0086*  ; uses EZ80 MLT instruction for speed
0B00DF             0087*  ; operation: UHL * A --> UHL
0B00DF             0088*  ; destroys: AF, HL
0B00DF             0089*  smul24x8:
0B00DF             0090*  ; make hl positive and store sign flag
0B00DF CD C4 00 0B 0091*  	call hlu_abs
0B00E3 F5          0092*  	push af
0B00E4             0093*  ; do the division
0B00E4 CD EF 00 0B 0094*      call mul24x8 ; hl = product
0B00E8             0095*  ; adjust sign of result
0B00E8 F1          0096*  	pop af ; sign de
0B00E9 F0          0097*  	ret p ; hl was positive, nothing to do
0B00EA CD D4 00 0B 0098*  	call neg_hlu ; result is negative
0B00EE C9          0099*  	ret
0B00EF             0100*  
0B00EF             0101*  ; unsigned multiplication of a 24-bit and 8-bit number giving a 32-bit result
0B00EF             0102*  ; uses EZ80 MLT instruction for speed
0B00EF             0103*  ; operation: UHL * A --> AUHL
0B00EF             0104*  ; destroys: AF, HL
0B00EF             0105*  mul24x8:
0B00EF D5          0106*  	push de ; preserve de
0B00F0             0107*  ; low byte
0B00F0 5D          0108*  	ld e,l
0B00F1 57          0109*  	ld d,a
0B00F2 ED 5C       0110*  	mlt de
0B00F4 6B          0111*  	ld l,e ; product low byte
0B00F5 08          0112*  	ex af,af' ; save multiplier
0B00F6 7A          0113*  	ld a,d ; carry
0B00F7 08          0114*  	ex af,af' ; save carry, restore multiplier
0B00F8             0115*  ; high byte
0B00F8 5C          0116*  	ld e,h
0B00F9 57          0117*  	ld d,a
0B00FA ED 5C       0118*  	mlt de
0B00FC 08          0119*  	ex af,af' ; save multiplier, restore carry
0B00FD 83          0120*  	add a,e ; add carry
0B00FE 67          0121*  	ld h,a ; product middle byte
0B00FF 7A          0122*  	ld a,d ; carry
0B0100 08          0123*  	ex af,af' ; save carry, restore multiplier
0B0101             0124*  ; upper byte
0B0101 22 1C 01 0B 0125*      ld (@scratch),hl ; 7 cycles
0B0105 5F          0126*  	ld e,a
0B0106 3A 1E 01 0B 0127*  	ld a,(@scratch+2)
0B010A 57          0128*  	ld d,a
0B010B ED 5C       0129*  	mlt de
0B010D 08          0130*  	ex af,af' ; restore carry
0B010E 8B          0131*  	adc a,e ; add carry
0B010F 32 1E 01 0B 0132*      ld (@scratch+2),a ; 5 cycles
0B0113 2A 1C 01 0B 0133*      ld hl,(@scratch) ; 7 cycles
0B0117             0134*  ; highest byte
0B0117 3E 00       0135*  	ld a,0 ; preserve carry flag
0B0119 8A          0136*  	adc a,d ; product highest byte
0B011A D1          0137*  	pop de ; restore de
0B011B C9          0138*  	ret
0B011C             0139*  @scratch: ds 3
0B011F             0140*  
0B011F 00 00 00 00 0141*  mul24out: blkb 6,0
       00 00       
0B0125             0142*  
0B0125             0143*  ; unsigned multiplication of two 24-bit numbers giving a 48-bit result
0B0125             0144*  ; operation: UHL * UDE --> mul24out
0B0125             0145*  mul24:
0B0125 DD E5       0146*  	push ix ; preserve
0B0127             0147*  ; point to output buffer and clear it
0B0127 DD 21 1F 01 0148*  	ld ix,mul24out
       0B          
0B012C C5          0149*  	push bc
0B012D 01 00 00 00 0150*  	ld bc,0
0B0131 DD 0F 00    0151*  	ld (ix),bc
0B0134 DD 0F 03    0152*  	ld (ix+3),bc
0B0137 C1          0153*  	pop bc
0B0138             0154*  ; STEP 1: UHL * E
0B0138 7B          0155*  	ld a,e
0B0139 E5          0156*  	push hl
0B013A CD EF 00 0B 0157*  	call mul24x8
0B013E DD 2F 00    0158*  	ld (ix+0),hl
0B0141 DD 77 03    0159*  	ld (ix+3),a
0B0144             0160*  ; STEP 2: UHL * D
0B0144 E1          0161*  	pop hl
0B0145 E5          0162*  	push hl
0B0146 7A          0163*  	ld a,d
0B0147 CD EF 00 0B 0164*  	call mul24x8
0B014B CD 64 01 0B 0165*  	call @accumulate
0B014F             0166*  ; STEP 3: UHL * DEU
0B014F E1          0167*  	pop hl
0B0150 ED 53 94 01 0168*  	ld (@de),de
       0B          
0B0155 3A 96 01 0B 0169*  	ld a,(@de+2)
0B0159 CD EF 00 0B 0170*  	call mul24x8
0B015D CD 64 01 0B 0171*  	call @accumulate
0B0161             0172*  ; all done
0B0161 DD E1       0173*  	pop ix ; restore
0B0163 C9          0174*  	ret
0B0164             0175*  @accumulate:
0B0164 DD 23       0176*  	inc ix
0B0166             0177*  ; highest byte of product to carry
0B0166 DD 77 03    0178*  	ld (ix+3),a
0B0169             0179*  ; low byte of product
0B0169 7D          0180*  	ld a,l
0B016A DD 86 00    0181*  	add a,(ix+0)
0B016D DD 77 00    0182*  	ld (ix+0),a
0B0170             0183*  ; high byte of product
0B0170 7C          0184*  	ld a,h
0B0171 DD 8E 01    0185*  	adc a,(ix+1)
0B0174 DD 77 01    0186*  	ld (ix+1),a
0B0177             0187*  ; uppper byte of product
0B0177 22 91 01 0B 0188*  	ld (@hl),hl
0B017B 3A 93 01 0B 0189*  	ld a,(@hl+2)
0B017F DD 8E 02    0190*  	adc a,(ix+2)
0B0182 DD 77 02    0191*  	ld (ix+2),a
0B0185             0192*  ; carry
0B0185 3E 00       0193*  	ld a,0 ; preserve flags
0B0187 DD 8E 03    0194*  	adc a,(ix+3)
0B018A DD 77 03    0195*  	ld (ix+3),a
0B018D C9          0196*  	ret
0B018E             0197*  
0B018E 00 00 00    0198*  @ix: dl 0
0B0191 00 00 00    0199*  @hl: dl 0
0B0194 00 00 00    0200*  @de: dl 0
0B0197             0201*  
0B0197             0202*  ; UHL * UDE --> UHL (unsigned)
0B0197             0203*  umul24:
0B0197 CD 25 01 0B 0204*  	call mul24
0B019B 2A 1F 01 0B 0205*  	ld hl,(mul24out)
0B019F C9          0206*  	ret
0B01A0             0207*  
0B01A0             0208*  ; UH.L = UH.L*UD.E (unsigned)
0B01A0             0209*  umul168:
0B01A0 CD 25 01 0B 0210*  	call mul24
0B01A4 2A 20 01 0B 0211*  	ld hl,(mul24out+1)
0B01A8 C9          0212*  	ret
0B01A9             0213*  
0B01A9             0214*  ; UH.L * UD.E --> UH.L (signed)
0B01A9             0215*  smul168:
0B01A9             0216*  ; make everything positive and store sign flags
0B01A9 CD C4 00 0B 0217*  	call hlu_abs
0B01AD F5          0218*  	push af
0B01AE EB          0219*  	ex de,hl
0B01AF CD C4 00 0B 0220*  	call hlu_abs
0B01B3 EB          0221*  	ex de,hl
0B01B4 F5          0222*  	push af
0B01B5             0223*  ; do the division
0B01B5 CD A0 01 0B 0224*      call umul168 ; hl = product
0B01B9             0225*  ; adjust sign of result
0B01B9 F1          0226*  	pop af ; sign de
0B01BA FA C5 01 0B 0227*  	jp m,@de_neg
0B01BE F1          0228*  	pop af ; sign hl
0B01BF F0          0229*  	ret p ; both positive, nothing to do
0B01C0             0230*  @hl_neg:
0B01C0 CD D4 00 0B 0231*      call neg_hlu ; de pos, hl neg, result is negative
0B01C4 C9          0232*      ret
0B01C5             0233*  @de_neg:
0B01C5 F1          0234*  	pop af
0B01C6 F8          0235*  	ret m ; both negative, nothing to do
0B01C7 CD D4 00 0B 0236*  	call neg_hlu ; result is negative
0B01CB C9          0237*  	ret
0B01CC             0238*  
0B01CC             0239*  ; UH.L / UD.E --> UD.E rem UHL (unsigned)
0B01CC             0240*  ; perform unsigned division of 16.8 fixed place values
0B01CC             0241*  ; with an unsigned 16.8 fixed place result and 24-bit remainder
0B01CC             0242*  udiv168:
0B01CC             0243*  ; back up divisor
0B01CC ED 53 03 02 0244*  	ld (@ude),de
       0B          
0B01D1             0245*  ; get the 16-bit integer part of the quotient
0B01D1 CD 34 02 0B 0246*      call udiv24 ; de = quotient, hl = remainder
0B01D5             0247*  ; load quotient to upper three bytes of output
0B01D5 ED 53 0A 02 0248*      ld (div168_out+1),de
       0B          
0B01DA             0249*  @div256:
0B01DA             0250*  ; multiply remainder by 256
0B01DA             0251*  	hlu_mul256
0B01DA 29          0001*M         add hl,hl ; * 2
0B01DB 29          0002*M         add hl,hl ; * 4
0B01DC 29          0003*M         add hl,hl ; * 8
0B01DD 29          0004*M         add hl,hl ; * 16
0B01DE 29          0005*M         add hl,hl ; * 32
0B01DF 29          0006*M         add hl,hl ; * 64
0B01E0 29          0007*M         add hl,hl ; * 128
0B01E1 29          0008*M         add hl,hl ; * 256
0B01E2             0252*  ; skip fractional computation if remainder is zero
0B01E2             0253*      sign_hlu
0B01E2 19          0001*M         add hl,de
0B01E3 B7          0002*M         or a
0B01E4 ED 52       0003*M         sbc hl,de
0B01E6 20 03       0254*      jr nz,@div_frac
0B01E8 AF          0255*      xor a
0B01E9 18 0A       0256*      jr @write_frac
0B01EB             0257*  ; now divide the shifted remainder by the divisor
0B01EB             0258*  @div_frac:
0B01EB ED 5B 03 02 0259*  	ld de,(@ude) ; get back divisor
       0B          
0B01F0 CD 34 02 0B 0260*      call udiv24 ; de = quotient, hl = remainder
0B01F4             0261*  ; load low byte of quotient to low byte of output
0B01F4 7B          0262*      ld a,e
0B01F5             0263*  @write_frac:
0B01F5 32 09 02 0B 0264*      ld (div168_out),a
0B01F9             0265*  ; load de with return value
0B01F9 ED 5B 09 02 0266*      ld de,(div168_out)
       0B          
0B01FE             0267*  ; load a with any overflow
0B01FE 3A 0C 02 0B 0268*      ld a,(div168_out+3)
0B0202 C9          0269*      ret ; ud.e is the 16.8 result
0B0203             0270*  @ude: ds 6
0B0209             0271*  div168_out: ds 4 ; the extra byte is for overflow
0B020D             0272*  
0B020D             0273*  ; UH.L / UD.E --> UD.E (signed) rem UHL (unsigned)
0B020D             0274*  ; perform signed division of 16.8 fixed place values
0B020D             0275*  ; with a signed 16.8 fixed place result and unsigned 24-bit remainder
0B020D             0276*  sdiv168:
0B020D             0277*  ; make everything positive and store sign flags
0B020D CD C4 00 0B 0278*  	call hlu_abs
0B0211 F5          0279*  	push af
0B0212 EB          0280*  	ex de,hl
0B0213 CD C4 00 0B 0281*  	call hlu_abs
0B0217 EB          0282*  	ex de,hl
0B0218 F5          0283*  	push af
0B0219             0284*  ; do the division
0B0219 CD CC 01 0B 0285*      call udiv168 ; de = quotient, hl = remainder
0B021D             0286*  ; adjust sign of result
0B021D F1          0287*  	pop af ; sign de
0B021E FA 2B 02 0B 0288*  	jp m,@de_neg
0B0222 F1          0289*  	pop af ; sign hl
0B0223 F0          0290*  	ret p ; both positive, nothing to do
0B0224             0291*  @hl_neg:
0B0224 EB          0292*      ex de,hl ; hl = quotient, de = remainder
0B0225 CD D4 00 0B 0293*      call neg_hlu ; de pos, hl neg, result is negative
0B0229 EB          0294*      ex de,hl ; de = negated quotient, hl = remainder
0B022A C9          0295*      ret
0B022B             0296*  @de_neg:
0B022B F1          0297*  	pop af
0B022C F8          0298*  	ret m ; both negative, nothing to do
0B022D EB          0299*      ex de,hl ; hl = quotient, de = remainder
0B022E CD D4 00 0B 0300*  	call neg_hlu ; result is negative
0B0232 EB          0301*      ex de,hl ; de = negated quotient, hl = remainder
0B0233 C9          0302*  	ret
0B0234             0303*  
0B0234             0304*  ;------------------------------------------------------------------------
0B0234             0305*  ;  arith24.asm
0B0234             0306*  ;  24-bit ez80 arithmetic routines
0B0234             0307*  ;  Copyright (c) Shawn Sijnstra 2024
0B0234             0308*  ;  MIT license
0B0234             0309*  ;
0B0234             0310*  ;  This library was created as a tool to help make ez80
0B0234             0311*  ;  24-bit native assembly routines for simple mathematical problems
0B0234             0312*  ;  more widely available.
0B0234             0313*  ;
0B0234             0314*  ;------------------------------------------------------------------------
0B0234             0315*  ;
0B0234             0316*  ;------------------------------------------------------------------------
0B0234             0317*  ; udiv24
0B0234             0318*  ; Unsigned 24-bit division
0B0234             0319*  ; Divides HLU by DEU. Gives result in DEU (and BC), remainder in HLU.
0B0234             0320*  ;
0B0234             0321*  ; Uses AF BC DE HL
0B0234             0322*  ; Uses Restoring Division algorithm
0B0234             0323*  ;------------------------------------------------------------------------
0B0234             0324*  
0B0234             0325*  udiv24:
0B0234 E5          0326*  	push	hl
0B0235 C1          0327*  	pop		bc	;move dividend to BCU
0B0236 21 00 00 00 0328*  	ld		hl,0	;result
0B023A A7          0329*  	and		a
0B023B ED 52       0330*  	sbc		hl,de	;test for div by 0
0B023D C8          0331*  	ret		z		;it's zero, carry flag is clear
0B023E 19          0332*  	add		hl,de	;HL is 0 again
0B023F 3E 18       0333*  	ld		a,24	;number of loops through.
0B0241             0334*  udiv1:
0B0241 C5          0335*  	push	bc	;complicated way of doing this because of lack of access to top bits
0B0242 E3          0336*  	ex		(sp),hl
0B0243 37          0337*  	scf
0B0244 ED 6A       0338*  	adc	hl,hl
0B0246 E3          0339*  	ex	(sp),hl
0B0247 C1          0340*  	pop	bc		;we now have bc = (bc * 2) + 1
0B0248             0341*  
0B0248 ED 6A       0342*  	adc	hl,hl
0B024A A7          0343*  	and	a		;is this the bug
0B024B ED 52       0344*  	sbc	hl,de
0B024D 30 02       0345*  	jr	nc,udiv2
0B024F 19          0346*  	add	hl,de
0B0250             0347*  ;	dec	c
0B0250 0B          0348*  	dec	bc
0B0251             0349*  udiv2:
0B0251 3D          0350*  	dec	a
0B0252 20 ED       0351*  	jr	nz,udiv1
0B0254 37          0352*  	scf		;flag used for div0 error
0B0255 C5          0353*  	push	bc
0B0256 D1          0354*  	pop		de	;remainder
0B0257 C9          0355*  	ret
0B0258             0356*  
0B0258             0357*  ;------------------------------------------------------------------------
0B0258             0358*  ;  END 24-bit ez80 arithmetic routines by Shawn Sijnstra
0B0258             0359*  ;------------------------------------------------------------------------
0B0258             0360*  
0B0258             0361*  
0B0258             0362*      ; include "trig24fast.inc"
0B0258             0363*  
0B0258             0364*  
0B0258             0365*  ; convert signed angles from a 360 to 256 degree circle
0B0258             0366*  ; inputs: uh.l is the angle360 in 16.8 fixed format
0B0258             0367*  ; outputs: uh.l is the angle256 in 16.8 fixed format
0B0258             0368*  ; destroys: TODO
0B0258             0369*  deg_360_to_256:
0B0258 D5          0370*  	push de ; preserve de
0B0259             0371*  ; make angle positive and store sign flag
0B0259 CD C4 00 0B 0372*  	call hlu_abs
0B025D F5          0373*  	push af
0B025E             0374*  ; multiply by 256 first to keep precision
0B025E             0375*  	hlu_mul256 ; uh.l = uh.l * 256
0B025E 29          0001*M         add hl,hl ; * 2
0B025F 29          0002*M         add hl,hl ; * 4
0B0260 29          0003*M         add hl,hl ; * 8
0B0261 29          0004*M         add hl,hl ; * 16
0B0262 29          0005*M         add hl,hl ; * 32
0B0263 29          0006*M         add hl,hl ; * 64
0B0264 29          0007*M         add hl,hl ; * 128
0B0265 29          0008*M         add hl,hl ; * 256
0B0266             0376*  ; divide uh.l by 360
0B0266 11 68 01 00 0377*  	ld de,360
0B026A CD 34 02 0B 0378*  	call udiv24 ; ud.e = degrees / 360
0B026E EB          0379*  	ex de,hl    ; uh.l = degrees / 360
0B026F             0380*  ; restore sign flag and adjust output accordingly
0B026F F1          0381*  	pop af
0B0270 F2 78 02 0B 0382*  	jp p,@pos ; positive number
0B0274 CD D4 00 0B 0383*  	call neg_hlu
0B0278             0384*  @pos:
0B0278             0385*  ; restore de and return uh.l as the result
0B0278 D1          0386*  	pop de
0B0279 C9          0387*  	ret
0B027A             0388*  
0B027A             0389*  ; convert signed angles from a 256 to 360 degree circle
0B027A             0390*  ; inputs: uh.l is the angle256 in 16.8 fixed format
0B027A             0391*  ; outputs: uh.l is the angle360 in 16.8 fixed format
0B027A             0392*  ; destroys: TODO
0B027A             0393*  deg_256_to_360:
0B027A D5          0394*  	push de ; preserve de
0B027B             0395*  ; make angle positive and store sign flag
0B027B CD C4 00 0B 0396*  	call hlu_abs
0B027F F5          0397*  	push af
0B0280             0398*  ; multiply by 360 first to keep precision
0B0280 11 68 01 00 0399*  	ld de,360
0B0284 CD 97 01 0B 0400*  	call umul24 ; uh.l = uh.l * 360
0B0288             0401*  ; divide uh.l by 256
0B0288 CD B7 00 0B 0402*  	call hlu_udiv256 ; uh.l = uh.l / 256
0B028C             0403*  ; restore sign flag and adjust output accordingly
0B028C F1          0404*  	pop af
0B028D F2 95 02 0B 0405*  	jp p,@pos ; positive number
0B0291 CD D4 00 0B 0406*  	call neg_hlu
0B0295             0407*  @pos:
0B0295             0408*  ; restore de and return uh.l as the result
0B0295 D1          0409*  	pop de
0B0296 C9          0410*  	ret
0B0297             0411*  
0B0297             0412*  ; fixed 16.8 routine
0B0297             0413*  ; cos(uh.l) --> uh.l
0B0297             0414*  ; destroys: f, hl
0B0297             0415*  cos168:
0B0297 D5          0416*      push de ; preserve de
0B0298             0417*  ; for cos we simply increment the angle by 90 degrees
0B0298             0418*  ; or 0x004000 in 16.8 degrees256
0B0298             0419*  ; which makes it a sin problem
0B0298 11 00 40 00 0420*      ld de,0x004000
0B029C 19          0421*      add hl,de ; modulo 256 happens below
0B029D D1          0422*      pop de ; restore de
0B029E             0423*  ; fall through to sin168
0B029E             0424*  
0B029E             0425*  ; ---------------------
0B029E             0426*  ; fixed 16.8 routine
0B029E             0427*  ; sin(uh.l) --> uh.l
0B029E             0428*  ; destroys: f, hl
0B029E             0429*  sin168:
0B029E D5          0430*  	push de
0B029F             0431*  ; handle negative angles appropriately
0B029F CD C4 00 0B 0432*  	call hlu_abs
0B02A3 F2 AC 02 0B 0433*  	jp p,@F
0B02A7 11 00 00 FF 0434*  	ld de,-256*256
0B02AB 19          0435*  	add hl,de
0B02AC             0436*  @@:
0B02AC 2E 03       0437*  	ld l,3 ; multiply by 3 to get our lookup index
0B02AE ED 6C       0438*      mlt hl
0B02B0 11 FC 04 0B 0439*      ld de,sin_lut_168 ; grab the lut address
0B02B4 19          0440*      add hl,de ; bump hl by the index
0B02B5 ED 27       0441*      ld hl,(hl) ; don't try this on a z80!
0B02B7 D1          0442*      pop de
0B02B8 C9          0443*      ret
0B02B9             0444*  
0B02B9             0445*  ; 16.8 fixed inputs / outputs
0B02B9             0446*  ; takes: uh.l as angle in degrees 256
0B02B9             0447*  ;        ud.e as radius
0B02B9             0448*  ; returns ub.c as dx, ud.e as dy, uh.l as radius
0B02B9             0449*  ;        displacements from origin (0,0)
0B02B9             0450*  ; destroys: everything except indexes
0B02B9             0451*  polar_to_cartesian:
0B02B9             0452*  ; back up input parameters
0B02B9 22 E8 02 0B 0453*      ld (@angle), hl
0B02BD ED 53 EB 02 0454*      ld (@radius), de
       0B          
0B02C2             0455*  ; compute dx = sin(uh.l) * ud.e
0B02C2 CD 9E 02 0B 0456*      call sin168 ; uh.l = sin(uh.l)
0B02C6 ED 5B EB 02 0457*  	ld de,(@radius)
       0B          
0B02CB CD A9 01 0B 0458*  	call smul168 ; uh.l = dx
0B02CF E5          0459*      push hl
0B02D0             0460*  ; compute dy = -cos(uh.l) * ud.e
0B02D0 2A E8 02 0B 0461*      ld hl,(@angle)
0B02D4 CD 97 02 0B 0462*      call cos168 ; uh.l = cos(uh.l)
0B02D8 ED 5B EB 02 0463*      ld de,(@radius)
       0B          
0B02DD CD A9 01 0B 0464*      call smul168    ; uh.l = dy
0B02E1 CD D4 00 0B 0465*      call neg_hlu ; invert dy for screen coords convention
0B02E5 EB          0466*      ex de,hl       ; de = dy for output
0B02E6 C1          0467*      pop bc          ; bc = dx for output
0B02E7             0468*  ; and out
0B02E7 C9          0469*      ret
0B02E8             0470*  @angle: ds 3
0B02EB             0471*  @radius: ds 3
0B02EE             0472*  
0B02EE             0473*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
0B02EE             0474*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
0B02EE             0475*  ; output: ub.c and ud.e are dx and dy in 16.8 fixed format
0B02EE             0476*  ;         also populates scratch locations dx168 and dy168
0B02EE             0477*  ; destroys: a,hl,bc,de
0B02EE             0478*  dxy168:
0B02EE             0479*  ; compute dx = x1-x0
0B02EE AF          0480*      xor a ; clear carry
0B02EF DD E5       0481*      push ix ; move ix to hl via the stack
0B02F1 E1          0482*      pop hl ; hl = x1
0B02F2 ED 42       0483*      sbc hl,bc ; hl = dx
0B02F4 22 09 03 0B 0484*      ld (dx168),hl ; dx to scratch
0B02F8             0485*  ; compute dy = y1-y0
0B02F8 AF          0486*      xor a ; clear carry
0B02F9 FD E5       0487*      push iy ; move iy to hl via the stack
0B02FB E1          0488*      pop hl ; hl = y1
0B02FC ED 52       0489*      sbc hl,de ; hl = dy
0B02FE 22 0F 03 0B 0490*      ld (dy168),hl ; dy to scratch
0B0302             0491*  ; populate output registers and return
0B0302 EB          0492*      ex de,hl        ; ud.e = dy
0B0303 ED 4B 09 03 0493*      ld bc,(dx168)   ; ub.c = dx
       0B          
0B0308 C9          0494*      ret
0B0309 00 00 00 00 0495*  dx168: blkb 6,0
       00 00       
0B030F 00 00 00 00 0496*  dy168: blkb 6,0
       00 00       
0B0315             0497*  
0B0315             0498*  ; compute the euclidian distance between two cartesian coordinates
0B0315             0499*  ; using the formula d = sqrt(dx^2+dy^2)
0B0315             0500*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
0B0315             0501*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
0B0315             0502*  ; output; uh.l is the 16.8 fixed format distance
0B0315             0503*  ;         also populates scratch locations dx168 and dy168
0B0315             0504*  ; destroys: a,hl,bc,de
0B0315             0505*  ; NOTE: rounds both deltas down to the nearest integer to avoid overflow when squaring,
0B0315             0506*  ;       thus the result will always be an integer, albeit in 16.8 format
0B0315             0507*  distance168:
0B0315 CD EE 02 0B 0508*  	call dxy168 ; ub.c = dx, ud.e = dy
0B0319             0509*  ; compute dy^2
0B0319 EB          0510*  	ex de,hl
0B031A CD C4 00 0B 0511*  	call hlu_abs
0B031E CD B7 00 0B 0512*  	call hlu_udiv256 ; make integer to avoid overflow
0B0322 E5          0513*  	push hl
0B0323 D1          0514*  	pop de
0B0324 CD 97 01 0B 0515*  	call umul24 ; hl = dy^2
0B0328 E5          0516*  	push hl ; save dy^2
0B0329             0517*  ; compute dx^2
0B0329 2A 09 03 0B 0518*  	ld hl,(dx168)
0B032D CD C4 00 0B 0519*  	call hlu_abs
0B0331 CD B7 00 0B 0520*  	call hlu_udiv256 ; make integer to avoid overflow
0B0335 E5          0521*  	push hl
0B0336 D1          0522*  	pop de
0B0337 CD 97 01 0B 0523*  	call umul24 ; hl = dx^2
0B033B             0524*  ; add dx^2 and dy^2
0B033B D1          0525*  	pop de ; de = dy^2 (was hl)
0B033C 19          0526*  	add hl,de ; hl = dx^2 + dy^2
0B033D             0527*  ; compute the square root
0B033D CD 16 04 0B 0528*  	call sqrt24 ; de = sqrt(dx^2 + dy^2)
0B0341 EB          0529*      ex de,hl ; hl = distance
0B0342             0530*      hlu_mul256 ; convert back to 16.8 fixed
0B0342 29          0001*M         add hl,hl ; * 2
0B0343 29          0002*M         add hl,hl ; * 4
0B0344 29          0003*M         add hl,hl ; * 8
0B0345 29          0004*M         add hl,hl ; * 16
0B0346 29          0005*M         add hl,hl ; * 32
0B0347 29          0006*M         add hl,hl ; * 64
0B0348 29          0007*M         add hl,hl ; * 128
0B0349 29          0008*M         add hl,hl ; * 256
0B034A C9          0531*  	ret
0B034B             0532*  
0B034B             0533*  ; atan2_(ub.c,ud.e) --> uh.l
0B034B             0534*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
0B034B             0535*  ;   whether inputs are integers or fractional doesn't matter
0B034B             0536*  ;   so long as the sign bit of the upper byte is correct
0B034B             0537*  ; output: uh.l is the 16.8 fixed angle in degrees 256
0B034B             0538*  ; angles are COMPASS HEADINGS based on
0B034B             0539*  ; screen coordinate conventions,where the y axis is flipped
0B034B             0540*  ; #E0 315      0       45 #20
0B034B             0541*  ;        -x,-y | +x,-y
0B034B             0542*  ; #C0 270------+------ 90 #40
0B034B             0543*  ;        -x,+y | +x,+y
0B034B             0544*  ; #A0 225   180 #80   135 #60
0B034B             0545*  atan2_168fast:
0B034B             0546*  ; get signs and make everything positive
0B034B             0547*  ; get abs(x) and store its original sign
0B034B C5          0548*      push bc
0B034C E1          0549*      pop hl
0B034D CD C4 00 0B 0550*      call hlu_abs ; if x was negative this also sets the sign flag
0B0351 E5          0551*      push hl ; store abs(x)
0B0352 C1          0552*      pop bc ; bc = abs(x)
0B0353 F5          0553*      push af ; store sign of x
0B0354             0554*  ; get abs(y) and store its original sign
0B0354 EB          0555*      ex de,hl ; hl = y
0B0355 CD C4 00 0B 0556*      call hlu_abs ; if y was negative this also sets the sign flag
0B0359 EB          0557*      ex de,hl ; de = abs(y)
0B035A F5          0558*      push af ; store sign of y
0B035B             0559*  ; if abs(bc) < abs(de),then we do bc/de,otherwise de/bc
0B035B             0560*  ; this ensures that our lookup value is between 0 and 1 inclusive
0B035B AF          0561*      xor a ; clear the carry flag
0B035C D5          0562*      push de
0B035D E1          0563*      pop hl
0B035E ED 42       0564*      sbc hl,bc
0B0360 F5          0565*      push af ; save sign of de - bc
0B0361 F2 6A 03 0B 0566*      jp p,@1 ; bc <= de, so we skip ahead
0B0365             0567*  ; otherwise we swap bc and de
0B0365 C5          0568*      push bc
0B0366 E1          0569*      pop hl
0B0367 EB          0570*      ex de,hl
0B0368 E5          0571*      push hl
0B0369 C1          0572*      pop bc
0B036A             0573*  @1:
0B036A             0574*  ; now we're ready to snag our preliminary result
0B036A C5          0575*  	push bc
0B036B E1          0576*  	pop hl
0B036C CD DA 03 0B 0577*      call atan_168fast ; uh.l comes back with prelim result
0B0370             0578*  ; now we adjust uh.l based on sign of de - bc
0B0370 F1          0579*      pop af
0B0371 F2 7D 03 0B 0580*      jp p,@2 ; bc <= de,so we skip ahead
0B0375 EB          0581*      ex de,hl
0B0376 21 00 40 00 0582*      ld hl,0x004000 ; 90 degrees
0B037A AF          0583*      xor a ; clear the carry flag
0B037B ED 52       0584*      sbc hl,de ; subtract result from 90 degrees
0B037D             0585*  @2:
0B037D             0586*  ; now the fun part of adjusting the result
0B037D             0587*  ; based on which quadrant (x,y) is in
0B037D             0588*  ; #E0 315      0       45 #20
0B037D             0589*  ;        -x,-y | +x,-y
0B037D             0590*  ; #C0 270------+------ 90 #40
0B037D             0591*  ;        -x,+y | +x,+y
0B037D             0592*  ; #A0 225   180 #80   135 #60
0B037D F1          0593*      pop af ; sign of y
0B037E CA BB 03 0B 0594*      jp z,@y_zero
0B0382 F2 9B 03 0B 0595*      jp p,@y_pos
0B0386             0596*  ; y neg,check x
0B0386 F1          0597*      pop af ; sign of x
0B0387 CA 95 03 0B 0598*      jp z,@y_neg_x_zero
0B038B F2 9A 03 0B 0599*      jp p,@y_neg_x_pos
0B038F             0600*  ; y neg,x neg
0B038F             0601*  ; angle is 270-360
0B038F             0602*  ; negating the intermediate does the trick
0B038F CD D4 00 0B 0603*      call neg_hlu
0B0393 18 31       0604*      jr @zero_hlu
0B0395             0605*  
0B0395             0606*  @y_neg_x_zero:
0B0395             0607*  ; y neg,x zero
0B0395             0608*  ; angle is 0
0B0395 21 00 00 00 0609*      ld hl,0
0B0399 C9          0610*      ret
0B039A             0611*  @y_neg_x_pos:
0B039A             0612*  ; y neg,x pos
0B039A             0613*  ; angle is 0 to 90
0B039A             0614*  ; so we're good
0B039A C9          0615*      ret
0B039B             0616*  
0B039B             0617*  @y_pos:
0B039B F1          0618*      pop af ; sign of x
0B039C CA AB 03 0B 0619*      jp z,@y_pos_x_zero
0B03A0 F2 B0 03 0B 0620*      jp p,@y_pos_x_pos
0B03A4             0621*  ; y pos,x neg
0B03A4             0622*  ; angle is 180-270
0B03A4             0623*  ; so we add 180 to intermediate
0B03A4 11 00 80 00 0624*      ld de,0x008000
0B03A8 19          0625*      add hl,de
0B03A9 18 1B       0626*      jr @zero_hlu
0B03AB             0627*  @y_pos_x_zero:
0B03AB             0628*  ; y pos,x zero
0B03AB             0629*  ; angle is 180
0B03AB 21 00 80 00 0630*      ld hl,0x008000
0B03AF C9          0631*      ret
0B03B0             0632*  @y_pos_x_pos:
0B03B0             0633*  ; y pos,x pos
0B03B0             0634*  ; angle is 90-180
0B03B0             0635*  ; neg the intermediate and add 180 degrees
0B03B0 CD D4 00 0B 0636*      call neg_hlu
0B03B4 11 00 80 00 0637*      ld de,0x008000
0B03B8 19          0638*      add hl,de
0B03B9 18 0B       0639*      jr @zero_hlu
0B03BB             0640*  
0B03BB             0641*  @y_zero:
0B03BB F1          0642*      pop af ; sign of x
0B03BC FA C1 03 0B 0643*      jp m,@y_zero_x_neg
0B03C0             0644*  ; y zero,x pos
0B03C0             0645*  ; angle is 90,nothing to do
0B03C0 C9          0646*      ret
0B03C1             0647*  @y_zero_x_neg:
0B03C1             0648*  ; y zero ,x neg
0B03C1             0649*  ; angle is 270
0B03C1 21 00 C0 00 0650*      ld hl,0x00C000
0B03C5 C9          0651*      ret
0B03C6             0652*  @zero_hlu:
0B03C6 AF          0653*      xor a
0B03C7 22 D4 03 0B 0654*      ld (@scratch),hl
0B03CB 32 D6 03 0B 0655*      ld (@scratch+2),a
0B03CF 2A D4 03 0B 0656*      ld hl,(@scratch)
0B03D3 C9          0657*      ret
0B03D4             0658*  @scratch: ds 6
0B03DA             0659*  
0B03DA             0660*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
0B03DA             0661*  ; output: uh.l is the 16.8 fixed format angle in degrees 256
0B03DA             0662*  ; destroys: a,hl,bc,de
0B03DA             0663*  ; note: only works for angles from 0 to 32 (45) degrees
0B03DA             0664*  ;   use atan2_168fast (which calls this proc) to handle the full 256 (360) degrees
0B03DA             0665*  atan_168fast:
0B03DA             0666*  ; because we use compass headings instead of geometric angles
0B03DA             0667*  ; we compute dx/dy which is 1/tan(theta) in the maths world
0B03DA             0668*  ; we can do faster unsigned division here because we know dx and dy are positive
0B03DA CD CC 01 0B 0669*  	call udiv168 ; ud.e = dx/dy
0B03DE EB          0670*  	ex de,hl ; uh.l = dx/dy
0B03DF             0671*  ; test uh.l for 0
0B03DF 19          0672*      add hl,de
0B03E0 B7          0673*      or a
0B03E1 ED 52       0674*      sbc hl,de
0B03E3 28 22       0675*      jr z,@is_zero
0B03E5             0676*  ; test uh.l for 1
0B03E5 AF          0677*      xor a ; clear carry
0B03E6 EB          0678*      ex de,hl
0B03E7 21 00 01 00 0679*      ld hl,0x000100 ; 1 in 16.8 fixed format
0B03EB ED 52       0680*      sbc hl,de
0B03ED 28 13       0681*      jr z,@is_45
0B03EF EB          0682*  	ex de,hl
0B03F0             0683*  ; no special cases so we move on
0B03F0             0684*  ; l contains the fractional portion of tan(uh.l)
0B03F0             0685*  ; we multiply it by three to get our lookup table index
0B03F0 26 03       0686*      ld h,3
0B03F2 ED 6C       0687*      mlt hl ; gosh that is handy
0B03F4 11 00 00 00 0688*      ld de,0 ; clear deu
0B03F8 54          0689*      ld d,h ; copy hl to de
0B03F9 5D          0690*      ld e,l ; de contains our index
0B03FA 21 FF 07 0B 0691*      ld hl,atan_lut_168 ; grab the lut address
0B03FE 19          0692*      add hl,de ; bump hl by the index
0B03FF ED 27       0693*      ld hl,(hl) ; don't try this on a z80!
0B0401 C9          0694*      ret ; and out
0B0402             0695*  @is_45:
0B0402 21 00 20 00 0696*      ld hl,0x002000 ; 45 degrees decimal
0B0406 C9          0697*      ret
0B0407             0698*  ; for the case tan(0)
0B0407             0699*  @is_zero:
0B0407 21 00 00 00 0700*      ld hl,0x000000
0B040B C9          0701*      ret
0B040C             0702*  
0B040C             0703*  ; Expects  ADL mode
0B040C             0704*  ; Inputs:  UH.L
0B040C             0705*  ; Outputs: UH.L is the 16.8 square root
0B040C             0706*  ;          UDE is the integer difference inputHL-DE^2
0B040C             0707*  sqrt168:
0B040C CD 16 04 0B 0708*      call sqrt24
0B0410 EB          0709*      ex de,hl
0B0411 29          0710*      add hl,hl
0B0412 29          0711*      add hl,hl
0B0413 29          0712*      add hl,hl
0B0414 29          0713*      add hl,hl
0B0415 C9          0714*      ret
0B0416             0715*  
0B0416             0716*  ; credit: xeda112358
0B0416             0717*  ; https://www.cemetech.net/forum/viewtopic.php?t=11178&postdays=0&postorder=asc&start=0
0B0416             0718*  sqrt24:
0B0416             0719*  ; Expects ADL mode
0B0416             0720*  ; Inputs: HL
0B0416             0721*  ; Outputs: DE is the integer square root
0B0416             0722*  ;  HL is the difference inputHL-DE^2
0B0416             0723*  ;  c flag reset
0B0416 01 00 00 00 0724*  	ld bc,0 ; clear bcu
0B041A 11 00 00 00 0725*  	ld de,0 ; clear deu
0B041E AF          0726*      xor a
0B041F 45          0727*      ld b,l
0B0420 C5          0728*      push bc
0B0421 47          0729*      ld b,a
0B0422 6F          0730*      ld l,a
0B0423             0731*  ; Iteration 1
0B0423 29          0732*      add hl,hl
0B0424 CB 11       0733*      rl c
0B0426 29          0734*      add hl,hl
0B0427 CB 11       0735*      rl c
0B0429 91          0736*      sub c
0B042A 30 04       0737*      jr nc,$+6
0B042C 1C          0738*      inc e
0B042D 1C          0739*      inc e
0B042E 2F          0740*      cpl
0B042F 4F          0741*      ld c,a
0B0430             0742*  ; Iteration 2
0B0430 29          0743*      add hl,hl
0B0431 CB 11       0744*      rl c
0B0433 29          0745*      add hl,hl
0B0434 CB 11       0746*      rl c
0B0436 CB 13       0747*      rl e
0B0438 7B          0748*      ld a,e
0B0439 91          0749*      sub c
0B043A 30 04       0750*      jr nc,$+6
0B043C 1C          0751*      inc e
0B043D 1C          0752*      inc e
0B043E 2F          0753*      cpl
0B043F 4F          0754*      ld c,a
0B0440             0755*  ; Iteration 3
0B0440 29          0756*      add hl,hl
0B0441 CB 11       0757*      rl c
0B0443 29          0758*      add hl,hl
0B0444 CB 11       0759*      rl c
0B0446 CB 13       0760*      rl e
0B0448 7B          0761*      ld a,e
0B0449 91          0762*      sub c
0B044A 30 04       0763*      jr nc,$+6
0B044C 1C          0764*      inc e
0B044D 1C          0765*      inc e
0B044E 2F          0766*      cpl
0B044F 4F          0767*      ld c,a
0B0450             0768*  ; Iteration 4
0B0450 29          0769*      add hl,hl
0B0451 CB 11       0770*      rl c
0B0453 29          0771*      add hl,hl
0B0454 CB 11       0772*      rl c
0B0456 CB 13       0773*      rl e
0B0458 7B          0774*      ld a,e
0B0459 91          0775*      sub c
0B045A 30 04       0776*      jr nc,$+6
0B045C 1C          0777*      inc e
0B045D 1C          0778*      inc e
0B045E 2F          0779*      cpl
0B045F 4F          0780*      ld c,a
0B0460             0781*  ; Iteration 5
0B0460 29          0782*      add hl,hl
0B0461 CB 11       0783*      rl c
0B0463 29          0784*      add hl,hl
0B0464 CB 11       0785*      rl c
0B0466 CB 13       0786*      rl e
0B0468 7B          0787*      ld a,e
0B0469 91          0788*      sub c
0B046A 30 04       0789*      jr nc,$+6
0B046C 1C          0790*      inc e
0B046D 1C          0791*      inc e
0B046E 2F          0792*      cpl
0B046F 4F          0793*      ld c,a
0B0470             0794*  ; Iteration 6
0B0470 29          0795*      add hl,hl
0B0471 CB 11       0796*      rl c
0B0473 29          0797*      add hl,hl
0B0474 CB 11       0798*      rl c
0B0476 CB 13       0799*      rl e
0B0478 7B          0800*      ld a,e
0B0479 91          0801*      sub c
0B047A 30 04       0802*      jr nc,$+6
0B047C 1C          0803*      inc e
0B047D 1C          0804*      inc e
0B047E 2F          0805*      cpl
0B047F 4F          0806*      ld c,a
0B0480             0807*  ; Iteration 7
0B0480 29          0808*      add hl,hl
0B0481 CB 11       0809*      rl c
0B0483 29          0810*      add hl,hl
0B0484 CB 11       0811*      rl c
0B0486 CB 10       0812*      rl b
0B0488 EB          0813*      ex de,hl
0B0489 29          0814*      add hl,hl
0B048A E5          0815*      push hl
0B048B ED 42       0816*      sbc hl,bc
0B048D 30 06       0817*      jr nc,$+8
0B048F 7C          0818*      ld a,h
0B0490 2F          0819*      cpl
0B0491 47          0820*      ld b,a
0B0492 7D          0821*      ld a,l
0B0493 2F          0822*      cpl
0B0494 4F          0823*      ld c,a
0B0495 E1          0824*      pop hl
0B0496 30 02       0825*      jr nc,$+4
0B0498 23          0826*      inc hl
0B0499 23          0827*      inc hl
0B049A EB          0828*      ex de,hl
0B049B             0829*  ; Iteration 8
0B049B 29          0830*      add hl,hl
0B049C 69          0831*      ld l,c
0B049D 60          0832*      ld h,b
0B049E ED 6A       0833*      adc hl,hl
0B04A0 ED 6A       0834*      adc hl,hl
0B04A2 EB          0835*      ex de,hl
0B04A3 29          0836*      add hl,hl
0B04A4 ED 52       0837*      sbc hl,de
0B04A6 19          0838*      add hl,de
0B04A7 EB          0839*      ex de,hl
0B04A8 30 04       0840*      jr nc,$+6
0B04AA ED 52       0841*      sbc hl,de
0B04AC 13          0842*      inc de
0B04AD 13          0843*      inc de
0B04AE             0844*  ; Iteration 9
0B04AE F1          0845*      pop af
0B04AF 17          0846*      rla
0B04B0 ED 6A       0847*      adc hl,hl
0B04B2 17          0848*      rla
0B04B3 ED 6A       0849*      adc hl,hl
0B04B5 EB          0850*      ex de,hl
0B04B6 29          0851*      add hl,hl
0B04B7 ED 52       0852*      sbc hl,de
0B04B9 19          0853*      add hl,de
0B04BA EB          0854*      ex de,hl
0B04BB 30 04       0855*      jr nc,$+6
0B04BD ED 52       0856*      sbc hl,de
0B04BF 13          0857*      inc de
0B04C0 13          0858*      inc de
0B04C1             0859*  ; Iteration 10
0B04C1 17          0860*      rla
0B04C2 ED 6A       0861*      adc hl,hl
0B04C4 17          0862*      rla
0B04C5 ED 6A       0863*      adc hl,hl
0B04C7 EB          0864*      ex de,hl
0B04C8 29          0865*      add hl,hl
0B04C9 ED 52       0866*      sbc hl,de
0B04CB 19          0867*      add hl,de
0B04CC EB          0868*      ex de,hl
0B04CD 30 04       0869*      jr nc,$+6
0B04CF ED 52       0870*      sbc hl,de
0B04D1 13          0871*      inc de
0B04D2 13          0872*      inc de
0B04D3             0873*  ; Iteration 11
0B04D3 17          0874*      rla
0B04D4 ED 6A       0875*      adc hl,hl
0B04D6 17          0876*      rla
0B04D7 ED 6A       0877*      adc hl,hl
0B04D9 EB          0878*      ex de,hl
0B04DA 29          0879*      add hl,hl
0B04DB ED 52       0880*      sbc hl,de
0B04DD 19          0881*      add hl,de
0B04DE EB          0882*      ex de,hl
0B04DF 30 04       0883*      jr nc,$+6
0B04E1 ED 52       0884*      sbc hl,de
0B04E3 13          0885*      inc de
0B04E4 13          0886*      inc de
0B04E5             0887*  ; Iteration 12
0B04E5 17          0888*      rla
0B04E6 ED 6A       0889*      adc hl,hl
0B04E8 17          0890*      rla
0B04E9 ED 6A       0891*      adc hl,hl
0B04EB EB          0892*      ex de,hl
0B04EC 29          0893*      add hl,hl
0B04ED ED 52       0894*      sbc hl,de
0B04EF 19          0895*      add hl,de
0B04F0 EB          0896*      ex de,hl
0B04F1 30 04       0897*      jr nc,$+6
0B04F3 ED 52       0898*      sbc hl,de
0B04F5 13          0899*      inc de
0B04F6 13          0900*      inc de
0B04F7 CB 1A       0901*      rr d
0B04F9 CB 1B       0902*      rr e
0B04FB C9          0903*      ret
0B04FC             0904*  
0B04FC             0905*  sin_lut_168:
0B04FC 00 00 00    0906*  	dl 0x000000 ; 0.000 00, 0.000
0B04FF 06 00 00    0907*  	dl 0x000006 ; 1.406 01, 0.025
0B0502 0C 00 00    0908*  	dl 0x00000C ; 2.813 02, 0.049
0B0505 12 00 00    0909*  	dl 0x000012 ; 4.219 03, 0.074
0B0508 19 00 00    0910*  	dl 0x000019 ; 5.625 04, 0.098
0B050B 1F 00 00    0911*  	dl 0x00001F ; 7.031 05, 0.122
0B050E 25 00 00    0912*  	dl 0x000025 ; 8.438 06, 0.147
0B0511 2B 00 00    0913*  	dl 0x00002B ; 9.844 07, 0.171
0B0514 31 00 00    0914*  	dl 0x000031 ; 11.250 08, 0.195
0B0517 38 00 00    0915*  	dl 0x000038 ; 12.656 09, 0.219
0B051A 3E 00 00    0916*  	dl 0x00003E ; 14.063 0A, 0.243
0B051D 44 00 00    0917*  	dl 0x000044 ; 15.469 0B, 0.267
0B0520 4A 00 00    0918*  	dl 0x00004A ; 16.875 0C, 0.290
0B0523 50 00 00    0919*  	dl 0x000050 ; 18.281 0D, 0.314
0B0526 56 00 00    0920*  	dl 0x000056 ; 19.688 0E, 0.337
0B0529 5C 00 00    0921*  	dl 0x00005C ; 21.094 0F, 0.360
0B052C 61 00 00    0922*  	dl 0x000061 ; 22.500 10, 0.383
0B052F 67 00 00    0923*  	dl 0x000067 ; 23.906 11, 0.405
0B0532 6D 00 00    0924*  	dl 0x00006D ; 25.313 12, 0.428
0B0535 73 00 00    0925*  	dl 0x000073 ; 26.719 13, 0.450
0B0538 78 00 00    0926*  	dl 0x000078 ; 28.125 14, 0.471
0B053B 7E 00 00    0927*  	dl 0x00007E ; 29.531 15, 0.493
0B053E 83 00 00    0928*  	dl 0x000083 ; 30.938 16, 0.514
0B0541 88 00 00    0929*  	dl 0x000088 ; 32.344 17, 0.535
0B0544 8E 00 00    0930*  	dl 0x00008E ; 33.750 18, 0.556
0B0547 93 00 00    0931*  	dl 0x000093 ; 35.156 19, 0.576
0B054A 98 00 00    0932*  	dl 0x000098 ; 36.563 1A, 0.596
0B054D 9D 00 00    0933*  	dl 0x00009D ; 37.969 1B, 0.615
0B0550 A2 00 00    0934*  	dl 0x0000A2 ; 39.375 1C, 0.634
0B0553 A7 00 00    0935*  	dl 0x0000A7 ; 40.781 1D, 0.653
0B0556 AB 00 00    0936*  	dl 0x0000AB ; 42.188 1E, 0.672
0B0559 B0 00 00    0937*  	dl 0x0000B0 ; 43.594 1F, 0.690
0B055C B5 00 00    0938*  	dl 0x0000B5 ; 45.000 20, 0.707
0B055F B9 00 00    0939*  	dl 0x0000B9 ; 46.406 21, 0.724
0B0562 BD 00 00    0940*  	dl 0x0000BD ; 47.813 22, 0.741
0B0565 C1 00 00    0941*  	dl 0x0000C1 ; 49.219 23, 0.757
0B0568 C5 00 00    0942*  	dl 0x0000C5 ; 50.625 24, 0.773
0B056B C9 00 00    0943*  	dl 0x0000C9 ; 52.031 25, 0.788
0B056E CD 00 00    0944*  	dl 0x0000CD ; 53.438 26, 0.803
0B0571 D1 00 00    0945*  	dl 0x0000D1 ; 54.844 27, 0.818
0B0574 D4 00 00    0946*  	dl 0x0000D4 ; 56.250 28, 0.831
0B0577 D8 00 00    0947*  	dl 0x0000D8 ; 57.656 29, 0.845
0B057A DB 00 00    0948*  	dl 0x0000DB ; 59.063 2A, 0.858
0B057D DE 00 00    0949*  	dl 0x0000DE ; 60.469 2B, 0.870
0B0580 E1 00 00    0950*  	dl 0x0000E1 ; 61.875 2C, 0.882
0B0583 E4 00 00    0951*  	dl 0x0000E4 ; 63.281 2D, 0.893
0B0586 E7 00 00    0952*  	dl 0x0000E7 ; 64.688 2E, 0.904
0B0589 EA 00 00    0953*  	dl 0x0000EA ; 66.094 2F, 0.914
0B058C EC 00 00    0954*  	dl 0x0000EC ; 67.500 30, 0.924
0B058F EE 00 00    0955*  	dl 0x0000EE ; 68.906 31, 0.933
0B0592 F1 00 00    0956*  	dl 0x0000F1 ; 70.313 32, 0.942
0B0595 F3 00 00    0957*  	dl 0x0000F3 ; 71.719 33, 0.950
0B0598 F4 00 00    0958*  	dl 0x0000F4 ; 73.125 34, 0.957
0B059B F6 00 00    0959*  	dl 0x0000F6 ; 74.531 35, 0.964
0B059E F8 00 00    0960*  	dl 0x0000F8 ; 75.938 36, 0.970
0B05A1 F9 00 00    0961*  	dl 0x0000F9 ; 77.344 37, 0.976
0B05A4 FB 00 00    0962*  	dl 0x0000FB ; 78.750 38, 0.981
0B05A7 FC 00 00    0963*  	dl 0x0000FC ; 80.156 39, 0.985
0B05AA FD 00 00    0964*  	dl 0x0000FD ; 81.563 3A, 0.989
0B05AD FE 00 00    0965*  	dl 0x0000FE ; 82.969 3B, 0.992
0B05B0 FE 00 00    0966*  	dl 0x0000FE ; 84.375 3C, 0.995
0B05B3 FF 00 00    0967*  	dl 0x0000FF ; 85.781 3D, 0.997
0B05B6 FF 00 00    0968*  	dl 0x0000FF ; 87.188 3E, 0.999
0B05B9 FF 00 00    0969*  	dl 0x0000FF ; 88.594 3F, 1.000
0B05BC 00 01 00    0970*  	dl 0x000100 ; 90.000 40, 1.000
0B05BF FF 00 00    0971*  	dl 0x0000FF ; 91.406 41, 1.000
0B05C2 FF 00 00    0972*  	dl 0x0000FF ; 92.813 42, 0.999
0B05C5 FF 00 00    0973*  	dl 0x0000FF ; 94.219 43, 0.997
0B05C8 FE 00 00    0974*  	dl 0x0000FE ; 95.625 44, 0.995
0B05CB FE 00 00    0975*  	dl 0x0000FE ; 97.031 45, 0.992
0B05CE FD 00 00    0976*  	dl 0x0000FD ; 98.438 46, 0.989
0B05D1 FC 00 00    0977*  	dl 0x0000FC ; 99.844 47, 0.985
0B05D4 FB 00 00    0978*  	dl 0x0000FB ; 101.250 48, 0.981
0B05D7 F9 00 00    0979*  	dl 0x0000F9 ; 102.656 49, 0.976
0B05DA F8 00 00    0980*  	dl 0x0000F8 ; 104.063 4A, 0.970
0B05DD F6 00 00    0981*  	dl 0x0000F6 ; 105.469 4B, 0.964
0B05E0 F4 00 00    0982*  	dl 0x0000F4 ; 106.875 4C, 0.957
0B05E3 F3 00 00    0983*  	dl 0x0000F3 ; 108.281 4D, 0.950
0B05E6 F1 00 00    0984*  	dl 0x0000F1 ; 109.688 4E, 0.942
0B05E9 EE 00 00    0985*  	dl 0x0000EE ; 111.094 4F, 0.933
0B05EC EC 00 00    0986*  	dl 0x0000EC ; 112.500 50, 0.924
0B05EF EA 00 00    0987*  	dl 0x0000EA ; 113.906 51, 0.914
0B05F2 E7 00 00    0988*  	dl 0x0000E7 ; 115.313 52, 0.904
0B05F5 E4 00 00    0989*  	dl 0x0000E4 ; 116.719 53, 0.893
0B05F8 E1 00 00    0990*  	dl 0x0000E1 ; 118.125 54, 0.882
0B05FB DE 00 00    0991*  	dl 0x0000DE ; 119.531 55, 0.870
0B05FE DB 00 00    0992*  	dl 0x0000DB ; 120.938 56, 0.858
0B0601 D8 00 00    0993*  	dl 0x0000D8 ; 122.344 57, 0.845
0B0604 D4 00 00    0994*  	dl 0x0000D4 ; 123.750 58, 0.831
0B0607 D1 00 00    0995*  	dl 0x0000D1 ; 125.156 59, 0.818
0B060A CD 00 00    0996*  	dl 0x0000CD ; 126.563 5A, 0.803
0B060D C9 00 00    0997*  	dl 0x0000C9 ; 127.969 5B, 0.788
0B0610 C5 00 00    0998*  	dl 0x0000C5 ; 129.375 5C, 0.773
0B0613 C1 00 00    0999*  	dl 0x0000C1 ; 130.781 5D, 0.757
0B0616 BD 00 00    1000*  	dl 0x0000BD ; 132.188 5E, 0.741
0B0619 B9 00 00    1001*  	dl 0x0000B9 ; 133.594 5F, 0.724
0B061C B5 00 00    1002*  	dl 0x0000B5 ; 135.000 60, 0.707
0B061F B0 00 00    1003*  	dl 0x0000B0 ; 136.406 61, 0.690
0B0622 AB 00 00    1004*  	dl 0x0000AB ; 137.813 62, 0.672
0B0625 A7 00 00    1005*  	dl 0x0000A7 ; 139.219 63, 0.653
0B0628 A2 00 00    1006*  	dl 0x0000A2 ; 140.625 64, 0.634
0B062B 9D 00 00    1007*  	dl 0x00009D ; 142.031 65, 0.615
0B062E 98 00 00    1008*  	dl 0x000098 ; 143.438 66, 0.596
0B0631 93 00 00    1009*  	dl 0x000093 ; 144.844 67, 0.576
0B0634 8E 00 00    1010*  	dl 0x00008E ; 146.250 68, 0.556
0B0637 88 00 00    1011*  	dl 0x000088 ; 147.656 69, 0.535
0B063A 83 00 00    1012*  	dl 0x000083 ; 149.063 6A, 0.514
0B063D 7E 00 00    1013*  	dl 0x00007E ; 150.469 6B, 0.493
0B0640 78 00 00    1014*  	dl 0x000078 ; 151.875 6C, 0.471
0B0643 73 00 00    1015*  	dl 0x000073 ; 153.281 6D, 0.450
0B0646 6D 00 00    1016*  	dl 0x00006D ; 154.688 6E, 0.428
0B0649 67 00 00    1017*  	dl 0x000067 ; 156.094 6F, 0.405
0B064C 61 00 00    1018*  	dl 0x000061 ; 157.500 70, 0.383
0B064F 5C 00 00    1019*  	dl 0x00005C ; 158.906 71, 0.360
0B0652 56 00 00    1020*  	dl 0x000056 ; 160.313 72, 0.337
0B0655 50 00 00    1021*  	dl 0x000050 ; 161.719 73, 0.314
0B0658 4A 00 00    1022*  	dl 0x00004A ; 163.125 74, 0.290
0B065B 44 00 00    1023*  	dl 0x000044 ; 164.531 75, 0.267
0B065E 3E 00 00    1024*  	dl 0x00003E ; 165.938 76, 0.243
0B0661 38 00 00    1025*  	dl 0x000038 ; 167.344 77, 0.219
0B0664 31 00 00    1026*  	dl 0x000031 ; 168.750 78, 0.195
0B0667 2B 00 00    1027*  	dl 0x00002B ; 170.156 79, 0.171
0B066A 25 00 00    1028*  	dl 0x000025 ; 171.563 7A, 0.147
0B066D 1F 00 00    1029*  	dl 0x00001F ; 172.969 7B, 0.122
0B0670 19 00 00    1030*  	dl 0x000019 ; 174.375 7C, 0.098
0B0673 12 00 00    1031*  	dl 0x000012 ; 175.781 7D, 0.074
0B0676 0C 00 00    1032*  	dl 0x00000C ; 177.188 7E, 0.049
0B0679 06 00 00    1033*  	dl 0x000006 ; 178.594 7F, 0.025
0B067C 00 00 00    1034*  	dl 0x000000 ; 180.000 80, 0.000
0B067F FA FF FF    1035*  	dl 0xFFFFFA ; 181.406 81, -0.025
0B0682 F4 FF FF    1036*  	dl 0xFFFFF4 ; 182.813 82, -0.049
0B0685 EE FF FF    1037*  	dl 0xFFFFEE ; 184.219 83, -0.074
0B0688 E7 FF FF    1038*  	dl 0xFFFFE7 ; 185.625 84, -0.098
0B068B E1 FF FF    1039*  	dl 0xFFFFE1 ; 187.031 85, -0.122
0B068E DB FF FF    1040*  	dl 0xFFFFDB ; 188.438 86, -0.147
0B0691 D5 FF FF    1041*  	dl 0xFFFFD5 ; 189.844 87, -0.171
0B0694 CF FF FF    1042*  	dl 0xFFFFCF ; 191.250 88, -0.195
0B0697 C8 FF FF    1043*  	dl 0xFFFFC8 ; 192.656 89, -0.219
0B069A C2 FF FF    1044*  	dl 0xFFFFC2 ; 194.063 8A, -0.243
0B069D BC FF FF    1045*  	dl 0xFFFFBC ; 195.469 8B, -0.267
0B06A0 B6 FF FF    1046*  	dl 0xFFFFB6 ; 196.875 8C, -0.290
0B06A3 B0 FF FF    1047*  	dl 0xFFFFB0 ; 198.281 8D, -0.314
0B06A6 AA FF FF    1048*  	dl 0xFFFFAA ; 199.688 8E, -0.337
0B06A9 A4 FF FF    1049*  	dl 0xFFFFA4 ; 201.094 8F, -0.360
0B06AC 9F FF FF    1050*  	dl 0xFFFF9F ; 202.500 90, -0.383
0B06AF 99 FF FF    1051*  	dl 0xFFFF99 ; 203.906 91, -0.405
0B06B2 93 FF FF    1052*  	dl 0xFFFF93 ; 205.313 92, -0.428
0B06B5 8D FF FF    1053*  	dl 0xFFFF8D ; 206.719 93, -0.450
0B06B8 88 FF FF    1054*  	dl 0xFFFF88 ; 208.125 94, -0.471
0B06BB 82 FF FF    1055*  	dl 0xFFFF82 ; 209.531 95, -0.493
0B06BE 7D FF FF    1056*  	dl 0xFFFF7D ; 210.938 96, -0.514
0B06C1 78 FF FF    1057*  	dl 0xFFFF78 ; 212.344 97, -0.535
0B06C4 72 FF FF    1058*  	dl 0xFFFF72 ; 213.750 98, -0.556
0B06C7 6D FF FF    1059*  	dl 0xFFFF6D ; 215.156 99, -0.576
0B06CA 68 FF FF    1060*  	dl 0xFFFF68 ; 216.563 9A, -0.596
0B06CD 63 FF FF    1061*  	dl 0xFFFF63 ; 217.969 9B, -0.615
0B06D0 5E FF FF    1062*  	dl 0xFFFF5E ; 219.375 9C, -0.634
0B06D3 59 FF FF    1063*  	dl 0xFFFF59 ; 220.781 9D, -0.653
0B06D6 55 FF FF    1064*  	dl 0xFFFF55 ; 222.188 9E, -0.672
0B06D9 50 FF FF    1065*  	dl 0xFFFF50 ; 223.594 9F, -0.690
0B06DC 4B FF FF    1066*  	dl 0xFFFF4B ; 225.000 A0, -0.707
0B06DF 47 FF FF    1067*  	dl 0xFFFF47 ; 226.406 A1, -0.724
0B06E2 43 FF FF    1068*  	dl 0xFFFF43 ; 227.813 A2, -0.741
0B06E5 3F FF FF    1069*  	dl 0xFFFF3F ; 229.219 A3, -0.757
0B06E8 3B FF FF    1070*  	dl 0xFFFF3B ; 230.625 A4, -0.773
0B06EB 37 FF FF    1071*  	dl 0xFFFF37 ; 232.031 A5, -0.788
0B06EE 33 FF FF    1072*  	dl 0xFFFF33 ; 233.438 A6, -0.803
0B06F1 2F FF FF    1073*  	dl 0xFFFF2F ; 234.844 A7, -0.818
0B06F4 2C FF FF    1074*  	dl 0xFFFF2C ; 236.250 A8, -0.831
0B06F7 28 FF FF    1075*  	dl 0xFFFF28 ; 237.656 A9, -0.845
0B06FA 25 FF FF    1076*  	dl 0xFFFF25 ; 239.063 AA, -0.858
0B06FD 22 FF FF    1077*  	dl 0xFFFF22 ; 240.469 AB, -0.870
0B0700 1F FF FF    1078*  	dl 0xFFFF1F ; 241.875 AC, -0.882
0B0703 1C FF FF    1079*  	dl 0xFFFF1C ; 243.281 AD, -0.893
0B0706 19 FF FF    1080*  	dl 0xFFFF19 ; 244.688 AE, -0.904
0B0709 16 FF FF    1081*  	dl 0xFFFF16 ; 246.094 AF, -0.914
0B070C 14 FF FF    1082*  	dl 0xFFFF14 ; 247.500 B0, -0.924
0B070F 12 FF FF    1083*  	dl 0xFFFF12 ; 248.906 B1, -0.933
0B0712 0F FF FF    1084*  	dl 0xFFFF0F ; 250.313 B2, -0.942
0B0715 0D FF FF    1085*  	dl 0xFFFF0D ; 251.719 B3, -0.950
0B0718 0C FF FF    1086*  	dl 0xFFFF0C ; 253.125 B4, -0.957
0B071B 0A FF FF    1087*  	dl 0xFFFF0A ; 254.531 B5, -0.964
0B071E 08 FF FF    1088*  	dl 0xFFFF08 ; 255.938 B6, -0.970
0B0721 07 FF FF    1089*  	dl 0xFFFF07 ; 257.344 B7, -0.976
0B0724 05 FF FF    1090*  	dl 0xFFFF05 ; 258.750 B8, -0.981
0B0727 04 FF FF    1091*  	dl 0xFFFF04 ; 260.156 B9, -0.985
0B072A 03 FF FF    1092*  	dl 0xFFFF03 ; 261.563 BA, -0.989
0B072D 02 FF FF    1093*  	dl 0xFFFF02 ; 262.969 BB, -0.992
0B0730 02 FF FF    1094*  	dl 0xFFFF02 ; 264.375 BC, -0.995
0B0733 01 FF FF    1095*  	dl 0xFFFF01 ; 265.781 BD, -0.997
0B0736 01 FF FF    1096*  	dl 0xFFFF01 ; 267.188 BE, -0.999
0B0739 01 FF FF    1097*  	dl 0xFFFF01 ; 268.594 BF, -1.000
0B073C 00 FF FF    1098*  	dl 0xFFFF00 ; 270.000 C0, -1.000
0B073F 01 FF FF    1099*  	dl 0xFFFF01 ; 271.406 C1, -1.000
0B0742 01 FF FF    1100*  	dl 0xFFFF01 ; 272.813 C2, -0.999
0B0745 01 FF FF    1101*  	dl 0xFFFF01 ; 274.219 C3, -0.997
0B0748 02 FF FF    1102*  	dl 0xFFFF02 ; 275.625 C4, -0.995
0B074B 02 FF FF    1103*  	dl 0xFFFF02 ; 277.031 C5, -0.992
0B074E 03 FF FF    1104*  	dl 0xFFFF03 ; 278.438 C6, -0.989
0B0751 04 FF FF    1105*  	dl 0xFFFF04 ; 279.844 C7, -0.985
0B0754 05 FF FF    1106*  	dl 0xFFFF05 ; 281.250 C8, -0.981
0B0757 07 FF FF    1107*  	dl 0xFFFF07 ; 282.656 C9, -0.976
0B075A 08 FF FF    1108*  	dl 0xFFFF08 ; 284.063 CA, -0.970
0B075D 0A FF FF    1109*  	dl 0xFFFF0A ; 285.469 CB, -0.964
0B0760 0C FF FF    1110*  	dl 0xFFFF0C ; 286.875 CC, -0.957
0B0763 0D FF FF    1111*  	dl 0xFFFF0D ; 288.281 CD, -0.950
0B0766 0F FF FF    1112*  	dl 0xFFFF0F ; 289.688 CE, -0.942
0B0769 12 FF FF    1113*  	dl 0xFFFF12 ; 291.094 CF, -0.933
0B076C 14 FF FF    1114*  	dl 0xFFFF14 ; 292.500 D0, -0.924
0B076F 16 FF FF    1115*  	dl 0xFFFF16 ; 293.906 D1, -0.914
0B0772 19 FF FF    1116*  	dl 0xFFFF19 ; 295.313 D2, -0.904
0B0775 1C FF FF    1117*  	dl 0xFFFF1C ; 296.719 D3, -0.893
0B0778 1F FF FF    1118*  	dl 0xFFFF1F ; 298.125 D4, -0.882
0B077B 22 FF FF    1119*  	dl 0xFFFF22 ; 299.531 D5, -0.870
0B077E 25 FF FF    1120*  	dl 0xFFFF25 ; 300.938 D6, -0.858
0B0781 28 FF FF    1121*  	dl 0xFFFF28 ; 302.344 D7, -0.845
0B0784 2C FF FF    1122*  	dl 0xFFFF2C ; 303.750 D8, -0.831
0B0787 2F FF FF    1123*  	dl 0xFFFF2F ; 305.156 D9, -0.818
0B078A 33 FF FF    1124*  	dl 0xFFFF33 ; 306.563 DA, -0.803
0B078D 37 FF FF    1125*  	dl 0xFFFF37 ; 307.969 DB, -0.788
0B0790 3B FF FF    1126*  	dl 0xFFFF3B ; 309.375 DC, -0.773
0B0793 3F FF FF    1127*  	dl 0xFFFF3F ; 310.781 DD, -0.757
0B0796 43 FF FF    1128*  	dl 0xFFFF43 ; 312.188 DE, -0.741
0B0799 47 FF FF    1129*  	dl 0xFFFF47 ; 313.594 DF, -0.724
0B079C 4B FF FF    1130*  	dl 0xFFFF4B ; 315.000 E0, -0.707
0B079F 50 FF FF    1131*  	dl 0xFFFF50 ; 316.406 E1, -0.690
0B07A2 55 FF FF    1132*  	dl 0xFFFF55 ; 317.813 E2, -0.672
0B07A5 59 FF FF    1133*  	dl 0xFFFF59 ; 319.219 E3, -0.653
0B07A8 5E FF FF    1134*  	dl 0xFFFF5E ; 320.625 E4, -0.634
0B07AB 63 FF FF    1135*  	dl 0xFFFF63 ; 322.031 E5, -0.615
0B07AE 68 FF FF    1136*  	dl 0xFFFF68 ; 323.438 E6, -0.596
0B07B1 6D FF FF    1137*  	dl 0xFFFF6D ; 324.844 E7, -0.576
0B07B4 72 FF FF    1138*  	dl 0xFFFF72 ; 326.250 E8, -0.556
0B07B7 78 FF FF    1139*  	dl 0xFFFF78 ; 327.656 E9, -0.535
0B07BA 7D FF FF    1140*  	dl 0xFFFF7D ; 329.063 EA, -0.514
0B07BD 82 FF FF    1141*  	dl 0xFFFF82 ; 330.469 EB, -0.493
0B07C0 88 FF FF    1142*  	dl 0xFFFF88 ; 331.875 EC, -0.471
0B07C3 8D FF FF    1143*  	dl 0xFFFF8D ; 333.281 ED, -0.450
0B07C6 93 FF FF    1144*  	dl 0xFFFF93 ; 334.688 EE, -0.428
0B07C9 99 FF FF    1145*  	dl 0xFFFF99 ; 336.094 EF, -0.405
0B07CC 9F FF FF    1146*  	dl 0xFFFF9F ; 337.500 F0, -0.383
0B07CF A4 FF FF    1147*  	dl 0xFFFFA4 ; 338.906 F1, -0.360
0B07D2 AA FF FF    1148*  	dl 0xFFFFAA ; 340.313 F2, -0.337
0B07D5 B0 FF FF    1149*  	dl 0xFFFFB0 ; 341.719 F3, -0.314
0B07D8 B6 FF FF    1150*  	dl 0xFFFFB6 ; 343.125 F4, -0.290
0B07DB BC FF FF    1151*  	dl 0xFFFFBC ; 344.531 F5, -0.267
0B07DE C2 FF FF    1152*  	dl 0xFFFFC2 ; 345.938 F6, -0.243
0B07E1 C8 FF FF    1153*  	dl 0xFFFFC8 ; 347.344 F7, -0.219
0B07E4 CF FF FF    1154*  	dl 0xFFFFCF ; 348.750 F8, -0.195
0B07E7 D5 FF FF    1155*  	dl 0xFFFFD5 ; 350.156 F9, -0.171
0B07EA DB FF FF    1156*  	dl 0xFFFFDB ; 351.563 FA, -0.147
0B07ED E1 FF FF    1157*  	dl 0xFFFFE1 ; 352.969 FB, -0.122
0B07F0 E7 FF FF    1158*  	dl 0xFFFFE7 ; 354.375 FC, -0.098
0B07F3 EE FF FF    1159*  	dl 0xFFFFEE ; 355.781 FD, -0.074
0B07F6 F4 FF FF    1160*  	dl 0xFFFFF4 ; 357.188 FE, -0.049
0B07F9 FA FF FF    1161*  	dl 0xFFFFFA ; 358.594 FF, -0.025
0B07FC 00 00 00    1162*  	dl 0x000000 ; 0.000 00, 0.000 for interpolation
0B07FF             1163*  
0B07FF             1164*  atan_lut_168:
0B07FF 00 00 00    1165*  	dl 0x000000 ; 000000, 0.000
0B0802 28 00 00    1166*  	dl 0x000028 ; 000001, 0.224
0B0805 51 00 00    1167*  	dl 0x000051 ; 000002, 0.448
0B0808 7A 00 00    1168*  	dl 0x00007A ; 000003, 0.671
0B080B A2 00 00    1169*  	dl 0x0000A2 ; 000004, 0.895
0B080E CB 00 00    1170*  	dl 0x0000CB ; 000005, 1.119
0B0811 F4 00 00    1171*  	dl 0x0000F4 ; 000006, 1.343
0B0814 1D 01 00    1172*  	dl 0x00011D ; 000007, 1.566
0B0817 45 01 00    1173*  	dl 0x000145 ; 000008, 1.790
0B081A 6E 01 00    1174*  	dl 0x00016E ; 000009, 2.013
0B081D 97 01 00    1175*  	dl 0x000197 ; 00000A, 2.237
0B0820 BF 01 00    1176*  	dl 0x0001BF ; 00000B, 2.460
0B0823 E8 01 00    1177*  	dl 0x0001E8 ; 00000C, 2.684
0B0826 11 02 00    1178*  	dl 0x000211 ; 00000D, 2.907
0B0829 39 02 00    1179*  	dl 0x000239 ; 00000E, 3.130
0B082C 62 02 00    1180*  	dl 0x000262 ; 00000F, 3.353
0B082F 8B 02 00    1181*  	dl 0x00028B ; 000010, 3.576
0B0832 B3 02 00    1182*  	dl 0x0002B3 ; 000011, 3.799
0B0835 DC 02 00    1183*  	dl 0x0002DC ; 000012, 4.022
0B0838 04 03 00    1184*  	dl 0x000304 ; 000013, 4.245
0B083B 2D 03 00    1185*  	dl 0x00032D ; 000014, 4.467
0B083E 55 03 00    1186*  	dl 0x000355 ; 000015, 4.690
0B0841 7E 03 00    1187*  	dl 0x00037E ; 000016, 4.912
0B0844 A6 03 00    1188*  	dl 0x0003A6 ; 000017, 5.134
0B0847 CE 03 00    1189*  	dl 0x0003CE ; 000018, 5.356
0B084A F7 03 00    1190*  	dl 0x0003F7 ; 000019, 5.578
0B084D 1F 04 00    1191*  	dl 0x00041F ; 00001A, 5.799
0B0850 48 04 00    1192*  	dl 0x000448 ; 00001B, 6.021
0B0853 70 04 00    1193*  	dl 0x000470 ; 00001C, 6.242
0B0856 98 04 00    1194*  	dl 0x000498 ; 00001D, 6.463
0B0859 C0 04 00    1195*  	dl 0x0004C0 ; 00001E, 6.684
0B085C E8 04 00    1196*  	dl 0x0004E8 ; 00001F, 6.905
0B085F 11 05 00    1197*  	dl 0x000511 ; 000020, 7.125
0B0862 39 05 00    1198*  	dl 0x000539 ; 000021, 7.345
0B0865 61 05 00    1199*  	dl 0x000561 ; 000022, 7.565
0B0868 89 05 00    1200*  	dl 0x000589 ; 000023, 7.785
0B086B B1 05 00    1201*  	dl 0x0005B1 ; 000024, 8.005
0B086E D9 05 00    1202*  	dl 0x0005D9 ; 000025, 8.224
0B0871 01 06 00    1203*  	dl 0x000601 ; 000026, 8.443
0B0874 28 06 00    1204*  	dl 0x000628 ; 000027, 8.662
0B0877 50 06 00    1205*  	dl 0x000650 ; 000028, 8.881
0B087A 78 06 00    1206*  	dl 0x000678 ; 000029, 9.099
0B087D A0 06 00    1207*  	dl 0x0006A0 ; 00002A, 9.317
0B0880 C7 06 00    1208*  	dl 0x0006C7 ; 00002B, 9.535
0B0883 EF 06 00    1209*  	dl 0x0006EF ; 00002C, 9.752
0B0886 16 07 00    1210*  	dl 0x000716 ; 00002D, 9.970
0B0889 3E 07 00    1211*  	dl 0x00073E ; 00002E, 10.187
0B088C 65 07 00    1212*  	dl 0x000765 ; 00002F, 10.403
0B088F 8D 07 00    1213*  	dl 0x00078D ; 000030, 10.620
0B0892 B4 07 00    1214*  	dl 0x0007B4 ; 000031, 10.836
0B0895 DB 07 00    1215*  	dl 0x0007DB ; 000032, 11.051
0B0898 03 08 00    1216*  	dl 0x000803 ; 000033, 11.267
0B089B 2A 08 00    1217*  	dl 0x00082A ; 000034, 11.482
0B089E 51 08 00    1218*  	dl 0x000851 ; 000035, 11.697
0B08A1 78 08 00    1219*  	dl 0x000878 ; 000036, 11.911
0B08A4 9F 08 00    1220*  	dl 0x00089F ; 000037, 12.125
0B08A7 C6 08 00    1221*  	dl 0x0008C6 ; 000038, 12.339
0B08AA ED 08 00    1222*  	dl 0x0008ED ; 000039, 12.553
0B08AD 13 09 00    1223*  	dl 0x000913 ; 00003A, 12.766
0B08B0 3A 09 00    1224*  	dl 0x00093A ; 00003B, 12.978
0B08B3 61 09 00    1225*  	dl 0x000961 ; 00003C, 13.191
0B08B6 87 09 00    1226*  	dl 0x000987 ; 00003D, 13.403
0B08B9 AE 09 00    1227*  	dl 0x0009AE ; 00003E, 13.614
0B08BC D4 09 00    1228*  	dl 0x0009D4 ; 00003F, 13.825
0B08BF FB 09 00    1229*  	dl 0x0009FB ; 000040, 14.036
0B08C2 21 0A 00    1230*  	dl 0x000A21 ; 000041, 14.247
0B08C5 47 0A 00    1231*  	dl 0x000A47 ; 000042, 14.457
0B08C8 6D 0A 00    1232*  	dl 0x000A6D ; 000043, 14.666
0B08CB 94 0A 00    1233*  	dl 0x000A94 ; 000044, 14.876
0B08CE BA 0A 00    1234*  	dl 0x000ABA ; 000045, 15.085
0B08D1 E0 0A 00    1235*  	dl 0x000AE0 ; 000046, 15.293
0B08D4 05 0B 00    1236*  	dl 0x000B05 ; 000047, 15.501
0B08D7 2B 0B 00    1237*  	dl 0x000B2B ; 000048, 15.709
0B08DA 51 0B 00    1238*  	dl 0x000B51 ; 000049, 15.916
0B08DD 77 0B 00    1239*  	dl 0x000B77 ; 00004A, 16.123
0B08E0 9C 0B 00    1240*  	dl 0x000B9C ; 00004B, 16.329
0B08E3 C2 0B 00    1241*  	dl 0x000BC2 ; 00004C, 16.535
0B08E6 E7 0B 00    1242*  	dl 0x000BE7 ; 00004D, 16.740
0B08E9 0C 0C 00    1243*  	dl 0x000C0C ; 00004E, 16.945
0B08EC 32 0C 00    1244*  	dl 0x000C32 ; 00004F, 17.150
0B08EF 57 0C 00    1245*  	dl 0x000C57 ; 000050, 17.354
0B08F2 7C 0C 00    1246*  	dl 0x000C7C ; 000051, 17.558
0B08F5 A1 0C 00    1247*  	dl 0x000CA1 ; 000052, 17.761
0B08F8 C6 0C 00    1248*  	dl 0x000CC6 ; 000053, 17.964
0B08FB EB 0C 00    1249*  	dl 0x000CEB ; 000054, 18.166
0B08FE 0F 0D 00    1250*  	dl 0x000D0F ; 000055, 18.368
0B0901 34 0D 00    1251*  	dl 0x000D34 ; 000056, 18.569
0B0904 58 0D 00    1252*  	dl 0x000D58 ; 000057, 18.770
0B0907 7D 0D 00    1253*  	dl 0x000D7D ; 000058, 18.970
0B090A A1 0D 00    1254*  	dl 0x000DA1 ; 000059, 19.170
0B090D C6 0D 00    1255*  	dl 0x000DC6 ; 00005A, 19.370
0B0910 EA 0D 00    1256*  	dl 0x000DEA ; 00005B, 19.569
0B0913 0E 0E 00    1257*  	dl 0x000E0E ; 00005C, 19.767
0B0916 32 0E 00    1258*  	dl 0x000E32 ; 00005D, 19.965
0B0919 56 0E 00    1259*  	dl 0x000E56 ; 00005E, 20.163
0B091C 7A 0E 00    1260*  	dl 0x000E7A ; 00005F, 20.360
0B091F 9E 0E 00    1261*  	dl 0x000E9E ; 000060, 20.556
0B0922 C1 0E 00    1262*  	dl 0x000EC1 ; 000061, 20.752
0B0925 E5 0E 00    1263*  	dl 0x000EE5 ; 000062, 20.947
0B0928 08 0F 00    1264*  	dl 0x000F08 ; 000063, 21.142
0B092B 2C 0F 00    1265*  	dl 0x000F2C ; 000064, 21.337
0B092E 4F 0F 00    1266*  	dl 0x000F4F ; 000065, 21.531
0B0931 72 0F 00    1267*  	dl 0x000F72 ; 000066, 21.724
0B0934 95 0F 00    1268*  	dl 0x000F95 ; 000067, 21.917
0B0937 B8 0F 00    1269*  	dl 0x000FB8 ; 000068, 22.109
0B093A DB 0F 00    1270*  	dl 0x000FDB ; 000069, 22.301
0B093D FE 0F 00    1271*  	dl 0x000FFE ; 00006A, 22.493
0B0940 21 10 00    1272*  	dl 0x001021 ; 00006B, 22.683
0B0943 44 10 00    1273*  	dl 0x001044 ; 00006C, 22.874
0B0946 66 10 00    1274*  	dl 0x001066 ; 00006D, 23.063
0B0949 89 10 00    1275*  	dl 0x001089 ; 00006E, 23.253
0B094C AB 10 00    1276*  	dl 0x0010AB ; 00006F, 23.441
0B094F CD 10 00    1277*  	dl 0x0010CD ; 000070, 23.629
0B0952 EF 10 00    1278*  	dl 0x0010EF ; 000071, 23.817
0B0955 11 11 00    1279*  	dl 0x001111 ; 000072, 24.004
0B0958 33 11 00    1280*  	dl 0x001133 ; 000073, 24.191
0B095B 55 11 00    1281*  	dl 0x001155 ; 000074, 24.376
0B095E 77 11 00    1282*  	dl 0x001177 ; 000075, 24.562
0B0961 99 11 00    1283*  	dl 0x001199 ; 000076, 24.747
0B0964 BA 11 00    1284*  	dl 0x0011BA ; 000077, 24.931
0B0967 DC 11 00    1285*  	dl 0x0011DC ; 000078, 25.115
0B096A FD 11 00    1286*  	dl 0x0011FD ; 000079, 25.298
0B096D 1E 12 00    1287*  	dl 0x00121E ; 00007A, 25.481
0B0970 3F 12 00    1288*  	dl 0x00123F ; 00007B, 25.663
0B0973 60 12 00    1289*  	dl 0x001260 ; 00007C, 25.844
0B0976 81 12 00    1290*  	dl 0x001281 ; 00007D, 26.025
0B0979 A2 12 00    1291*  	dl 0x0012A2 ; 00007E, 26.206
0B097C C3 12 00    1292*  	dl 0x0012C3 ; 00007F, 26.386
0B097F E4 12 00    1293*  	dl 0x0012E4 ; 000080, 26.565
0B0982 04 13 00    1294*  	dl 0x001304 ; 000081, 26.744
0B0985 25 13 00    1295*  	dl 0x001325 ; 000082, 26.922
0B0988 45 13 00    1296*  	dl 0x001345 ; 000083, 27.100
0B098B 65 13 00    1297*  	dl 0x001365 ; 000084, 27.277
0B098E 85 13 00    1298*  	dl 0x001385 ; 000085, 27.453
0B0991 A5 13 00    1299*  	dl 0x0013A5 ; 000086, 27.629
0B0994 C5 13 00    1300*  	dl 0x0013C5 ; 000087, 27.805
0B0997 E5 13 00    1301*  	dl 0x0013E5 ; 000088, 27.979
0B099A 05 14 00    1302*  	dl 0x001405 ; 000089, 28.154
0B099D 24 14 00    1303*  	dl 0x001424 ; 00008A, 28.327
0B09A0 44 14 00    1304*  	dl 0x001444 ; 00008B, 28.501
0B09A3 63 14 00    1305*  	dl 0x001463 ; 00008C, 28.673
0B09A6 83 14 00    1306*  	dl 0x001483 ; 00008D, 28.845
0B09A9 A2 14 00    1307*  	dl 0x0014A2 ; 00008E, 29.017
0B09AC C1 14 00    1308*  	dl 0x0014C1 ; 00008F, 29.187
0B09AF E0 14 00    1309*  	dl 0x0014E0 ; 000090, 29.358
0B09B2 FF 14 00    1310*  	dl 0x0014FF ; 000091, 29.527
0B09B5 1E 15 00    1311*  	dl 0x00151E ; 000092, 29.697
0B09B8 3C 15 00    1312*  	dl 0x00153C ; 000093, 29.865
0B09BB 5B 15 00    1313*  	dl 0x00155B ; 000094, 30.033
0B09BE 79 15 00    1314*  	dl 0x001579 ; 000095, 30.201
0B09C1 98 15 00    1315*  	dl 0x001598 ; 000096, 30.368
0B09C4 B6 15 00    1316*  	dl 0x0015B6 ; 000097, 30.534
0B09C7 D4 15 00    1317*  	dl 0x0015D4 ; 000098, 30.700
0B09CA F2 15 00    1318*  	dl 0x0015F2 ; 000099, 30.865
0B09CD 10 16 00    1319*  	dl 0x001610 ; 00009A, 31.030
0B09D0 2E 16 00    1320*  	dl 0x00162E ; 00009B, 31.194
0B09D3 4C 16 00    1321*  	dl 0x00164C ; 00009C, 31.357
0B09D6 6A 16 00    1322*  	dl 0x00166A ; 00009D, 31.520
0B09D9 87 16 00    1323*  	dl 0x001687 ; 00009E, 31.682
0B09DC A5 16 00    1324*  	dl 0x0016A5 ; 00009F, 31.844
0B09DF C2 16 00    1325*  	dl 0x0016C2 ; 0000A0, 32.005
0B09E2 DF 16 00    1326*  	dl 0x0016DF ; 0000A1, 32.166
0B09E5 FC 16 00    1327*  	dl 0x0016FC ; 0000A2, 32.326
0B09E8 19 17 00    1328*  	dl 0x001719 ; 0000A3, 32.486
0B09EB 36 17 00    1329*  	dl 0x001736 ; 0000A4, 32.645
0B09EE 53 17 00    1330*  	dl 0x001753 ; 0000A5, 32.803
0B09F1 70 17 00    1331*  	dl 0x001770 ; 0000A6, 32.961
0B09F4 8C 17 00    1332*  	dl 0x00178C ; 0000A7, 33.118
0B09F7 A9 17 00    1333*  	dl 0x0017A9 ; 0000A8, 33.275
0B09FA C5 17 00    1334*  	dl 0x0017C5 ; 0000A9, 33.431
0B09FD E2 17 00    1335*  	dl 0x0017E2 ; 0000AA, 33.587
0B0A00 FE 17 00    1336*  	dl 0x0017FE ; 0000AB, 33.742
0B0A03 1A 18 00    1337*  	dl 0x00181A ; 0000AC, 33.896
0B0A06 36 18 00    1338*  	dl 0x001836 ; 0000AD, 34.050
0B0A09 52 18 00    1339*  	dl 0x001852 ; 0000AE, 34.203
0B0A0C 6E 18 00    1340*  	dl 0x00186E ; 0000AF, 34.356
0B0A0F 8A 18 00    1341*  	dl 0x00188A ; 0000B0, 34.509
0B0A12 A5 18 00    1342*  	dl 0x0018A5 ; 0000B1, 34.660
0B0A15 C1 18 00    1343*  	dl 0x0018C1 ; 0000B2, 34.811
0B0A18 DC 18 00    1344*  	dl 0x0018DC ; 0000B3, 34.962
0B0A1B F7 18 00    1345*  	dl 0x0018F7 ; 0000B4, 35.112
0B0A1E 13 19 00    1346*  	dl 0x001913 ; 0000B5, 35.262
0B0A21 2E 19 00    1347*  	dl 0x00192E ; 0000B6, 35.410
0B0A24 49 19 00    1348*  	dl 0x001949 ; 0000B7, 35.559
0B0A27 64 19 00    1349*  	dl 0x001964 ; 0000B8, 35.707
0B0A2A 7F 19 00    1350*  	dl 0x00197F ; 0000B9, 35.854
0B0A2D 99 19 00    1351*  	dl 0x001999 ; 0000BA, 36.001
0B0A30 B4 19 00    1352*  	dl 0x0019B4 ; 0000BB, 36.147
0B0A33 CE 19 00    1353*  	dl 0x0019CE ; 0000BC, 36.293
0B0A36 E9 19 00    1354*  	dl 0x0019E9 ; 0000BD, 36.438
0B0A39 03 1A 00    1355*  	dl 0x001A03 ; 0000BE, 36.582
0B0A3C 1D 1A 00    1356*  	dl 0x001A1D ; 0000BF, 36.726
0B0A3F 37 1A 00    1357*  	dl 0x001A37 ; 0000C0, 36.870
0B0A42 51 1A 00    1358*  	dl 0x001A51 ; 0000C1, 37.013
0B0A45 6B 1A 00    1359*  	dl 0x001A6B ; 0000C2, 37.155
0B0A48 85 1A 00    1360*  	dl 0x001A85 ; 0000C3, 37.297
0B0A4B 9F 1A 00    1361*  	dl 0x001A9F ; 0000C4, 37.439
0B0A4E B9 1A 00    1362*  	dl 0x001AB9 ; 0000C5, 37.579
0B0A51 D2 1A 00    1363*  	dl 0x001AD2 ; 0000C6, 37.720
0B0A54 EC 1A 00    1364*  	dl 0x001AEC ; 0000C7, 37.859
0B0A57 05 1B 00    1365*  	dl 0x001B05 ; 0000C8, 37.999
0B0A5A 1E 1B 00    1366*  	dl 0x001B1E ; 0000C9, 38.137
0B0A5D 37 1B 00    1367*  	dl 0x001B37 ; 0000CA, 38.276
0B0A60 50 1B 00    1368*  	dl 0x001B50 ; 0000CB, 38.413
0B0A63 69 1B 00    1369*  	dl 0x001B69 ; 0000CC, 38.550
0B0A66 82 1B 00    1370*  	dl 0x001B82 ; 0000CD, 38.687
0B0A69 9B 1B 00    1371*  	dl 0x001B9B ; 0000CE, 38.823
0B0A6C B4 1B 00    1372*  	dl 0x001BB4 ; 0000CF, 38.959
0B0A6F CC 1B 00    1373*  	dl 0x001BCC ; 0000D0, 39.094
0B0A72 E5 1B 00    1374*  	dl 0x001BE5 ; 0000D1, 39.228
0B0A75 FD 1B 00    1375*  	dl 0x001BFD ; 0000D2, 39.362
0B0A78 16 1C 00    1376*  	dl 0x001C16 ; 0000D3, 39.496
0B0A7B 2E 1C 00    1377*  	dl 0x001C2E ; 0000D4, 39.629
0B0A7E 46 1C 00    1378*  	dl 0x001C46 ; 0000D5, 39.762
0B0A81 5E 1C 00    1379*  	dl 0x001C5E ; 0000D6, 39.894
0B0A84 76 1C 00    1380*  	dl 0x001C76 ; 0000D7, 40.025
0B0A87 8E 1C 00    1381*  	dl 0x001C8E ; 0000D8, 40.156
0B0A8A A5 1C 00    1382*  	dl 0x001CA5 ; 0000D9, 40.286
0B0A8D BD 1C 00    1383*  	dl 0x001CBD ; 0000DA, 40.416
0B0A90 D5 1C 00    1384*  	dl 0x001CD5 ; 0000DB, 40.546
0B0A93 EC 1C 00    1385*  	dl 0x001CEC ; 0000DC, 40.675
0B0A96 04 1D 00    1386*  	dl 0x001D04 ; 0000DD, 40.803
0B0A99 1B 1D 00    1387*  	dl 0x001D1B ; 0000DE, 40.931
0B0A9C 32 1D 00    1388*  	dl 0x001D32 ; 0000DF, 41.059
0B0A9F 49 1D 00    1389*  	dl 0x001D49 ; 0000E0, 41.186
0B0AA2 60 1D 00    1390*  	dl 0x001D60 ; 0000E1, 41.312
0B0AA5 77 1D 00    1391*  	dl 0x001D77 ; 0000E2, 41.438
0B0AA8 8E 1D 00    1392*  	dl 0x001D8E ; 0000E3, 41.564
0B0AAB A5 1D 00    1393*  	dl 0x001DA5 ; 0000E4, 41.689
0B0AAE BB 1D 00    1394*  	dl 0x001DBB ; 0000E5, 41.814
0B0AB1 D2 1D 00    1395*  	dl 0x001DD2 ; 0000E6, 41.938
0B0AB4 E9 1D 00    1396*  	dl 0x001DE9 ; 0000E7, 42.061
0B0AB7 FF 1D 00    1397*  	dl 0x001DFF ; 0000E8, 42.184
0B0ABA 15 1E 00    1398*  	dl 0x001E15 ; 0000E9, 42.307
0B0ABD 2C 1E 00    1399*  	dl 0x001E2C ; 0000EA, 42.429
0B0AC0 42 1E 00    1400*  	dl 0x001E42 ; 0000EB, 42.551
0B0AC3 58 1E 00    1401*  	dl 0x001E58 ; 0000EC, 42.672
0B0AC6 6E 1E 00    1402*  	dl 0x001E6E ; 0000ED, 42.793
0B0AC9 84 1E 00    1403*  	dl 0x001E84 ; 0000EE, 42.913
0B0ACC 99 1E 00    1404*  	dl 0x001E99 ; 0000EF, 43.033
0B0ACF AF 1E 00    1405*  	dl 0x001EAF ; 0000F0, 43.152
0B0AD2 C5 1E 00    1406*  	dl 0x001EC5 ; 0000F1, 43.271
0B0AD5 DA 1E 00    1407*  	dl 0x001EDA ; 0000F2, 43.390
0B0AD8 F0 1E 00    1408*  	dl 0x001EF0 ; 0000F3, 43.508
0B0ADB 05 1F 00    1409*  	dl 0x001F05 ; 0000F4, 43.625
0B0ADE 1B 1F 00    1410*  	dl 0x001F1B ; 0000F5, 43.742
0B0AE1 30 1F 00    1411*  	dl 0x001F30 ; 0000F6, 43.859
0B0AE4 45 1F 00    1412*  	dl 0x001F45 ; 0000F7, 43.975
0B0AE7 5A 1F 00    1413*  	dl 0x001F5A ; 0000F8, 44.091
0B0AEA 6F 1F 00    1414*  	dl 0x001F6F ; 0000F9, 44.206
0B0AED 84 1F 00    1415*  	dl 0x001F84 ; 0000FA, 44.321
0B0AF0 99 1F 00    1416*  	dl 0x001F99 ; 0000FB, 44.435
0B0AF3 AD 1F 00    1417*  	dl 0x001FAD ; 0000FC, 44.549
0B0AF6 C2 1F 00    1418*  	dl 0x001FC2 ; 0000FD, 44.662
0B0AF9 D7 1F 00    1419*  	dl 0x001FD7 ; 0000FE, 44.775
0B0AFC EB 1F 00    1420*  	dl 0x001FEB ; 0000FF, 44.888
0B0AFF 00 20 00    1421*  	dl 0x002000 ; 000100, 45.000 only needed for interpolation
0B0B02             1422*  
0B0B02             1423*  	; include "functions.inc"
0B0B02             1424*  
0B0B02             1425*      MACRO printChar char
0B0B02             1426*          LD A, char
0B0B02             1427*          RST.LIL 10h
0B0B02             1428*      ENDMACRO
0B0B02             1429*  
0B0B02             1430*  ; put the value in HLU into the accumulator
0B0B02             1431*  ; destroys: af
0B0B02             1432*      MACRO HLU_TO_A
0B0B02             1433*          push hl ; 4 cycles
0B0B02             1434*          inc sp ; 1 cycle
0B0B02             1435*          pop af  ; 4 cycles
0B0B02             1436*          dec sp ; 1 cycle
0B0B02             1437*                 ; 10 cycles total
0B0B02             1438*      ENDMACRO
0B0B02             1439*  
0B0B02             1440*  ; put the value in the accumulator into HLU
0B0B02             1441*  ; destroys a
0B0B02             1442*  A_TO_HLU:
0B0B02             1443*      ; call is 7 cycles
0B0B02 22 0F 0B 0B 1444*      ld (@scratch),hl ; 7 cycles
0B0B06 32 11 0B 0B 1445*      ld (@scratch+2),a ; 5 cycles
0B0B0A 2A 0F 0B 0B 1446*      ld hl,(@scratch) ; 7 cycles
0B0B0E C9          1447*      ret ; 6 cycles
0B0B0F             1448*          ; 25 cycles total
0B0B0F 00 00 00    1449*  @scratch: dl 0
0B0B12             1450*  
0B0B12             1451*  
0B0B12             1452*  ; Print a zero-terminated string inline with code, e.g.:
0B0B12             1453*  ;
0B0B12             1454*  ;    call printInline
0B0B12             1455*  ;    ASCIZ "Hello, world!\r\n"
0B0B12             1456*  ;
0B0B12             1457*  ; Destroys: HL,AF
0B0B12             1458*  printInline:
0B0B12 E1          1459*      pop hl ; get the return address = pointer to start of string
0B0B13 CD 19 0B 0B 1460*      call printString ; HL advances to end of string
0B0B17 E5          1461*      push hl ; restore the return address = pointer to end of string
0B0B18 C9          1462*      ret
0B0B19             1463*  
0B0B19             1464*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
0B0B19             1465*  ; Print a zero-terminated string
0B0B19             1466*  ; HL: Pointer to string
0B0B19             1467*  printString:
0B0B19 C5          1468*  	PUSH	BC
0B0B1A 01 00 00 00 1469*  	LD		BC,0
0B0B1E 3E 00       1470*  	LD 	 	A,0
0B0B20 5B DF       1471*  	RST.LIL 18h
0B0B22 C1          1472*  	POP		BC
0B0B23 C9          1473*  	RET
0B0B24             1474*  ; print a VDU sequence
0B0B24             1475*  ; HL: Pointer to VDU sequence - <1 byte length> <data>
0B0B24             1476*  sendVDUsequence:
0B0B24 C5          1477*  	PUSH	BC
0B0B25 01 00 00 00 1478*  	LD		BC, 0
0B0B29 4E          1479*  	LD		C, (HL)
0B0B2A 5B DF       1480*  	RST.LIL	18h
0B0B2C C1          1481*  	POP		BC
0B0B2D C9          1482*  	RET
0B0B2E             1483*  ; Print Newline sequence to VDP
0B0B2E             1484*  printNewLine:
0B0B2E F5          1485*      push af ; for some reason rst.lil 10h sets carry flag
0B0B2F 3E 0D       1486*  	LD	A, '\r'
0B0B31 5B D7       1487*  	RST.LIL 10h
0B0B33 3E 0A       1488*  	LD	A, '\n'
0B0B35 5B D7       1489*  	RST.LIL 10h
0B0B37 F1          1490*      pop af
0B0B38 C9          1491*  	RET
0B0B39             1492*  
0B0B39             1493*  ; Print a 24-bit HEX number
0B0B39             1494*  ; HLU: Number to print
0B0B39             1495*  printHex24:
0B0B39             1496*      HLU_TO_A
0B0B39 E5          0001*M         push hl ; 4 cycles
0B0B3A 33          0002*M         inc sp ; 1 cycle
0B0B3B F1          0003*M         pop af  ; 4 cycles
0B0B3C 3B          0004*M         dec sp ; 1 cycle
0B0B3D             0005*M                ; 10 cycles total
0B0B3D CD 47 0B 0B 1497*  	CALL	printHex8
0B0B41             1498*  ; Print a 16-bit HEX number
0B0B41             1499*  ; HL: Number to print
0B0B41             1500*  printHex16:
0B0B41 7C          1501*  	LD		A,H
0B0B42 CD 47 0B 0B 1502*  	CALL	printHex8
0B0B46 7D          1503*  	LD		A,L
0B0B47             1504*  ; Print an 8-bit HEX number
0B0B47             1505*  ; A: Number to print
0B0B47             1506*  printHex8:
0B0B47 4F          1507*  	LD		C,A
0B0B48 1F          1508*  	RRA
0B0B49 1F          1509*  	RRA
0B0B4A 1F          1510*  	RRA
0B0B4B 1F          1511*  	RRA
0B0B4C CD 51 0B 0B 1512*  	CALL	@F
0B0B50 79          1513*  	LD		A,C
0B0B51             1514*  @@:
0B0B51 E6 0F       1515*  	AND		0Fh
0B0B53 C6 90       1516*  	ADD		A,90h
0B0B55 27          1517*  	DAA
0B0B56 CE 40       1518*  	ADC		A,40h
0B0B58 27          1519*  	DAA
0B0B59 5B D7       1520*  	RST.LIL	10h
0B0B5B C9          1521*  	RET
0B0B5C             1522*  
0B0B5C             1523*  printHexUHL:
0B0B5C E5          1524*  	push hl
0B0B5D CD 39 0B 0B 1525*  	call printHex24
0B0B61 E1          1526*  	pop hl
0B0B62 C9          1527*  	ret
0B0B63             1528*  
0B0B63             1529*  
0B0B63             1530*  ; print registers to screen in hexidecimal format
0B0B63             1531*  ; inputs: none
0B0B63             1532*  ; outputs: values of every register printed to screen
0B0B63             1533*  ;    values of each register in global scratch memory
0B0B63             1534*  ; destroys: nothing
0B0B63             1535*  dumpRegistersHex:
0B0B63             1536*  ; store everything in scratch
0B0B63 22 08 0C 0B 1537*      ld (@uhl),hl
0B0B67 ED 43 0B 0C 1538*      ld (@ubc),bc
       0B          
0B0B6C ED 53 0E 0C 1539*      ld (@ude),de
       0B          
0B0B71 DD 22 11 0C 1540*      ld (@uix),ix
       0B          
0B0B76 FD 22 14 0C 1541*      ld (@uiy),iy
       0B          
0B0B7B F5          1542*      push af
0B0B7C E1          1543*      pop hl
0B0B7D 22 05 0C 0B 1544*      ld (@uaf),hl
0B0B81 F5          1545*      push af
0B0B82             1546*  
0B0B82             1547*  ; print each register
0B0B82 CD 12 0B 0B 1548*      call printInline
0B0B86 61 66 3D 00 1549*      asciz "af="
0B0B8A 2A 05 0C 0B 1550*      ld hl,(@uaf)
0B0B8E CD 39 0B 0B 1551*      call printHex24
0B0B92             1552*  
0B0B92 CD 12 0B 0B 1553*      call printInline
0B0B96 20 68 6C 3D 1554*      asciz " hl="
       00          
0B0B9B 2A 08 0C 0B 1555*      ld hl,(@uhl)
0B0B9F CD 39 0B 0B 1556*      call printHex24
0B0BA3             1557*  
0B0BA3 CD 12 0B 0B 1558*      call printInline
0B0BA7 20 62 63 3D 1559*      asciz " bc="
       00          
0B0BAC 2A 0B 0C 0B 1560*      ld hl,(@ubc)
0B0BB0 CD 39 0B 0B 1561*      call printHex24
0B0BB4             1562*  
0B0BB4 CD 12 0B 0B 1563*      call printInline
0B0BB8 20 64 65 3D 1564*      asciz " de="
       00          
0B0BBD 2A 0E 0C 0B 1565*      ld hl,(@ude)
0B0BC1 CD 39 0B 0B 1566*      call printHex24
0B0BC5             1567*  
0B0BC5 CD 12 0B 0B 1568*      call printInline
0B0BC9 20 69 78 3D 1569*      asciz " ix="
       00          
0B0BCE 2A 11 0C 0B 1570*      ld hl,(@uix)
0B0BD2 CD 39 0B 0B 1571*      call printHex24
0B0BD6             1572*  
0B0BD6 CD 12 0B 0B 1573*      call printInline
0B0BDA 20 69 79 3D 1574*      asciz " iy="
       00          
0B0BDF 2A 14 0C 0B 1575*      ld hl,(@uiy)
0B0BE3 CD 39 0B 0B 1576*      call printHex24
0B0BE7             1577*  
0B0BE7 CD 2E 0B 0B 1578*      call printNewLine
0B0BEB             1579*  ; restore everything
0B0BEB 2A 08 0C 0B 1580*      ld hl, (@uhl)
0B0BEF ED 4B 0B 0C 1581*      ld bc, (@ubc)
       0B          
0B0BF4 ED 5B 0E 0C 1582*      ld de, (@ude)
       0B          
0B0BF9 DD 2A 11 0C 1583*      ld ix, (@uix)
       0B          
0B0BFE FD 2A 14 0C 1584*      ld iy, (@uiy)
       0B          
0B0C03 F1          1585*      pop af
0B0C04             1586*  ; all done
0B0C04 C9          1587*      ret
0B0C05             1588*  
0B0C05 00 00 00    1589*  @uaf: dl 0
0B0C08 00 00 00    1590*  @uhl: dl 0
0B0C0B 00 00 00    1591*  @ubc: dl 0
0B0C0E 00 00 00    1592*  @ude: dl 0
0B0C11 00 00 00    1593*  @uix: dl 0
0B0C14 00 00 00    1594*  @uiy: dl 0
0B0C17             1595*  
0B0C17             1596*  ; Prints the right justified decimal value in HL without leading zeroes
0B0C17             1597*  ; HL : Value to print
0B0C17             1598*  ; preserves all registers and flags
0B0C17             1599*  printDec:
0B0C17             1600*  ; BEGIN MY CODE
0B0C17             1601*  ; back up all the things
0B0C17 F5          1602*      push af
0B0C18 C5          1603*      push bc
0B0C19 D5          1604*      push de
0B0C1A E5          1605*      push hl
0B0C1B             1606*  ; END MY CODE
0B0C1B 11 43 0C 0B 1607*  	LD	 DE, _printDecBuffer
0B0C1F CD 53 0C 0B 1608*  	CALL u24_to_ascii
0B0C23             1609*  ; BEGIN MY CODE
0B0C23             1610*  ; replace leading zeroes with spaces
0B0C23 21 43 0C 0B 1611*      LD	 HL, _printDecBuffer
0B0C27 06 07       1612*      ld   B, 7 ; if HL was 0, we want to keep the final zero
0B0C29             1613*  @loop:
0B0C29 7E          1614*      LD	 A, (HL)
0B0C2A FE 30       1615*      CP	 '0'
0B0C2C C2 36 0C 0B 1616*      JP	 NZ, @done
0B0C30 3E 20       1617*      LD   A, ' '
0B0C32 77          1618*      LD	 (HL), A
0B0C33 23          1619*      INC	 HL
0B0C34             1620*      ; CALL vdu_cursor_forward
0B0C34 10 F3       1621*      DJNZ @loop
0B0C36             1622*  @done:
0B0C36             1623*  ; END MY CODE
0B0C36 21 43 0C 0B 1624*  	LD	 HL, _printDecBuffer
0B0C3A CD 19 0B 0B 1625*  	CALL printString
0B0C3E             1626*  ; BEGIN MY CODE
0B0C3E             1627*  ; restore all the things
0B0C3E E1          1628*      pop hl
0B0C3F D1          1629*      pop de
0B0C40 C1          1630*      pop bc
0B0C41 F1          1631*      pop af
0B0C42             1632*  ; END MY CODE
0B0C42 C9          1633*  	RET
0B0C43 00 00 00 00 1634*  _printDecBuffer: blkb 16,0 ; a few bytes extra just to be sure
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0B0C53             1635*  
0B0C53             1636*  ; This routine converts the unsigned 24-bit value in HLU into it's ASCII representation,
0B0C53             1637*  ; starting to memory location pointing by DE, in decimal form and with leading zeroes
0B0C53             1638*  ; so it will allways be 8 characters length
0B0C53             1639*  ; HL : Value to convert to string
0B0C53             1640*  ; DE : pointer to buffer, at least 8 byte + 0
0B0C53             1641*  u24_to_ascii:
0B0C53 01 80 69 67 1642*  	LD	 BC,-10000000
0B0C57 CD 8A 0C 0B 1643*  	CALL @one_digit
0B0C5B 01 C0 BD F0 1644*  	LD	 BC,-1000000
0B0C5F CD 8A 0C 0B 1645*  	CALL @one_digit
0B0C63 01 60 79 FE 1646*  	LD	 BC,-100000
0B0C67 CD 8A 0C 0B 1647*  	CALL @one_digit
0B0C6B 01 F0 D8 FF 1648*  	LD   BC,-10000
0B0C6F CD 8A 0C 0B 1649*  	CALL @one_digit
0B0C73 01 18 FC FF 1650*  	LD   BC,-1000
0B0C77 CD 8A 0C 0B 1651*  	CALL @one_digit
0B0C7B 01 9C FF FF 1652*  	LD   BC,-100
0B0C7F CD 8A 0C 0B 1653*  	CALL @one_digit
0B0C83 0E F6       1654*  	LD   C,-10
0B0C85 CD 8A 0C 0B 1655*  	CALL @one_digit
0B0C89 48          1656*  	LD   C,B
0B0C8A             1657*  @one_digit:
0B0C8A 3E 2F       1658*  	LD   A,'0'-1
0B0C8C             1659*  @divide_me:
0B0C8C 3C          1660*  	INC  A
0B0C8D 09          1661*  	ADD  HL,BC
0B0C8E 38 FC       1662*  	JR   C,@divide_me
0B0C90 ED 42       1663*  	SBC  HL,BC
0B0C92 12          1664*  	LD   (DE),A
0B0C93 13          1665*  	INC  DE
0B0C94 C9          1666*  	RET
0B0C95             1667*  
0B0C95             1668*  print_u24:
0B0C95 D5          1669*      push de
0B0C96 E5          1670*      push hl
0B0C97 11 43 0C 0B 1671*      ld de,_printDecBuffer
0B0C9B CD 53 0C 0B 1672*      call u24_to_ascii
0B0C9F 21 43 0C 0B 1673*      ld hl,_printDecBuffer
0B0CA3 CD 19 0B 0B 1674*      call printString
0B0CA7 3E 20       1675*      ld a,' '
0B0CA9 5B D7       1676*      rst.lil 10h
0B0CAB E1          1677*      pop hl
0B0CAC D1          1678*      pop de
0B0CAD C9          1679*      ret
0B0CAE             1680*  
0B0CAE             1681*  ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
0B0CAE             1682*  ; HL : Value to convert to string (integer part in H, fractional part in L)
0B0CAE             1683*  ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
0B0CAE             1684*  u168_to_ascii:
0B0CAE             1685*  ; add a leading space to make room for sign flag if needed
0B0CAE 3E 20       1686*      ld a,' '
0B0CB0 12          1687*      ld (de),a
0B0CB1 13          1688*      inc de
0B0CB2             1689*  ; Convert integer part
0B0CB2 E5          1690*      push hl               ; Save HL (well need the fractional part later)
0B0CB3 CD B7 00 0B 1691*      call hlu_udiv256    ; Shift to get integer portion in HL
0B0CB7 01 F0 D8 FF 1692*      ld   bc, -10000
0B0CBB CD DE 0C 0B 1693*      call @one_int
0B0CBF 01 18 FC FF 1694*      ld   bc, -1000
0B0CC3 CD DE 0C 0B 1695*      call @one_int
0B0CC7 01 9C FF FF 1696*      ld   bc, -100
0B0CCB CD DE 0C 0B 1697*      call @one_int
0B0CCF 0E F6       1698*      ld   c, -10
0B0CD1 CD DE 0C 0B 1699*      call @one_int
0B0CD5 48          1700*      ld   c, b
0B0CD6 CD DE 0C 0B 1701*      call @one_int
0B0CDA C3 E9 0C 0B 1702*      jp   @frac            ; Jump to fractional part conversion
0B0CDE             1703*  @one_int:
0B0CDE 3E 2F       1704*      ld   a, '0' - 1       ; Start ASCII character at '0'
0B0CE0             1705*  @divide_me:
0B0CE0 3C          1706*      inc  a
0B0CE1 09          1707*      add  hl, bc           ; Accumulate until overflow
0B0CE2 38 FC       1708*      jr   c, @divide_me
0B0CE4 ED 42       1709*      sbc  hl, bc           ; Remove excess after overflow
0B0CE6 12          1710*      ld   (de), a          ; Store ASCII digit
0B0CE7 13          1711*      inc  de
0B0CE8 C9          1712*      ret
0B0CE9             1713*  ; Convert fractional part
0B0CE9             1714*  @frac:
0B0CE9 3E 2E       1715*      ld   a, '.'           ; Decimal point
0B0CEB 12          1716*      ld   (de), a
0B0CEC 13          1717*      inc  de
0B0CED E1          1718*      pop  hl               ; Restore HL with original fraction
0B0CEE 06 03       1719*      ld   b, 3             ; Loop counter for 3 fractional digits
0B0CF0             1720*  @frac_loop:
0B0CF0 26 0A       1721*      ld   h, 10            ; Load multiplier for fractional part
0B0CF2 ED 6C       1722*      mlt  hl               ; Multiply by 10, result in HL (H holds the integer part)
0B0CF4 3E 30       1723*      ld   a, '0'
0B0CF6 84          1724*      add  a, h             ; Convert integer part to ASCII
0B0CF7 12          1725*      ld   (de), a
0B0CF8 13          1726*      inc  de
0B0CF9 10 F5       1727*      djnz @frac_loop       ; Repeat for each fractional digit
0B0CFB             1728*  ; Add null terminator
0B0CFB AF          1729*      xor  a                ; Null terminator
0B0CFC 12          1730*      ld   (de), a
0B0CFD C9          1731*      ret
0B0CFE             1732*  
0B0CFE             1733*  print_u168:
0B0CFE D5          1734*      push de
0B0CFF E5          1735*      push hl
0B0D00 11 43 0C 0B 1736*      ld de,_printDecBuffer
0B0D04 CD AE 0C 0B 1737*      call u168_to_ascii
0B0D08 21 43 0C 0B 1738*      ld hl,_printDecBuffer
0B0D0C CD 19 0B 0B 1739*      call printString
0B0D10 E1          1740*      pop hl
0B0D11 D1          1741*      pop de
0B0D12 C9          1742*      ret
0B0D13             1743*  
0B0D13             1744*  ; signed version of u168_to_ascii
0B0D13             1745*  s168_to_ascii:
0B0D13 D5          1746*      push de ; save starting address of buffer
0B0D14 CD C4 00 0B 1747*      call hlu_abs
0B0D18 F5          1748*      push af ; save sign flag
0B0D19 CD AE 0C 0B 1749*      call u168_to_ascii
0B0D1D F1          1750*      pop af ; restore sign flag
0B0D1E D1          1751*      pop de ; restore starting address of buffer
0B0D1F F0          1752*      ret p ; hlu was positive so nothing to do
0B0D20 3E 2D       1753*      ld a,'-'
0B0D22 12          1754*      ld (de),a
0B0D23 C9          1755*      ret
0B0D24             1756*  
0B0D24             1757*  print_s168:
0B0D24 D5          1758*      push de
0B0D25 E5          1759*      push hl
0B0D26 11 43 0C 0B 1760*      ld de,_printDecBuffer
0B0D2A CD 13 0D 0B 1761*      call s168_to_ascii
0B0D2E 21 43 0C 0B 1762*      ld hl,_printDecBuffer
0B0D32 CD 19 0B 0B 1763*      call printString
0B0D36 E1          1764*      pop hl
0B0D37 D1          1765*      pop de
0B0D38 C9          1766*      ret
0B0D39             1767*  
0B0D39             1768*  	; include "parse.inc"
0B0D39             1769*  
0B0D39             1770*  ;
0B0D39             1771*  ; Title:	Number Parsing Functions
0B0D39             1772*  ; Author:	Dean Belfield
0B0D39             1773*  ; Created:	15/11/2022
0B0D39             1774*  ; Last Updated:	15/11/2022
0B0D39             1775*  ; Last Updated: 29/12/2022 Lennart Benchop adapt for 24-bit mode.
0B0D39             1776*  ; Modinfo:
0B0D39             1777*  ; 2024/04/08    Adapt for ez80asm
0B0D39             1778*  
0B0D39             1779*  ; Read a number and convert to binary
0B0D39             1780*  ; If prefixed with &, will read as hex, otherwise decimal
0B0D39             1781*  ;   Inputs: HL: Pointer in string buffer
0B0D39             1782*  ;  Outputs: HL: Updated text pointer
0B0D39             1783*  ;           DE: Value
0B0D39             1784*  ;            A: Terminator (spaces skipped)
0B0D39             1785*  ;            F: Carry set if valid number, otherwise reset
0B0D39             1786*  ; Destroys: A,D,E,H,L,F
0B0D39             1787*  ;
0B0D39 11 00 00 00 1788*  ASC_TO_NUMBER:		LD		DE, 0			; Initialise DE
0B0D3D             1789*  			; CALL		_skip_spaces		; Skip whitespace
0B0D3D 7E          1790*  			LD		A, (HL)			; Read first character
0B0D3E B7          1791*  			OR		A			; Check for end of string
0B0D3F C8          1792*  			RET		Z			; Return with no carry if not
0B0D40 C5          1793*  			PUSH		BC			; Preserve BC
0B0D41 FE 26       1794*  			CP		'&'			; Is it prefixed with '&' (HEX number)?
0B0D43 20 23       1795*  			JR		NZ, ASC_TO_NUMBER3	; Jump to decimal parser if not
0B0D45 23          1796*  			INC		HL			; Otherwise fall through to ASC_TO_HEX
0B0D46             1797*  ;
0B0D46 7E          1798*  ASC_TO_NUMBER1:		LD		A, (HL)			; Fetch the character
0B0D47 CD 89 0D 0B 1799*  			CALL   	 	UPPRC			; Convert to uppercase
0B0D4B D6 30       1800*  			SUB		'0'			; Normalise to 0
0B0D4D 38 37       1801*  			JR 		C, ASC_TO_NUMBER4	; Return if < ASCII '0'
0B0D4F FE 0A       1802*  			CP 		10			; Check if >= 10
0B0D51 38 06       1803*  			JR 		C, ASC_TO_NUMBER2	; No, so skip next bit
0B0D53 D6 07       1804*  			SUB 		7			; Adjust ASCII A-F to nibble
0B0D55 FE 10       1805*  			CP 		16			; Check for > F
0B0D57 30 2D       1806*  			JR 		NC, ASC_TO_NUMBER4	; Return if out of range
0B0D59             1807*  ;
0B0D59 E5          1808*  ASC_TO_NUMBER2:		PUSH		HL			; Stack HL
0B0D5A D5          1809*  			PUSH		DE			; LD HL, DE
0B0D5B E1          1810*  			POP		HL
0B0D5C 29          1811*  			ADD		HL, HL
0B0D5D 29          1812*  			ADD		HL, HL
0B0D5E 29          1813*  			ADD		HL, HL
0B0D5F 29          1814*  			ADD		HL, HL
0B0D60 E5          1815*  			PUSH		HL			; LD DE, HL
0B0D61 D1          1816*  			POP		DE
0B0D62 E1          1817*  			POP		HL			; Restore HL
0B0D63 B3          1818*  			OR      	E			; OR the new digit in to the least significant nibble
0B0D64 5F          1819*  			LD      	E, A
0B0D65             1820*  ;
0B0D65 23          1821*  			INC		HL			; Onto the next character
0B0D66 18 DE       1822*  			JR      	ASC_TO_NUMBER1		; And loop
0B0D68             1823*  ;
0B0D68 7E          1824*  ASC_TO_NUMBER3:		LD		A, (HL)
0B0D69 D6 30       1825*  			SUB		'0'			; Normalise to 0
0B0D6B 38 19       1826*  			JR		C, ASC_TO_NUMBER4	; Return if < ASCII '0'
0B0D6D FE 0A       1827*  			CP		10			; Check if >= 10
0B0D6F 30 15       1828*  			JR		NC, ASC_TO_NUMBER4	; Return if >= 10
0B0D71             1829*  ;
0B0D71 E5          1830*  			PUSH		HL			; Stack HL
0B0D72 D5          1831*  			PUSH		DE			; LD HL, DE
0B0D73 E1          1832*  			POP		HL
0B0D74 E5          1833*  			PUSH		HL			; LD BC, HL
0B0D75 C1          1834*  			POP		BC
0B0D76 29          1835*  			ADD		HL, HL 			; x 2
0B0D77 29          1836*  			ADD		HL, HL 			; x 4
0B0D78 09          1837*  			ADD		HL, BC 			; x 5
0B0D79 29          1838*  			ADD		HL, HL 			; x 10
0B0D7A 01 00 00 00 1839*  			LD		BC, 0
0B0D7E 4F          1840*  			LD 		C, A			; LD BCU, A
0B0D7F 09          1841*  			ADD		HL, BC			; Add BCU to HL
0B0D80 E5          1842*  			PUSH		HL			; LD DE, HL
0B0D81 D1          1843*  			POP		DE
0B0D82 E1          1844*  			POP		HL			; Restore HL
0B0D83             1845*  ;
0B0D83 23          1846*  			INC		HL
0B0D84 18 E2       1847*  			JR		ASC_TO_NUMBER3
0B0D86 C1          1848*  ASC_TO_NUMBER4:		POP		BC
0B0D87 37          1849*  			SCF					; We have a valid number so set carry
0B0D88 C9          1850*  			RET
0B0D89             1851*  
0B0D89             1852*  
0B0D89             1853*  ; Convert a character to upper case
0B0D89             1854*  ;  A: Character to convert
0B0D89             1855*  ;
0B0D89 E6 7F       1856*  UPPRC:  		AND     	7FH
0B0D8B FE 60       1857*  			CP      	'`'
0B0D8D D8          1858*  			RET     	C
0B0D8E E6 5F       1859*  			AND     	5FH			; Convert to upper case
0B0D90 C9          1860*  			RET
0B0D91             1861*  
0B0D91             1862*  ; -----------------------------------------------------------------------
0B0D91             1863*  ;
0B0D91             1864*  ; additional functions by Brandon R. Gates based on Dean's code
0B0D91             1865*  ;
0B0D91             1866*  ;------------------------------------------------------------------------
0B0D91             1867*  ; Read a number and convert to binary (decimal only)
0B0D91             1868*  ; Inputs: hl: Pointer in string buffer
0B0D91             1869*  ; Outputs: hl: Updated text pointer
0B0D91             1870*  ;         de: Value
0B0D91             1871*  ;         a: Terminator (spaces skipped)
0B0D91             1872*  ;         f: Carry set if valid number, otherwise reset
0B0D91             1873*  ; Destroys: a, d, e, h, l, f
0B0D91             1874*  ;------------------------------------------------------------------------
0B0D91             1875*  asc_to_s24:
0B0D91 3E 01       1876*      ld a,1 ; set sign flag
0B0D93 32 DF 0D 0B 1877*      ld (@sign),a ; store sign flag
0B0D97             1878*  
0B0D97 11 00 00 00 1879*      ld de, 0 ; initialise de
0B0D9B             1880*      ; call _skip_spaces ; skip whitespace
0B0D9B             1881*  
0B0D9B 7E          1882*      ld a, (hl) ; read first character
0B0D9C B7          1883*      or a ; check for end of string
0B0D9D C8          1884*      ret z ; return with no carry if not
0B0D9E             1885*  
0B0D9E C5          1886*      push bc ; preserve bc
0B0D9F             1887*  
0B0D9F FE 2D       1888*      cp '-' ; check for negative number
0B0DA1 C2 AB 0D 0B 1889*      jp nz,@loop ; number is positive, nothing more to do
0B0DA5 AF          1890*      xor a ; sign flag to zero
0B0DA6 32 DF 0D 0B 1891*      ld (@sign),a ; store sign flag
0B0DAA 23          1892*      inc hl ; skip '-'
0B0DAB             1893*  
0B0DAB             1894*  @loop:
0B0DAB 7E          1895*      ld a, (hl)
0B0DAC D6 30       1896*      sub '0' ; normalise to 0
0B0DAE 38 19       1897*      jr c, @integer_end ; return if < ascii '0'
0B0DB0 FE 0A       1898*      cp 10 ; check if >= 10
0B0DB2 30 15       1899*      jr nc, @integer_end ; return if >= 10
0B0DB4 E5          1900*      push hl ; stack hl
0B0DB5 D5          1901*      push de ; ld hl, de
0B0DB6 E1          1902*      pop hl
0B0DB7 E5          1903*      push hl ; ld bc, hl
0B0DB8 C1          1904*      pop bc
0B0DB9 29          1905*      add hl, hl ; x 2
0B0DBA 29          1906*      add hl, hl ; x 4
0B0DBB 09          1907*      add hl, bc ; x 5
0B0DBC 29          1908*      add hl, hl ; x 10
0B0DBD 01 00 00 00 1909*      ld bc, 0
0B0DC1 4F          1910*      ld c, a ; ld bcu, a
0B0DC2 09          1911*      add hl, bc ; add bcu to hl
0B0DC3 E5          1912*      push hl ; ld de, hl
0B0DC4 D1          1913*      pop de
0B0DC5 E1          1914*      pop hl ; restore hl
0B0DC6 23          1915*      inc hl
0B0DC7 18 E2       1916*      jr @loop
0B0DC9             1917*  
0B0DC9             1918*  @integer_end:
0B0DC9 C1          1919*      pop bc ; send bc back how she came in
0B0DCA 3A DF 0D 0B 1920*      ld a, (@sign) ; get sign flag
0B0DCE 3D          1921*      dec a ; check if negative
0B0DCF F2 DD 0D 0B 1922*      jp p,@pos ; positive number
0B0DD3             1923*  
0B0DD3             1924*  ; Negate de
0B0DD3 E5          1925*      push hl ; save text pointer
0B0DD4 21 00 00 00 1926*      ld hl, 0
0B0DD8 AF          1927*      xor a ; clear carry
0B0DD9 ED 52       1928*      sbc hl, de ; subtract DE from HL
0B0DDB EB          1929*      ex de, hl ; DE = 0-HL
0B0DDC E1          1930*      pop hl ; restore text pointer
0B0DDD             1931*  
0B0DDD             1932*  @pos:
0B0DDD 37          1933*      scf ; we have a valid number so set carry
0B0DDE C9          1934*      ret
0B0DDF             1935*  
0B0DDF 00          1936*  @sign: db 0 ; sign flag buffer
0B0DE0             1937*  
0B0DE0             1938*  
0B0DE0             1939*  ;------------------------------------------------------------------------
0B0DE0             1940*  ; Read a number and convert to binary (decimal only)
0B0DE0             1941*  ; Inputs: hl: Pointer in string buffer
0B0DE0             1942*  ; Outputs: hl: Updated text pointer
0B0DE0             1943*  ;         de: Value
0B0DE0             1944*  ;         a: Terminator (spaces skipped)
0B0DE0             1945*  ;         f: Carry set if valid number, otherwise reset
0B0DE0             1946*  ; Destroys: a, d, e, h, l, f
0B0DE0             1947*  ;------------------------------------------------------------------------
0B0DE0             1948*  asc_to_s168:
0B0DE0 3E 01       1949*      ld a,1 ; set sign flag
0B0DE2 32 9F 0E 0B 1950*      ld (@sign),a ; store sign flag
0B0DE6             1951*  
0B0DE6 11 00 00 00 1952*      ld de, 0 ; initialise de
0B0DEA ED 53 97 0E 1953*      ld (@result), de ; clear low bytes of result buffer
       0B          
0B0DEF ED 53 9B 0E 1954*      ld (@scratch), de ; clear low bytes of scratch buffer
       0B          
0B0DF4             1955*  
0B0DF4             1956*      ; call _skip_spaces ; skip whitespace
0B0DF4             1957*  
0B0DF4 7E          1958*      ld a, (hl) ; read first character
0B0DF5 B7          1959*      or a ; check for end of string
0B0DF6 C8          1960*      ret z ; return with no carry if not
0B0DF7             1961*  
0B0DF7 C5          1962*      push bc ; preserve bc
0B0DF8             1963*  
0B0DF8 FE 2D       1964*      cp '-' ; check for negative number
0B0DFA C2 04 0E 0B 1965*      jp nz,@loop ; number is positive, nothing more to do
0B0DFE AF          1966*      xor a ; sign flag to zero
0B0DFF 32 9F 0E 0B 1967*      ld (@sign),a ; store sign flag
0B0E03 23          1968*      inc hl ; skip '-'
0B0E04             1969*  
0B0E04             1970*  @loop:
0B0E04 7E          1971*      ld a, (hl)
0B0E05             1972*  
0B0E05             1973*  ; chcek for decimal point
0B0E05 FE 2E       1974*      cp '.' ; check for decimal point
0B0E07 CA 48 0E 0B 1975*      jp z,@fractional_start ; jump to fractional part
0B0E0B             1976*  
0B0E0B             1977*  ; process integer part
0B0E0B D6 30       1978*      sub '0' ; normalise to 0
0B0E0D 38 19       1979*      jr c, @integer_end ; return if < ascii '0'
0B0E0F FE 0A       1980*      cp 10 ; check if >= 10
0B0E11 30 15       1981*      jr nc, @integer_end ; return if >= 10
0B0E13 E5          1982*      push hl ; stack hl
0B0E14 D5          1983*      push de ; ld hl, de
0B0E15 E1          1984*      pop hl
0B0E16 E5          1985*      push hl ; ld bc, hl
0B0E17 C1          1986*      pop bc
0B0E18 29          1987*      add hl, hl ; x 2
0B0E19 29          1988*      add hl, hl ; x 4
0B0E1A 09          1989*      add hl, bc ; x 5
0B0E1B 29          1990*      add hl, hl ; x 10
0B0E1C 01 00 00 00 1991*      ld bc, 0
0B0E20 4F          1992*      ld c, a ; ld bcu, a
0B0E21 09          1993*      add hl, bc ; add bcu to hl
0B0E22 E5          1994*      push hl ; ld de, hl
0B0E23 D1          1995*      pop de
0B0E24 E1          1996*      pop hl ; restore hl
0B0E25 23          1997*      inc hl
0B0E26 18 DC       1998*      jr @loop
0B0E28             1999*  
0B0E28             2000*  @integer_end:
0B0E28 ED 53 98 0E 2001*      ld (@result+1), de      ; Store integer part in result buffer (shifted up one byte)
       0B          
0B0E2D             2002*  
0B0E2D             2003*  @end:
0B0E2D C1          2004*      pop bc ; send bc back how she came in
0B0E2E ED 5B 97 0E 2005*      ld de,(@result) ; will contain shifted integer part combined with any fractional value
       0B          
0B0E33 3A 9F 0E 0B 2006*      ld a, (@sign) ; get sign flag
0B0E37 3D          2007*      dec a ; check if negative
0B0E38 F2 46 0E 0B 2008*      jp p,@pos ; positive number
0B0E3C             2009*  
0B0E3C             2010*  ; Negate de
0B0E3C E5          2011*      push hl ; save text pointer
0B0E3D 21 00 00 00 2012*      ld hl, 0
0B0E41 AF          2013*      xor a ; clear carry
0B0E42 ED 52       2014*      sbc hl, de ; subtract DE from HL
0B0E44 EB          2015*      ex de, hl ; DE = 0-HL
0B0E45 E1          2016*      pop hl ; restore text pointer
0B0E46             2017*  
0B0E46             2018*  @pos:
0B0E46 37          2019*      scf ; we have a valid number so set carry
0B0E47 C9          2020*      ret
0B0E48             2021*  
0B0E48             2022*  @fractional_start:
0B0E48 DD E5       2023*      push ix                    ; preserve ix
0B0E4A ED 53 98 0E 2024*      ld (@result+1), de         ; Store integer part in result buffer (shifted up one byte)
       0B          
0B0E4F 06 03       2025*      ld b, 3                    ; Set loop counter to 3 for up to three fractional digits
0B0E51 11 00 00 00 2026*      ld de, 0                   ; Initialize DE as the fractional accumulator
0B0E55 DD 21 A0 0E 2027*      ld ix, powers_of_10        ; Point IX to the lookup table for the scaling factor based on digits
       0B          
0B0E5A 23          2028*      inc hl                     ; Skip decimal point
0B0E5B             2029*  
0B0E5B             2030*  @fractional_loop:
0B0E5B 7E          2031*      ld a, (hl)                 ; Load next character
0B0E5C D6 30       2032*      sub '0'                    ; Normalize ASCII to decimal
0B0E5E 38 1C       2033*      jr c, @end_fraction        ; Exit if < '0'
0B0E60 FE 0A       2034*      cp 10
0B0E62 30 18       2035*      jr nc, @end_fraction       ; Exit if >= 10
0B0E64             2036*  
0B0E64             2037*      ; Multiply the current fractional accumulator by 10
0B0E64 E5          2038*      push hl                    ; Save char pointer
0B0E65 F5          2039*      push af                    ; Save the digit
0B0E66 EB          2040*      ex de, hl
0B0E67 E5          2041*      push hl
0B0E68 29          2042*      add hl,hl ; * 2
0B0E69 29          2043*      add hl,hl ; * 4
0B0E6A D1          2044*      pop de
0B0E6B 19          2045*      add hl,de ; * 5
0B0E6C 29          2046*      add hl,hl ; * 10
0B0E6D 11 00 00 00 2047*      ld de, 0                   ; Clear DEU
0B0E71 F1          2048*      pop af                     ; Restore the current digit
0B0E72 5F          2049*      ld e, a                    ; Load the digit into E
0B0E73 19          2050*      add hl, de                 ; Add the digit to the accumulator
0B0E74 EB          2051*      ex de, hl                  ; Result back to DE
0B0E75 ED 32 03    2052*      lea ix,ix+3                ; Advance IX to the next scaling factor
0B0E78 E1          2053*      pop hl                     ; Restore char pointer
0B0E79 23          2054*      inc hl                     ; Move to the next character
0B0E7A 10 DF       2055*      djnz @fractional_loop      ; Loop if more digits to process
0B0E7C             2056*  
0B0E7C             2057*  @end_fraction:
0B0E7C             2058*  ; Final scaling based on number of fractional digits processed
0B0E7C ED 53 9C 0E 2059*      ld (@scratch+1), de          ; Shift fractional part up a byte
       0B          
0B0E81 2A 9B 0E 0B 2060*      ld hl,(@scratch)             ; Load the shifted fractional part into HL
0B0E85             2061*  
0B0E85 DD 17 00    2062*      ld de, (ix)                ; Load final scaling factor from IX based on digit count
0B0E88 CD 34 02 0B 2063*      call udiv24                ; Perform 24-bit division to scale down
0B0E8C 7B          2064*      ld a, e                    ; Load the low byte (8-bit fractional part) into A
0B0E8D 32 97 0E 0B 2065*      ld (@result), a            ; Store fractional part in result buffer
0B0E91 DD E1       2066*      pop ix                     ; Restore ix
0B0E93 C3 2D 0E 0B 2067*      jp @end                    ; Final sign check and flag setup
0B0E97             2068*  
0B0E97             2069*  @result: ds 4                  ; 32-bit result buffer to shift integer part up one byte
0B0E9B             2070*  @scratch: ds 4                 ; 32-bit scratch buffer for intermediate calculations
0B0E9F 00          2071*  @sign: db 0                    ; Sign flag buffer
0B0EA0             2072*  
0B0EA0             2073*  powers_of_10:
0B0EA0 01 00 00    2074*      dl 1                       ; 10^0
0B0EA3 0A 00 00    2075*      dl 10                      ; 10^1
0B0EA6 64 00 00    2076*      dl 100                     ; 10^2
0B0EA9 E8 03 00    2077*      dl 1000                    ; 10^3
0B0EAC 10 27 00    2078*      dl 10000                   ; 10^4
0B0EAF             0059   
0B0EAF             0060   ; --- MAIN PROGRAM ---
0B0EAF             0061   main:
0B0EAF 0D          0062       dec c ; decrement the argument count to skip the program name
0B0EB0             0063   
0B0EB0             0064   ; compute distance between the origin and a point entered by the user
0B0EB0 CD 4E 0F 0B 0065       call get_arg_s168
0B0EB4 ED 53 41 0F 0066       ld (@arg1),de ; dx
       0B          
0B0EB9 CD 4E 0F 0B 0067       call get_arg_s168
0B0EBD ED 53 44 0F 0068       ld (@arg2),de ; dy
       0B          
0B0EC2             0069   
0B0EC2             0070   ; echo the input
0B0EC2 CD 12 0B 0B 0071       call printInline
0B0EC6 64 69 73 74 0072       asciz "distance to target at: "
       61 6E 63 65 
       20 74 6F 20 
       74 61 72 67 
       65 74 20 61 
       74 3A 20 00 
0B0EDE 2A 41 0F 0B 0073       ld hl,(@arg1)
0B0EE2 CD 24 0D 0B 0074       call print_s168
0B0EE6 3E 2C       0075       ld a,',' ; print a comma
0B0EE8 5B D7       0076       rst.lil 10h
0B0EEA 2A 44 0F 0B 0077       ld hl,(@arg2)
0B0EEE CD 24 0D 0B 0078       call print_s168
0B0EF2 CD 12 0B 0B 0079       call printInline
0B0EF6 20 3D 20 00 0080       asciz " = "
0B0EFA             0081   
0B0EFA             0082   ; compute the distance
0B0EFA DD 2A 41 0F 0083       ld ix,(@arg1) ; x1
       0B          
0B0EFF FD 2A 44 0F 0084       ld iy,(@arg2) ; y1
       0B          
0B0F04 01 00 00 00 0085       ld bc,0 ; x1 0
0B0F08 11 00 00 00 0086       ld de,0 ; y1 0
0B0F0C CD 15 03 0B 0087       call distance168
0B0F10 CD 24 0D 0B 0088       call print_s168
0B0F14             0089   
0B0F14             0090   ; compute angle between the origin and the point entered by the user
0B0F14 CD 12 0B 0B 0091       call printInline
0B0F18 0D 0A 74 61 0092       asciz "\r\ntarget bearing: "
       72 67 65 74 
       20 62 65 61 
       72 69 6E 67 
       3A 20 00    
0B0F2B ED 4B 09 03 0093       ld bc,(dx168)
       0B          
0B0F30 ED 5B 0F 03 0094       ld de,(dy168)
       0B          
0B0F35 CD 4B 03 0B 0095       call atan2_168fast ; uh.l = atan2(dx,-dy) in deg256
0B0F39             0096       ; call deg_256_to_360 ; convert to 360 degree circle
0B0F39 CD 24 0D 0B 0097       call print_s168
0B0F3D             0098   
0B0F3D C3 8E 00 0B 0099       jp _main_end_ok
0B0F41             0100   
0B0F41 00 00 00    0101   @arg1: dl 0
0B0F44 00 00 00    0102   @arg2: dl 0
0B0F47             0103   
0B0F47             0104   ; ========== HELPER FUNCTIONS ==========
0B0F47             0105   ; get the next argument after ix as a string
0B0F47             0106   ; inputs: ix = pointer to the argument string
0B0F47             0107   ; outputs: HL = pointer to the argument string, ix points to the next argument
0B0F47             0108   ; destroys: a, h, l, f
0B0F47             0109   get_arg_text:
0B0F47 ED 32 03    0110       lea ix,ix+3 ; point to the next argument
0B0F4A DD 27 00    0111       ld hl,(ix) ; get the argument string
0B0F4D C9          0112       ret
0B0F4E             0113   
0B0F4E             0114   ; get the next argument after ix as a signed 16.8 fixed point number
0B0F4E             0115   ; inputs: ix = pointer to the argument string
0B0F4E             0116   ; outputs: ude = signed 16.8 fixed point number
0B0F4E             0117   ; destroys: a, d, e, h, l, f
0B0F4E             0118   get_arg_s168:
0B0F4E ED 32 03    0119       lea ix,ix+3 ; point to the next argument
0B0F51 DD 27 00    0120       ld hl,(ix) ; get the argument string
0B0F54 CD E0 0D 0B 0121       call asc_to_s168 ; convert the string to a number
0B0F58 C9          0122       ret ; return with the value in DE
0B0F59             0123   
0B0F59             0124   ; Inputs: ix = pointer to the argument string
0B0F59             0125   ; Outputs: ude = signed 24-bit integer
0B0F59             0126   ; Destroys: a, d, e, h, l, f
0B0F59             0127   get_arg_s24:
0B0F59 ED 32 03    0128       lea ix,ix+3 ; point to the next argument
0B0F5C DD 27 00    0129       ld hl,(ix) ; get the argument string
0B0F5F CD 91 0D 0B 0130       call asc_to_s24 ; convert the string to a number
0B0F63 C9          0131       ret ; return with the value in DE
0B0F64             0132   
0B0F64             0133   ; match the next argument after ix to the dispatch table at iy
0B0F64             0134   ; - arguments and dispatch entries are zero-terminated, case-sensitive strings
0B0F64             0135   ; - final entry of dispatch table must be a 3-byte zero or bad things will happen
0B0F64             0136   ; returns: NO MATCH: iy=dispatch list terminator a=1 and zero flag reset
0B0F64             0137   ; ON MATCH: iy=dispatch address, a=0 and zero flag set
0B0F64             0138   ; destroys: a, hl, de, ix, iy, flags
0B0F64             0139   match_next:
0B0F64 ED 32 03    0140       lea ix,ix+3 ; point to the next argument
0B0F67             0141   @loop:
0B0F67 FD 27 00    0142       ld hl,(iy) ; pointer argument dispatch record
0B0F6A             0143       sign_hlu ; check for list terminator
0B0F6A 19          0001M          add hl,de
0B0F6B B7          0002M          or a
0B0F6C ED 52       0003M          sbc hl,de
0B0F6E CA 86 0F 0B 0144       jp z,@no_match ; if a=0, return error
0B0F72 23          0145       inc hl ; skip over jp instruction
0B0F73 23          0146       inc hl
0B0F74 DD 17 00    0147       ld de,(ix) ; pointer to the argument string
0B0F77 CD 8C 0F 0B 0148       call str_equal ; compare the argument to the dispatch table entry
0B0F7B CA 88 0F 0B 0149       jp z,@match ; if equal, return success
0B0F7F ED 33 03    0150       lea iy,iy+3 ; if not equal, bump iy to next dispatch table entry
0B0F82 C3 67 0F 0B 0151       jp @loop ; and loop
0B0F86             0152   @no_match:
0B0F86 3C          0153       inc a ; no match so return a=1 and zero flag reset
0B0F87 C9          0154       ret
0B0F88             0155   @match:
0B0F88 FD 37 00    0156       ld iy,(iy) ; get the function pointer
0B0F8B C9          0157       ret ; return a=0 and zero flag set
0B0F8C             0158   
0B0F8C             0159   ; compare two zero-terminated strings for equality, case-sensitive
0B0F8C             0160   ; hl: pointer to first string, de: pointer to second string
0B0F8C             0161   ; returns: z if equal, nz if not equal
0B0F8C             0162   ; destroys: a, hl, de
0B0F8C             0163   str_equal:
0B0F8C 1A          0164       ld a,(de) ; get the first character
0B0F8D BE          0165       cp (hl) ; compare to the second character
0B0F8E C0          0166       ret nz ; if not equal, return
0B0F8F B7          0167       or a
0B0F90 C8          0168       ret z ; if equal and zero, return
0B0F91 23          0169       inc hl ; next character
0B0F92 13          0170       inc de
0B0F93 C3 8C 0F 0B 0171       jp str_equal ; loop until end of string
0B0F97             0172   
0B0F97             0173   ; === BOILERPLATE MOSLET CODE ===
0B0F97             0174   ; Parse the parameter string into a C array
0B0F97             0175   ; Parameters
0B0F97             0176   ; - HL: Address of parameter string
0B0F97             0177   ; - IX: Address for array pointer storage
0B0F97             0178   ; Returns:
0B0F97             0179   ; - C: Number of parameters parsed
0B0F97             0180   ;
0B0F97 01 34 00 0B 0181   _parse_params: LD BC, _exec_name
0B0F9B DD 0F 00    0182       LD (IX+0), BC ; ARGV[0] = the executable name
0B0F9E ED 32 03    0183       LEA IX, IX+3
0B0FA1 CD D9 0F 0B 0184       CALL _skip_spaces ; Skip HL past any leading spaces
0B0FA5             0185   ;
0B0FA5 01 01 00 00 0186       LD BC, 1 ; C: ARGC = 1 - also clears out top 16 bits of BCU
0B0FA9 06 0F       0187       LD B, argv_ptrs_max - 1 ; B: Maximum number of argv_ptrs
0B0FAB             0188   ;
0B0FAB             0189   _parse_params_1:
0B0FAB C5          0190       PUSH BC ; Stack ARGC
0B0FAC E5          0191       PUSH HL ; Stack start address of token
0B0FAD CD CA 0F 0B 0192       CALL _get_token ; Get the next token
0B0FB1 79          0193       LD A, C ; A: Length of the token in characters
0B0FB2 D1          0194       POP DE ; Start address of token (was in HL)
0B0FB3 C1          0195       POP BC ; ARGC
0B0FB4 B7          0196       OR A ; Check for A=0 (no token found) OR at end of string
0B0FB5 C8          0197       RET Z
0B0FB6             0198   ;
0B0FB6 DD 1F 00    0199       LD (IX+0), DE ; Store the pointer to the token
0B0FB9 E5          0200       PUSH HL ; DE=HL
0B0FBA D1          0201       POP DE
0B0FBB CD D9 0F 0B 0202       CALL _skip_spaces ; And skip HL past any spaces onto the next character
0B0FBF AF          0203       XOR A
0B0FC0 12          0204       LD (DE), A ; Zero-terminate the token
0B0FC1 ED 32 03    0205       LEA IX, IX+3 ; Advance to next pointer position
0B0FC4 0C          0206       INC C ; Increment ARGC
0B0FC5 79          0207       LD A, C ; Check for C >= A
0B0FC6 B8          0208       CP B
0B0FC7 38 E2       0209       JR C, _parse_params_1 ; And loop
0B0FC9 C9          0210       RET
0B0FCA             0211   
0B0FCA             0212   ; Get the next token
0B0FCA             0213   ; Parameters:
0B0FCA             0214   ; - HL: Address of parameter string
0B0FCA             0215   ; Returns:
0B0FCA             0216   ; - HL: Address of first character after token
0B0FCA             0217   ; - C: Length of token (in characters)
0B0FCA             0218   ;
0B0FCA 0E 00       0219   _get_token: LD C, 0 ; Initialise length
0B0FCC 7E          0220   @@: LD A, (HL) ; Get the character from the parameter string
0B0FCD B7          0221       OR A ; Exit if 0 (end of parameter string in MOS)
0B0FCE C8          0222       RET Z
0B0FCF FE 0D       0223       CP 13 ; Exit if CR (end of parameter string in BBC BASIC)
0B0FD1 C8          0224       RET Z
0B0FD2 FE 20       0225       CP ' ' ; Exit if space (end of token)
0B0FD4 C8          0226       RET Z
0B0FD5 23          0227       INC HL ; Advance to next character
0B0FD6 0C          0228       INC C ; Increment length
0B0FD7 18 F3       0229       JR @B
0B0FD9             0230   
0B0FD9             0231   ; Skip spaces in the parameter string
0B0FD9             0232   ; Parameters:
0B0FD9             0233   ; - HL: Address of parameter string
0B0FD9             0234   ; Returns:
0B0FD9             0235   ; - HL: Address of next none-space character
0B0FD9             0236   ; F: Z if at end of string, otherwise NZ if there are more tokens to be parsed
0B0FD9             0237   ;
0B0FD9 7E          0238   _skip_spaces: LD A, (HL) ; Get the character from the parameter string
0B0FDA FE 20       0239       CP ' ' ; Exit if not space
0B0FDC C0          0240       RET NZ
0B0FDD 23          0241       INC HL ; Advance to next character
0B0FDE 18 F9       0242       JR _skip_spaces ; Increment length
