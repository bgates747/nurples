PC     Output      Line
040000             0001   ; macro files generally want to go here, before any of the other includes
040000             0002   ; which call the macro, otherwise the assembler won't have the macro
040000             0003   ; available to run when it is called, and will fail with something
040000             0004   ; along the lines of 'invalid label' at such and such a line
040000             0005       include "src/asm/macros.inc"
040000             0001*  
040000             0002*  ; https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
040000             0003*  ; Macro for loading bitmaps to VDP buffers
040000             0004*  	macro LOADBMP n,width,height,file
040000             0005*  	db 23,27,0  ; VDU 23, 27, 0 select bitmap
040000             0006*  	db n      ; specify target bitmap number (8-bits)
040000             0007*  	db 23,27,1  ; load bitmap data
040000             0008*      dw width    ; in pixels
040000             0009*      dw height   ; in pixels
040000             0010*  	incbin file ; path to file containing binary bitmap data
040000             0011*  	endmacro
040000             0012*  
040000             0013*  ; https://discord.com/channels/1158535358624039014/1158536809916149831/1208492884861653145
040000             0014*  	; load an rgba2222 bitmap to a 16-bit bufferId
040000             0015*  	macro LOADBMPBUFFER2 bufferId,width,height,file
040000             0016*  
040000             0017*      ; Clear buffer
040000             0018*      db 23,0,0xA0
040000             0019*      dw bufferId
040000             0020*      db 2
040000             0021*  
040000             0022*      db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040000             0023*      dw bufferId
040000             0024*  
040000             0025*      ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040000             0026*      db 23,0,0xA0
040000             0027*      dw bufferId
040000             0028*      db 0
040000             0029*  	dw width * height ; length of data in bytes
040000             0030*      incbin file ; bitmap data
040000             0031*  
040000             0032*      ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040000             0033*      db 23,27,0x21
040000             0034*      dw width ; in pixels
040000             0035*      dw height ; in pixels
040000             0036*      db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
040000             0037*      endmacro
040000             0038*  
040000             0039*  	; load an rgba8888 bitmap to a 16-bit bufferId
040000             0040*  	macro LOADBMPBUFFER8 bufferId,width,height,file
040000             0041*  
040000             0042*      ; Clear buffer
040000             0043*      db 23,0,0xA0
040000             0044*      dw bufferId
040000             0045*      db 2
040000             0046*  
040000             0047*      db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040000             0048*      dw bufferId
040000             0049*  
040000             0050*      ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040000             0051*      db 23,0,0xA0
040000             0052*      dw bufferId
040000             0053*      db 0
040000             0054*  	dw width * height * 4 ; length of data in bytes
040000             0055*      incbin file ; bitmap data
040000             0056*  
040000             0057*      ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040000             0058*      db 23,27,0x21
040000             0059*      dw width ; in pixels
040000             0060*      dw height ; in pixels
040000             0061*      db 0 ; bitmap format: 0 = RGBA8888 (4-bytes per pixel)
040000             0062*      endmacro
040000             0006   
040000             0007   ;MOS INITIALIATION MUST GO HERE BEFORE ANY OTHER CODE
040000             0008       .assume adl=1
040000             0009       .org 0x040000
040000             0010   
040000 C3 45 00 04 0011       jp start
040004             0012   
040004 FF FF FF FF 0013       .align 64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040040 4D 4F 53    0014       .db "MOS"
040043 00          0015       .db 00h
040044 01          0016       .db 01h
040045             0017   
040045             0018   start:
040045 F5          0019       push af
040046 C5          0020       push bc
040047 D5          0021       push de
040048 DD E5       0022       push ix
04004A FD E5       0023       push iy
04004C             0024   
04004C             0025   ; ###############################################
04004C             0026   ; ez80asmLinker.py loader code goes here if used.
04004C             0027   ; ###############################################
04004C             0028   
04004C             0029   ; ###############################################
04004C CD A9 70 04 0030   	call	init			; Initialization code
040050 CD 34 71 04 0031   	call 	main			; Call the main function
040054             0032   ; ###############################################
040054             0033   
040054             0034   exit:
040054             0035   
040054 FD E1       0036       pop iy                              ; Pop all registers back from the stack
040056 DD E1       0037       pop ix
040058 D1          0038       pop de
040059 C1          0039       pop bc
04005A F1          0040       pop af
04005B 21 00 00 00 0041       ld hl,0                             ; Load the MOS API return code (0) for no errors.
04005F             0042   
04005F C9          0043       ret                                 ; Return MOS
040060             0044   
040060             0045   ; after this we can put includes in any order we wish, even in between
040060             0046   ; code blocks if there is any program-dependent or asethetic reason to do so
040060             0047   	include "src/asm/images2.inc"
040060             0001*  ; Bitmap indices:
040060             0002*  BUF_0TILE_EMPTY: equ $0100
040060             0003*  BUF_1TILE_CROSS: equ $0101
040060             0004*  BUF_2TILE_HORIZ: equ $0102
040060             0005*  BUF_3TILE_VERT: equ $0103
040060             0006*  BUF_4TILE_SQUARE: equ $0104
040060             0007*  BUF_5TILE_CIRCLE: equ $0105
040060             0008*  BUF_6TILE_PAD: equ $0106
040060             0009*  BUF_7TILE_TURRET: equ $0107
040060             0010*  BUF_CIRCLE: equ $0108
040060             0011*  BUF_CRATER: equ $0109
040060             0012*  BUF_EXPLOSION_A: equ $010A
040060             0013*  BUF_EXPLOSION_B: equ $010B
040060             0014*  BUF_EXPLOSION_C: equ $010C
040060             0015*  BUF_EXPLOSION_D: equ $010D
040060             0016*  BUF_EXPLOSION_E: equ $010E
040060             0017*  BUF_FIREBALL_A: equ $010F
040060             0018*  BUF_FIREBALL_B: equ $0110
040060             0019*  BUF_LASER_A: equ $0111
040060             0020*  BUF_LASER_B: equ $0112
040060             0021*  BUF_PAD: equ $0113
040060             0022*  BUF_SEEKER_000: equ $0114
040060             0023*  BUF_SEEKER_001: equ $0115
040060             0024*  BUF_SEEKER_002: equ $0116
040060             0025*  BUF_SEEKER_003: equ $0117
040060             0026*  BUF_SEEKER_004: equ $0118
040060             0027*  BUF_SEEKER_005: equ $0119
040060             0028*  BUF_SEEKER_006: equ $011A
040060             0029*  BUF_SEEKER_007: equ $011B
040060             0030*  BUF_SEEKER_008: equ $011C
040060             0031*  BUF_SEEKER_009: equ $011D
040060             0032*  BUF_SEEKER_010: equ $011E
040060             0033*  BUF_SEEKER_011: equ $011F
040060             0034*  BUF_SEEKER_012: equ $0120
040060             0035*  BUF_SEEKER_013: equ $0121
040060             0036*  BUF_SEEKER_014: equ $0122
040060             0037*  BUF_SEEKER_015: equ $0123
040060             0038*  BUF_SEEKER_016: equ $0124
040060             0039*  BUF_SEEKER_017: equ $0125
040060             0040*  BUF_SEEKER_018: equ $0126
040060             0041*  BUF_SEEKER_019: equ $0127
040060             0042*  BUF_SEEKER_020: equ $0128
040060             0043*  BUF_SEEKER_021: equ $0129
040060             0044*  BUF_SEEKER_022: equ $012A
040060             0045*  BUF_SEEKER_023: equ $012B
040060             0046*  BUF_SEEKER_024: equ $012C
040060             0047*  BUF_SEEKER_025: equ $012D
040060             0048*  BUF_SEEKER_026: equ $012E
040060             0049*  BUF_SEEKER_027: equ $012F
040060             0050*  BUF_SEEKER_028: equ $0130
040060             0051*  BUF_SEEKER_029: equ $0131
040060             0052*  BUF_SEEKER_030: equ $0132
040060             0053*  BUF_SEEKER_031: equ $0133
040060             0054*  BUF_SHIP_0L: equ $0134
040060             0055*  BUF_SHIP_1C: equ $0135
040060             0056*  BUF_SHIP_2R: equ $0136
040060             0057*  BUF_SHIP_SMALL: equ $0137
040060             0058*  BUF_STAR: equ $0138
040060             0059*  BUF_TURRET: equ $0139
040060             0060*  BUF_TURRET_ROT: equ $013A
040060             0061*  
040060             0062*  ; import .rgba bitmap files and load them into VDP buffers
040060             0063*  bmp2_init:
040060 21 6B 00 04 0064*  	ld hl, @cmd
040064 01 76 3C 00 0065*  	ld bc, @end-@cmd
040068 5B DF       0066*  	rst.lil $18
04006A C9          0067*  	ret
04006B             0068*  @cmd:
04006B             0069*  	LOADBMPBUFFER2 BUF_0TILE_EMPTY,16,16,"src/rgba2/0tile_empty.rgba2"
04006B             0001*M 
04006B             0002*M     ; Clear buffer
04006B 17 00 A0    0003*M     db 23,0,0xA0
04006E 00 01       0004*M     dw bufferId
040070 02          0005*M     db 2
040071             0006*M 
040071 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040074 00 01       0008*M     dw bufferId
040076             0009*M 
040076             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040076 17 00 A0    0011*M     db 23,0,0xA0
040079 00 01       0012*M     dw bufferId
04007B 00          0013*M     db 0
04007C 00 01       0014*M 	dw width * height ; length of data in bytes
04007E 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04017E             0016*M 
04017E             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
04017E 17 1B 21    0018*M     db 23,27,0x21
040181 10 00       0019*M     dw width ; in pixels
040183 10 00       0020*M     dw height ; in pixels
040185 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
040186             0070*  	LOADBMPBUFFER2 BUF_1TILE_CROSS,16,16,"src/rgba2/1tile_cross.rgba2"
040186             0001*M 
040186             0002*M     ; Clear buffer
040186 17 00 A0    0003*M     db 23,0,0xA0
040189 01 01       0004*M     dw bufferId
04018B 02          0005*M     db 2
04018C             0006*M 
04018C 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
04018F 01 01       0008*M     dw bufferId
040191             0009*M 
040191             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040191 17 00 A0    0011*M     db 23,0,0xA0
040194 01 01       0012*M     dw bufferId
040196 00          0013*M     db 0
040197 00 01       0014*M 	dw width * height ; length of data in bytes
040199 00 00 D0 F5 0015*M     incbin file ; bitmap data
       FA FF FF FF 
       FF FF FF EA 
       F5 D0 00 00 
       00 00 D0 F5 
       FA EA FF FF 
       FF FF EA EA 
       F5 D0 00 00 
       D0 D0 D0 F5 
       FA FF FF FF 
       FF FF EA EA 
       F5 D0 D0 D0 
       F5 F5 F5 F5 
       FB FA EA EA 
       EA EA EA E5 
       F5 F5 F5 F5 
       D1 E5 E5 D0 
       FA FB E5 FA 
       FA FA FA FA 
       C0 D0 D0 D0 
       E1 E1 D0 D0 
       FA D1 D0 D1 
       D0 D0 D0 EA 
       D1 D1 D1 D1 
       FA FF E5 E5 
       E5 D0 F8 FD 
       FE F8 D0 E5 
       D1 E5 E5 E5 
       FA FF FA E5 
       E5 D0 F8 FD 
       FE F8 D0 FA 
       E5 E5 E5 E5 
       E5 FB FA E5 
       E5 D0 F8 FD 
       FE F8 E1 FA 
       E5 E5 E5 E5 
       FA FA FA E5 
       E5 D0 F8 FD 
       FD F8 D0 FA 
       E5 E5 E5 E5 
       E5 E5 E5 E5 
       E5 D0 F8 F8 
       F8 F8 D0 FA 
       D1 D1 D1 D1 
       E1 E1 E1 E1 
       D1 D0 D0 D0 
       D0 D0 D0 E5 
       D0 D1 D0 D0 
       F5 F5 F5 F5 
       E5 D1 E1 E5 
       E5 E5 E5 E5 
       F5 F5 F5 F5 
       D0 D0 D0 F5 
       E5 E5 E5 E5 
       E6 E5 E5 E5 
       F5 D0 D0 D0 
       00 00 D0 F5 
       E5 E6 D6 E6 
       D7 E6 E6 E5 
       F5 D0 00 00 
       00 00 D0 F5 
       E5 E6 E6 D6 
       D6 D6 E6 E5 
       F5 D0 00 00 
040299             0016*M 
040299             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040299 17 1B 21    0018*M     db 23,27,0x21
04029C 10 00       0019*M     dw width ; in pixels
04029E 10 00       0020*M     dw height ; in pixels
0402A0 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0402A1             0071*  	LOADBMPBUFFER2 BUF_2TILE_HORIZ,16,16,"src/rgba2/2tile_horiz.rgba2"
0402A1             0001*M 
0402A1             0002*M     ; Clear buffer
0402A1 17 00 A0    0003*M     db 23,0,0xA0
0402A4 02 01       0004*M     dw bufferId
0402A6 02          0005*M     db 2
0402A7             0006*M 
0402A7 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0402AA 02 01       0008*M     dw bufferId
0402AC             0009*M 
0402AC             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0402AC 17 00 A0    0011*M     db 23,0,0xA0
0402AF 02 01       0012*M     dw bufferId
0402B1 00          0013*M     db 0
0402B2 00 01       0014*M 	dw width * height ; length of data in bytes
0402B4 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       D0 D0 D0 D0 
       D0 D0 D0 D0 
       D0 D0 D0 D0 
       D0 D0 D0 D0 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       EA EA EA EA 
       EA EA EA EA 
       EA EA EA EA 
       EA EA EA EA 
       EA EA FF F8 
       F8 F8 F8 EA 
       EA EA EA EA 
       EA EA EA EA 
       EA EA EA EA 
       EA EA EA EA 
       EA EA FF FF 
       EA EA FA FA 
       F8 F8 EA EA 
       EA EA EA EA 
       EA EA EA EA 
       EA EA FA E5 
       F8 F8 EA EA 
       D0 E6 E6 D1 
       D1 D1 D1 EA 
       EA F8 F5 F5 
       EA F8 EA D0 
       C0 D1 D1 D1 
       D1 D2 D1 D0 
       D0 EA F5 E5 
       EA EA F8 E5 
       E5 E6 E6 E6 
       E6 E6 D1 F8 
       E5 EA E5 E5 
       EA E5 D1 D1 
       D1 D1 D1 D1 
       D1 D1 C0 D1 
       EA D1 EA D0 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       D0 D0 D0 D0 
       D0 D0 D0 D0 
       D0 D0 D0 D0 
       D0 D0 D0 D0 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0403B4             0016*M 
0403B4             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0403B4 17 1B 21    0018*M     db 23,27,0x21
0403B7 10 00       0019*M     dw width ; in pixels
0403B9 10 00       0020*M     dw height ; in pixels
0403BB 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0403BC             0072*  	LOADBMPBUFFER2 BUF_3TILE_VERT,16,16,"src/rgba2/3tile_vert.rgba2"
0403BC             0001*M 
0403BC             0002*M     ; Clear buffer
0403BC 17 00 A0    0003*M     db 23,0,0xA0
0403BF 03 01       0004*M     dw bufferId
0403C1 02          0005*M     db 2
0403C2             0006*M 
0403C2 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0403C5 03 01       0008*M     dw bufferId
0403C7             0009*M 
0403C7             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0403C7 17 00 A0    0011*M     db 23,0,0xA0
0403CA 03 01       0012*M     dw bufferId
0403CC 00          0013*M     db 0
0403CD 00 01       0014*M 	dw width * height ; length of data in bytes
0403CF 00 00 D0 F5 0015*M     incbin file ; bitmap data
       D0 D0 D0 D0 
       E5 E5 EA EA 
       F5 D0 00 00 
       00 00 D0 F5 
       D0 E5 E5 E5 
       E5 F8 EA EA 
       F5 D0 00 00 
       00 00 D0 F5 
       D0 D0 E5 E5 
       FA F8 FD F8 
       F5 D0 00 00 
       00 00 D0 F5 
       D0 D0 E1 E5 
       E5 E5 FA F8 
       F5 D0 00 00 
       00 00 D0 F5 
       D0 D0 D0 D1 
       E6 E6 FA EA 
       F5 D0 00 00 
       00 00 D0 F5 
       C0 D1 D1 D1 
       FB EA FB D1 
       F5 D0 00 00 
       00 00 D0 F5 
       C0 D0 EA C0 
       EA EA EA EA 
       F5 D0 00 00 
       00 00 D0 F5 
       D0 E5 EA EA 
       EA FF EA FF 
       F5 D0 00 00 
       00 00 D0 F5 
       D0 E1 EA EA 
       EA FF EA FF 
       F5 D0 00 00 
       00 00 D0 F5 
       C0 D0 C0 EA 
       EA EA EA FF 
       F5 D0 00 00 
       00 00 D0 F5 
       D0 E5 EA EA 
       EA EA EA FF 
       F5 D0 00 00 
       00 00 D0 F5 
       D0 E5 EA EA 
       EA EA EA EA 
       F5 D0 00 00 
       00 00 D0 F5 
       D0 E5 EA EA 
       EA EA EA EA 
       F5 D0 00 00 
       00 00 D0 F5 
       D0 E5 F8 F8 
       FA EA EA EA 
       F5 D0 00 00 
       00 00 D0 F5 
       EA EA F8 F8 
       EA EA EA EA 
       F5 D0 00 00 
       00 00 D0 F5 
       C0 E5 F8 F8 
       EA EA EA EA 
       F5 D0 00 00 
0404CF             0016*M 
0404CF             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0404CF 17 1B 21    0018*M     db 23,27,0x21
0404D2 10 00       0019*M     dw width ; in pixels
0404D4 10 00       0020*M     dw height ; in pixels
0404D6 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0404D7             0073*  	LOADBMPBUFFER2 BUF_4TILE_SQUARE,16,16,"src/rgba2/4tile_square.rgba2"
0404D7             0001*M 
0404D7             0002*M     ; Clear buffer
0404D7 17 00 A0    0003*M     db 23,0,0xA0
0404DA 04 01       0004*M     dw bufferId
0404DC 02          0005*M     db 2
0404DD             0006*M 
0404DD 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0404E0 04 01       0008*M     dw bufferId
0404E2             0009*M 
0404E2             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0404E2 17 00 A0    0011*M     db 23,0,0xA0
0404E5 04 01       0012*M     dw bufferId
0404E7 00          0013*M     db 0
0404E8 00 01       0014*M 	dw width * height ; length of data in bytes
0404EA D0 D1 E5 D1 0015*M     incbin file ; bitmap data
       E5 E5 D0 D5 
       D0 D0 D0 D0 
       D0 D5 D0 D1 
       D5 EA EA EA 
       EA E5 E5 E5 
       E5 E5 E5 D5 
       D1 FF E9 D5 
       D0 EA EA D5 
       D5 D5 D1 D5 
       D4 D4 FE FE 
       D1 EA E5 D5 
       D0 C0 D1 D1 
       D2 D2 E6 E9 
       FE FE FE FE 
       C0 C0 C0 D1 
       D0 D1 D1 D2 
       D2 D2 E6 D4 
       E9 E9 FE FE 
       D1 D0 D0 D0 
       D0 D1 D2 D2 
       D2 D2 D5 C0 
       D1 D1 D4 E9 
       D1 C0 E5 D0 
       D0 D1 C0 D5 
       D5 D5 E6 E6 
       E6 E6 D1 E5 
       E5 C0 E5 E5 
       D0 D1 D1 E9 
       FE D5 D1 D2 
       D2 D1 D1 E9 
       E9 C0 D1 D0 
       E5 D1 C0 D0 
       E5 D0 D1 D2 
       D2 D1 D1 E5 
       E5 C0 EA D0 
       E5 E5 C0 C0 
       D5 C1 D5 D1 
       D1 C1 D1 D0 
       D4 D5 EA D0 
       E5 E5 D5 D2 
       D2 D2 D0 D0 
       D5 D5 D5 E9 
       E9 C0 EA E5 
       E5 E5 D5 D2 
       D2 D2 EA E9 
       FA FA D4 E6 
       E5 D5 E5 D1 
       D0 EA D5 D2 
       D1 C1 D5 E5 
       E9 E9 D0 E5 
       D0 E5 E5 E5 
       D0 D4 E9 D4 
       C0 C0 D5 C0 
       D0 D0 C0 D0 
       D0 EA EA D0 
       D0 D4 D4 D5 
       C0 D0 D5 C0 
       C0 C0 D0 C0 
       D0 D0 D0 D0 
       D0 D0 D0 C0 
       C0 D0 D0 D0 
       D5 D0 D0 C0 
       D0 D5 D0 D0 
0405EA             0016*M 
0405EA             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0405EA 17 1B 21    0018*M     db 23,27,0x21
0405ED 10 00       0019*M     dw width ; in pixels
0405EF 10 00       0020*M     dw height ; in pixels
0405F1 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0405F2             0074*  	LOADBMPBUFFER2 BUF_5TILE_CIRCLE,16,16,"src/rgba2/5tile_circle.rgba2"
0405F2             0001*M 
0405F2             0002*M     ; Clear buffer
0405F2 17 00 A0    0003*M     db 23,0,0xA0
0405F5 05 01       0004*M     dw bufferId
0405F7 02          0005*M     db 2
0405F8             0006*M 
0405F8 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0405FB 05 01       0008*M     dw bufferId
0405FD             0009*M 
0405FD             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0405FD 17 00 A0    0011*M     db 23,0,0xA0
040600 05 01       0012*M     dw bufferId
040602 00          0013*M     db 0
040603 00 01       0014*M 	dw width * height ; length of data in bytes
040605 00 00 00 00 0015*M     incbin file ; bitmap data
       00 D0 D0 D0 
       D0 D0 D0 00 
       00 00 00 00 
       00 00 00 D0 
       D0 D0 D0 D1 
       EA D1 D1 D0 
       D0 00 00 00 
       00 00 D0 D0 
       D0 D1 D1 EA 
       FB EA D1 D1 
       D0 D0 00 00 
       00 D0 D0 D1 
       D1 D0 D0 D1 
       D1 EA D1 E5 
       EA D0 D0 00 
       00 D0 E1 D1 
       D0 D0 CA EA 
       EA D7 EA E6 
       D1 D1 D0 00 
       D0 D1 E1 FA 
       D1 CA EF FF 
       FF EF D7 D0 
       D1 D1 D1 D0 
       D0 D0 D0 E5 
       FB EA EF FF 
       FF EF EA D0 
       E5 D0 D0 D0 
       D0 E1 D0 EA 
       EA EF EF EF 
       EF EF EA E5 
       EA D0 D0 D0 
       D0 D0 D0 D1 
       EA F8 EA EA 
       EA EA F8 D0 
       EA D0 D1 D0 
       D0 D0 D1 D1 
       E5 EA F8 F8 
       F8 F8 E5 E1 
       D0 D0 D0 D0 
       D0 D0 D0 D0 
       D1 E5 E5 E1 
       E1 E1 E1 D0 
       D0 D1 D0 D0 
       00 D0 D0 D0 
       D0 D0 C0 D0 
       D0 C0 D0 D0 
       D0 C0 D0 00 
       00 D0 D0 D0 
       C0 C0 EA E6 
       E6 D1 C0 C0 
       D0 D0 D0 00 
       00 00 D0 D0 
       C0 D1 D1 D1 
       D1 D1 D1 D0 
       D0 D0 00 00 
       00 00 00 D0 
       D0 D1 D1 D1 
       D1 D1 D1 D0 
       D0 00 00 00 
       00 00 00 00 
       00 D0 D0 D0 
       D0 D0 D0 00 
       00 00 00 00 
040705             0016*M 
040705             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040705 17 1B 21    0018*M     db 23,27,0x21
040708 10 00       0019*M     dw width ; in pixels
04070A 10 00       0020*M     dw height ; in pixels
04070C 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
04070D             0075*  	LOADBMPBUFFER2 BUF_6TILE_PAD,16,16,"src/rgba2/6tile_pad.rgba2"
04070D             0001*M 
04070D             0002*M     ; Clear buffer
04070D 17 00 A0    0003*M     db 23,0,0xA0
040710 06 01       0004*M     dw bufferId
040712 02          0005*M     db 2
040713             0006*M 
040713 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040716 06 01       0008*M     dw bufferId
040718             0009*M 
040718             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040718 17 00 A0    0011*M     db 23,0,0xA0
04071B 06 01       0012*M     dw bufferId
04071D 00          0013*M     db 0
04071E 00 01       0014*M 	dw width * height ; length of data in bytes
040720 00 00 00 00 0015*M     incbin file ; bitmap data
       00 D0 D0 DF 
       DF D0 D0 00 
       00 00 00 00 
       00 C3 C3 D0 
       D0 F5 F5 DF 
       DF F5 F5 D0 
       D0 C3 C3 00 
       00 C3 C3 D0 
       F5 F5 D0 D0 
       D0 D0 F5 F5 
       D0 C3 C3 00 
       00 D0 D0 F5 
       FA FA D0 DF 
       DF D0 FA FA 
       F5 D0 D0 00 
       00 D0 F5 FA 
       D9 D9 D0 D0 
       D0 D0 D9 D9 
       FA F5 D0 00 
       D0 F5 F5 FA 
       D9 D9 D0 DF 
       DF D0 D9 D9 
       FA F5 F5 D0 
       D0 F5 D0 D0 
       D0 D0 D0 DF 
       DF D0 D0 D0 
       D0 D0 F5 D0 
       DF DF D0 DF 
       D0 DF DF D0 
       D0 DF DF D0 
       DF D0 DF DF 
       DF DF D0 DF 
       D0 DF DF D0 
       D0 DF DF D0 
       DF D0 DF DF 
       D0 F5 D0 D0 
       D0 D0 D0 DF 
       DF D0 D0 D0 
       D0 D0 F5 D0 
       D0 F5 F5 FA 
       D9 D9 D0 DF 
       DF D0 D9 D9 
       FA F5 F5 D0 
       00 D0 F5 FA 
       D9 D9 D0 D0 
       D0 D0 D9 D9 
       FA F5 D0 00 
       00 D0 D0 F5 
       FA FA D0 DF 
       DF D0 FA FA 
       F5 D0 D0 00 
       00 C3 C3 D0 
       F5 F5 D0 D0 
       D0 D0 F5 F5 
       D0 C3 C3 00 
       00 C3 C3 D0 
       D0 F5 F5 DF 
       DF F5 F5 D0 
       D0 C3 C3 00 
       00 00 00 00 
       00 D0 D0 DF 
       DF D0 D0 00 
       00 00 00 00 
040820             0016*M 
040820             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040820 17 1B 21    0018*M     db 23,27,0x21
040823 10 00       0019*M     dw width ; in pixels
040825 10 00       0020*M     dw height ; in pixels
040827 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
040828             0076*  	LOADBMPBUFFER2 BUF_7TILE_TURRET,16,16,"src/rgba2/7tile_turret.rgba2"
040828             0001*M 
040828             0002*M     ; Clear buffer
040828 17 00 A0    0003*M     db 23,0,0xA0
04082B 07 01       0004*M     dw bufferId
04082D 02          0005*M     db 2
04082E             0006*M 
04082E 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040831 07 01       0008*M     dw bufferId
040833             0009*M 
040833             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040833 17 00 A0    0011*M     db 23,0,0xA0
040836 07 01       0012*M     dw bufferId
040838 00          0013*M     db 0
040839 00 01       0014*M 	dw width * height ; length of data in bytes
04083B 00 00 00 00 0015*M     incbin file ; bitmap data
       00 D0 D0 DF 
       DF D0 D0 00 
       00 00 00 00 
       00 00 00 D0 
       D0 F5 F5 DF 
       DF F5 F5 D0 
       D0 00 00 00 
       00 00 D0 F5 
       F5 F5 C3 C3 
       C3 C3 F5 F5 
       F5 D0 00 00 
       00 D0 F5 F5 
       F5 F5 D0 DF 
       DF D0 F5 F5 
       F5 F5 D0 00 
       00 D0 F5 F5 
       F5 C3 C3 C3 
       C3 C3 C3 F5 
       F5 F5 D0 00 
       D0 F5 F5 F5 
       F5 F5 D0 DF 
       DF D0 F5 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 F5 D0 DF 
       DF D0 F5 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       C3 C3 C3 C3 
       C3 C3 C3 C3 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 D0 D0 DF 
       DF D0 D0 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 D0 C3 DF 
       DF C3 D0 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 D0 C3 DF 
       DF C3 D0 F5 
       F5 F5 F5 D0 
       00 D0 F5 F5 
       F5 D0 D0 E5 
       E5 D0 D0 F5 
       F5 F5 D0 00 
       00 D0 F5 F5 
       D0 D0 E5 FA 
       FA E5 D0 D0 
       F5 F5 D0 00 
       00 00 D0 F5 
       D0 E5 FA FA 
       FA FA E5 D0 
       F5 D0 00 00 
       00 00 00 D0 
       D0 D0 E5 FA 
       FA E5 D0 D0 
       D0 00 00 00 
       00 00 00 00 
       00 D0 D0 D0 
       D0 D0 D0 00 
       00 00 00 00 
04093B             0016*M 
04093B             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
04093B 17 1B 21    0018*M     db 23,27,0x21
04093E 10 00       0019*M     dw width ; in pixels
040940 10 00       0020*M     dw height ; in pixels
040942 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
040943             0077*  	LOADBMPBUFFER2 BUF_CIRCLE,16,16,"src/rgba2/circle.rgba2"
040943             0001*M 
040943             0002*M     ; Clear buffer
040943 17 00 A0    0003*M     db 23,0,0xA0
040946 08 01       0004*M     dw bufferId
040948 02          0005*M     db 2
040949             0006*M 
040949 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
04094C 08 01       0008*M     dw bufferId
04094E             0009*M 
04094E             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
04094E 17 00 A0    0011*M     db 23,0,0xA0
040951 08 01       0012*M     dw bufferId
040953 00          0013*M     db 0
040954 00 01       0014*M 	dw width * height ; length of data in bytes
040956 00 00 00 00 0015*M     incbin file ; bitmap data
       00 D0 D0 D0 
       D0 D0 D0 00 
       00 00 00 00 
       00 00 00 D0 
       D0 F5 F5 F5 
       F5 F5 F5 D0 
       D0 00 00 00 
       00 00 D0 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 D0 00 00 
       00 D0 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 D0 00 
       00 D0 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 D0 00 
       D0 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 D0 
       00 D0 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 D0 00 
       00 D0 F5 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 F5 D0 00 
       00 00 D0 F5 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 D0 00 00 
       00 00 00 D0 
       D0 F5 F5 F5 
       F5 F5 F5 D0 
       D0 00 00 00 
       00 00 00 00 
       00 D0 D0 D0 
       D0 D0 D0 00 
       00 00 00 00 
040A56             0016*M 
040A56             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040A56 17 1B 21    0018*M     db 23,27,0x21
040A59 10 00       0019*M     dw width ; in pixels
040A5B 10 00       0020*M     dw height ; in pixels
040A5D 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
040A5E             0078*  	LOADBMPBUFFER2 BUF_CRATER,16,16,"src/rgba2/crater.rgba2"
040A5E             0001*M 
040A5E             0002*M     ; Clear buffer
040A5E 17 00 A0    0003*M     db 23,0,0xA0
040A61 09 01       0004*M     dw bufferId
040A63 02          0005*M     db 2
040A64             0006*M 
040A64 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040A67 09 01       0008*M     dw bufferId
040A69             0009*M 
040A69             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040A69 17 00 A0    0011*M     db 23,0,0xA0
040A6C 09 01       0012*M     dw bufferId
040A6E 00          0013*M     db 0
040A6F 00 01       0014*M 	dw width * height ; length of data in bytes
040A71 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 E2 C0 F2 
       C0 D1 E2 00 
       00 00 00 00 
       00 00 D2 D5 
       C0 D2 C0 C6 
       D1 C6 D1 C1 
       C0 E2 00 00 
       00 F2 EA D5 
       DF C0 D1 D2 
       DF D2 D1 C1 
       C0 EA C0 00 
       00 F2 D5 C0 
       C0 C0 CB D1 
       D6 DF D5 C0 
       C0 C0 D5 00 
       F2 D5 C0 C6 
       C0 CB D1 D6 
       D6 D7 D6 C0 
       D5 C1 C0 C0 
       D5 C0 C0 D5 
       C1 D1 C1 D6 
       C2 D7 C2 C1 
       C0 CB C1 C1 
       C1 C6 C0 C1 
       DF C2 D6 D7 
       D7 DB D6 CB 
       C1 D6 D6 D5 
       C0 C0 C0 D5 
       F7 D6 D7 DB 
       EB EF D7 D6 
       D6 CB C1 C1 
       C1 D6 C0 C1 
       D6 EB EB FF 
       CB FF FF EB 
       D6 C1 C1 D5 
       EA D5 C0 DF 
       C2 EA EA FF 
       FF FF EA C0 
       D6 D2 D5 C0 
       00 FA C2 D5 
       D5 C1 C0 CB 
       EA C0 D6 C1 
       C1 D5 E2 00 
       00 F2 FA C1 
       D5 D6 D5 C2 
       C0 D2 D2 D5 
       D6 C1 D5 00 
       00 00 FA F2 
       EB D6 C0 C0 
       C1 D5 D6 D6 
       EA D5 00 00 
       00 00 00 00 
       00 FA F6 F2 
       FA F6 F6 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040B71             0016*M 
040B71             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040B71 17 1B 21    0018*M     db 23,27,0x21
040B74 10 00       0019*M     dw width ; in pixels
040B76 10 00       0020*M     dw height ; in pixels
040B78 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
040B79             0079*  	LOADBMPBUFFER2 BUF_EXPLOSION_A,16,16,"src/rgba2/explosion_a.rgba2"
040B79             0001*M 
040B79             0002*M     ; Clear buffer
040B79 17 00 A0    0003*M     db 23,0,0xA0
040B7C 0A 01       0004*M     dw bufferId
040B7E 02          0005*M     db 2
040B7F             0006*M 
040B7F 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040B82 0A 01       0008*M     dw bufferId
040B84             0009*M 
040B84             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040B84 17 00 A0    0011*M     db 23,0,0xA0
040B87 0A 01       0012*M     dw bufferId
040B89 00          0013*M     db 0
040B8A 00 01       0014*M 	dw width * height ; length of data in bytes
040B8C 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 C7 
       C7 C7 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 C7 C7 
       EF C7 C7 00 
       00 00 00 00 
       00 00 00 00 
       00 00 C7 EF 
       EF EF C7 00 
       00 00 00 00 
       00 00 00 C7 
       C7 00 C7 C7 
       EF C7 C7 00 
       00 00 00 00 
       00 00 00 C7 
       C7 00 00 C7 
       C7 C7 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040C8C             0016*M 
040C8C             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040C8C 17 1B 21    0018*M     db 23,27,0x21
040C8F 10 00       0019*M     dw width ; in pixels
040C91 10 00       0020*M     dw height ; in pixels
040C93 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
040C94             0080*  	LOADBMPBUFFER2 BUF_EXPLOSION_B,16,16,"src/rgba2/explosion_b.rgba2"
040C94             0001*M 
040C94             0002*M     ; Clear buffer
040C94 17 00 A0    0003*M     db 23,0,0xA0
040C97 0B 01       0004*M     dw bufferId
040C99 02          0005*M     db 2
040C9A             0006*M 
040C9A 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040C9D 0B 01       0008*M     dw bufferId
040C9F             0009*M 
040C9F             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040C9F 17 00 A0    0011*M     db 23,0,0xA0
040CA2 0B 01       0012*M     dw bufferId
040CA4 00          0013*M     db 0
040CA5 00 01       0014*M 	dw width * height ; length of data in bytes
040CA7 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 C7 C7 00 
       00 00 00 00 
       00 00 00 C7 
       C7 C7 00 00 
       00 C7 C7 00 
       00 00 00 00 
       00 C7 C7 EF 
       EF EF C7 C7 
       00 00 00 00 
       00 00 00 00 
       00 C7 EF EF 
       EF EF EF C7 
       00 00 00 00 
       00 00 00 00 
       C7 EF EF EF 
       EF EF EF EF 
       C7 00 00 00 
       00 00 00 C7 
       C7 EF EF EF 
       EF EF EF EF 
       C7 00 00 00 
       00 00 C7 C7 
       C7 C7 EF EF 
       EF EF EF EF 
       C7 00 00 00 
       00 00 C7 C7 
       C7 C7 EF EF 
       EF EF EF C7 
       00 00 00 00 
       00 00 00 C7 
       C7 C7 C7 EF 
       EF EF C7 C7 
       00 00 00 00 
       00 00 00 00 
       00 00 00 C7 
       C7 C7 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040DA7             0016*M 
040DA7             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040DA7 17 1B 21    0018*M     db 23,27,0x21
040DAA 10 00       0019*M     dw width ; in pixels
040DAC 10 00       0020*M     dw height ; in pixels
040DAE 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
040DAF             0081*  	LOADBMPBUFFER2 BUF_EXPLOSION_C,16,16,"src/rgba2/explosion_c.rgba2"
040DAF             0001*M 
040DAF             0002*M     ; Clear buffer
040DAF 17 00 A0    0003*M     db 23,0,0xA0
040DB2 0C 01       0004*M     dw bufferId
040DB4 02          0005*M     db 2
040DB5             0006*M 
040DB5 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040DB8 0C 01       0008*M     dw bufferId
040DBA             0009*M 
040DBA             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040DBA 17 00 A0    0011*M     db 23,0,0xA0
040DBD 0C 01       0012*M     dw bufferId
040DBF 00          0013*M     db 0
040DC0 00 01       0014*M 	dw width * height ; length of data in bytes
040DC2 00 C7 00 00 0015*M     incbin file ; bitmap data
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       C6 C6 00 00 
       00 00 00 00 
       00 00 C7 C7 
       C7 C7 00 C6 
       C7 C7 C6 00 
       00 00 00 00 
       C7 C7 EF EF 
       EF EF C7 C6 
       C7 C7 C6 00 
       00 00 00 C7 
       EF EF EF EF 
       EF EF EF EF 
       C6 C6 00 00 
       00 00 00 C7 
       EF EF EF EF 
       EF EF EF EF 
       C7 00 00 00 
       00 00 C7 EF 
       EF EF EF EF 
       EF EF EF EF 
       EF C7 00 00 
       00 C6 C6 C6 
       C6 EF EF EF 
       EF EF EF EF 
       EF C7 00 00 
       C6 C6 C7 C7 
       C6 C6 EF EF 
       EF EF EF EF 
       EF C7 00 00 
       C6 C7 C7 EF 
       C7 C6 EF EF 
       EF EF EF EF 
       EF C7 00 00 
       C6 C7 00 C7 
       C7 C6 EF EF 
       EF EF EF EF 
       C7 00 00 00 
       C6 C6 C7 C7 
       C6 C6 EF EF 
       EF EF EF EF 
       C7 00 00 00 
       00 C6 C6 C6 
       C6 C7 EF EF 
       EF EF C7 C7 
       00 00 00 00 
       00 00 00 00 
       00 00 C7 C7 
       C7 C7 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040EC2             0016*M 
040EC2             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040EC2 17 1B 21    0018*M     db 23,27,0x21
040EC5 10 00       0019*M     dw width ; in pixels
040EC7 10 00       0020*M     dw height ; in pixels
040EC9 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
040ECA             0082*  	LOADBMPBUFFER2 BUF_EXPLOSION_D,16,16,"src/rgba2/explosion_d.rgba2"
040ECA             0001*M 
040ECA             0002*M     ; Clear buffer
040ECA 17 00 A0    0003*M     db 23,0,0xA0
040ECD 0D 01       0004*M     dw bufferId
040ECF 02          0005*M     db 2
040ED0             0006*M 
040ED0 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040ED3 0D 01       0008*M     dw bufferId
040ED5             0009*M 
040ED5             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040ED5 17 00 A0    0011*M     db 23,0,0xA0
040ED8 0D 01       0012*M     dw bufferId
040EDA 00          0013*M     db 0
040EDB 00 01       0014*M 	dw width * height ; length of data in bytes
040EDD 00 C7 C7 00 0015*M     incbin file ; bitmap data
       00 00 00 00 
       00 00 00 00 
       00 C6 00 00 
       00 C7 C7 00 
       00 00 C6 C6 
       C6 C6 00 C6 
       00 00 00 00 
       00 00 00 00 
       C6 C6 C7 C7 
       C7 C7 C6 C6 
       C6 C6 00 00 
       00 00 00 C6 
       C7 C7 EF EF 
       EF EF EF EF 
       C6 C6 00 C6 
       00 00 C6 C7 
       EF EF EF EF 
       EF EF EF C6 
       C7 C6 00 00 
       00 00 C6 C7 
       EF EF EF 00 
       00 EF EF EF 
       C7 C6 C6 00 
       00 C6 C7 EF 
       EF EF 00 00 
       00 00 EF EF 
       EF C7 C6 00 
       00 C6 C7 EF 
       EF 00 00 00 
       00 00 00 EF 
       EF C7 C6 00 
       00 C7 C7 C7 
       C7 00 00 00 
       00 00 00 EF 
       EF C7 C6 00 
       C7 C6 C7 EF 
       EF C7 00 00 
       00 00 EF EF 
       EF C7 C6 00 
       C6 00 C6 C7 
       EF C7 EF 00 
       00 EF EF EF 
       C7 C6 00 00 
       C6 00 C6 C7 
       EF EF EF EF 
       EF EF EF EF 
       C7 C6 00 00 
       C6 00 00 C6 
       C7 C7 EF EF 
       EF EF C7 C7 
       C6 00 00 00 
       00 C6 C6 C6 
       C7 C6 C7 C7 
       C7 C7 C6 C6 
       00 00 00 00 
       00 00 00 00 
       00 00 C6 C6 
       C6 C6 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040FDD             0016*M 
040FDD             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
040FDD 17 1B 21    0018*M     db 23,27,0x21
040FE0 10 00       0019*M     dw width ; in pixels
040FE2 10 00       0020*M     dw height ; in pixels
040FE4 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
040FE5             0083*  	LOADBMPBUFFER2 BUF_EXPLOSION_E,16,16,"src/rgba2/explosion_e.rgba2"
040FE5             0001*M 
040FE5             0002*M     ; Clear buffer
040FE5 17 00 A0    0003*M     db 23,0,0xA0
040FE8 0E 01       0004*M     dw bufferId
040FEA 02          0005*M     db 2
040FEB             0006*M 
040FEB 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
040FEE 0E 01       0008*M     dw bufferId
040FF0             0009*M 
040FF0             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040FF0 17 00 A0    0011*M     db 23,0,0xA0
040FF3 0E 01       0012*M     dw bufferId
040FF5 00          0013*M     db 0
040FF6 00 01       0014*M 	dw width * height ; length of data in bytes
040FF8 00 00 00 C6 0015*M     incbin file ; bitmap data
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 C6 00 00 
       C6 00 C6 C6 
       C6 C6 00 00 
       00 00 00 00 
       00 C6 00 00 
       C6 C6 C7 C7 
       C7 C7 C7 C6 
       00 00 00 00 
       00 00 C6 C6 
       C7 C7 00 00 
       00 00 00 00 
       C7 00 00 00 
       00 00 C6 C7 
       00 00 00 00 
       00 00 00 00 
       00 C6 00 00 
       00 00 C6 C7 
       00 00 00 00 
       00 00 00 00 
       00 C6 00 00 
       00 C6 C7 00 
       00 00 00 00 
       00 00 00 00 
       00 00 C6 00 
       00 C6 C7 00 
       00 00 00 00 
       00 00 00 00 
       00 00 C7 00 
       00 C6 C7 00 
       00 00 00 00 
       00 00 00 00 
       00 00 C7 00 
       00 C6 C7 00 
       00 00 00 00 
       00 00 00 00 
       00 00 C7 00 
       00 00 C6 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 C6 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 C7 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       C6 C6 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 C7 C7 
       C7 C7 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0410F8             0016*M 
0410F8             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0410F8 17 1B 21    0018*M     db 23,27,0x21
0410FB 10 00       0019*M     dw width ; in pixels
0410FD 10 00       0020*M     dw height ; in pixels
0410FF 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
041100             0084*  	LOADBMPBUFFER2 BUF_FIREBALL_A,7,7,"src/rgba2/fireball_a.rgba2"
041100             0001*M 
041100             0002*M     ; Clear buffer
041100 17 00 A0    0003*M     db 23,0,0xA0
041103 0F 01       0004*M     dw bufferId
041105 02          0005*M     db 2
041106             0006*M 
041106 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
041109 0F 01       0008*M     dw bufferId
04110B             0009*M 
04110B             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
04110B 17 00 A0    0011*M     db 23,0,0xA0
04110E 0F 01       0012*M     dw bufferId
041110 00          0013*M     db 0
041111 31 00       0014*M 	dw width * height ; length of data in bytes
041113 00 00 D2 D2 0015*M     incbin file ; bitmap data
       D2 00 00 00 
       D2 C3 D2 CB 
       D1 00 D2 CB 
       D6 D7 DB D7 
       D2 D7 D2 D6 
       DB D2 D2 D2 
       D2 D2 D6 D6 
       D6 C3 D1 00 
       D1 C3 D2 CB 
       C1 00 00 00 
       D1 D2 D1 00 
       00          
041144             0016*M 
041144             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
041144 17 1B 21    0018*M     db 23,27,0x21
041147 07 00       0019*M     dw width ; in pixels
041149 07 00       0020*M     dw height ; in pixels
04114B 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
04114C             0085*  	LOADBMPBUFFER2 BUF_FIREBALL_B,7,7,"src/rgba2/fireball_b.rgba2"
04114C             0001*M 
04114C             0002*M     ; Clear buffer
04114C 17 00 A0    0003*M     db 23,0,0xA0
04114F 10 01       0004*M     dw bufferId
041151 02          0005*M     db 2
041152             0006*M 
041152 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
041155 10 01       0008*M     dw bufferId
041157             0009*M 
041157             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
041157 17 00 A0    0011*M     db 23,0,0xA0
04115A 10 01       0012*M     dw bufferId
04115C 00          0013*M     db 0
04115D 31 00       0014*M 	dw width * height ; length of data in bytes
04115F 00 00 D2 D2 0015*M     incbin file ; bitmap data
       D2 00 00 00 
       D2 C3 DF CB 
       D1 00 D2 D2 
       C7 C3 D7 D2 
       D1 D7 C3 DF 
       CB CB C3 D2 
       D2 D2 C7 CB 
       C7 C3 D1 00 
       D1 C3 C3 D2 
       C1 00 00 00 
       D1 D2 D1 00 
       00          
041190             0016*M 
041190             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
041190 17 1B 21    0018*M     db 23,27,0x21
041193 07 00       0019*M     dw width ; in pixels
041195 07 00       0020*M     dw height ; in pixels
041197 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
041198             0086*  	LOADBMPBUFFER2 BUF_LASER_A,5,13,"src/rgba2/laser_a.rgba2"
041198             0001*M 
041198             0002*M     ; Clear buffer
041198 17 00 A0    0003*M     db 23,0,0xA0
04119B 11 01       0004*M     dw bufferId
04119D 02          0005*M     db 2
04119E             0006*M 
04119E 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0411A1 11 01       0008*M     dw bufferId
0411A3             0009*M 
0411A3             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0411A3 17 00 A0    0011*M     db 23,0,0xA0
0411A6 11 01       0012*M     dw bufferId
0411A8 00          0013*M     db 0
0411A9 41 00       0014*M 	dw width * height ; length of data in bytes
0411AB 00 FF FF FF 0015*M     incbin file ; bitmap data
       00 FA FF FF 
       FF FA FA FF 
       FF FF FA FA 
       FF FF FF FA 
       00 FA FF FA 
       00 00 FA FF 
       FA 00 00 E5 
       FF E5 00 00 
       00 FF E5 00 
       00 00 FF E5 
       00 00 00 FA 
       00 00 00 00 
       E5 00 00 00 
       00 E5 00 00 
       00 00 00 00 
       00          
0411EC             0016*M 
0411EC             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0411EC 17 1B 21    0018*M     db 23,27,0x21
0411EF 05 00       0019*M     dw width ; in pixels
0411F1 0D 00       0020*M     dw height ; in pixels
0411F3 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0411F4             0087*  	LOADBMPBUFFER2 BUF_LASER_B,5,13,"src/rgba2/laser_b.rgba2"
0411F4             0001*M 
0411F4             0002*M     ; Clear buffer
0411F4 17 00 A0    0003*M     db 23,0,0xA0
0411F7 12 01       0004*M     dw bufferId
0411F9 02          0005*M     db 2
0411FA             0006*M 
0411FA 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0411FD 12 01       0008*M     dw bufferId
0411FF             0009*M 
0411FF             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0411FF 17 00 A0    0011*M     db 23,0,0xA0
041202 12 01       0012*M     dw bufferId
041204 00          0013*M     db 0
041205 41 00       0014*M 	dw width * height ; length of data in bytes
041207 00 FF FF FF 0015*M     incbin file ; bitmap data
       00 FA FF FF 
       FF FA FA FF 
       FF FF FA FA 
       FF FF FF FA 
       00 FA FF FA 
       00 00 FA FF 
       FA 00 00 FA 
       FF E5 00 00 
       E5 E5 00 00 
       00 00 E5 00 
       00 00 00 E5 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 E5 00 
       00          
041248             0016*M 
041248             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
041248 17 1B 21    0018*M     db 23,27,0x21
04124B 05 00       0019*M     dw width ; in pixels
04124D 0D 00       0020*M     dw height ; in pixels
04124F 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
041250             0088*  	LOADBMPBUFFER2 BUF_PAD,16,16,"src/rgba2/pad.rgba2"
041250             0001*M 
041250             0002*M     ; Clear buffer
041250 17 00 A0    0003*M     db 23,0,0xA0
041253 13 01       0004*M     dw bufferId
041255 02          0005*M     db 2
041256             0006*M 
041256 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
041259 13 01       0008*M     dw bufferId
04125B             0009*M 
04125B             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
04125B 17 00 A0    0011*M     db 23,0,0xA0
04125E 13 01       0012*M     dw bufferId
041260 00          0013*M     db 0
041261 00 01       0014*M 	dw width * height ; length of data in bytes
041263 00 00 00 00 0015*M     incbin file ; bitmap data
       00 D0 D0 DF 
       DF D0 D0 00 
       00 00 00 00 
       00 C3 C3 D0 
       D0 F5 F5 DF 
       DF F5 F5 D0 
       D0 C3 C3 00 
       00 C3 C3 D0 
       F5 F5 D0 D0 
       D0 D0 F5 F5 
       D0 C3 C3 00 
       00 D0 D0 F5 
       FA FA D0 DF 
       DF D0 FA FA 
       F5 D0 D0 00 
       00 D0 F5 FA 
       D9 D9 D0 D0 
       D0 D0 D9 D9 
       FA F5 D0 00 
       D0 F5 F5 FA 
       D9 D9 D0 DF 
       DF D0 D9 D9 
       FA F5 F5 D0 
       D0 F5 D0 D0 
       D0 D0 D0 DF 
       DF D0 D0 D0 
       D0 D0 F5 D0 
       DF DF D0 DF 
       D0 DF DF D0 
       D0 DF DF D0 
       DF D0 DF DF 
       DF DF D0 DF 
       D0 DF DF D0 
       D0 DF DF D0 
       DF D0 DF DF 
       D0 F5 D0 D0 
       D0 D0 D0 DF 
       DF D0 D0 D0 
       D0 D0 F5 D0 
       D0 F5 F5 FA 
       D9 D9 D0 DF 
       DF D0 D9 D9 
       FA F5 F5 D0 
       00 D0 F5 FA 
       D9 D9 D0 D0 
       D0 D0 D9 D9 
       FA F5 D0 00 
       00 D0 D0 F5 
       FA FA D0 DF 
       DF D0 FA FA 
       F5 D0 D0 00 
       00 C3 C3 D0 
       F5 F5 D0 D0 
       D0 D0 F5 F5 
       D0 C3 C3 00 
       00 C3 C3 D0 
       D0 F5 F5 DF 
       DF F5 F5 D0 
       D0 C3 C3 00 
       00 00 00 00 
       00 D0 D0 DF 
       DF D0 D0 00 
       00 00 00 00 
041363             0016*M 
041363             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
041363 17 1B 21    0018*M     db 23,27,0x21
041366 10 00       0019*M     dw width ; in pixels
041368 10 00       0020*M     dw height ; in pixels
04136A 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
04136B             0089*  	LOADBMPBUFFER2 BUF_SEEKER_000,16,16,"src/rgba2/seeker_000.rgba2"
04136B             0001*M 
04136B             0002*M     ; Clear buffer
04136B 17 00 A0    0003*M     db 23,0,0xA0
04136E 14 01       0004*M     dw bufferId
041370 02          0005*M     db 2
041371             0006*M 
041371 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
041374 14 01       0008*M     dw bufferId
041376             0009*M 
041376             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
041376 17 00 A0    0011*M     db 23,0,0xA0
041379 14 01       0012*M     dw bufferId
04137B 00          0013*M     db 0
04137C 00 01       0014*M 	dw width * height ; length of data in bytes
04137E 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 F5 
       E1 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 F5 
       E1 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 FA F5 
       E1 E5 00 00 
       00 00 00 00 
       00 FA 00 00 
       EA 00 FF FF 
       EE EA 00 EA 
       00 00 EA 00 
       F6 E2 E5 00 
       E1 F6 FB FF 
       EB E5 E2 E1 
       00 E5 E1 E2 
       F6 E1 F6 E2 
       E1 EB FB FA 
       F6 E6 D7 E1 
       F7 F6 E1 E1 
       F5 E1 E1 00 
       F6 EA FA F5 
       F5 E5 D5 F6 
       00 E1 E1 E1 
       00 E1 E1 E2 
       E1 F6 F8 FC 
       F8 F4 E1 E1 
       E2 E1 E1 00 
       00 E1 00 00 
       E1 E1 FC FE 
       FD F8 E1 E1 
       00 00 E1 00 
       00 E1 00 00 
       E1 E1 FD FE 
       FD F9 D0 E1 
       00 00 E1 00 
       00 FA 00 00 
       E1 E1 F5 FD 
       F9 E1 D0 E1 
       00 00 EA 00 
       EF DB DB 00 
       E5 E1 E2 F5 
       F5 D1 D0 E5 
       00 DB DB DB 
       00 DF 00 00 
       00 E1 E2 F5 
       E1 D1 D0 00 
       00 00 DF 00 
       EF DB DB 00 
       00 E1 E2 00 
       00 D1 D0 00 
       00 DB DB DB 
       00 EB 00 00 
       00 E2 FB 00 
       00 E6 D1 00 
       00 00 D7 00 
       00 C3 00 00 
       00 F3 00 00 
       00 00 F3 00 
       00 00 C3 00 
04147E             0016*M 
04147E             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
04147E 17 1B 21    0018*M     db 23,27,0x21
041481 10 00       0019*M     dw width ; in pixels
041483 10 00       0020*M     dw height ; in pixels
041485 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
041486             0090*  	LOADBMPBUFFER2 BUF_SEEKER_001,16,16,"src/rgba2/seeker_001.rgba2"
041486             0001*M 
041486             0002*M     ; Clear buffer
041486 17 00 A0    0003*M     db 23,0,0xA0
041489 15 01       0004*M     dw bufferId
04148B 02          0005*M     db 2
04148C             0006*M 
04148C 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
04148F 15 01       0008*M     dw bufferId
041491             0009*M 
041491             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
041491 17 00 A0    0011*M     db 23,0,0xA0
041494 15 01       0012*M     dw bufferId
041496 00          0013*M     db 0
041497 00 01       0014*M 	dw width * height ; length of data in bytes
041499 00 FA 00 00 0015*M     incbin file ; bitmap data
       00 00 FA 00 
       F5 F5 E0 00 
       00 00 00 00 
       00 00 FA 00 
       EA 00 00 FF 
       F5 E5 D0 00 
       00 00 00 00 
       00 E6 FA 00 
       00 EA 00 FA 
       F5 E0 E5 E5 
       00 00 00 00 
       00 F2 E1 E5 
       00 E6 F6 FF 
       FF EA E5 00 
       EA 00 00 00 
       00 E1 E1 E2 
       E1 E2 FB FB 
       FF EA E5 E2 
       EA 00 FF EA 
       F5 E4 E1 E1 
       F1 E6 EB FB 
       FA E6 E6 E2 
       E1 E9 E5 E6 
       00 E0 E1 E2 
       E1 F6 FA F9 
       F5 E5 D6 E2 
       F6 F6 E1 E1 
       D0 E0 00 E2 
       E1 E5 F8 FC 
       F8 F4 E5 E5 
       F2 E1 E1 E1 
       F5 E5 00 E0 
       E1 E1 FD FE 
       FD F4 E1 E1 
       E2 E1 E1 E0 
       EB EB 00 E1 
       E0 E5 FD FE 
       FD E4 D1 E1 
       00 E0 E1 00 
       DF DB DB E5 
       E5 E1 F5 FD 
       E5 D0 D0 E0 
       00 E0 E0 00 
       DF DF 00 FF 
       E4 E2 F6 F5 
       E1 D0 E5 E1 
       00 F5 F5 00 
       DB DB D6 00 
       E0 E2 E1 E1 
       D1 D0 E5 F0 
       EB DB DB 00 
       E7 00 00 E1 
       E2 E7 00 D1 
       D1 D0 00 00 
       00 DF DB 00 
       C3 00 00 F2 
       F3 FF 00 E6 
       E6 C0 00 DB 
       DB DB EB 00 
       00 00 00 00 
       00 00 E6 00 
       E2 E2 00 00 
       D7 DB DB 00 
041599             0016*M 
041599             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
041599 17 1B 21    0018*M     db 23,27,0x21
04159C 10 00       0019*M     dw width ; in pixels
04159E 10 00       0020*M     dw height ; in pixels
0415A0 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0415A1             0091*  	LOADBMPBUFFER2 BUF_SEEKER_002,16,16,"src/rgba2/seeker_002.rgba2"
0415A1             0001*M 
0415A1             0002*M     ; Clear buffer
0415A1 17 00 A0    0003*M     db 23,0,0xA0
0415A4 16 01       0004*M     dw bufferId
0415A6 02          0005*M     db 2
0415A7             0006*M 
0415A7 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0415AA 16 01       0008*M     dw bufferId
0415AC             0009*M 
0415AC             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0415AC 17 00 A0    0011*M     db 23,0,0xA0
0415AF 16 01       0012*M     dw bufferId
0415B1 00          0013*M     db 0
0415B2 00 01       0014*M 	dw width * height ; length of data in bytes
0415B4 00 00 00 FE 0015*M     incbin file ; bitmap data
       00 FA 00 00 
       00 E1 F5 00 
       00 00 00 00 
       00 00 F6 FA 
       FF 00 FA 00 
       FF F1 F5 E0 
       00 00 00 00 
       00 00 E2 E1 
       E5 00 EA 00 
       FA F5 E0 E1 
       00 D0 00 00 
       00 F5 E1 E1 
       E6 E1 E2 F6 
       FF FA E5 E5 
       E5 00 00 00 
       00 E1 E0 E1 
       E2 E1 E7 FB 
       FF FF EA D5 
       00 EA E5 00 
       00 E0 E1 E2 
       E2 F6 EB FB 
       FA FA E5 E2 
       E6 EA 00 FA 
       00 E0 E0 F3 
       E1 E5 F9 F9 
       F5 E5 E6 E2 
       E1 F7 E5 EA 
       FA F5 00 E4 
       E1 E1 F8 FC 
       F8 F4 E5 E6 
       F6 F6 E5 E1 
       DB EB 00 E0 
       E0 E5 FD FE 
       FD F4 E1 E5 
       E2 E1 E1 E1 
       DF DB 00 E5 
       E1 E5 FE FE 
       FD E4 E1 E1 
       E2 E1 E0 E1 
       DB F1 00 E5 
       E1 E2 F9 F9 
       E5 D0 E1 E4 
       00 E0 E1 00 
       DB DB 00 E0 
       E2 F2 F5 E1 
       D1 D0 E0 00 
       00 E0 E0 00 
       00 00 E1 E1 
       E2 E1 E0 D1 
       D0 E5 E5 00 
       EA E5 00 00 
       00 00 F2 F7 
       FB 00 D2 D1 
       D0 00 F0 EB 
       DB DA 00 00 
       00 00 00 F2 
       00 00 E6 E5 
       D0 00 E7 DF 
       DF DB 00 00 
       00 00 00 00 
       00 00 00 E2 
       D1 00 EB DB 
       DB E7 00 00 
0416B4             0016*M 
0416B4             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0416B4 17 1B 21    0018*M     db 23,27,0x21
0416B7 10 00       0019*M     dw width ; in pixels
0416B9 10 00       0020*M     dw height ; in pixels
0416BB 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0416BC             0092*  	LOADBMPBUFFER2 BUF_SEEKER_003,16,16,"src/rgba2/seeker_003.rgba2"
0416BC             0001*M 
0416BC             0002*M     ; Clear buffer
0416BC 17 00 A0    0003*M     db 23,0,0xA0
0416BF 17 01       0004*M     dw bufferId
0416C1 02          0005*M     db 2
0416C2             0006*M 
0416C2 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0416C5 17 01       0008*M     dw bufferId
0416C7             0009*M 
0416C7             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0416C7 17 00 A0    0011*M     db 23,0,0xA0
0416CA 17 01       0012*M     dw bufferId
0416CC 00          0013*M     db 0
0416CD 00 01       0014*M 	dw width * height ; length of data in bytes
0416CF 00 00 00 F7 0015*M     incbin file ; bitmap data
       FA FF 00 F5 
       00 FA 00 00 
       00 00 00 00 
       00 00 00 F6 
       E2 E5 00 EA 
       00 FF 00 F5 
       F5 00 00 00 
       00 00 F5 E1 
       E1 E5 00 FA 
       00 FA F5 F5 
       E0 00 00 00 
       00 00 E0 E1 
       E1 E2 E1 E2 
       F6 FF F5 E0 
       E5 00 00 00 
       00 E0 E1 E1 
       E2 F1 E6 EB 
       FB FF FF EA 
       E5 00 00 00 
       00 E1 E0 00 
       E2 E1 E6 FB 
       FB FA EA E5 
       00 FE 00 F5 
       EB FA 00 00 
       E1 E1 F9 F9 
       F5 F5 E6 E2 
       E2 EA 00 00 
       CB DB 00 E0 
       E1 E1 FC FC 
       F8 E5 E6 D6 
       E1 D1 C4 EA 
       DF E7 F0 E5 
       E0 F9 FE FE 
       F8 F4 E5 F6 
       F6 F6 F5 E5 
       DB D6 FF E5 
       E1 F5 FD FD 
       FD E4 E1 E1 
       E1 E1 E1 E1 
       C6 00 E0 E1 
       E2 F6 F9 E5 
       E4 D0 E1 E2 
       E1 E1 E0 E1 
       00 E2 E1 E2 
       E2 F5 E1 D1 
       D0 E0 E1 00 
       E0 E1 E0 00 
       00 F3 F7 FB 
       00 E0 D1 D1 
       E5 E5 00 00 
       E0 E0 00 00 
       00 00 00 FF 
       00 E6 D1 D0 
       E5 F0 DB EA 
       E5 00 00 00 
       00 00 00 F7 
       00 E6 D1 D0 
       00 00 DB DA 
       DB 00 00 00 
       00 00 00 00 
       00 F3 E2 00 
       DB DB DF DF 
       EB 00 00 00 
0417CF             0016*M 
0417CF             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0417CF 17 1B 21    0018*M     db 23,27,0x21
0417D2 10 00       0019*M     dw width ; in pixels
0417D4 10 00       0020*M     dw height ; in pixels
0417D6 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0417D7             0093*  	LOADBMPBUFFER2 BUF_SEEKER_004,16,16,"src/rgba2/seeker_004.rgba2"
0417D7             0001*M 
0417D7             0002*M     ; Clear buffer
0417D7 17 00 A0    0003*M     db 23,0,0xA0
0417DA 18 01       0004*M     dw bufferId
0417DC 02          0005*M     db 2
0417DD             0006*M 
0417DD 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0417E0 18 01       0008*M     dw bufferId
0417E2             0009*M 
0417E2             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0417E2 17 00 A0    0011*M     db 23,0,0xA0
0417E5 18 01       0012*M     dw bufferId
0417E7 00          0013*M     db 0
0417E8 00 01       0014*M 	dw width * height ; length of data in bytes
0417EA 00 00 00 00 0015*M     incbin file ; bitmap data
       F6 E2 FA 00 
       FA 00 00 00 
       00 00 00 00 
       00 00 00 F5 
       E1 E1 E5 00 
       EA 00 00 00 
       F5 00 00 00 
       00 00 00 E0 
       E1 F1 E6 D0 
       EA 00 FA F6 
       F5 F5 00 00 
       00 00 E0 E1 
       E1 E1 E2 E1 
       E2 FB FF F5 
       F1 E0 E0 00 
       EF F5 E0 E0 
       E2 E2 F6 EA 
       FB FB FF EA 
       E0 E5 00 00 
       DB EB F0 00 
       D4 E1 F6 FA 
       FB FB FF EE 
       EA E5 00 00 
       DF DB 00 E1 
       E1 E1 F5 F8 
       F5 F5 EA E5 
       D1 00 00 00 
       DB 00 F0 E5 
       E0 E5 FC FD 
       F8 E5 E6 E7 
       E2 EA EA EA 
       EB 00 E5 E5 
       E1 F9 FE FE 
       F8 F4 E5 E2 
       E1 D0 00 00 
       00 00 E0 E1 
       E2 F9 FD FD 
       F8 E4 E1 F6 
       F6 F6 E5 EA 
       00 E1 F2 E2 
       F5 F5 E5 E5 
       D4 E1 E1 E2 
       E1 E1 E1 E1 
       F3 F7 FB E3 
       E4 E1 D1 D0 
       D0 E1 E4 E2 
       E1 E1 E1 E1 
       00 00 FF 00 
       D2 D1 D1 D5 
       E5 E1 00 E1 
       E1 E0 E0 00 
       00 00 E6 EA 
       E6 D1 D0 E5 
       F0 00 F0 E0 
       E0 00 00 00 
       00 00 00 00 
       E2 C0 00 00 
       00 DB EA F5 
       00 00 00 00 
       00 00 00 00 
       F3 00 00 EB 
       DB DF DB DB 
       00 00 00 00 
0418EA             0016*M 
0418EA             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0418EA 17 1B 21    0018*M     db 23,27,0x21
0418ED 10 00       0019*M     dw width ; in pixels
0418EF 10 00       0020*M     dw height ; in pixels
0418F1 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0418F2             0094*  	LOADBMPBUFFER2 BUF_SEEKER_005,16,16,"src/rgba2/seeker_005.rgba2"
0418F2             0001*M 
0418F2             0002*M     ; Clear buffer
0418F2 17 00 A0    0003*M     db 23,0,0xA0
0418F5 19 01       0004*M     dw bufferId
0418F7 02          0005*M     db 2
0418F8             0006*M 
0418F8 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0418FB 19 01       0008*M     dw bufferId
0418FD             0009*M 
0418FD             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0418FD 17 00 A0    0011*M     db 23,0,0xA0
041900 19 01       0012*M     dw bufferId
041902 00          0013*M     db 0
041903 00 01       0014*M 	dw width * height ; length of data in bytes
041905 00 00 00 00 0015*M     incbin file ; bitmap data
       00 F5 E2 E6 
       FA 00 F5 00 
       00 00 00 00 
       00 00 00 00 
       E1 E1 E1 F6 
       C8 00 00 00 
       00 00 00 00 
       00 00 00 E0 
       E1 E1 E1 E2 
       D1 EA EA 00 
       00 00 00 00 
       FF EF F5 E0 
       E1 E2 E2 E1 
       E1 E2 00 FA 
       F5 F5 F5 00 
       DF DA EA 00 
       00 E2 E1 F6 
       EB FB FB FF 
       E0 F5 E0 00 
       DF DB DB 00 
       E1 E1 E1 FA 
       FB FB FF FF 
       E5 E1 00 00 
       DB 00 F0 E5 
       E0 E1 F4 F8 
       F9 F6 FA EA 
       EA E5 E6 E5 
       DB 00 E5 E5 
       E1 E9 FD FD 
       F8 F5 E5 E5 
       E1 00 00 00 
       00 E0 E0 E1 
       E2 F9 FE FE 
       F8 F4 E6 D7 
       E2 FA EA F5 
       F2 E2 E2 E2 
       F6 F9 FD FD 
       F8 E0 E5 E2 
       E1 00 00 00 
       F3 FB F7 E4 
       F5 E1 E1 E4 
       E4 E1 E1 F6 
       F7 E6 E5 EA 
       00 00 00 00 
       D1 D1 D0 D0 
       E0 E1 E2 E1 
       E1 E1 E1 E6 
       00 E6 EA E6 
       D1 D0 D5 E5 
       E0 00 00 E0 
       E1 E1 E1 E2 
       00 00 00 E6 
       D0 D0 FF F0 
       00 00 E0 E1 
       E0 E1 00 00 
       00 00 00 F2 
       D1 00 D6 E7 
       DB E6 E1 E0 
       00 00 00 00 
       00 00 00 00 
       00 DB DB DF 
       CB EA 00 00 
       00 00 00 00 
041A05             0016*M 
041A05             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
041A05 17 1B 21    0018*M     db 23,27,0x21
041A08 10 00       0019*M     dw width ; in pixels
041A0A 10 00       0020*M     dw height ; in pixels
041A0C 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
041A0D             0095*  	LOADBMPBUFFER2 BUF_SEEKER_006,16,16,"src/rgba2/seeker_006.rgba2"
041A0D             0001*M 
041A0D             0002*M     ; Clear buffer
041A0D 17 00 A0    0003*M     db 23,0,0xA0
041A10 1A 01       0004*M     dw bufferId
041A12 02          0005*M     db 2
041A13             0006*M 
041A13 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
041A16 1A 01       0008*M     dw bufferId
041A18             0009*M 
041A18             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
041A18 17 00 A0    0011*M     db 23,0,0xA0
041A1B 1A 01       0012*M     dw bufferId
041A1D 00          0013*M     db 0
041A1E 00 01       0014*M 	dw width * height ; length of data in bytes
041A20 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 F5 E1 
       E2 FA FF 00 
       00 00 00 00 
       00 00 00 00 
       E0 E0 E0 E1 
       E5 E5 00 E5 
       00 00 00 00 
       FF EF EB F5 
       E0 E1 E1 E1 
       E2 D1 EA EA 
       00 F5 00 00 
       DF DF DB FA 
       00 00 E2 F2 
       E1 E1 E6 00 
       FA 00 00 00 
       DB DF EB 00 
       00 D4 E1 E1 
       F6 E7 F6 FF 
       FA F5 F5 00 
       DB E7 F0 E5 
       E0 E1 E1 F6 
       FA FB FB FF 
       FA E0 F5 E0 
       00 00 00 E5 
       E1 E5 F8 F8 
       F9 FA FA FF 
       EA E0 E0 D0 
       E2 E1 E0 E1 
       E1 F9 FE FD 
       FC F5 F6 EA 
       EA E5 FA 00 
       F3 F7 E2 E2 
       F6 FD FE FE 
       F8 F4 E6 E6 
       E1 00 00 00 
       00 FF E3 E5 
       F5 F5 F9 FD 
       F4 E4 D6 E2 
       E2 EA EA 00 
       00 00 00 D0 
       E1 D1 E0 D4 
       E1 E1 F6 E1 
       E1 00 00 EA 
       00 00 E6 D1 
       D1 D0 D0 D0 
       E1 E1 E2 FB 
       F6 E5 FE 00 
       00 F3 E6 D0 
       D0 E5 E5 E0 
       E0 F3 E1 E1 
       E1 E1 EA FA 
       00 00 E2 D0 
       00 00 00 00 
       00 E1 E0 E0 
       E1 E1 E2 00 
       00 00 00 00 
       DB F1 DB DA 
       E5 E0 E1 E0 
       E1 00 00 00 
       00 00 00 00 
       DB DB DF DA 
       FA 00 00 00 
       00 00 00 00 
041B20             0016*M 
041B20             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
041B20 17 1B 21    0018*M     db 23,27,0x21
041B23 10 00       0019*M     dw width ; in pixels
041B25 10 00       0020*M     dw height ; in pixels
041B27 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
041B28             0096*  	LOADBMPBUFFER2 BUF_SEEKER_007,16,16,"src/rgba2/seeker_007.rgba2"
041B28             0001*M 
041B28             0002*M     ; Clear buffer
041B28 17 00 A0    0003*M     db 23,0,0xA0
041B2B 1B 01       0004*M     dw bufferId
041B2D 02          0005*M     db 2
041B2E             0006*M 
041B2E 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
041B31 1B 01       0008*M     dw bufferId
041B33             0009*M 
041B33             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
041B33 17 00 A0    0011*M     db 23,0,0xA0
041B36 1B 01       0012*M     dw bufferId
041B38 00          0013*M     db 0
041B39 00 01       0014*M 	dw width * height ; length of data in bytes
041B3B 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 E5 
       F5 E2 E6 FE 
       00 00 00 00 
       EF EF EF EF 
       F5 E0 E0 E1 
       E1 E1 E5 FF 
       00 00 00 00 
       EB DB DF DB 
       FA E0 E1 E1 
       E1 E2 E9 00 
       00 00 00 00 
       EB DB 00 EB 
       00 00 00 E2 
       F6 E1 E1 EA 
       EA 00 00 00 
       00 DB 00 F0 
       E1 E0 E5 E1 
       F6 E6 E6 E2 
       00 FA 00 00 
       00 00 00 E5 
       E5 E0 E1 E5 
       FA EB FB FA 
       FA FA E0 F5 
       F2 E1 E0 E1 
       E1 E5 FD F8 
       F8 FA FB FF 
       FA E0 F5 F5 
       F7 FB E2 E2 
       F2 F9 FE FE 
       FC F5 FA FF 
       EE E1 E0 E0 
       00 FB E2 E5 
       F5 FD FD FD 
       F8 E5 E5 EA 
       EA E5 FF 00 
       E6 00 00 E1 
       E1 E5 F9 F8 
       F4 E5 D6 E2 
       E2 00 00 E5 
       00 EA D5 D1 
       D1 D0 D0 E4 
       E1 E5 E2 E1 
       E6 EA 00 00 
       00 E2 D1 D0 
       D0 E5 E0 E1 
       E1 E1 F6 E6 
       00 00 E6 00 
       00 F2 D0 00 
       FF E5 E1 E0 
       E2 E2 E1 F6 
       E5 00 00 00 
       00 00 00 D6 
       00 DB 00 00 
       00 E0 E1 E1 
       E1 FA EA 00 
       00 00 00 DB 
       DF DB EA E5 
       E0 E1 E0 E1 
       E1 E2 00 EA 
       00 C3 D7 DB 
       DF DB EA F4 
       E0 00 E0 00 
       00 00 00 00 
041C3B             0016*M 
041C3B             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
041C3B 17 1B 21    0018*M     db 23,27,0x21
041C3E 10 00       0019*M     dw width ; in pixels
041C40 10 00       0020*M     dw height ; in pixels
041C42 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
041C43             0097*  	LOADBMPBUFFER2 BUF_SEEKER_008,16,16,"src/rgba2/seeker_008.rgba2"
041C43             0001*M 
041C43             0002*M     ; Clear buffer
041C43 17 00 A0    0003*M     db 23,0,0xA0
041C46 1C 01       0004*M     dw bufferId
041C48 02          0005*M     db 2
041C49             0006*M 
041C49 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
041C4C 1C 01       0008*M     dw bufferId
041C4E             0009*M 
041C4E             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
041C4E 17 00 A0    0011*M     db 23,0,0xA0
041C51 1C 01       0012*M     dw bufferId
041C53 00          0013*M     db 0
041C54 00 01       0014*M 	dw width * height ; length of data in bytes
041C56 00 00 EF 00 0015*M     incbin file ; bitmap data
       EF 00 00 00 
       00 F5 F6 F6 
       00 00 00 00 
       C3 EB DB DF 
       DB FA E1 E1 
       E1 E1 E1 E2 
       FA 00 00 00 
       00 00 DB 00 
       DB 00 00 00 
       E1 E1 F6 E5 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       E2 00 E2 00 
       00 00 00 00 
       00 00 00 00 
       E5 E1 E1 E1 
       E1 F6 E1 E1 
       EA 00 00 00 
       F3 E2 E1 E1 
       E1 E1 E1 E1 
       F6 EA EB F6 
       00 00 00 00 
       00 FB E2 E2 
       E2 F5 FD FC 
       F8 FA FB FB 
       FF FA 00 00 
       00 00 00 F5 
       F5 FD FE FE 
       FC F5 FA FF 
       FF F5 F5 F5 
       00 00 00 E1 
       F5 F9 FD FD 
       F8 F5 F6 EB 
       EE E1 E1 E1 
       00 E6 D1 D1 
       D1 E1 F9 F8 
       F4 E5 E6 E5 
       EA E5 00 00 
       F3 D1 D0 D0 
       D0 D0 D0 E1 
       E1 D5 D7 E2 
       00 00 00 00 
       00 00 00 00 
       E5 E1 E1 E1 
       E1 F6 E1 E1 
       EA 00 00 00 
       00 00 00 00 
       00 00 00 00 
       E2 00 F7 00 
       00 00 00 00 
       00 00 DB 00 
       DB 00 00 00 
       E1 E1 F6 E5 
       00 00 00 00 
       C3 D7 DB DF 
       DB EA E1 E1 
       E1 E1 E1 E1 
       EA 00 00 00 
       00 00 DB 00 
       DB 00 00 00 
       00 E1 E1 E2 
       00 00 00 00 
041D56             0016*M 
041D56             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
041D56 17 1B 21    0018*M     db 23,27,0x21
041D59 10 00       0019*M     dw width ; in pixels
041D5B 10 00       0020*M     dw height ; in pixels
041D5D 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
041D5E             0098*  	LOADBMPBUFFER2 BUF_SEEKER_009,16,16,"src/rgba2/seeker_009.rgba2"
041D5E             0001*M 
041D5E             0002*M     ; Clear buffer
041D5E 17 00 A0    0003*M     db 23,0,0xA0
041D61 1D 01       0004*M     dw bufferId
041D63 02          0005*M     db 2
041D64             0006*M 
041D64 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
041D67 1D 01       0008*M     dw bufferId
041D69             0009*M 
041D69             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
041D69 17 00 A0    0011*M     db 23,0,0xA0
041D6C 1D 01       0012*M     dw bufferId
041D6E 00          0013*M     db 0
041D6F 00 01       0014*M 	dw width * height ; length of data in bytes
041D71 00 C3 E7 DB 0015*M     incbin file ; bitmap data
       DF DF EB F5 
       D0 00 F5 00 
       00 00 00 00 
       00 00 00 DB 
       DF DB EB E5 
       E0 E0 E4 E1 
       F2 E6 00 FA 
       00 00 00 D6 
       00 DB 00 00 
       00 E1 E1 E1 
       E1 FA FA 00 
       00 F2 E1 00 
       FF E5 E1 E0 
       E2 E2 E1 E2 
       E5 00 00 00 
       00 F3 E2 E0 
       E4 E5 E0 E1 
       E1 E1 F1 E1 
       00 00 EA 00 
       00 FF E7 E2 
       E2 E1 E5 E1 
       E5 F6 E6 E2 
       E6 EA 00 00 
       E6 00 00 E1 
       F6 F5 FD FD 
       F8 FA EB FB 
       F6 00 00 FA 
       00 E6 D1 E1 
       F5 FD FE FE 
       FC F9 FB FB 
       FF FA FF 00 
       E2 E6 D1 D1 
       E1 E5 FD FD 
       F8 F5 FA FF 
       FF F5 F5 F5 
       E2 C0 D0 D0 
       D0 D0 E4 F4 
       F4 E5 E6 EA 
       EA E0 E5 F5 
       00 00 00 E5 
       E5 D0 D1 E1 
       E5 D6 E6 E5 
       E5 E5 D0 E0 
       00 DB 00 F0 
       E1 E0 E1 E1 
       E5 E2 E2 E2 
       00 E5 00 00 
       D7 DB 00 EB 
       00 00 00 E2 
       F2 F6 E1 EA 
       EA 00 00 00 
       DB DB DF DB 
       F5 E0 E0 E1 
       E1 F6 E9 00 
       00 00 00 00 
       DB EB DB DB 
       F5 E0 E1 E1 
       E1 E1 E5 FF 
       00 00 00 00 
       00 00 00 00 
       00 00 00 E0 
       E1 E1 E6 EA 
       00 00 00 00 
041E71             0016*M 
041E71             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
041E71 17 1B 21    0018*M     db 23,27,0x21
041E74 10 00       0019*M     dw width ; in pixels
041E76 10 00       0020*M     dw height ; in pixels
041E78 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
041E79             0099*  	LOADBMPBUFFER2 BUF_SEEKER_010,16,16,"src/rgba2/seeker_010.rgba2"
041E79             0001*M 
041E79             0002*M     ; Clear buffer
041E79 17 00 A0    0003*M     db 23,0,0xA0
041E7C 1E 01       0004*M     dw bufferId
041E7E 02          0005*M     db 2
041E7F             0006*M 
041E7F 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
041E82 1E 01       0008*M     dw bufferId
041E84             0009*M 
041E84             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
041E84 17 00 A0    0011*M     db 23,0,0xA0
041E87 1E 01       0012*M     dw bufferId
041E89 00          0013*M     db 0
041E8A 00 01       0014*M 	dw width * height ; length of data in bytes
041E8C 00 00 00 00 0015*M     incbin file ; bitmap data
       DB DB DF DB 
       FA 00 00 00 
       00 00 00 00 
       00 00 00 00 
       DB F1 DB EB 
       F5 E0 E0 E1 
       F5 00 00 00 
       00 00 F2 E1 
       00 00 00 00 
       00 E0 E1 E0 
       E1 E2 F6 00 
       00 F2 F7 E1 
       E0 E5 E5 E0 
       E4 F3 E2 E1 
       E1 E1 FA FE 
       00 00 FB E2 
       E2 E1 E1 E0 
       E1 E1 E2 E2 
       E6 E5 FF 00 
       00 00 00 E1 
       F2 E2 E5 E5 
       E1 E5 F6 E1 
       E1 00 00 FA 
       00 E6 D2 E0 
       F5 F9 FE FD 
       F8 F9 EB E7 
       E2 EA FA 00 
       E2 E5 D1 D1 
       E1 F9 FE FE 
       FC F9 FB FB 
       F6 00 00 00 
       D1 D0 D0 D0 
       D1 E5 FD FD 
       F8 F5 FA FF 
       FF FA FF 00 
       00 00 00 E5 
       D0 D0 E4 F4 
       F4 E5 FA FF 
       FA F5 F1 E1 
       EB E7 F0 E5 
       E0 E1 E1 E1 
       E5 E6 E5 EA 
       E5 E0 F5 F5 
       DB DF EB 00 
       00 E4 E1 E5 
       E6 E2 E2 D5 
       E5 E1 E0 00 
       DB DF DB EA 
       00 00 E2 E2 
       F6 E1 E6 00 
       E5 00 00 00 
       E7 DB DA E5 
       E0 E0 E1 E1 
       F6 F7 EA EA 
       00 D0 00 00 
       00 00 00 00 
       E0 E1 E0 E1 
       E5 E5 00 E5 
       00 00 00 00 
       00 00 00 00 
       00 00 E1 E1 
       E1 EA FA 00 
       00 00 00 00 
041F8C             0016*M 
041F8C             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
041F8C 17 1B 21    0018*M     db 23,27,0x21
041F8F 10 00       0019*M     dw width ; in pixels
041F91 10 00       0020*M     dw height ; in pixels
041F93 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
041F94             0100*  	LOADBMPBUFFER2 BUF_SEEKER_011,16,16,"src/rgba2/seeker_011.rgba2"
041F94             0001*M 
041F94             0002*M     ; Clear buffer
041F94 17 00 A0    0003*M     db 23,0,0xA0
041F97 1F 01       0004*M     dw bufferId
041F99 02          0005*M     db 2
041F9A             0006*M 
041F9A 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
041F9D 1F 01       0008*M     dw bufferId
041F9F             0009*M 
041F9F             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
041F9F 17 00 A0    0011*M     db 23,0,0xA0
041FA2 1F 01       0012*M     dw bufferId
041FA4 00          0013*M     db 0
041FA5 00 01       0014*M 	dw width * height ; length of data in bytes
041FA7 00 00 00 00 0015*M     incbin file ; bitmap data
       00 C6 DB DF 
       CB EB 00 00 
       00 00 00 00 
       00 00 00 F3 
       E2 00 D6 E7 
       DB FA E1 E0 
       00 00 00 00 
       00 00 00 F7 
       E1 E0 FF F0 
       00 00 E0 E1 
       E0 F5 00 00 
       00 F7 FF FB 
       E2 E1 E5 E5 
       E0 00 00 E1 
       E1 E1 F6 F7 
       00 00 00 00 
       E2 E2 E1 E0 
       E1 E1 E2 E2 
       E1 E1 E2 FA 
       F3 E6 E6 E0 
       F5 F6 F5 F9 
       E1 E1 E1 F1 
       E2 E5 E5 FF 
       E2 D1 D1 D1 
       E1 F9 FD FE 
       FC F9 E6 E6 
       E1 00 00 00 
       00 D0 D0 D1 
       D1 E5 FD FE 
       FC F9 FB EB 
       E2 FA EA F5 
       DB 00 E5 E5 
       D0 E4 FD F8 
       F8 F5 FB FB 
       F6 00 00 00 
       DB 00 F0 E5 
       E0 D0 E4 F4 
       E5 F5 FA FF 
       FF FA FF FA 
       DF DB DB 00 
       E1 E1 E1 E5 
       E6 E6 EA FF 
       F5 F5 00 00 
       DF DA EA 00 
       00 E2 E1 F6 
       D6 E2 E5 EA 
       E0 F5 F5 00 
       EB DB E5 E0 
       E0 E1 E1 F6 
       E1 E2 00 E5 
       E5 E0 F5 00 
       00 00 00 E0 
       E1 E1 E1 F6 
       D1 EA FE 00 
       00 00 00 00 
       00 00 00 00 
       E0 E0 E1 F5 
       C4 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 E1 E1 E5 
       EA 00 F5 00 
       00 00 00 00 
0420A7             0016*M 
0420A7             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0420A7 17 1B 21    0018*M     db 23,27,0x21
0420AA 10 00       0019*M     dw width ; in pixels
0420AC 10 00       0020*M     dw height ; in pixels
0420AE 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0420AF             0101*  	LOADBMPBUFFER2 BUF_SEEKER_012,16,16,"src/rgba2/seeker_012.rgba2"
0420AF             0001*M 
0420AF             0002*M     ; Clear buffer
0420AF 17 00 A0    0003*M     db 23,0,0xA0
0420B2 20 01       0004*M     dw bufferId
0420B4 02          0005*M     db 2
0420B5             0006*M 
0420B5 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0420B8 20 01       0008*M     dw bufferId
0420BA             0009*M 
0420BA             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0420BA 17 00 A0    0011*M     db 23,0,0xA0
0420BD 20 01       0012*M     dw bufferId
0420BF 00          0013*M     db 0
0420C0 00 01       0014*M 	dw width * height ; length of data in bytes
0420C2 00 00 00 00 0015*M     incbin file ; bitmap data
       F3 00 00 EB 
       DB DF DB EF 
       00 00 00 00 
       00 00 00 00 
       F7 E1 00 00 
       00 DB EB F5 
       00 00 00 00 
       00 00 E6 FF 
       FB F2 E0 E5 
       F0 00 F0 E0 
       E0 00 00 00 
       00 00 EA 00 
       E3 E2 E1 E5 
       E5 E1 00 E0 
       E1 E0 F5 00 
       F3 E2 E6 D2 
       E4 F5 E2 E1 
       E0 E1 D4 E2 
       E1 E1 E1 F6 
       00 C0 D1 D1 
       E1 F5 F9 F9 
       E5 E1 E1 E2 
       E1 F1 E1 E2 
       00 00 D0 D1 
       D1 E5 FD FE 
       FC F5 F6 F6 
       E2 E6 E5 FA 
       EB 00 E5 D5 
       D0 E5 FD FE 
       FD F8 FA EA 
       E1 D0 00 00 
       DB 00 F0 E5 
       D0 D4 F8 F8 
       F8 F5 FB FB 
       E2 EA EA FA 
       DF DB 00 E1 
       E1 E1 E4 F4 
       E5 F5 FB FB 
       FB 00 00 00 
       DB EA F0 00 
       E4 E1 E1 E5 
       E6 EA FF FF 
       FF FA 00 00 
       DB F5 E0 E1 
       E2 E2 F6 E2 
       E7 E5 EE EA 
       F5 F6 00 00 
       00 00 E0 E1 
       E1 E1 F6 E1 
       E2 D1 EA E0 
       F1 F5 F5 00 
       00 00 00 E0 
       E1 E1 F6 D0 
       EA 00 E5 E5 
       E0 F5 00 00 
       00 00 00 E0 
       E1 E1 E5 00 
       EA 00 00 00 
       E0 00 00 00 
       00 00 00 00 
       E1 E1 EA 00 
       EA 00 00 00 
       00 00 00 00 
0421C2             0016*M 
0421C2             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0421C2 17 1B 21    0018*M     db 23,27,0x21
0421C5 10 00       0019*M     dw width ; in pixels
0421C7 10 00       0020*M     dw height ; in pixels
0421C9 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0421CA             0102*  	LOADBMPBUFFER2 BUF_SEEKER_013,16,16,"src/rgba2/seeker_013.rgba2"
0421CA             0001*M 
0421CA             0002*M     ; Clear buffer
0421CA 17 00 A0    0003*M     db 23,0,0xA0
0421CD 21 01       0004*M     dw bufferId
0421CF 02          0005*M     db 2
0421D0             0006*M 
0421D0 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0421D3 21 01       0008*M     dw bufferId
0421D5             0009*M 
0421D5             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0421D5 17 00 A0    0011*M     db 23,0,0xA0
0421D8 21 01       0012*M     dw bufferId
0421DA 00          0013*M     db 0
0421DB 00 01       0014*M 	dw width * height ; length of data in bytes
0421DD 00 00 00 00 0015*M     incbin file ; bitmap data
       00 F3 F2 00 
       DB DB DF DF 
       FF 00 00 00 
       00 00 00 E6 
       00 FB E2 E0 
       00 00 DB DA 
       EF 00 00 00 
       00 00 00 EA 
       00 F7 E2 E0 
       E5 F0 DB EA 
       F5 00 00 00 
       00 F2 E6 E6 
       00 E4 E2 E1 
       E5 E5 00 00 
       E0 E0 00 00 
       00 D1 D0 D1 
       D1 F5 F6 E2 
       E1 E0 E1 00 
       E1 E1 E1 00 
       DB 00 D0 D0 
       D1 E1 F9 F9 
       E9 E1 E1 E2 
       E2 E1 E1 F5 
       DB D6 FF D5 
       D0 E1 FD FE 
       FD F4 E1 E1 
       E2 E1 E1 E2 
       DF E7 F0 E5 
       D0 E4 FD FE 
       FD F8 FA F6 
       E1 E2 F6 E6 
       CB DB 00 E0 
       E0 E4 F8 F8 
       F8 F9 FB EB 
       E1 D1 C8 FA 
       EA E6 00 00 
       E1 E1 E0 F4 
       F5 F6 FB FB 
       E2 EA 00 00 
       00 E1 E0 00 
       E2 E1 E5 E6 
       E5 FA FF FB 
       00 EA 00 F5 
       00 E0 E1 E0 
       E1 F6 E2 D7 
       E5 EA FF FF 
       FA 00 00 00 
       00 00 E0 E1 
       E1 F7 E1 E2 
       E1 EA E5 E0 
       F5 00 00 00 
       00 00 E1 E1 
       E1 E6 00 FA 
       00 E5 E1 F5 
       F5 00 00 00 
       00 00 00 E1 
       E1 E5 00 EA 
       00 E6 00 E0 
       F5 00 00 00 
       00 00 00 E2 
       E6 EA 00 F5 
       00 E5 00 00 
       00 00 00 00 
0422DD             0016*M 
0422DD             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0422DD 17 1B 21    0018*M     db 23,27,0x21
0422E0 10 00       0019*M     dw width ; in pixels
0422E2 10 00       0020*M     dw height ; in pixels
0422E4 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0422E5             0103*  	LOADBMPBUFFER2 BUF_SEEKER_014,16,16,"src/rgba2/seeker_014.rgba2"
0422E5             0001*M 
0422E5             0002*M     ; Clear buffer
0422E5 17 00 A0    0003*M     db 23,0,0xA0
0422E8 22 01       0004*M     dw bufferId
0422EA 02          0005*M     db 2
0422EB             0006*M 
0422EB 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0422EE 22 01       0008*M     dw bufferId
0422F0             0009*M 
0422F0             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0422F0 17 00 A0    0011*M     db 23,0,0xA0
0422F3 22 01       0012*M     dw bufferId
0422F5 00          0013*M     db 0
0422F6 00 01       0014*M 	dw width * height ; length of data in bytes
0422F8 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 F3 
       E2 00 DB DB 
       DF FF 00 00 
       00 00 00 F3 
       00 00 FF F7 
       E1 00 E7 DF 
       DF EF 00 00 
       00 00 E2 E6 
       E6 00 E3 E2 
       E0 00 F0 EB 
       DB EB 00 00 
       00 00 D0 D0 
       D1 D0 E5 E2 
       E1 E5 E5 00 
       FA F5 00 00 
       DB DB 00 D0 
       D1 E1 F5 F6 
       E1 E1 E0 00 
       00 E0 E0 00 
       DB F1 00 E5 
       D0 D1 F5 FD 
       F9 E5 E1 D4 
       00 E1 E0 00 
       DF DB 00 E5 
       D0 E0 F9 FE 
       FE F8 E1 E1 
       E2 E1 E0 F5 
       DA DA 00 E0 
       D0 D4 FD FE 
       FD F8 F6 E1 
       F2 E1 E1 E1 
       FA E5 00 E0 
       E1 E1 F4 F8 
       FC F9 FA F6 
       E1 E2 E5 E2 
       00 E0 E1 F3 
       E1 E1 E4 F4 
       F5 FA FB E7 
       E1 D1 E5 FA 
       00 E1 E0 E1 
       E2 F6 D6 E6 
       F6 FA FB F6 
       E6 EA 00 FF 
       00 E0 E0 E1 
       FB E1 E2 E6 
       EA FF FF FF 
       00 EA E5 00 
       00 E1 E1 E1 
       F6 E1 E2 E1 
       EA EA FA FA 
       FA 00 00 00 
       00 00 E1 E1 
       E5 00 EA 00 
       E5 E0 E0 F5 
       00 F5 00 00 
       00 00 E2 EA 
       FE 00 EA 00 
       FA E0 F5 F5 
       00 00 00 00 
       00 00 00 FA 
       00 EA 00 00 
       00 D0 E0 00 
       00 00 00 00 
0423F8             0016*M 
0423F8             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0423F8 17 1B 21    0018*M     db 23,27,0x21
0423FB 10 00       0019*M     dw width ; in pixels
0423FD 10 00       0020*M     dw height ; in pixels
0423FF 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
042400             0104*  	LOADBMPBUFFER2 BUF_SEEKER_015,16,16,"src/rgba2/seeker_015.rgba2"
042400             0001*M 
042400             0002*M     ; Clear buffer
042400 17 00 A0    0003*M     db 23,0,0xA0
042403 23 01       0004*M     dw bufferId
042405 02          0005*M     db 2
042406             0006*M 
042406 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
042409 23 01       0008*M     dw bufferId
04240B             0009*M 
04240B             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
04240B 17 00 A0    0011*M     db 23,0,0xA0
04240E 23 01       0012*M     dw bufferId
042410 00          0013*M     db 0
042411 00 01       0014*M 	dw width * height ; length of data in bytes
042413 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 E6 00 
       F7 F2 00 00 
       EB EB EF 00 
       C3 00 00 F2 
       E2 EA 00 FB 
       FB E1 00 DB 
       DB DB EF 00 
       D7 00 00 D0 
       D1 D5 00 E2 
       E2 E0 00 00 
       00 DF EF 00 
       DB DB D6 00 
       D0 D1 E1 E5 
       E2 E1 E5 F0 
       EB DB EF 00 
       DF DF 00 FF 
       D0 D1 E1 F5 
       F2 E1 E5 E1 
       00 FA F5 00 
       DB DB DB E5 
       E5 D0 E5 FD 
       F9 E5 E0 E0 
       00 E0 E0 00 
       EA EA 00 E1 
       E0 D0 F9 FD 
       FE FD E1 E5 
       00 E1 E0 00 
       F4 E5 00 E0 
       E1 E4 F8 FD 
       FE F8 E5 E1 
       E2 E1 E1 E5 
       E0 E0 00 E2 
       E1 E1 F4 F8 
       FC F8 FA F6 
       F6 E1 E1 F5 
       00 E1 E0 E2 
       E1 E5 E5 E5 
       F5 FA EB E6 
       E1 E2 E1 E2 
       E0 E0 E1 E1 
       F6 E2 D6 E5 
       FA FB FB E6 
       E1 E9 E5 E6 
       00 E1 E1 F6 
       E6 E1 E2 EA 
       FF FF FA E2 
       EA 00 FF FE 
       00 E1 E1 E5 
       00 E6 E2 EA 
       EE FA FA 00 
       EA 00 00 00 
       00 E2 FA 00 
       00 EA 00 E5 
       E1 E0 FA FA 
       00 00 00 00 
       00 00 EA 00 
       E6 00 00 FF 
       E0 F5 E0 00 
       00 00 00 00 
       00 EA 00 00 
       00 00 E5 00 
       E0 F5 F5 00 
       00 00 00 00 
042513             0016*M 
042513             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
042513 17 1B 21    0018*M     db 23,27,0x21
042516 10 00       0019*M     dw width ; in pixels
042518 10 00       0020*M     dw height ; in pixels
04251A 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
04251B             0105*  	LOADBMPBUFFER2 BUF_SEEKER_016,16,16,"src/rgba2/seeker_016.rgba2"
04251B             0001*M 
04251B             0002*M     ; Clear buffer
04251B 17 00 A0    0003*M     db 23,0,0xA0
04251E 24 01       0004*M     dw bufferId
042520 02          0005*M     db 2
042521             0006*M 
042521 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
042524 24 01       0008*M     dw bufferId
042526             0009*M 
042526             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
042526 17 00 A0    0011*M     db 23,0,0xA0
042529 24 01       0012*M     dw bufferId
04252B 00          0013*M     db 0
04252C 00 01       0014*M 	dw width * height ; length of data in bytes
04252E 00 C3 00 00 0015*M     incbin file ; bitmap data
       00 F3 00 00 
       00 00 F3 00 
       00 00 C3 00 
       00 D7 00 00 
       00 D1 E6 00 
       00 FB E2 00 
       00 00 EB 00 
       DB DB DB 00 
       00 D0 D1 00 
       00 E2 E1 00 
       00 DB DB EF 
       00 DF 00 00 
       00 D0 D1 E1 
       F5 E2 E1 00 
       00 00 DF 00 
       DB DB DB 00 
       E5 D0 D1 F5 
       F5 E2 E1 E5 
       00 DB DB EF 
       00 EA 00 00 
       E1 D0 E1 F9 
       FD F5 E1 E1 
       00 00 FA 00 
       00 E1 00 00 
       E1 D0 F9 FD 
       FE FD E1 E1 
       00 00 E1 00 
       00 E1 00 00 
       E1 E1 F8 FD 
       FE FC E1 E1 
       00 00 E1 00 
       00 E1 E1 E2 
       E1 E1 F4 F8 
       FC F8 F6 E1 
       E2 E1 E1 00 
       E1 E1 E1 00 
       F6 D5 E5 F5 
       F5 FA EA F6 
       00 E1 E1 F5 
       E1 E1 F6 F7 
       E1 D7 E6 F6 
       FA FB EB E1 
       E2 F6 E1 F6 
       E2 E1 E5 00 
       E1 E2 E5 EB 
       FF FB F6 E1 
       00 E5 E2 F6 
       00 EA 00 00 
       EA 00 EA EE 
       FF FF 00 EA 
       00 00 FA 00 
       00 00 00 00 
       00 00 E5 E1 
       F5 FA 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 E1 
       F5 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 E1 
       F5 00 00 00 
       00 00 00 00 
04262E             0016*M 
04262E             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
04262E 17 1B 21    0018*M     db 23,27,0x21
042631 10 00       0019*M     dw width ; in pixels
042633 10 00       0020*M     dw height ; in pixels
042635 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
042636             0106*  	LOADBMPBUFFER2 BUF_SEEKER_017,16,16,"src/rgba2/seeker_017.rgba2"
042636             0001*M 
042636             0002*M     ; Clear buffer
042636 17 00 A0    0003*M     db 23,0,0xA0
042639 25 01       0004*M     dw bufferId
04263B 02          0005*M     db 2
04263C             0006*M 
04263C 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
04263F 25 01       0008*M     dw bufferId
042641             0009*M 
042641             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
042641 17 00 A0    0011*M     db 23,0,0xA0
042644 25 01       0012*M     dw bufferId
042646 00          0013*M     db 0
042647 00 01       0014*M 	dw width * height ; length of data in bytes
042649 00 DB DB D7 0015*M     incbin file ; bitmap data
       00 00 E2 E2 
       00 E6 00 00 
       00 00 00 00 
       00 EB DB DB 
       DB 00 C0 E6 
       E6 00 FF F3 
       F2 00 00 C3 
       00 DB DF 00 
       00 00 D0 D1 
       D1 00 E7 E2 
       E1 00 00 E7 
       00 DB DB EB 
       F0 E5 D0 D1 
       E1 E1 E2 E0 
       00 D6 DB DB 
       00 F5 F5 00 
       E1 E5 D0 E1 
       F5 F6 E2 E4 
       FF 00 DF DF 
       00 E0 E0 00 
       E0 D0 D0 E5 
       FD F5 E1 E5 
       E5 DB DB DF 
       00 E1 E0 00 
       E1 D1 E4 FD 
       FE FD E5 E0 
       E1 00 EB EB 
       E0 E1 E1 E2 
       E1 E1 F4 FD 
       FE FD E1 E1 
       E0 00 E5 F5 
       E1 E1 E1 F2 
       E5 E5 F4 F8 
       FC F8 E5 E1 
       E2 00 E0 D0 
       E1 E1 F6 F6 
       E2 D6 E5 F5 
       F9 FA F6 E1 
       E2 E1 E0 00 
       E6 E5 E9 E1 
       E2 E6 E6 FA 
       FB EB E6 F1 
       E1 E1 E4 F5 
       EA FF 00 EA 
       E2 E5 EA FF 
       FB FB E2 E1 
       E2 E1 E1 00 
       00 00 00 EA 
       00 E5 EA FF 
       FF F6 E6 00 
       E5 E1 F2 00 
       00 00 00 00 
       E5 E5 E0 F5 
       FA 00 EA 00 
       00 FA E6 00 
       00 00 00 00 
       00 D0 E5 F5 
       FF 00 00 EA 
       00 FA 00 00 
       00 00 00 00 
       00 E0 F5 F5 
       00 FA 00 00 
       00 00 FA 00 
042749             0016*M 
042749             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
042749 17 1B 21    0018*M     db 23,27,0x21
04274C 10 00       0019*M     dw width ; in pixels
04274E 10 00       0020*M     dw height ; in pixels
042750 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
042751             0107*  	LOADBMPBUFFER2 BUF_SEEKER_018,16,16,"src/rgba2/seeker_018.rgba2"
042751             0001*M 
042751             0002*M     ; Clear buffer
042751 17 00 A0    0003*M     db 23,0,0xA0
042754 26 01       0004*M     dw bufferId
042756 02          0005*M     db 2
042757             0006*M 
042757 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
04275A 26 01       0008*M     dw bufferId
04275C             0009*M 
04275C             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
04275C 17 00 A0    0011*M     db 23,0,0xA0
04275F 26 01       0012*M     dw bufferId
042761 00          0013*M     db 0
042762 00 01       0014*M 	dw width * height ; length of data in bytes
042764 00 00 E7 DB 0015*M     incbin file ; bitmap data
       DB EB 00 D1 
       E2 00 00 00 
       00 00 00 00 
       00 00 DB DF 
       DF E7 00 D0 
       E5 E6 00 00 
       F2 00 00 00 
       00 00 DA DB 
       EB F0 00 D0 
       D1 D2 00 FB 
       F7 F2 00 00 
       00 00 E5 EA 
       00 E5 E5 D0 
       D1 E0 E1 E2 
       E1 E1 00 00 
       00 E0 E0 00 
       00 E0 D0 D1 
       E1 F5 F2 E2 
       E0 00 DB DB 
       00 E1 E0 00 
       E4 E1 D0 E5 
       F9 F9 E2 E1 
       E5 00 F1 DB 
       E1 E0 E1 E2 
       E1 E1 E4 FD 
       FE FE E5 E1 
       E5 00 DB DF 
       E1 E1 E1 E2 
       E5 E1 F4 FD 
       FE FD E5 E0 
       E0 00 EB DB 
       E1 E5 F6 F6 
       E6 E5 F4 F8 
       FC F8 E1 E1 
       E4 00 F5 FA 
       EA E5 F7 E1 
       E2 E6 E5 F5 
       F9 F9 E5 E1 
       F3 E0 E0 00 
       FA 00 EA E6 
       E2 E5 FA FA 
       FB EB F6 E2 
       E2 E1 E0 00 
       00 E5 EA 00 
       D5 EA FF FF 
       FB E7 E1 E2 
       E1 E0 E1 00 
       00 00 00 E5 
       E5 E5 FA FF 
       F6 E2 E1 E6 
       E1 E1 F5 00 
       00 00 D0 00 
       E1 E0 F5 FA 
       00 EA 00 E5 
       E1 E2 00 00 
       00 00 00 00 
       E0 F5 F1 FF 
       00 FA 00 FF 
       FA F6 00 00 
       00 00 00 00 
       00 F5 E1 00 
       00 00 FA 00 
       FE 00 00 00 
042864             0016*M 
042864             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
042864 17 1B 21    0018*M     db 23,27,0x21
042867 10 00       0019*M     dw width ; in pixels
042869 10 00       0020*M     dw height ; in pixels
04286B 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
04286C             0108*  	LOADBMPBUFFER2 BUF_SEEKER_019,16,16,"src/rgba2/seeker_019.rgba2"
04286C             0001*M 
04286C             0002*M     ; Clear buffer
04286C 17 00 A0    0003*M     db 23,0,0xA0
04286F 27 01       0004*M     dw bufferId
042871 02          0005*M     db 2
042872             0006*M 
042872 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
042875 27 01       0008*M     dw bufferId
042877             0009*M 
042877             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
042877 17 00 A0    0011*M     db 23,0,0xA0
04287A 27 01       0012*M     dw bufferId
04287C 00          0013*M     db 0
04287D 00 01       0014*M 	dw width * height ; length of data in bytes
04287F 00 00 00 EB 0015*M     incbin file ; bitmap data
       DF DF DB DB 
       00 E2 F3 00 
       00 00 00 00 
       00 00 00 DB 
       DA DB 00 00 
       D0 D1 E6 00 
       F7 00 00 00 
       00 00 00 E5 
       EA DB F0 E5 
       D0 D1 E6 00 
       FF 00 00 00 
       00 00 E0 E0 
       00 00 E5 E5 
       D1 D1 E0 00 
       FB F7 F3 00 
       00 E0 E1 E0 
       00 E1 E0 D0 
       D1 E1 F5 E2 
       E2 E1 E2 00 
       E1 E0 E1 E1 
       E2 E1 D0 E4 
       E5 F9 F6 E2 
       E1 E0 00 C6 
       E1 E1 E1 E1 
       E1 E1 E4 FD 
       FD FD F5 E1 
       E5 FF D6 DB 
       E5 F5 F6 F6 
       F6 E5 F4 F8 
       FE FE F9 E0 
       E5 F0 E7 DF 
       EA C4 D1 E1 
       D6 E6 E5 F8 
       FC FC E1 E1 
       E0 00 DB CB 
       00 00 EA E2 
       E2 E6 F5 F5 
       F9 F9 E1 E1 
       00 00 FA EB 
       F5 00 FE 00 
       E5 EA FA FB 
       FB E6 E1 E2 
       00 E0 E1 00 
       00 00 00 E5 
       EA FF FF FB 
       EB E6 F1 E2 
       E1 E1 E0 00 
       00 00 00 E5 
       E0 F5 FF F6 
       E2 E1 E2 E1 
       E1 E0 00 00 
       00 00 00 E0 
       F5 F5 FA 00 
       FA 00 E5 E1 
       E1 F5 00 00 
       00 00 00 F5 
       F5 00 FF 00 
       EA 00 E5 E2 
       F6 00 00 00 
       00 00 00 00 
       00 00 FA 00 
       F5 00 FF FA 
       F7 00 00 00 
04297F             0016*M 
04297F             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
04297F 17 1B 21    0018*M     db 23,27,0x21
042982 10 00       0019*M     dw width ; in pixels
042984 10 00       0020*M     dw height ; in pixels
042986 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
042987             0109*  	LOADBMPBUFFER2 BUF_SEEKER_020,16,16,"src/rgba2/seeker_020.rgba2"
042987             0001*M 
042987             0002*M     ; Clear buffer
042987 17 00 A0    0003*M     db 23,0,0xA0
04298A 28 01       0004*M     dw bufferId
04298C 02          0005*M     db 2
04298D             0006*M 
04298D 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
042990 28 01       0008*M     dw bufferId
042992             0009*M 
042992             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
042992 17 00 A0    0011*M     db 23,0,0xA0
042995 28 01       0012*M     dw bufferId
042997 00          0013*M     db 0
042998 00 01       0014*M 	dw width * height ; length of data in bytes
04299A 00 00 00 00 0015*M     incbin file ; bitmap data
       DB DB DF DB 
       EB 00 00 F3 
       00 00 00 00 
       00 00 00 00 
       F5 EA DB 00 
       00 00 C0 E2 
       00 00 00 00 
       00 00 00 E0 
       E0 F0 00 F0 
       E5 D0 D1 E6 
       EA E6 00 00 
       00 E0 E0 E1 
       E1 00 E1 E5 
       D5 D1 D1 D2 
       00 FF 00 00 
       E1 E1 E1 E1 
       E2 E4 E1 D0 
       D0 D1 E1 E4 
       E3 FB F7 F3 
       E1 E1 E1 E1 
       E2 E1 E1 D4 
       E5 E5 F5 F5 
       E2 F2 E1 00 
       EA E5 F6 F6 
       F6 E1 E4 F8 
       FD FD F9 E2 
       E1 E0 00 00 
       00 00 D0 E1 
       E2 E5 F4 F8 
       FE FE F9 E1 
       E5 E5 00 EB 
       EA EA EA E2 
       E7 E6 E5 F8 
       FD FC E5 E0 
       E5 F0 00 DB 
       00 00 00 D1 
       E5 EA F5 F5 
       F8 F5 E1 E1 
       E1 00 DB DF 
       00 00 E5 EA 
       EE FF FB FB 
       FA F6 E1 D4 
       00 F0 EB DB 
       00 00 E5 E0 
       EA FF FB FB 
       EA F6 E2 E2 
       E0 E0 F5 EF 
       00 E0 E0 F1 
       F5 FF FB E2 
       E1 E2 E1 E1 
       E1 E0 00 00 
       00 00 F5 F5 
       F6 FA 00 EA 
       D0 E6 F1 E1 
       E0 00 00 00 
       00 00 00 F5 
       00 00 00 EA 
       00 E5 E1 E1 
       F5 00 00 00 
       00 00 00 00 
       00 00 00 FA 
       00 FA E2 F6 
       00 00 00 00 
042A9A             0016*M 
042A9A             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
042A9A 17 1B 21    0018*M     db 23,27,0x21
042A9D 10 00       0019*M     dw width ; in pixels
042A9F 10 00       0020*M     dw height ; in pixels
042AA1 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
042AA2             0110*  	LOADBMPBUFFER2 BUF_SEEKER_021,16,16,"src/rgba2/seeker_021.rgba2"
042AA2             0001*M 
042AA2             0002*M     ; Clear buffer
042AA2 17 00 A0    0003*M     db 23,0,0xA0
042AA5 29 01       0004*M     dw bufferId
042AA7 02          0005*M     db 2
042AA8             0006*M 
042AA8 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
042AAB 29 01       0008*M     dw bufferId
042AAD             0009*M 
042AAD             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
042AAD 17 00 A0    0011*M     db 23,0,0xA0
042AB0 29 01       0012*M     dw bufferId
042AB2 00          0013*M     db 0
042AB3 00 01       0014*M 	dw width * height ; length of data in bytes
042AB5 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 EA CB 
       DF DB DB 00 
       00 00 00 00 
       00 00 00 00 
       E0 E1 E6 DB 
       E7 D6 00 D1 
       F2 00 00 00 
       00 00 E1 E0 
       E1 E0 00 00 
       F0 FF D0 D0 
       E6 00 00 00 
       E2 E1 E1 E1 
       E0 00 00 E0 
       E5 D5 D0 D1 
       E6 EA E6 00 
       E6 E1 E1 E1 
       E1 E2 E1 E0 
       D0 D0 D1 D1 
       00 00 00 00 
       EA E5 E6 F7 
       F6 E1 E1 E4 
       E4 E1 E1 F5 
       E4 F7 FB F3 
       00 00 00 E1 
       E2 E5 E0 F8 
       FD FD F9 F6 
       E2 E2 E2 F2 
       F5 EA FA E2 
       D7 E6 F4 F8 
       FE FE F9 E2 
       E1 E0 E0 00 
       00 00 00 E1 
       E5 E5 F5 F8 
       FD FD E9 E1 
       E5 E5 00 DB 
       E5 E6 E5 EA 
       EA FA F6 F9 
       F8 F4 E1 E0 
       E5 F0 00 DB 
       00 00 E1 E5 
       FF FF FB FB 
       FA E1 E1 E1 
       00 DB DB DF 
       00 E0 F5 E0 
       FF FB FB EB 
       F6 E1 E2 00 
       00 EA DA DF 
       00 F5 F5 F5 
       FA 00 E2 E1 
       E1 E2 E2 E1 
       E0 F5 EF FF 
       00 00 00 00 
       00 EA EA D1 
       E2 E1 E1 E1 
       E0 00 00 00 
       00 00 00 00 
       00 00 00 C8 
       F6 E1 E1 E1 
       00 00 00 00 
       00 00 00 00 
       00 F5 00 FA 
       E6 E2 F5 00 
       00 00 00 00 
042BB5             0016*M 
042BB5             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
042BB5 17 1B 21    0018*M     db 23,27,0x21
042BB8 10 00       0019*M     dw width ; in pixels
042BBA 10 00       0020*M     dw height ; in pixels
042BBC 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
042BBD             0111*  	LOADBMPBUFFER2 BUF_SEEKER_022,16,16,"src/rgba2/seeker_022.rgba2"
042BBD             0001*M 
042BBD             0002*M     ; Clear buffer
042BBD 17 00 A0    0003*M     db 23,0,0xA0
042BC0 2A 01       0004*M     dw bufferId
042BC2 02          0005*M     db 2
042BC3             0006*M 
042BC3 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
042BC6 2A 01       0008*M     dw bufferId
042BC8             0009*M 
042BC8             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
042BC8 17 00 A0    0011*M     db 23,0,0xA0
042BCB 2A 01       0012*M     dw bufferId
042BCD 00          0013*M     db 0
042BCE 00 01       0014*M 	dw width * height ; length of data in bytes
042BD0 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 FA 
       DA DF DB DB 
       00 00 00 00 
       00 00 00 E1 
       E0 E1 E0 E5 
       DA DB F1 DB 
       00 00 00 00 
       00 E2 E1 E1 
       E0 E0 E1 00 
       00 00 00 00 
       D0 E2 00 00 
       FA EA E1 E1 
       E1 E1 F3 E0 
       E0 E5 E5 D0 
       D0 E6 F3 00 
       00 FE E5 F6 
       FB E2 E1 E1 
       D0 D0 D0 D1 
       D1 E6 00 00 
       EA 00 00 E1 
       E1 F6 E1 E1 
       D4 E0 D1 E1 
       D0 00 00 00 
       00 EA EA E2 
       E2 D6 E4 F4 
       FD F9 F5 F5 
       E5 E3 FF 00 
       00 00 00 E1 
       E6 E6 F4 F8 
       FE FE FD F6 
       E2 E2 F7 F3 
       00 FA E5 EA 
       EA F6 F5 FC 
       FD FE F9 E1 
       E1 E0 E1 E2 
       D0 E0 E0 EA 
       FF FA FA F9 
       F8 F8 E5 E1 
       E5 00 00 00 
       E0 F5 E0 FA 
       FF FB FB FA 
       F6 E1 E1 E0 
       E5 F0 E7 DB 
       00 F5 F5 FA 
       FF F6 E7 F6 
       E1 E1 D4 00 
       00 EB DF DB 
       00 00 00 FA 
       00 E6 E1 E1 
       F2 E2 00 00 
       FA DB DF DF 
       00 00 F5 00 
       EA EA D1 E2 
       E1 E1 E1 E0 
       F5 EB EF FF 
       00 00 00 00 
       E5 00 E5 E5 
       E1 E0 E0 E0 
       00 00 00 00 
       00 00 00 00 
       00 FF FA E2 
       E1 F5 00 00 
       00 00 00 00 
042CD0             0016*M 
042CD0             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
042CD0 17 1B 21    0018*M     db 23,27,0x21
042CD3 10 00       0019*M     dw width ; in pixels
042CD5 10 00       0020*M     dw height ; in pixels
042CD7 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
042CD8             0112*  	LOADBMPBUFFER2 BUF_SEEKER_023,16,16,"src/rgba2/seeker_023.rgba2"
042CD8             0001*M 
042CD8             0002*M     ; Clear buffer
042CD8 17 00 A0    0003*M     db 23,0,0xA0
042CDB 2B 01       0004*M     dw bufferId
042CDD 02          0005*M     db 2
042CDE             0006*M 
042CDE 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
042CE1 2B 01       0008*M     dw bufferId
042CE3             0009*M 
042CE3             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
042CE3 17 00 A0    0011*M     db 23,0,0xA0
042CE6 2B 01       0012*M     dw bufferId
042CE8 00          0013*M     db 0
042CE9 00 01       0014*M 	dw width * height ; length of data in bytes
042CEB 00 00 00 00 0015*M     incbin file ; bitmap data
       00 E0 00 E0 
       F4 EA DB DF 
       DB D7 C3 00 
       EA 00 E2 E1 
       E1 E0 E1 E0 
       E5 EA DB DF 
       DB 00 00 00 
       00 EA FA E1 
       E1 E1 E0 00 
       00 00 DB 00 
       D6 00 00 00 
       00 00 00 E5 
       F6 E1 E2 E2 
       E0 E1 E5 FF 
       00 D0 F2 00 
       00 E6 00 00 
       E6 F6 E1 E1 
       E1 E0 E5 D0 
       D0 D1 E2 00 
       00 00 EA E6 
       E1 E2 E5 E1 
       E4 D0 D0 D1 
       D1 D5 EA 00 
       E5 00 00 E2 
       E2 D6 E5 F4 
       F8 F9 E5 E1 
       E1 00 00 E6 
       00 FF E5 EA 
       EA E5 E5 F8 
       FD FD FD F5 
       E5 E2 FB 00 
       E0 E0 E1 EE 
       FF FA F5 FC 
       FE FE F9 F2 
       E2 E2 FB F7 
       F5 F5 E0 FA 
       FF FB FA F8 
       F8 FD E5 E1 
       E1 E0 E1 F2 
       F5 E0 FA FA 
       FA FB EB FA 
       E5 E1 E0 E5 
       E5 00 00 00 
       00 00 FA 00 
       E2 E6 E6 F6 
       E1 E5 E0 E1 
       F0 00 DB 00 
       00 00 00 EA 
       EA E1 E1 F6 
       E2 00 00 00 
       EB 00 DB EB 
       00 00 00 00 
       00 E9 E2 E1 
       E1 E1 E0 FA 
       DB DF DB EB 
       00 00 00 00 
       FF E5 E1 E1 
       E1 E0 E0 F5 
       EF EF EF EF 
       00 00 00 00 
       FE E6 E2 F5 
       E5 00 00 00 
       00 00 00 00 
042DEB             0016*M 
042DEB             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
042DEB 17 1B 21    0018*M     db 23,27,0x21
042DEE 10 00       0019*M     dw width ; in pixels
042DF0 10 00       0020*M     dw height ; in pixels
042DF2 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
042DF3             0113*  	LOADBMPBUFFER2 BUF_SEEKER_024,16,16,"src/rgba2/seeker_024.rgba2"
042DF3             0001*M 
042DF3             0002*M     ; Clear buffer
042DF3 17 00 A0    0003*M     db 23,0,0xA0
042DF6 2C 01       0004*M     dw bufferId
042DF8 02          0005*M     db 2
042DF9             0006*M 
042DF9 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
042DFC 2C 01       0008*M     dw bufferId
042DFE             0009*M 
042DFE             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
042DFE 17 00 A0    0011*M     db 23,0,0xA0
042E01 2C 01       0012*M     dw bufferId
042E03 00          0013*M     db 0
042E04 00 01       0014*M 	dw width * height ; length of data in bytes
042E06 00 00 00 00 0015*M     incbin file ; bitmap data
       E2 E1 E1 00 
       00 00 00 DB 
       00 DB 00 00 
       00 00 00 EA 
       E1 E1 E1 E1 
       E1 E1 EA DB 
       DF DB D7 C3 
       00 00 00 00 
       E5 F6 E1 E1 
       00 00 00 DB 
       00 DB 00 00 
       00 00 00 00 
       00 F7 00 E2 
       00 00 00 00 
       00 00 00 00 
       00 00 00 EA 
       E1 E1 F6 E1 
       E1 E1 E1 E5 
       00 00 00 00 
       00 00 00 00 
       E2 D7 D5 E1 
       E1 D0 D0 D0 
       D0 D0 D1 F3 
       00 00 E5 EA 
       E5 E6 E5 F4 
       F8 F9 E1 D1 
       D1 D1 E6 00 
       E1 E1 E1 EE 
       EB F6 F5 F8 
       FD FD F9 F5 
       E1 00 00 00 
       F5 F5 F5 FF 
       FF FA F5 FC 
       FE FE FD F5 
       F5 00 00 00 
       00 00 FA FF 
       FB FB FA F8 
       FC FD F5 E2 
       E2 E2 FB 00 
       00 00 00 00 
       F6 EB EA F6 
       E1 E1 E1 E1 
       E1 E1 E2 F3 
       00 00 00 EA 
       E1 E1 F6 E1 
       E1 E1 E1 E5 
       00 00 00 00 
       00 00 00 00 
       00 E2 00 E2 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       E5 F6 E1 E1 
       00 00 00 DB 
       00 DB 00 00 
       00 00 00 FA 
       E2 E1 E1 E1 
       E1 E1 FA DB 
       DF DB EB C3 
       00 00 00 00 
       F6 F6 F5 00 
       00 00 00 EF 
       00 EF 00 00 
042F06             0016*M 
042F06             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
042F06 17 1B 21    0018*M     db 23,27,0x21
042F09 10 00       0019*M     dw width ; in pixels
042F0B 10 00       0020*M     dw height ; in pixels
042F0D 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
042F0E             0114*  	LOADBMPBUFFER2 BUF_SEEKER_025,16,16,"src/rgba2/seeker_025.rgba2"
042F0E             0001*M 
042F0E             0002*M     ; Clear buffer
042F0E 17 00 A0    0003*M     db 23,0,0xA0
042F11 2D 01       0004*M     dw bufferId
042F13 02          0005*M     db 2
042F14             0006*M 
042F14 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
042F17 2D 01       0008*M     dw bufferId
042F19             0009*M 
042F19             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
042F19 17 00 A0    0011*M     db 23,0,0xA0
042F1C 2D 01       0012*M     dw bufferId
042F1E 00          0013*M     db 0
042F1F 00 01       0014*M 	dw width * height ; length of data in bytes
042F21 00 00 00 00 0015*M     incbin file ; bitmap data
       EA E6 E1 E1 
       E0 00 00 00 
       00 00 00 00 
       00 00 00 00 
       FF E5 E1 E1 
       E1 E1 E0 F5 
       DB DB EB DB 
       00 00 00 00 
       00 E9 F6 E1 
       E1 E0 E0 F5 
       DB DF DB DB 
       00 00 00 EA 
       EA E1 F6 F2 
       E2 00 00 00 
       EB 00 DB D7 
       00 00 E5 00 
       E2 E2 E2 E5 
       E1 E1 E0 E1 
       F0 00 DB 00 
       E0 D0 E5 E5 
       E5 E6 D6 E5 
       E1 D1 D0 E5 
       E5 00 00 00 
       F5 E5 E0 EA 
       EA E6 E5 F4 
       F4 E4 D0 D0 
       D0 D0 C0 E2 
       F5 F5 F5 FF 
       FF FA F5 F8 
       FD FD E5 E1 
       D1 D1 E6 E2 
       00 FF FA FF 
       FB FB F9 FC 
       FE FE FD F5 
       E1 D1 E6 00 
       FA 00 00 F6 
       FB EB FA F8 
       FD FD F5 F6 
       E1 00 00 E6 
       00 00 EA E6 
       E2 E6 F6 E5 
       E1 E5 E1 E2 
       E2 E7 FF 00 
       00 EA 00 00 
       E1 F1 E1 E1 
       E1 E0 E5 E4 
       E0 E2 F3 00 
       00 00 00 E5 
       E2 E1 E2 E2 
       E0 E1 E5 FF 
       00 E1 F2 00 
       00 FA FA E1 
       E1 E1 E1 00 
       00 00 DB 00 
       D6 00 00 00 
       FA 00 E6 F2 
       E1 E4 E0 E0 
       E5 EB DB DF 
       DB 00 00 00 
       00 00 00 00 
       00 F5 00 D0 
       F5 EB DF DF 
       DB E7 C3 00 
043021             0016*M 
043021             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
043021 17 1B 21    0018*M     db 23,27,0x21
043024 10 00       0019*M     dw width ; in pixels
043026 10 00       0020*M     dw height ; in pixels
043028 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
043029             0115*  	LOADBMPBUFFER2 BUF_SEEKER_026,16,16,"src/rgba2/seeker_026.rgba2"
043029             0001*M 
043029             0002*M     ; Clear buffer
043029 17 00 A0    0003*M     db 23,0,0xA0
04302C 2E 01       0004*M     dw bufferId
04302E 02          0005*M     db 2
04302F             0006*M 
04302F 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
043032 2E 01       0008*M     dw bufferId
043034             0009*M 
043034             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
043034 17 00 A0    0011*M     db 23,0,0xA0
043037 2E 01       0012*M     dw bufferId
043039 00          0013*M     db 0
04303A 00 01       0014*M 	dw width * height ; length of data in bytes
04303C 00 00 00 00 0015*M     incbin file ; bitmap data
       00 FA EA E1 
       E1 E1 00 00 
       00 00 00 00 
       00 00 00 00 
       E5 00 E5 E5 
       E1 E0 E1 E0 
       00 00 00 00 
       00 00 D0 00 
       EA EA F7 F6 
       E1 E1 E0 E0 
       E5 DA DB E7 
       00 00 00 E5 
       00 E6 E1 F6 
       E2 E2 00 00 
       EA DB DF DB 
       00 E0 E1 E5 
       D5 E2 E2 E6 
       E5 E1 E4 00 
       00 EB DF DB 
       F5 F5 E0 E5 
       EA E5 E6 E5 
       E1 E1 E1 E0 
       E5 F0 E7 EB 
       E1 F1 F5 FA 
       FF FA E5 F4 
       F4 E4 D0 D0 
       E5 00 00 00 
       00 FF FA FF 
       FF FA F5 F8 
       FD FD E5 D1 
       D0 D0 D0 D1 
       00 00 00 F6 
       FB FB F9 FC 
       FE FE F9 E1 
       D1 D1 E5 E2 
       00 FA EA E2 
       E7 EB F9 F8 
       FD FE F9 F5 
       E0 D2 E6 00 
       FA 00 00 E1 
       E1 F6 E5 E1 
       E5 E5 E2 F2 
       E1 00 00 00 
       00 FF E5 E6 
       E2 E2 E1 E1 
       E0 E1 E1 E2 
       E2 FB 00 00 
       FE FA E1 E1 
       E1 E2 F3 E4 
       E0 E5 E5 E0 
       E1 F7 F2 00 
       00 F6 E2 E1 
       E0 E1 E0 00 
       00 00 00 00 
       E1 F2 00 00 
       00 00 00 F5 
       E1 E0 E0 F5 
       EB DB F1 DB 
       00 00 00 00 
       00 00 00 00 
       00 00 00 FA 
       DB DF DB DB 
       00 00 00 00 
04313C             0016*M 
04313C             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
04313C 17 1B 21    0018*M     db 23,27,0x21
04313F 10 00       0019*M     dw width ; in pixels
043141 10 00       0020*M     dw height ; in pixels
043143 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
043144             0116*  	LOADBMPBUFFER2 BUF_SEEKER_027,16,16,"src/rgba2/seeker_027.rgba2"
043144             0001*M 
043144             0002*M     ; Clear buffer
043144 17 00 A0    0003*M     db 23,0,0xA0
043147 2F 01       0004*M     dw bufferId
043149 02          0005*M     db 2
04314A             0006*M 
04314A 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
04314D 2F 01       0008*M     dw bufferId
04314F             0009*M 
04314F             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
04314F 17 00 A0    0011*M     db 23,0,0xA0
043152 2F 01       0012*M     dw bufferId
043154 00          0013*M     db 0
043155 00 01       0014*M 	dw width * height ; length of data in bytes
043157 00 00 00 00 0015*M     incbin file ; bitmap data
       00 F5 00 EA 
       E5 E1 E1 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 C4 
       F5 E1 E0 E0 
       00 00 00 00 
       00 00 00 00 
       00 FE EA D1 
       F6 E1 E1 E1 
       E0 00 00 00 
       00 F5 E0 E5 
       E5 00 E2 E1 
       F6 E1 E1 E0 
       E0 E5 DB EB 
       00 F5 F5 E0 
       EA E5 E2 D6 
       F6 E1 E2 00 
       00 EA DA DF 
       00 00 F5 F5 
       FF EA E6 E6 
       E5 E1 E1 E1 
       00 DB DB DF 
       FA FF FA FF 
       FF FA F5 E5 
       F4 E4 D0 E0 
       E5 F0 00 DB 
       00 00 00 F6 
       FB FB F5 F8 
       F8 FD E4 D0 
       E5 E5 00 DB 
       F5 EA FA E2 
       EB FB F9 FC 
       FE FD E5 D1 
       D1 D0 D0 00 
       00 00 00 E1 
       E6 E6 F9 FC 
       FE FD F9 E1 
       D1 D1 D1 E2 
       FF E5 E5 E2 
       F1 E1 E1 E1 
       F9 F5 F6 F5 
       E0 E6 E6 F3 
       FA E2 E1 E1 
       E2 E2 E1 E1 
       E0 E1 E2 E2 
       00 00 00 00 
       F7 F6 E1 E1 
       E1 00 00 E0 
       E5 E5 E1 E2 
       FB FF F7 00 
       00 00 F5 E0 
       E1 E0 00 00 
       F0 FF E0 E1 
       F7 00 00 00 
       00 00 00 00 
       E0 E1 FA DB 
       E7 D6 00 E2 
       F3 00 00 00 
       00 00 00 00 
       00 00 EB CB 
       DF DB C6 00 
       00 00 00 00 
043257             0016*M 
043257             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
043257 17 1B 21    0018*M     db 23,27,0x21
04325A 10 00       0019*M     dw width ; in pixels
04325C 10 00       0020*M     dw height ; in pixels
04325E 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
04325F             0117*  	LOADBMPBUFFER2 BUF_SEEKER_028,16,16,"src/rgba2/seeker_028.rgba2"
04325F             0001*M 
04325F             0002*M     ; Clear buffer
04325F 17 00 A0    0003*M     db 23,0,0xA0
043262 30 01       0004*M     dw bufferId
043264 02          0005*M     db 2
043265             0006*M 
043265 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
043268 30 01       0008*M     dw bufferId
04326A             0009*M 
04326A             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
04326A 17 00 A0    0011*M     db 23,0,0xA0
04326D 30 01       0012*M     dw bufferId
04326F 00          0013*M     db 0
043270 00 01       0014*M 	dw width * height ; length of data in bytes
043272 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 EA 
       00 EA E1 E1 
       00 00 00 00 
       00 00 00 E0 
       00 00 00 EA 
       00 E5 E1 E1 
       E0 00 00 00 
       00 00 F5 E0 
       E5 E5 00 EA 
       D0 F6 E1 E1 
       E0 00 00 00 
       00 F5 F5 F1 
       E0 EA D1 E2 
       E1 F6 E1 E1 
       E1 E0 00 00 
       00 00 F6 F5 
       EA EE E5 E7 
       E2 F6 E2 E2 
       E1 E0 F5 DB 
       00 00 FA FF 
       FF FF EA E6 
       E5 E1 E1 E4 
       00 F0 EA DB 
       00 00 00 FB 
       FB FB F5 E5 
       F4 E4 E1 E1 
       E1 00 DB DF 
       FA EA EA E2 
       FB FB F5 F8 
       F8 F8 D4 D0 
       E5 F0 00 DB 
       00 00 D0 E1 
       EA FA F8 FD 
       FE FD E5 D0 
       D5 E5 00 EB 
       FA E5 E6 E2 
       F6 F6 F5 FC 
       FE FD E5 D1 
       D1 D0 00 00 
       E2 E1 F1 E1 
       E2 E1 E1 E5 
       F9 F9 F5 E1 
       D1 D1 C0 00 
       F6 E1 E1 E1 
       E2 D4 E1 E0 
       E1 E2 F5 E4 
       D2 E6 E2 F3 
       00 F5 E0 E1 
       E0 00 E1 E5 
       E5 E1 E2 E3 
       00 EA 00 00 
       00 00 00 E0 
       E0 F0 00 F0 
       E5 E0 F2 FB 
       FF E6 00 00 
       00 00 00 00 
       F5 EB DB 00 
       00 00 E1 F7 
       00 00 00 00 
       00 00 00 00 
       EF DB DF DB 
       EB 00 00 F3 
       00 00 00 00 
043372             0016*M 
043372             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
043372 17 1B 21    0018*M     db 23,27,0x21
043375 10 00       0019*M     dw width ; in pixels
043377 10 00       0020*M     dw height ; in pixels
043379 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
04337A             0118*  	LOADBMPBUFFER2 BUF_SEEKER_029,16,16,"src/rgba2/seeker_029.rgba2"
04337A             0001*M 
04337A             0002*M     ; Clear buffer
04337A 17 00 A0    0003*M     db 23,0,0xA0
04337D 31 01       0004*M     dw bufferId
04337F 02          0005*M     db 2
043380             0006*M 
043380 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
043383 31 01       0008*M     dw bufferId
043385             0009*M 
043385             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
043385 17 00 A0    0011*M     db 23,0,0xA0
043388 31 01       0012*M     dw bufferId
04338A 00          0013*M     db 0
04338B 00 01       0014*M 	dw width * height ; length of data in bytes
04338D 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 E5 00 
       F5 00 EA E6 
       E2 00 00 00 
       00 00 00 F5 
       E0 00 E6 00 
       EA 00 E5 E1 
       E1 00 00 00 
       00 00 00 F5 
       F5 E1 E5 00 
       FA 00 E6 E1 
       E1 E1 00 00 
       00 00 00 F5 
       E0 E5 EA E1 
       E2 E1 F7 E1 
       E1 E0 00 00 
       00 00 00 FA 
       FF FF EA E5 
       D7 E2 F6 E1 
       E0 E1 E0 00 
       F5 00 EA 00 
       FB FF FA E5 
       E6 E5 E1 E2 
       00 E0 E1 00 
       00 00 EA E2 
       FB FB F6 F5 
       F4 E0 E1 E1 
       00 00 E6 EA 
       FA C8 D1 E1 
       EB FB F9 F8 
       F8 F8 E4 E0 
       E0 00 DB CB 
       E6 F6 E2 E1 
       F6 FA F8 FD 
       FE FD E4 D0 
       E5 F0 E7 DF 
       E2 E1 E1 E2 
       E1 E1 F4 FD 
       FE FD E1 D0 
       D5 FF D6 DB 
       F5 E1 E1 E2 
       E2 E1 E1 E9 
       F9 F9 E1 D1 
       D0 D0 00 DB 
       00 E1 E1 E1 
       00 E1 E0 E1 
       E2 F6 F5 D1 
       D1 D0 D1 00 
       00 00 E0 E0 
       00 00 E5 E5 
       E1 E2 E4 00 
       E6 E6 F2 00 
       00 00 00 F5 
       EA DB F0 E5 
       E0 E2 F7 00 
       EA 00 00 00 
       00 00 00 EF 
       DA DB 00 00 
       E0 E2 FB 00 
       E6 00 00 00 
       00 00 00 FF 
       DF DF DB DB 
       00 F2 F3 00 
       00 00 00 00 
04348D             0016*M 
04348D             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
04348D 17 1B 21    0018*M     db 23,27,0x21
043490 10 00       0019*M     dw width ; in pixels
043492 10 00       0020*M     dw height ; in pixels
043494 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
043495             0119*  	LOADBMPBUFFER2 BUF_SEEKER_030,16,16,"src/rgba2/seeker_030.rgba2"
043495             0001*M 
043495             0002*M     ; Clear buffer
043495 17 00 A0    0003*M     db 23,0,0xA0
043498 32 01       0004*M     dw bufferId
04349A 02          0005*M     db 2
04349B             0006*M 
04349B 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
04349E 32 01       0008*M     dw bufferId
0434A0             0009*M 
0434A0             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0434A0 17 00 A0    0011*M     db 23,0,0xA0
0434A3 32 01       0012*M     dw bufferId
0434A5 00          0013*M     db 0
0434A6 00 01       0014*M 	dw width * height ; length of data in bytes
0434A8 00 00 00 00 0015*M     incbin file ; bitmap data
       00 E0 D0 00 
       00 00 EA 00 
       FA 00 00 00 
       00 00 00 00 
       F5 F5 E0 FA 
       00 EA 00 FE 
       EA E2 00 00 
       00 00 F5 00 
       F5 E0 E0 E5 
       00 EA 00 E5 
       E1 E1 00 00 
       00 00 00 FA 
       FA FA EA EA 
       E1 E2 E1 F6 
       E1 E1 E1 00 
       00 E5 EA 00 
       FF FF FF EA 
       E6 E2 E1 FB 
       E1 E0 E0 00 
       FF 00 EA E6 
       F6 FB FA F6 
       E6 D6 F6 E2 
       E1 E0 E1 00 
       FA E5 D1 E1 
       E7 FB FA F5 
       F4 E4 E1 E1 
       F3 E1 E0 00 
       E2 E5 E2 E1 
       F6 FA F9 FC 
       F8 F4 E1 E1 
       E0 00 E5 FA 
       E1 E1 E1 F2 
       E1 F6 F8 FD 
       FE FD D4 D0 
       E0 00 DA DA 
       F5 E0 E1 E2 
       E1 E1 F8 FE 
       FE F9 E0 D0 
       E5 00 DB DF 
       00 E0 E1 00 
       D4 E1 E5 F9 
       FD F5 D1 D0 
       E5 00 F1 DB 
       00 E0 E0 00 
       00 E0 E1 E1 
       F6 F5 E1 D1 
       D0 00 DB DB 
       00 00 F5 FA 
       00 E5 E5 E1 
       E2 E5 D0 D1 
       D0 D0 00 00 
       00 00 EB DB 
       EB F0 00 E0 
       E2 E3 00 E6 
       E6 E2 00 00 
       00 00 EF DF 
       DF E7 00 E1 
       F7 FF 00 00 
       F3 00 00 00 
       00 00 FF DF 
       DB DB 00 E2 
       F3 00 00 00 
       00 00 00 00 
0435A8             0016*M 
0435A8             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0435A8 17 1B 21    0018*M     db 23,27,0x21
0435AB 10 00       0019*M     dw width ; in pixels
0435AD 10 00       0020*M     dw height ; in pixels
0435AF 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0435B0             0120*  	LOADBMPBUFFER2 BUF_SEEKER_031,16,16,"src/rgba2/seeker_031.rgba2"
0435B0             0001*M 
0435B0             0002*M     ; Clear buffer
0435B0 17 00 A0    0003*M     db 23,0,0xA0
0435B3 33 01       0004*M     dw bufferId
0435B5 02          0005*M     db 2
0435B6             0006*M 
0435B6 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0435B9 33 01       0008*M     dw bufferId
0435BB             0009*M 
0435BB             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0435BB 17 00 A0    0011*M     db 23,0,0xA0
0435BE 33 01       0012*M     dw bufferId
0435C0 00          0013*M     db 0
0435C1 00 01       0014*M 	dw width * height ; length of data in bytes
0435C3 00 00 00 00 0015*M     incbin file ; bitmap data
       00 F5 F5 E0 
       00 E5 00 00 
       00 00 EA 00 
       00 00 00 00 
       00 E0 F5 E0 
       FF 00 00 E6 
       00 EA 00 00 
       00 00 00 00 
       FA FA E0 E1 
       E5 00 EA 00 
       00 FA E2 00 
       00 00 00 EA 
       00 FA FA EE 
       EA E2 E6 00 
       E5 E1 E1 00 
       FE FF 00 EA 
       E2 FA FF FF 
       EA E2 E1 E6 
       F6 E1 E1 00 
       E6 E5 E9 E1 
       E6 FB FB FA 
       E5 D6 E2 F6 
       E1 E1 E0 E0 
       E2 E1 E2 E1 
       E6 EB FA F5 
       E5 E5 E5 E1 
       E2 E0 E1 00 
       F5 E1 E1 F6 
       F6 FA F8 FC 
       F8 F4 E1 E1 
       E2 00 E0 E0 
       E5 E1 E1 E2 
       E1 E5 F8 FE 
       FD F8 E4 E1 
       E0 00 E5 F4 
       00 E0 E1 00 
       E5 E1 FD FE 
       FD F9 D0 E0 
       E1 00 EA EA 
       00 E0 E0 00 
       E0 E0 E5 F9 
       FD E5 D0 E5 
       E5 DB DB DB 
       00 F5 FA 00 
       E1 E5 E1 F2 
       F5 E1 D1 D0 
       FF 00 DF DF 
       00 EF DB EB 
       F0 E5 E1 E2 
       E5 E1 D1 D0 
       00 D6 DB DB 
       00 EF DF 00 
       00 00 E0 E2 
       E2 00 D5 D1 
       D0 00 00 D7 
       00 EF DB DB 
       DB 00 E1 FB 
       FB 00 EA E2 
       F2 00 00 C3 
       00 EF EB EB 
       00 00 F2 F7 
       00 E6 00 00 
       00 00 00 00 
0436C3             0016*M 
0436C3             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0436C3 17 1B 21    0018*M     db 23,27,0x21
0436C6 10 00       0019*M     dw width ; in pixels
0436C8 10 00       0020*M     dw height ; in pixels
0436CA 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0436CB             0121*  	LOADBMPBUFFER2 BUF_SHIP_0L,16,16,"src/rgba2/ship_0l.rgba2"
0436CB             0001*M 
0436CB             0002*M     ; Clear buffer
0436CB 17 00 A0    0003*M     db 23,0,0xA0
0436CE 34 01       0004*M     dw bufferId
0436D0 02          0005*M     db 2
0436D1             0006*M 
0436D1 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0436D4 34 01       0008*M     dw bufferId
0436D6             0009*M 
0436D6             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0436D6 17 00 A0    0011*M     db 23,0,0xA0
0436D9 34 01       0012*M     dw bufferId
0436DB 00          0013*M     db 0
0436DC 00 01       0014*M 	dw width * height ; length of data in bytes
0436DE 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 C6 
       C7 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 C6 CA 
       CB C7 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 D5 E5 
       CB C7 00 00 
       00 00 00 00 
       00 00 00 00 
       00 D5 FD FE 
       E5 C7 00 00 
       00 00 00 00 
       00 00 00 00 
       00 D5 FD FE 
       E5 C7 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 D5 E5 
       CB C7 00 00 
       00 00 00 00 
       00 00 00 00 
       00 C7 C6 CA 
       CB C7 DB 00 
       00 00 00 00 
       00 00 C7 00 
       C7 CA C6 CA 
       CB C7 CB DB 
       00 00 C7 00 
       00 00 C7 00 
       CA CA C6 CA 
       CB C7 CB CB 
       DB 00 C7 00 
       00 00 C7 C7 
       CA C6 C6 CA 
       CB C7 C7 CB 
       CB DB C7 00 
       00 00 C7 CA 
       C6 C6 C6 CA 
       CB C7 C7 C7 
       CB CB C7 00 
       00 00 C7 CA 
       C6 CA C6 CA 
       CB C7 CB C7 
       C7 CB C7 00 
       00 00 C7 CA 
       C7 C7 C6 CA 
       CB C7 DB DB 
       C7 CB C7 00 
       00 00 C7 00 
       00 00 C6 00 
       00 C7 00 00 
       DB CB C7 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       DB DB C7 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 C7 00 
0437DE             0016*M 
0437DE             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0437DE 17 1B 21    0018*M     db 23,27,0x21
0437E1 10 00       0019*M     dw width ; in pixels
0437E3 10 00       0020*M     dw height ; in pixels
0437E5 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
0437E6             0122*  	LOADBMPBUFFER2 BUF_SHIP_1C,16,16,"src/rgba2/ship_1c.rgba2"
0437E6             0001*M 
0437E6             0002*M     ; Clear buffer
0437E6 17 00 A0    0003*M     db 23,0,0xA0
0437E9 35 01       0004*M     dw bufferId
0437EB 02          0005*M     db 2
0437EC             0006*M 
0437EC 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
0437EF 35 01       0008*M     dw bufferId
0437F1             0009*M 
0437F1             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0437F1 17 00 A0    0011*M     db 23,0,0xA0
0437F4 35 01       0012*M     dw bufferId
0437F6 00          0013*M     db 0
0437F7 00 01       0014*M 	dw width * height ; length of data in bytes
0437F9 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 DB 
       C7 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 DB CB 
       CB C7 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 DB E9 
       E5 C7 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 E9 FE 
       FE E5 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 E9 FE 
       FE E5 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 DB E9 
       E5 C7 00 00 
       00 00 00 00 
       00 00 00 00 
       00 DB DB CB 
       CB C7 DB 00 
       00 00 00 00 
       00 DB 00 00 
       DB CB DB CB 
       CB C7 CB DB 
       00 00 C7 00 
       00 DB 00 DB 
       CB CB DB CB 
       CB C7 CB CB 
       DB 00 C7 00 
       00 DB DB CB 
       CB C7 DB CB 
       CB C7 C7 CB 
       CB DB C7 00 
       00 DB CB CB 
       C7 C7 DB CB 
       CB C7 C7 C7 
       CB CB C7 00 
       00 DB CB C7 
       C7 CB DB CB 
       CB C7 CB C7 
       C7 CB C7 00 
       00 DB CB C7 
       DB DB DB CB 
       CB C7 DB DB 
       C7 CB C7 00 
       00 DB DB DB 
       00 00 DB 00 
       00 C7 00 00 
       DB DB C7 00 
       00 DB 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 C7 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0438F9             0016*M 
0438F9             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
0438F9 17 1B 21    0018*M     db 23,27,0x21
0438FC 10 00       0019*M     dw width ; in pixels
0438FE 10 00       0020*M     dw height ; in pixels
043900 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
043901             0123*  	LOADBMPBUFFER2 BUF_SHIP_2R,16,16,"src/rgba2/ship_2r.rgba2"
043901             0001*M 
043901             0002*M     ; Clear buffer
043901 17 00 A0    0003*M     db 23,0,0xA0
043904 36 01       0004*M     dw bufferId
043906 02          0005*M     db 2
043907             0006*M 
043907 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
04390A 36 01       0008*M     dw bufferId
04390C             0009*M 
04390C             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
04390C 17 00 A0    0011*M     db 23,0,0xA0
04390F 36 01       0012*M     dw bufferId
043911 00          0013*M     db 0
043912 00 01       0014*M 	dw width * height ; length of data in bytes
043914 00 00 00 00 0015*M     incbin file ; bitmap data
       00 00 00 DB 
       C6 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 DB CB 
       CB C6 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 DB CB 
       E5 D5 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 DB E5 
       FE FD D5 00 
       00 00 00 00 
       00 00 00 00 
       00 00 DB E5 
       FE FD D5 00 
       00 00 00 00 
       00 00 00 00 
       00 00 DB CB 
       E5 D5 00 00 
       00 00 00 00 
       00 00 00 00 
       00 DB DB CB 
       CB C6 C7 00 
       00 00 00 00 
       00 DB 00 00 
       DB CB DB CB 
       CB C6 CA C7 
       00 C6 00 00 
       00 DB 00 DB 
       CB CB DB CB 
       CB C6 CA CA 
       00 C6 00 00 
       00 DB DB CB 
       CB C7 DB CB 
       CB C6 C6 CA 
       C7 C6 00 00 
       00 DB CB CB 
       C7 C7 DB CB 
       CB C6 C6 C6 
       CA C6 00 00 
       00 DB CB C7 
       C7 CB DB CB 
       CB C6 CA C6 
       CA C6 00 00 
       00 DB CB C7 
       DB DB DB CB 
       CB C6 C7 C7 
       CA C6 00 00 
       00 DB CB DB 
       00 00 DB 00 
       00 C6 00 00 
       00 C6 00 00 
       00 DB DB DB 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 DB 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
043A14             0016*M 
043A14             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
043A14 17 1B 21    0018*M     db 23,27,0x21
043A17 10 00       0019*M     dw width ; in pixels
043A19 10 00       0020*M     dw height ; in pixels
043A1B 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
043A1C             0124*  	LOADBMPBUFFER2 BUF_SHIP_SMALL,8,8,"src/rgba2/ship_small.rgba2"
043A1C             0001*M 
043A1C             0002*M     ; Clear buffer
043A1C 17 00 A0    0003*M     db 23,0,0xA0
043A1F 37 01       0004*M     dw bufferId
043A21 02          0005*M     db 2
043A22             0006*M 
043A22 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
043A25 37 01       0008*M     dw bufferId
043A27             0009*M 
043A27             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
043A27 17 00 A0    0011*M     db 23,0,0xA0
043A2A 37 01       0012*M     dw bufferId
043A2C 00          0013*M     db 0
043A2D 40 00       0014*M 	dw width * height ; length of data in bytes
043A2F 00 00 00 CB 0015*M     incbin file ; bitmap data
       CA 00 00 00 
       00 00 00 FE 
       FD 00 00 00 
       00 00 00 FE 
       FD 00 00 00 
       CB 00 00 CB 
       CA 00 00 CA 
       CB 00 CB C7 
       C6 CB 00 CA 
       CB CB C7 CB 
       CA C6 CB CA 
       CB C7 CB CB 
       CA CB C6 CA 
       CB 00 00 00 
       00 00 00 CA 
043A6F             0016*M 
043A6F             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
043A6F 17 1B 21    0018*M     db 23,27,0x21
043A72 08 00       0019*M     dw width ; in pixels
043A74 08 00       0020*M     dw height ; in pixels
043A76 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
043A77             0125*  	LOADBMPBUFFER2 BUF_STAR,5,5,"src/rgba2/star.rgba2"
043A77             0001*M 
043A77             0002*M     ; Clear buffer
043A77 17 00 A0    0003*M     db 23,0,0xA0
043A7A 38 01       0004*M     dw bufferId
043A7C 02          0005*M     db 2
043A7D             0006*M 
043A7D 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
043A80 38 01       0008*M     dw bufferId
043A82             0009*M 
043A82             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
043A82 17 00 A0    0011*M     db 23,0,0xA0
043A85 38 01       0012*M     dw bufferId
043A87 00          0013*M     db 0
043A88 19 00       0014*M 	dw width * height ; length of data in bytes
043A8A 00 00 D1 00 0015*M     incbin file ; bitmap data
       00 00 00 E6 
       00 00 D1 E6 
       FF E6 D1 00 
       00 E6 00 00 
       00 00 D1 00 
       00          
043AA3             0016*M 
043AA3             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
043AA3 17 1B 21    0018*M     db 23,27,0x21
043AA6 05 00       0019*M     dw width ; in pixels
043AA8 05 00       0020*M     dw height ; in pixels
043AAA 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
043AAB             0126*  	LOADBMPBUFFER2 BUF_TURRET,16,16,"src/rgba2/turret.rgba2"
043AAB             0001*M 
043AAB             0002*M     ; Clear buffer
043AAB 17 00 A0    0003*M     db 23,0,0xA0
043AAE 39 01       0004*M     dw bufferId
043AB0 02          0005*M     db 2
043AB1             0006*M 
043AB1 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
043AB4 39 01       0008*M     dw bufferId
043AB6             0009*M 
043AB6             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
043AB6 17 00 A0    0011*M     db 23,0,0xA0
043AB9 39 01       0012*M     dw bufferId
043ABB 00          0013*M     db 0
043ABC 00 01       0014*M 	dw width * height ; length of data in bytes
043ABE 00 00 00 00 0015*M     incbin file ; bitmap data
       00 D0 D0 DF 
       DF D0 D0 00 
       00 00 00 00 
       00 00 00 D0 
       D0 F5 F5 DF 
       DF F5 F5 D0 
       D0 00 00 00 
       00 00 D0 F5 
       F5 F5 C3 C3 
       C3 C3 F5 F5 
       F5 D0 00 00 
       00 D0 F5 F5 
       F5 F5 D0 DF 
       DF D0 F5 F5 
       F5 F5 D0 00 
       00 D0 F5 F5 
       F5 C3 C3 C3 
       C3 C3 C3 F5 
       F5 F5 D0 00 
       D0 F5 F5 F5 
       F5 F5 D0 DF 
       DF D0 F5 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 F5 D0 DF 
       DF D0 F5 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       C3 C3 C3 C3 
       C3 C3 C3 C3 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 D0 D0 DF 
       DF D0 D0 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 D0 C3 DF 
       DF C3 D0 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 D0 C3 DF 
       DF C3 D0 F5 
       F5 F5 F5 D0 
       00 D0 F5 F5 
       F5 D0 D0 E5 
       E5 D0 D0 F5 
       F5 F5 D0 00 
       00 D0 F5 F5 
       D0 D0 E5 FA 
       FA E5 D0 D0 
       F5 F5 D0 00 
       00 00 D0 F5 
       D0 E5 FA FA 
       FA FA E5 D0 
       F5 D0 00 00 
       00 00 00 D0 
       D0 D0 E5 FA 
       FA E5 D0 D0 
       D0 00 00 00 
       00 00 00 00 
       00 D0 D0 D0 
       D0 D0 D0 00 
       00 00 00 00 
043BBE             0016*M 
043BBE             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
043BBE 17 1B 21    0018*M     db 23,27,0x21
043BC1 10 00       0019*M     dw width ; in pixels
043BC3 10 00       0020*M     dw height ; in pixels
043BC5 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
043BC6             0127*  	LOADBMPBUFFER2 BUF_TURRET_ROT,16,16,"src/rgba2/turret_rot.rgba2"
043BC6             0001*M 
043BC6             0002*M     ; Clear buffer
043BC6 17 00 A0    0003*M     db 23,0,0xA0
043BC9 3A 01       0004*M     dw bufferId
043BCB 02          0005*M     db 2
043BCC             0006*M 
043BCC 17 1B 20    0007*M     db 23,27,0x20 ; select buffer VDU 23, 27, &20, bufferId;
043BCF 3A 01       0008*M     dw bufferId
043BD1             0009*M 
043BD1             0010*M     ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
043BD1 17 00 A0    0011*M     db 23,0,0xA0
043BD4 3A 01       0012*M     dw bufferId
043BD6 00          0013*M     db 0
043BD7 00 01       0014*M 	dw width * height ; length of data in bytes
043BD9 00 00 00 00 0015*M     incbin file ; bitmap data
       00 D0 D0 D0 
       D0 D0 D0 00 
       00 00 00 00 
       00 00 00 D0 
       D0 F5 F5 F5 
       F5 F5 F5 D0 
       D0 00 00 00 
       00 00 DF DF 
       F5 F5 F5 F5 
       F5 F5 F5 F5 
       F5 D0 00 00 
       00 D0 DF DF 
       DF D0 F5 C3 
       F5 F5 F5 F5 
       F5 F5 D0 00 
       00 D0 F5 DF 
       DF DF C3 F5 
       F5 F5 F5 F5 
       F5 F5 D0 00 
       D0 F5 F5 D0 
       DF C3 DF D0 
       F5 C3 F5 F5 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       C3 DF DF DF 
       C3 F5 F5 F5 
       C3 F5 F5 D0 
       D0 F5 F5 C3 
       F5 D0 DF C3 
       DF D0 F5 C3 
       F5 F5 F5 D0 
       D0 F5 F5 F5 
       F5 F5 C3 DF 
       DF DF D0 D0 
       D0 D0 F5 D0 
       D0 F5 F5 F5 
       F5 C3 F5 D0 
       DF DF DF C3 
       D0 D0 D0 D0 
       D0 F5 F5 F5 
       F5 F5 F5 F5 
       D0 DF C3 FA 
       E5 E5 D0 D0 
       00 D0 F5 F5 
       F5 F5 F5 C3 
       D0 C3 FA FA 
       FA E5 D0 00 
       00 D0 F5 F5 
       F5 F5 C3 F5 
       D0 D0 E5 FA 
       E5 E5 D0 00 
       00 00 D0 F5 
       F5 F5 F5 F5 
       D0 D0 E5 E5 
       E5 D0 00 00 
       00 00 00 D0 
       D0 F5 F5 F5 
       F5 D0 D0 D0 
       D0 00 00 00 
       00 00 00 00 
       00 D0 D0 D0 
       D0 D0 D0 00 
       00 00 00 00 
043CD9             0016*M 
043CD9             0017*M     ;Create bitmap from selected buffer :: VDU 23, 27, &21, w; h; format
043CD9 17 1B 21    0018*M     db 23,27,0x21
043CDC 10 00       0019*M     dw width ; in pixels
043CDE 10 00       0020*M     dw height ; in pixels
043CE0 01          0021*M     db 1 ; bitmap format: 1 = RGBA2222 (1-bytes per pixel)
043CE1             0128*  @end:
043CE1             0048   	include "src/asm/fonts.inc"
043CE1             0001*  font_nurples:
043CE1 00 00 00 00 0002*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ;   #20 32
       00 00 00 00 
043CE9 20 20 20 20 0003*      db 0x20,0x20,0x20,0x20,0x00,0x00,0x20,0x00 ; ! #21 33
       00 00 20 00 
043CF1 50 50 00 00 0004*      db 0x50,0x50,0x00,0x00,0x00,0x00,0x00,0x00 ; " #22 34
       00 00 00 00 
043CF9 00 50 F8 50 0005*      db 0x00,0x50,0xF8,0x50,0x50,0xF8,0x50,0x00 ; # #23 35
       50 F8 50 00 
043D01 20 70 A0 70 0006*      db 0x20,0x70,0xA0,0x70,0x28,0x70,0x20,0x00 ; $ #24 36
       28 70 20 00 
043D09 00 88 10 20 0007*      db 0x00,0x88,0x10,0x20,0x40,0x88,0x00,0x00 ; % #25 37
       40 88 00 00 
043D11 60 90 80 40 0008*      db 0x60,0x90,0x80,0x40,0xA8,0x90,0x68,0x00 ; & #26 38
       A8 90 68 00 
043D19 20 20 00 00 0009*      db 0x20,0x20,0x00,0x00,0x00,0x00,0x00,0x00 ; ' #27 39
       00 00 00 00 
043D21 10 20 40 40 0010*      db 0x10,0x20,0x40,0x40,0x40,0x20,0x10,0x00 ; ( #28 40
       40 20 10 00 
043D29 40 20 10 10 0011*      db 0x40,0x20,0x10,0x10,0x10,0x20,0x40,0x00 ; ) #29 41
       10 20 40 00 
043D31 20 A8 70 20 0012*      db 0x20,0xA8,0x70,0x20,0x70,0xA8,0x20,0x00 ; * #2A 42
       70 A8 20 00 
043D39 00 20 20 70 0013*      db 0x00,0x20,0x20,0x70,0x20,0x20,0x00,0x00 ; + #2B 43
       20 20 00 00 
043D41 00 00 00 00 0014*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x40 ; ,0x2C 44
       00 00 20 40 
043D49 00 00 00 70 0015*      db 0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x00 ; - #2D 45
       00 00 00 00 
043D51 00 00 00 00 0016*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00 ; . #2E 46
       00 00 20 00 
043D59 10 10 20 20 0017*      db 0x10,0x10,0x20,0x20,0x40,0x40,0x80,0x80 ; / #2F 47
       40 40 80 80 
043D61 70 88 C8 A8 0018*      db 0x70,0x88,0xC8,0xA8,0x98,0x88,0x70,0x00 ; 0 #30 48
       98 88 70 00 
043D69 20 60 20 20 0019*      db 0x20,0x60,0x20,0x20,0x20,0x20,0x70,0x00 ; 1 #31 49
       20 20 70 00 
043D71 60 90 10 20 0020*      db 0x60,0x90,0x10,0x20,0x40,0x80,0xF0,0x00 ; 2 #32 50
       40 80 F0 00 
043D79 60 90 10 60 0021*      db 0x60,0x90,0x10,0x60,0x10,0x90,0x60,0x00 ; 3 #33 51
       10 90 60 00 
043D81 10 30 50 90 0022*      db 0x10,0x30,0x50,0x90,0xF8,0x10,0x10,0x00 ; 4 #34 52
       F8 10 10 00 
043D89 F0 80 E0 10 0023*      db 0xF0,0x80,0xE0,0x10,0x10,0x90,0x60,0x00 ; 5 #35 53
       10 90 60 00 
043D91 60 90 80 E0 0024*      db 0x60,0x90,0x80,0xE0,0x90,0x90,0x60,0x00 ; 6 #36 54
       90 90 60 00 
043D99 F0 10 20 20 0025*      db 0xF0,0x10,0x20,0x20,0x40,0x40,0x40,0x00 ; 7 #37 55
       40 40 40 00 
043DA1 60 90 90 60 0026*      db 0x60,0x90,0x90,0x60,0x90,0x90,0x60,0x00 ; 8 #38 56
       90 90 60 00 
043DA9 60 90 90 70 0027*      db 0x60,0x90,0x90,0x70,0x10,0x10,0x60,0x00 ; 9 #39 57
       10 10 60 00 
043DB1 00 00 00 20 0028*      db 0x00,0x00,0x00,0x20,0x00,0x00,0x20,0x00 ; : #3A 58
       00 00 20 00 
043DB9 00 00 00 20 0029*      db 0x00,0x00,0x00,0x20,0x00,0x00,0x20,0x40 ; ; #3B 59
       00 00 20 40 
043DC1 08 10 20 40 0030*      db 0x08,0x10,0x20,0x40,0x20,0x10,0x08,0x00 ; < #3C 60
       20 10 08 00 
043DC9 00 00 70 00 0031*      db 0x00,0x00,0x70,0x00,0x70,0x00,0x00,0x00 ; = #3D 61
       70 00 00 00 
043DD1 80 40 20 10 0032*      db 0x80,0x40,0x20,0x10,0x20,0x40,0x80,0x00 ; > #3E 62
       20 40 80 00 
043DD9 70 88 08 10 0033*      db 0x70,0x88,0x08,0x10,0x20,0x00,0x20,0x00 ; ? #3F 63
       20 00 20 00 
043DE1 30 48 98 A8 0034*      db 0x30,0x48,0x98,0xA8,0xA8,0x90,0x40,0x30 ; @ #40 64
       A8 90 40 30 
043DE9 70 88 88 F8 0035*      db 0x70,0x88,0x88,0xF8,0x88,0x88,0x88,0x00 ; A #41 65
       88 88 88 00 
043DF1 F0 88 88 F0 0036*      db 0xF0,0x88,0x88,0xF0,0x88,0x88,0xF0,0x00 ; B #42 66
       88 88 F0 00 
043DF9 70 88 80 80 0037*      db 0x70,0x88,0x80,0x80,0x80,0x88,0x70,0x00 ; C #43 67
       80 88 70 00 
043E01 E0 90 88 88 0038*      db 0xE0,0x90,0x88,0x88,0x88,0x90,0xE0,0x00 ; D #44 68
       88 90 E0 00 
043E09 F8 80 80 E0 0039*      db 0xF8,0x80,0x80,0xE0,0x80,0x80,0xF8,0x00 ; E #45 69
       80 80 F8 00 
043E11 F8 80 80 E0 0040*      db 0xF8,0x80,0x80,0xE0,0x80,0x80,0x80,0x00 ; F #46 70
       80 80 80 00 
043E19 70 88 80 B8 0041*      db 0x70,0x88,0x80,0xB8,0x88,0x88,0x70,0x00 ; G #47 71
       88 88 70 00 
043E21 88 88 88 F8 0042*      db 0x88,0x88,0x88,0xF8,0x88,0x88,0x88,0x00 ; H #48 72
       88 88 88 00 
043E29 70 20 20 20 0043*      db 0x70,0x20,0x20,0x20,0x20,0x20,0x70,0x00 ; I #49 73
       20 20 70 00 
043E31 78 10 10 10 0044*      db 0x78,0x10,0x10,0x10,0x10,0x50,0x20,0x00 ; J #4A 74
       10 50 20 00 
043E39 88 90 A0 D0 0045*      db 0x88,0x90,0xA0,0xD0,0x88,0x88,0x88,0x00 ; K #4B 75
       88 88 88 00 
043E41 40 40 40 40 0046*      db 0x40,0x40,0x40,0x40,0x40,0x40,0x78,0x00 ; L #4C 76
       40 40 78 00 
043E49 88 88 D8 A8 0047*      db 0x88,0x88,0xD8,0xA8,0x88,0x88,0x88,0x00 ; M #4D 77
       88 88 88 00 
043E51 88 88 C8 A8 0048*      db 0x88,0x88,0xC8,0xA8,0x98,0x88,0x88,0x00 ; N #4E 78
       98 88 88 00 
043E59 70 88 88 88 0049*      db 0x70,0x88,0x88,0x88,0x88,0x88,0x70,0x00 ; O #4F 79
       88 88 70 00 
043E61 F0 88 88 F0 0050*      db 0xF0,0x88,0x88,0xF0,0x80,0x80,0x80,0x00 ; P #50 80
       80 80 80 00 
043E69 70 88 88 88 0051*      db 0x70,0x88,0x88,0x88,0xA8,0x90,0x68,0x00 ; Q #51 81
       A8 90 68 00 
043E71 F0 88 88 F0 0052*      db 0xF0,0x88,0x88,0xF0,0xA0,0x90,0x88,0x00 ; R #52 82
       A0 90 88 00 
043E79 70 88 80 70 0053*      db 0x70,0x88,0x80,0x70,0x08,0x88,0x70,0x00 ; S #53 83
       08 88 70 00 
043E81 F8 20 20 20 0054*      db 0xF8,0x20,0x20,0x20,0x20,0x20,0x20,0x00 ; T #54 84
       20 20 20 00 
043E89 88 88 88 88 0055*      db 0x88,0x88,0x88,0x88,0x88,0x88,0x70,0x00 ; U #55 85
       88 88 70 00 
043E91 88 88 88 88 0056*      db 0x88,0x88,0x88,0x88,0x88,0x50,0x20,0x00 ; V #56 86
       88 50 20 00 
043E99 88 88 88 88 0057*      db 0x88,0x88,0x88,0x88,0xA8,0xA8,0x50,0x00 ; W #57 87
       A8 A8 50 00 
043EA1 88 88 50 20 0058*      db 0x88,0x88,0x50,0x20,0x50,0x88,0x88,0x00 ; X #58 88
       50 88 88 00 
043EA9 88 88 50 20 0059*      db 0x88,0x88,0x50,0x20,0x20,0x20,0x20,0x00 ; Y #59 89
       20 20 20 00 
043EB1 F8 08 10 20 0060*      db 0xF8,0x08,0x10,0x20,0x40,0x80,0xF8,0x00 ; Z #5A 90
       40 80 F8 00 
043EB9 38 20 20 20 0061*      db 0x38,0x20,0x20,0x20,0x20,0x20,0x38,0x00 ; [ #5B 91
       20 20 38 00 
043EC1 80 80 40 40 0062*      db 0x80,0x80,0x40,0x40,0x20,0x20,0x10,0x10 ; \ #5C 92
       20 20 10 10 
043EC9 E0 20 20 20 0063*      db 0xE0,0x20,0x20,0x20,0x20,0x20,0xE0,0x00 ; ] #5D 93
       20 20 E0 00 
043ED1 20 50 88 00 0064*      db 0x20,0x50,0x88,0x00,0x00,0x00,0x00,0x00 ; ^ #5E 94
       00 00 00 00 
043ED9 00 00 00 00 0065*      db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF8 ; _ #5F 95
       00 00 00 F8 
043EE1 40 20 00 00 0066*      db 0x40,0x20,0x00,0x00,0x00,0x00,0x00,0x00 ; ` #60 96
       00 00 00 00 
043EE9 00 00 60 10 0067*      db 0x00,0x00,0x60,0x10,0x70,0x90,0x70,0x00 ; a #61 97
       70 90 70 00 
043EF1 80 80 E0 90 0068*      db 0x80,0x80,0xE0,0x90,0x90,0x90,0xE0,0x00 ; b #62 98
       90 90 E0 00 
043EF9 00 00 60 90 0069*      db 0x00,0x00,0x60,0x90,0x80,0x90,0x60,0x00 ; c #63 99
       80 90 60 00 
043F01 10 10 70 90 0070*      db 0x10,0x10,0x70,0x90,0x90,0x90,0x70,0x00 ; d #64 100
       90 90 70 00 
043F09 00 00 60 90 0071*      db 0x00,0x00,0x60,0x90,0xF0,0x80,0x70,0x00 ; e #65 101
       F0 80 70 00 
043F11 60 90 80 C0 0072*      db 0x60,0x90,0x80,0xC0,0x80,0x80,0x80,0x00 ; f #66 102
       80 80 80 00 
043F19 00 00 70 90 0073*      db 0x00,0x00,0x70,0x90,0x90,0x70,0x10,0x60 ; g #67 103
       90 70 10 60 
043F21 80 80 E0 90 0074*      db 0x80,0x80,0xE0,0x90,0x90,0x90,0x90,0x00 ; h #68 104
       90 90 90 00 
043F29 00 20 00 20 0075*      db 0x00,0x20,0x00,0x20,0x20,0x20,0x20,0x00 ; i #69 105
       20 20 20 00 
043F31 00 10 00 10 0076*      db 0x00,0x10,0x00,0x10,0x10,0x10,0x50,0x20 ; j #6A 106
       10 10 50 20 
043F39 80 80 90 A0 0077*      db 0x80,0x80,0x90,0xA0,0xC0,0xA0,0x90,0x00 ; k #6B 107
       C0 A0 90 00 
043F41 20 20 20 20 0078*      db 0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x00 ; l #6C 108
       20 20 20 00 
043F49 00 00 D0 A8 0079*      db 0x00,0x00,0xD0,0xA8,0xA8,0x88,0x88,0x00 ; m #6D 109
       A8 88 88 00 
043F51 00 00 B0 C8 0080*      db 0x00,0x00,0xB0,0xC8,0x88,0x88,0x88,0x00 ; n #6E 110
       88 88 88 00 
043F59 00 00 70 88 0081*      db 0x00,0x00,0x70,0x88,0x88,0x88,0x70,0x00 ; o #6F 111
       88 88 70 00 
043F61 00 00 F0 88 0082*      db 0x00,0x00,0xF0,0x88,0x88,0xF0,0x80,0x80 ; p #70 112
       88 F0 80 80 
043F69 00 00 78 88 0083*      db 0x00,0x00,0x78,0x88,0x88,0x78,0x08,0x08 ; q #71 113
       88 78 08 08 
043F71 00 00 B0 C8 0084*      db 0x00,0x00,0xB0,0xC8,0x80,0x80,0x80,0x00 ; r 114 #72
       80 80 80 00 
043F79 00 00 70 80 0085*      db 0x00,0x00,0x70,0x80,0x60,0x10,0xE0,0x00 ; s #73 115
       60 10 E0 00 
043F81 40 40 F0 40 0086*      db 0x40,0x40,0xF0,0x40,0x40,0x40,0x30,0x00 ; t #74 116
       40 40 30 00 
043F89 00 00 88 88 0087*      db 0x00,0x00,0x88,0x88,0x88,0x98,0x68,0x00 ; u #75 117
       88 98 68 00 
043F91 00 00 88 88 0088*      db 0x00,0x00,0x88,0x88,0x88,0x50,0x20,0x00 ; v #76 118
       88 50 20 00 
043F99 00 00 88 88 0089*      db 0x00,0x00,0x88,0x88,0xA8,0xA8,0x50,0x00 ; w #77 119
       A8 A8 50 00 
043FA1 00 00 88 50 0090*      db 0x00,0x00,0x88,0x50,0x20,0x50,0x88,0x00 ; x #78 120
       20 50 88 00 
043FA9 00 00 88 88 0091*      db 0x00,0x00,0x88,0x88,0x50,0x50,0x20,0xC0 ; y #79 121
       50 50 20 C0 
043FB1 00 00 F8 10 0092*      db 0x00,0x00,0xF8,0x10,0x20,0x40,0xF8,0x00 ; z #7A 122
       20 40 F8 00 
043FB9 30 40 40 80 0093*      db 0x30,0x40,0x40,0x80,0x40,0x40,0x30,0x00 ; { #7B 123
       40 40 30 00 
043FC1 20 20 20 20 0094*      db 0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20 ; | #7C 124
       20 20 20 20 
043FC9 60 10 10 08 0095*      db 0x60,0x10,0x10,0x08,0x10,0x10,0x60,0x00 ; } #7D 125
       10 10 60 00 
043FD1 68 B0 00 00 0096*      db 0x68,0xB0,0x00,0x00,0x00,0x00,0x00,0x00 ; ~ #7E 126
       00 00 00 00 
043FD9 A8 50 A8 50 0097*      db 0xA8,0x50,0xA8,0x50,0xA8,0x50,0xA8,0x00 ;  #7F 127
       A8 50 A8 00 
043FE1 00 00 00 FC 0098*      db 0x00,0x00,0x00,0xFC,0x00,0x00,0x00,0x00 ; ─ #80 128
       00 00 00 00 
043FE9 20 20 20 20 0099*      db 0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20 ; │ #81 129
       20 20 20 20 
043FF1 00 00 00 3C 0100*      db 0x00,0x00,0x00,0x3C,0x20,0x20,0x20,0x20 ; ┌ #82 130
       20 20 20 20 
043FF9 00 00 00 E0 0101*      db 0x00,0x00,0x00,0xE0,0x20,0x20,0x20,0x20 ; ┐ #83 131
       20 20 20 20 
044001 20 20 20 3C 0102*      db 0x20,0x20,0x20,0x3C,0x00,0x00,0x00,0x00 ; └ #84 132
       00 00 00 00 
044009 20 20 20 E0 0103*      db 0x20,0x20,0x20,0xE0,0x00,0x00,0x00,0x00 ; ┘ #85 133
       00 00 00 00 
044011 20 20 20 3C 0104*      db 0x20,0x20,0x20,0x3C,0x20,0x20,0x20,0x20 ; ├ #86 134
       20 20 20 20 
044019 20 20 20 E0 0105*      db 0x20,0x20,0x20,0xE0,0x20,0x20,0x20,0x20 ; ┤ #87 135
       20 20 20 20 
044021 00 00 00 FC 0106*      db 0x00,0x00,0x00,0xFC,0x20,0x20,0x20,0x20 ; ┬ #88 136
       20 20 20 20 
044029 20 20 20 FC 0107*      db 0x20,0x20,0x20,0xFC,0x00,0x00,0x00,0x00 ; ┴ #89 137
       00 00 00 00 
044031 20 20 20 FC 0108*      db 0x20,0x20,0x20,0xFC,0x20,0x20,0x20,0x20 ; ┼ #8A 138
       20 20 20 20 
044039 00 00 FC 00 0109*      db 0x00,0x00,0xFC,0x00,0xFC,0x00,0x00,0x00 ; ═ #8B 139
       FC 00 00 00 
044041 50 50 50 50 0110*      db 0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50 ; ║ #8C 140
       50 50 50 50 
044049 00 00 3C 20 0111*      db 0x00,0x00,0x3C,0x20,0x3C,0x20,0x20,0x20 ; ╒ #8D 141
       3C 20 20 20 
044051 00 00 00 7C 0112*      db 0x00,0x00,0x00,0x7C,0x50,0x50,0x50,0x50 ; ╓ #8E 142
       50 50 50 50 
044059 00 00 7C 40 0113*      db 0x00,0x00,0x7C,0x40,0x5C,0x50,0x50,0x50 ; ╔ #8F 143
       5C 50 50 50 
044061 00 00 E0 20 0114*      db 0x00,0x00,0xE0,0x20,0xE0,0x20,0x20,0x20 ; ╕ #90 144
       E0 20 20 20 
044069 00 00 00 F0 0115*      db 0x00,0x00,0x00,0xF0,0x50,0x50,0x50,0x50 ; ╖ #91 145
       50 50 50 50 
044071 00 00 F0 10 0116*      db 0x00,0x00,0xF0,0x10,0xD0,0x50,0x50,0x50 ; ╗ #92 146
       D0 50 50 50 
044079 20 20 3C 20 0117*      db 0x20,0x20,0x3C,0x20,0x3C,0x00,0x00,0x00 ; ╘ #93 147
       3C 00 00 00 
044081 50 50 50 7C 0118*      db 0x50,0x50,0x50,0x7C,0x00,0x00,0x00,0x00 ; ╙ #94 148
       00 00 00 00 
044089 50 50 5C 40 0119*      db 0x50,0x50,0x5C,0x40,0x7C,0x00,0x00,0x00 ; ╚ #95 149
       7C 00 00 00 
044091 20 20 E0 20 0120*      db 0x20,0x20,0xE0,0x20,0xE0,0x00,0x00,0x00 ; ╛ #96 150
       E0 00 00 00 
044099 50 50 50 F0 0121*      db 0x50,0x50,0x50,0xF0,0x00,0x00,0x00,0x00 ; ╜ #97 151
       00 00 00 00 
0440A1 50 50 D0 10 0122*      db 0x50,0x50,0xD0,0x10,0xF0,0x00,0x00,0x00 ; ╝ #98 152
       F0 00 00 00 
0440A9 20 20 3C 20 0123*      db 0x20,0x20,0x3C,0x20,0x3C,0x20,0x20,0x20 ; ╞ #99 153
       3C 20 20 20 
0440B1 50 50 50 5C 0124*      db 0x50,0x50,0x50,0x5C,0x50,0x50,0x50,0x50 ; ╟ #9A 154
       50 50 50 50 
0440B9 50 50 5C 40 0125*      db 0x50,0x50,0x5C,0x40,0x5C,0x50,0x50,0x50 ; ╠ #9B 155
       5C 50 50 50 
0440C1 20 20 E0 20 0126*      db 0x20,0x20,0xE0,0x20,0xE0,0x20,0x20,0x20 ; ╡ #9C 156
       E0 20 20 20 
0440C9 50 50 50 D0 0127*      db 0x50,0x50,0x50,0xD0,0x50,0x50,0x50,0x50 ; ╢ #9D 157
       50 50 50 50 
0440D1 50 50 D0 10 0128*      db 0x50,0x50,0xD0,0x10,0xD0,0x50,0x50,0x50 ; ╣ #9E 158
       D0 50 50 50 
0440D9 00 00 FC 00 0129*      db 0x00,0x00,0xFC,0x00,0xFC,0x20,0x20,0x20 ; ╤ #9F 159
       FC 20 20 20 
0440E1 00 00 00 FC 0130*      db 0x00,0x00,0x00,0xFC,0x50,0x50,0x50,0x50 ; ╥ #A0 160
       50 50 50 50 
0440E9 00 00 FC 00 0131*      db 0x00,0x00,0xFC,0x00,0xDC,0x50,0x50,0x50 ; ╦ #A1 161
       DC 50 50 50 
0440F1 20 20 FC 00 0132*      db 0x20,0x20,0xFC,0x00,0xFC,0x00,0x00,0x00 ; ╧ #A2 162
       FC 00 00 00 
0440F9 50 50 50 FC 0133*      db 0x50,0x50,0x50,0xFC,0x00,0x00,0x00,0x00 ; ╨ #A3 163
       00 00 00 00 
044101 50 50 DC 00 0134*      db 0x50,0x50,0xDC,0x00,0xFC,0x00,0x00,0x00 ; ╩ #A4 164
       FC 00 00 00 
044109 20 20 FC 20 0135*      db 0x20,0x20,0xFC,0x20,0xFC,0x20,0x20,0x20 ; ╪ #A5 165
       FC 20 20 20 
044111 50 50 50 FC 0136*      db 0x50,0x50,0x50,0xFC,0x50,0x50,0x50,0x50 ; ╫ #A6 166
       50 50 50 50 
044119 50 50 DC 00 0137*      db 0x50,0x50,0xDC,0x00,0xDC,0x50,0x50,0x50 ; ╬ #A7 167
       DC 50 50 50 
044121 FC FC 00 00 0138*      db 0xFC,0xFC,0x00,0x00,0x00,0x00,0x00,0x00 ; ▀ #A8 168
       00 00 00 00 
044129 00 00 00 00 0139*      db 0x00,0x00,0x00,0x00,0x00,0x00,0xFC,0xFC ; ▄ #A9 169
       00 00 FC FC 
044131 FC FC FC FC 0140*      db 0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC ; █ #AA 170
       FC FC FC FC 
044139 C0 C0 C0 C0 0141*      db 0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0 ; ▌ #AB 171
       C0 C0 C0 C0 
044141 0C 0C 0C 0C 0142*      db 0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C ; ▐ #AC 172
       0C 0C 0C 0C 
044149 A8 00 A8 00 0143*      db 0xA8,0x00,0xA8,0x00,0xA8,0x00,0xA8,0x00 ; ░ #AD 173
       A8 00 A8 00 
044151 A8 54 A8 54 0144*      db 0xA8,0x54,0xA8,0x54,0xA8,0x54,0xA8,0x54 ; ▒ #AE 174
       A8 54 A8 54 
044159 54 FC 54 FC 0145*      db 0x54,0xFC,0x54,0xFC,0x54,0xFC,0x54,0xFC ; ▓ #AF 175
       54 FC 54 FC 
044161             0049   	include "src/asm/levels.inc"
044161 00          0001*  tiles_level_00: db  0 ; number of rows, 0 is max of 256
044162 00 00 00 00 0002*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 0
       00 00 00 00 
       00 01 02 02 
       01 02 02 01 
044172 00 00 00 00 0003*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x05,0x00,0x03 ; row 1
       00 00 00 00 
       00 03 00 05 
       03 05 00 03 
044182 00 00 00 00 0004*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 2
       00 00 00 00 
       00 03 00 00 
       03 00 00 03 
044192 00 00 00 07 0005*  	db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 3
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
0441A2 00 00 00 03 0006*  	db 0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x05,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x03 ; row 4
       00 05 03 05 
       00 03 05 00 
       03 00 00 03 
0441B2 00 00 00 03 0007*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 5
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
0441C2 00 00 00 01 0008*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 6
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
0441D2 00 00 00 03 0009*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 7
       00 00 03 05 
       04 03 00 00 
       03 00 00 03 
0441E2 00 00 00 03 0010*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 8
       00 00 03 04 
       05 03 00 00 
       03 00 00 03 
0441F2 01 02 02 01 0011*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 9
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
044202 03 04 05 03 0012*  	db 0x03,0x04,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03 ; row 10
       00 00 03 00 
       00 03 00 00 
       03 05 05 03 
044212 03 05 04 03 0013*  	db 0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03 ; row 11
       00 00 03 00 
       00 03 00 00 
       03 04 04 03 
044222 01 02 02 01 0014*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x01 ; row 12
       02 02 01 02 
       02 06 02 02 
       01 02 02 01 
044232 00 00 00 00 0015*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x03 ; row 13
       00 00 03 04 
       00 03 05 00 
       03 00 00 03 
044242 00 00 00 00 0016*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 14
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
044252 00 00 00 00 0017*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 15
       00 00 01 02 
       02 07 02 02 
       01 02 02 01 
044262 00 00 00 00 0018*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x05,0x03,0x00,0x00,0x00 ; row 16
       00 00 03 05 
       05 03 00 05 
       03 00 00 00 
044272 00 00 00 00 0019*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 17
       00 00 03 05 
       04 03 00 00 
       03 00 00 00 
044282 00 00 00 00 0020*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 18
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
044292 00 00 00 00 0021*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x00,0x03,0x00,0x00,0x00 ; row 19
       00 00 03 00 
       00 03 04 00 
       03 00 00 00 
0442A2 00 00 00 00 0022*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 20
       00 00 03 00 
       05 03 00 00 
       03 00 00 00 
0442B2 00 00 00 00 0023*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00 ; row 21
       00 00 03 00 
       00 03 05 00 
       03 00 00 00 
0442C2 00 00 00 00 0024*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 22
       00 00 03 04 
       00 03 00 00 
       03 00 00 00 
0442D2 00 00 00 00 0025*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 23
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
0442E2 00 00 00 00 0026*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 24
       00 00 03 00 
       04 03 00 00 
       00 00 00 00 
0442F2 00 00 00 00 0027*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 25
       00 00 03 05 
       00 03 00 00 
       00 00 00 00 
044302 00 00 00 01 0028*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00 ; row 26
       02 02 01 02 
       02 07 00 00 
       00 00 00 00 
044312 00 00 00 03 0029*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 27
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044322 00 00 00 03 0030*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 28
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
044332 00 00 00 01 0031*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 29
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
044342 00 00 00 03 0032*  	db 0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 30
       04 05 03 00 
       00 03 00 00 
       00 00 00 00 
044352 00 00 00 03 0033*  	db 0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 31
       05 05 03 00 
       00 03 00 00 
       00 00 00 00 
044362 00 00 00 01 0034*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 32
       02 02 06 02 
       02 01 00 00 
       00 00 00 00 
044372 00 00 00 00 0035*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 33
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044382 00 00 00 00 0036*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 34
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044392 00 00 00 00 0037*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 35
       00 00 01 02 
       02 01 02 02 
       07 00 00 00 
0443A2 00 00 00 00 0038*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 36
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0443B2 00 00 00 00 0039*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 37
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0443C2 00 00 00 00 0040*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 38
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
0443D2 00 00 00 00 0041*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 39
       00 00 03 04 
       04 03 00 00 
       00 00 00 00 
0443E2 00 00 00 00 0042*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 40
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
0443F2 00 00 00 01 0043*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 41
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
044402 00 00 00 03 0044*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 42
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044412 00 00 00 03 0045*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 43
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044422 07 02 02 01 0046*  	db 0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 44
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
044432 03 00 00 03 0047*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 45
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044442 03 00 00 03 0048*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 46
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044452 01 02 02 01 0049*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 47
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
044462 00 00 00 03 0050*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 48
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044472 00 00 00 03 0051*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 49
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044482 00 00 00 06 0052*  	db 0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00 ; row 50
       02 02 01 02 
       02 07 00 00 
       00 00 00 00 
044492 00 00 00 00 0053*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 51
       00 00 03 05 
       04 03 00 00 
       00 00 00 00 
0444A2 00 00 00 00 0054*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 52
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
0444B2 00 00 00 00 0055*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 53
       00 00 01 02 
       02 01 00 00 
       00 00 00 00 
0444C2 00 00 00 00 0056*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 54
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0444D2 00 00 00 00 0057*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 55
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0444E2 00 00 00 01 0058*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 56
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
0444F2 00 00 00 03 0059*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 57
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
044502 00 00 00 03 0060*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 58
       00 00 03 04 
       04 03 00 00 
       00 00 00 00 
044512 00 00 00 01 0061*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 59
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
044522 00 00 00 03 0062*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 60
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044532 00 00 00 03 0063*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 61
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044542 00 00 00 07 0064*  	db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00 ; row 62
       02 02 01 02 
       02 06 00 00 
       00 00 00 00 
044552 00 00 00 00 0065*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 63
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044562 00 00 00 00 0066*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 64
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044572 00 00 00 00 0067*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 65
       00 00 01 02 
       02 01 00 00 
       00 00 00 00 
044582 00 00 00 00 0068*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 66
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044592 00 00 00 00 0069*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 67
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
0445A2 00 00 00 00 0070*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 68
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
0445B2 00 00 00 00 0071*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00 ; row 69
       00 00 00 00 
       00 03 04 04 
       03 00 00 00 
0445C2 00 00 00 00 0072*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00 ; row 70
       00 00 00 00 
       00 03 05 04 
       03 00 00 00 
0445D2 00 00 00 00 0073*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 71
       00 00 00 00 
       00 01 02 02 
       01 00 00 00 
0445E2 00 00 00 00 0074*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 72
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
0445F2 00 00 00 00 0075*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 73
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
044602 00 00 00 00 0076*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 74
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
044612 00 00 00 00 0077*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 75
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
044622 00 00 00 00 0078*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 76
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
044632 00 00 00 07 0079*  	db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 77
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
044642 00 00 00 03 0080*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 78
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044652 00 00 00 03 0081*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 79
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044662 00 00 00 01 0082*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00 ; row 80
       02 02 01 02 
       02 06 00 00 
       00 00 00 00 
044672 00 00 00 03 0083*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 81
       00 00 03 05 
       04 03 00 00 
       00 00 00 00 
044682 00 00 00 03 0084*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 82
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
044692 00 00 00 01 0085*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 83
       02 02 01 02 
       02 01 02 02 
       07 00 00 00 
0446A2 00 00 00 00 0086*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 84
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0446B2 00 00 00 00 0087*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 85
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0446C2 00 00 00 00 0088*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 86
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
0446D2 00 00 00 00 0089*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 87
       00 00 03 05 
       05 03 00 00 
       03 00 00 00 
0446E2 00 00 00 00 0090*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 88
       00 00 03 04 
       04 03 00 00 
       03 00 00 00 
0446F2 00 00 00 00 0091*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 89
       00 00 01 02 
       02 01 02 02 
       01 02 02 01 
044702 00 00 00 00 0092*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 90
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
044712 00 00 00 00 0093*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 91
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
044722 00 00 00 00 0094*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 92
       00 00 06 02 
       02 01 02 02 
       01 02 02 01 
044732 00 00 00 00 0095*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x04,0x03 ; row 93
       00 00 00 00 
       00 03 00 00 
       03 05 04 03 
044742 00 00 00 00 0096*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x05,0x03 ; row 94
       00 00 00 00 
       00 03 00 00 
       03 04 05 03 
044752 00 00 00 01 0097*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 95
       02 02 02 02 
       02 07 02 02 
       01 02 02 01 
044762 00 00 00 03 0098*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 96
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
044772 00 00 00 03 0099*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 97
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
044782 00 00 00 01 0100*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01,0x02,0x02,0x01 ; row 98
       02 02 02 02 
       02 02 02 02 
       01 02 02 01 
044792 01 02 02 01 0101*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 99
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0447A2 03 00 00 03 0102*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 100
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0447B2 03 00 00 03 0103*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 101
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0447C2 01 02 02 07 0104*  	db 0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 102
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0447D2 03 00 00 03 0105*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 103
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0447E2 03 00 00 03 0106*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 104
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0447F2 01 02 02 01 0107*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 105
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
044802 03 00 04 03 0108*  	db 0x03,0x00,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 106
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044812 03 04 00 03 0109*  	db 0x03,0x04,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 107
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044822 01 02 02 01 0110*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 108
       02 02 06 02 
       02 01 00 00 
       00 00 00 00 
044832 03 00 00 03 0111*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 109
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044842 03 00 04 03 0112*  	db 0x03,0x00,0x04,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 110
       00 00 03 04 
       04 03 00 00 
       00 00 00 00 
044852 01 02 02 01 0113*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 111
       02 02 07 02 
       02 01 00 00 
       00 00 00 00 
044862 00 00 00 03 0114*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 112
       00 00 03 05 
       00 03 00 00 
       00 00 00 00 
044872 00 00 00 03 0115*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 113
       00 00 03 05 
       00 03 00 00 
       00 00 00 00 
044882 00 00 00 01 0116*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 114
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
044892 00 00 00 00 0117*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00 ; row 115
       00 00 03 00 
       00 03 04 04 
       03 00 00 00 
0448A2 00 00 00 00 0118*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00 ; row 116
       00 00 03 00 
       00 03 05 05 
       03 00 00 00 
0448B2 00 00 00 00 0119*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 117
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
0448C2 00 00 00 00 0120*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 118
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
0448D2 00 00 00 00 0121*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 119
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
0448E2 00 00 00 00 0122*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x01 ; row 120
       00 00 00 00 
       00 06 02 02 
       01 02 02 01 
0448F2 00 00 00 00 0123*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x00,0x05,0x03 ; row 121
       00 00 00 00 
       00 03 00 05 
       03 00 05 03 
044902 00 00 00 00 0124*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x04,0x03,0x05,0x00,0x03 ; row 122
       00 00 00 00 
       00 03 00 04 
       03 05 00 03 
044912 00 00 00 00 0125*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 123
       00 00 00 00 
       00 07 02 02 
       01 02 02 01 
044922 00 00 00 00 0126*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 124
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
044932 00 00 00 00 0127*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 125
       00 00 00 00 
       00 03 00 00 
       03 00 00 00 
044942 00 00 00 00 0128*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 126
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
044952 00 00 00 00 0129*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 127
       00 00 03 05 
       04 03 00 00 
       00 00 00 00 
044962 00 00 00 00 0130*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 128
       00 00 03 04 
       05 03 00 00 
       00 00 00 00 
044972 00 00 00 01 0131*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00 ; row 129
       02 02 01 02 
       02 06 00 00 
       00 00 00 00 
044982 00 00 00 03 0132*  	db 0x00,0x00,0x00,0x03,0x05,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 130
       05 00 03 00 
       00 00 00 00 
       00 00 00 00 
044992 00 00 00 03 0133*  	db 0x00,0x00,0x00,0x03,0x00,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 131
       00 05 03 00 
       00 00 00 00 
       00 00 00 00 
0449A2 01 02 02 07 0134*  	db 0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 132
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
0449B2 03 04 00 03 0135*  	db 0x03,0x04,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 133
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0449C2 03 05 04 03 0136*  	db 0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 134
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0449D2 01 02 02 01 0137*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 135
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0449E2 03 00 00 03 0138*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 136
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0449F2 03 00 00 03 0139*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 137
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044A02 01 02 02 01 0140*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 138
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
044A12 03 00 00 03 0141*  	db 0x03,0x00,0x00,0x03,0x04,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 139
       04 05 03 00 
       00 00 00 00 
       00 00 00 00 
044A22 03 00 00 03 0142*  	db 0x03,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 140
       05 04 03 00 
       00 00 00 00 
       00 00 00 00 
044A32 01 02 02 01 0143*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 141
       02 02 01 02 
       02 01 02 02 
       07 00 00 00 
044A42 00 00 00 03 0144*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 142
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
044A52 00 00 00 03 0145*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 143
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
044A62 00 00 00 06 0146*  	db 0x00,0x00,0x00,0x06,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 144
       02 02 01 02 
       02 01 02 02 
       01 02 02 01 
044A72 00 00 00 00 0147*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x03 ; row 145
       00 00 03 00 
       00 03 04 04 
       03 00 00 03 
044A82 00 00 00 00 0148*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03 ; row 146
       00 00 03 00 
       00 03 05 05 
       03 00 00 03 
044A92 00 00 00 00 0149*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01 ; row 147
       00 00 01 02 
       02 01 02 02 
       06 02 02 01 
044AA2 00 00 00 00 0150*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 148
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
044AB2 00 00 00 00 0151*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 149
       00 00 03 00 
       00 03 00 00 
       03 00 00 03 
044AC2 00 00 00 00 0152*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 150
       00 00 01 02 
       02 01 02 02 
       01 02 02 01 
044AD2 00 00 00 00 0153*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x03 ; row 151
       00 00 00 00 
       00 03 04 04 
       03 00 00 03 
044AE2 00 00 00 00 0154*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03 ; row 152
       00 00 00 00 
       00 03 05 04 
       03 00 00 03 
044AF2 00 00 00 00 0155*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 153
       00 00 00 00 
       00 01 02 02 
       01 02 02 01 
044B02 00 00 00 00 0156*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 154
       00 00 00 00 
       00 03 00 00 
       03 00 00 03 
044B12 00 00 00 00 0157*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03 ; row 155
       00 00 00 00 
       00 03 00 00 
       03 00 00 03 
044B22 00 00 00 00 0158*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01 ; row 156
       00 00 00 00 
       00 07 02 02 
       01 02 02 01 
044B32 00 00 00 00 0159*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 157
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
044B42 00 00 00 00 0160*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 158
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
044B52 00 00 00 00 0161*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01 ; row 159
       00 00 00 00 
       00 00 00 00 
       01 02 02 01 
044B62 00 00 00 00 0162*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03 ; row 160
       00 00 00 00 
       00 00 00 00 
       03 05 05 03 
044B72 00 00 00 00 0163*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03 ; row 161
       00 00 00 00 
       00 00 00 00 
       03 05 04 03 
044B82 00 00 00 00 0164*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x02,0x02,0x01 ; row 162
       00 00 00 00 
       00 00 00 00 
       06 02 02 01 
044B92 00 00 00 00 0165*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 163
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
044BA2 00 00 00 00 0166*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03 ; row 164
       00 00 00 00 
       00 00 00 00 
       03 00 00 03 
044BB2 00 00 00 01 0167*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x07,0x02,0x02,0x01 ; row 165
       02 02 02 02 
       02 02 02 02 
       07 02 02 01 
044BC2 00 00 00 03 0168*  	db 0x00,0x00,0x00,0x03,0x04,0x04,0x05,0x04,0x05,0x05,0x05,0x04,0x04,0x04,0x05,0x03 ; row 166
       04 04 05 04 
       05 05 05 04 
       04 04 05 03 
044BD2 00 00 00 03 0169*  	db 0x00,0x00,0x00,0x03,0x05,0x05,0x04,0x04,0x04,0x04,0x05,0x05,0x04,0x05,0x05,0x03 ; row 167
       05 05 04 04 
       04 04 05 05 
       04 05 05 03 
044BE2 00 00 00 01 0170*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01 ; row 168
       02 02 02 02 
       02 02 02 02 
       02 02 02 01 
044BF2 01 02 02 07 0171*  	db 0x01,0x02,0x02,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 169
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044C02 03 00 00 03 0172*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 170
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044C12 03 00 00 03 0173*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 171
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044C22 01 02 02 01 0174*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 172
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044C32 03 04 04 03 0175*  	db 0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 173
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044C42 03 04 04 03 0176*  	db 0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 174
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044C52 01 02 02 01 0177*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 175
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044C62 03 00 00 03 0178*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 176
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044C72 03 00 00 03 0179*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 177
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044C82 01 02 02 01 0180*  	db 0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 178
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044C92 03 00 00 03 0181*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 179
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044CA2 03 00 00 03 0182*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 180
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044CB2 01 02 02 07 0183*  	db 0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 181
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
044CC2 03 00 00 03 0184*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 182
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044CD2 03 00 00 03 0185*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 183
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044CE2 01 02 02 01 0186*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 184
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
044CF2 00 00 00 03 0187*  	db 0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 185
       05 05 03 00 
       00 03 00 00 
       00 00 00 00 
044D02 00 00 00 03 0188*  	db 0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 186
       05 05 03 00 
       00 03 00 00 
       00 00 00 00 
044D12 00 00 00 01 0189*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 187
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
044D22 00 00 00 03 0190*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 188
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044D32 00 00 00 03 0191*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 189
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044D42 00 00 00 01 0192*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 190
       02 02 06 02 
       02 01 00 00 
       00 00 00 00 
044D52 00 00 00 03 0193*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 191
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044D62 00 00 00 03 0194*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 192
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044D72 00 00 00 01 0195*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 193
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
044D82 00 00 00 03 0196*  	db 0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 194
       04 04 03 00 
       00 00 00 00 
       00 00 00 00 
044D92 00 00 00 03 0197*  	db 0x00,0x00,0x00,0x03,0x04,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 195
       04 04 03 00 
       00 00 00 00 
       00 00 00 00 
044DA2 00 00 00 01 0198*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 196
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
044DB2 00 00 00 03 0199*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 197
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044DC2 00 00 00 03 0200*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 198
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044DD2 00 00 00 07 0201*  	db 0x00,0x00,0x00,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 199
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
044DE2 00 00 00 03 0202*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 200
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044DF2 00 00 00 03 0203*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 201
       00 00 03 00 
       00 03 00 00 
       00 00 00 00 
044E02 00 00 00 01 0204*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 202
       02 02 01 02 
       02 01 00 00 
       00 00 00 00 
044E12 00 00 00 00 0205*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 203
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
044E22 00 00 00 00 0206*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x05,0x03,0x00,0x00,0x00,0x00,0x00,0x00 ; row 204
       00 00 03 05 
       05 03 00 00 
       00 00 00 00 
044E32 00 00 00 00 0207*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 205
       00 00 01 02 
       02 01 02 02 
       07 00 00 00 
044E42 00 00 00 00 0208*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 206
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
044E52 00 00 00 00 0209*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 207
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
044E62 00 00 00 00 0210*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01 ; row 208
       00 00 01 02 
       02 01 02 02 
       01 02 02 01 
044E72 00 00 00 00 0211*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03 ; row 209
       00 00 00 00 
       00 03 00 00 
       03 04 04 03 
044E82 00 00 00 00 0212*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x04,0x04,0x03 ; row 210
       00 00 00 00 
       00 03 00 00 
       03 04 04 03 
044E92 00 00 00 00 0213*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x06,0x02,0x02,0x01,0x02,0x02,0x01 ; row 211
       00 00 00 00 
       01 06 02 02 
       01 02 02 01 
044EA2 00 00 00 00 0214*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x01,0x00,0x00,0x00,0x00,0x00 ; row 212
       00 00 00 01 
       05 04 01 00 
       00 00 00 00 
044EB2 00 00 00 00 0215*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00 ; row 213
       00 00 01 05 
       04 05 01 00 
       00 00 00 00 
044EC2 00 00 00 00 0216*  	db 0x00,0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00 ; row 214
       00 01 05 04 
       05 01 00 00 
       00 00 00 00 
044ED2 00 00 00 00 0217*  	db 0x00,0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 215
       01 05 04 05 
       01 00 00 00 
       00 00 00 00 
044EE2 00 00 00 01 0218*  	db 0x00,0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 216
       05 04 05 01 
       00 00 00 00 
       00 00 00 00 
044EF2 00 00 01 05 0219*  	db 0x00,0x00,0x01,0x05,0x04,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 217
       04 05 01 00 
       00 00 00 00 
       00 00 00 00 
044F02 01 02 02 07 0220*  	db 0x01,0x02,0x02,0x07,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 218
       05 01 00 00 
       00 00 00 00 
       00 00 00 00 
044F12 03 00 00 03 0221*  	db 0x03,0x00,0x00,0x03,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 219
       01 00 00 00 
       00 00 00 00 
       00 00 00 00 
044F22 03 00 00 03 0222*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 220
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
044F32 01 02 02 01 0223*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 221
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
044F42 03 00 00 03 0224*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 222
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044F52 03 00 00 03 0225*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 223
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044F62 01 02 02 01 0226*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 224
       02 02 06 00 
       00 00 00 00 
       00 00 00 00 
044F72 00 00 00 03 0227*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 225
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044F82 00 00 00 03 0228*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 226
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
044F92 00 00 00 01 0229*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x00,0x00,0x00 ; row 227
       02 02 01 02 
       02 01 02 02 
       07 00 00 00 
044FA2 00 00 00 03 0230*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 228
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
044FB2 00 00 00 03 0231*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 229
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
044FC2 00 00 00 01 0232*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 230
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
044FD2 00 00 00 03 0233*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 231
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
044FE2 00 00 00 03 0234*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 232
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
044FF2 01 02 02 01 0235*  	db 0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x06,0x00,0x00,0x00 ; row 233
       02 02 01 02 
       02 01 02 02 
       06 00 00 00 
045002 03 00 00 03 0236*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 234
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
045012 03 00 00 03 0237*  	db 0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 235
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
045022 07 02 02 01 0238*  	db 0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 236
       02 02 01 00 
       00 00 00 00 
       00 00 00 00 
045032 00 00 00 03 0239*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 237
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
045042 00 00 00 03 0240*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 238
       00 00 03 00 
       00 00 00 00 
       00 00 00 00 
045052 00 00 00 01 0241*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 239
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
045062 00 00 00 03 0242*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 240
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
045072 00 00 00 03 0243*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 241
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
045082 00 00 00 01 0244*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 242
       02 02 06 02 
       02 01 02 02 
       01 00 00 00 
045092 00 00 00 00 0245*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 243
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0450A2 00 00 00 00 0246*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 244
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
0450B2 00 00 00 00 0247*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 245
       00 00 01 02 
       02 01 02 02 
       01 00 00 00 
0450C2 00 00 00 00 0248*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 246
       00 00 03 05 
       04 03 00 00 
       03 00 00 00 
0450D2 00 00 00 00 0249*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x05,0x04,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 247
       00 00 03 05 
       04 03 00 00 
       03 00 00 00 
0450E2 00 00 00 01 0250*  	db 0x00,0x00,0x00,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x01,0x00,0x00,0x00 ; row 248
       02 02 01 02 
       02 01 02 02 
       01 00 00 00 
0450F2 00 00 00 03 0251*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 249
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
045102 00 00 00 03 0252*  	db 0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x00 ; row 250
       00 00 03 00 
       00 03 00 00 
       03 00 00 00 
045112 01 02 02 07 0253*  	db 0x01,0x02,0x02,0x07,0x02,0x02,0x01,0x02,0x02,0x01,0x02,0x02,0x07,0x02,0x02,0x01 ; row 251
       02 02 01 02 
       02 01 02 02 
       07 02 02 01 
045122 03 05 05 03 0254*  	db 0x03,0x05,0x05,0x03,0x04,0x05,0x03,0x05,0x05,0x03,0x00,0x05,0x03,0x05,0x04,0x03 ; row 252
       04 05 03 05 
       05 03 00 05 
       03 05 04 03 
045132 03 04 04 03 0255*  	db 0x03,0x04,0x04,0x03,0x05,0x05,0x03,0x04,0x04,0x03,0x05,0x00,0x03,0x04,0x04,0x03 ; row 253
       05 05 03 04 
       04 03 05 00 
       03 04 04 03 
045142 01 02 02 06 0256*  	db 0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x06,0x02,0x02,0x01,0x02,0x02,0x06 ; row 254
       02 02 01 02 
       02 06 02 02 
       01 02 02 06 
045152 00 00 00 00 0257*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
045162             0258*  
045162             0259*  
045162 10          0260*  tiles_level_01: db 16  ; number of rows, 0 is max of 256
045163 00 00 00 00 0261*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
045173 00 00 00 00 0262*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
045183 00 00 00 00 0263*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
045193 00 00 00 00 0264*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0451A3 00 00 00 00 0265*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0451B3 00 00 00 00 0266*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0451C3 00 00 00 00 0267*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0451D3 00 00 00 00 0268*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0451E3 00 00 00 00 0269*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0451F3 00 00 00 00 0270*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
045203 00 00 00 00 0271*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
045213 00 00 00 00 0272*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
045223 00 00 00 00 0273*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
045233 00 00 00 00 0274*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
045243 00 00 00 00 0275*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
045253 00 00 00 00 0276*  	db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; row 255
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
045263             0277*  
045263             0050   
045263             0051   	include "src/asm/sprites.inc"
045263             0001*  ; ###### SPRITE TABLE FIELD INDICES ######
045263             0002*  table_bytes_per_record: equ 38 ; 38 bytes per sprite record
045263             0003*  sprite_id:              equ 00 ; 1 bytes unique spriteId, zero-based
045263             0004*  sprite_type:            equ 01 ; 1 bytes type of sprite as defined in enemies.inc
045263             0005*  sprite_base_bufferId:   equ 02 ; 3 bytes bitmap bufferId
045263             0006*  sprite_move_program:    equ 05 ; 3 bytes address of sprite's behavior subroutine
045263             0007*  sprite_collisions:      equ 08 ; 1 bytes low/high nibble: collision details
045263             0008*  sprite_dim_x:           equ 09 ; 1 bytes sprite width in pixels
045263             0009*  sprite_dim_y:           equ 10 ; 1 bytes sprite height in pixels
045263             0010*  sprite_x:               equ 11 ; 3 bytes 16.8 fractional x position in pixels
045263             0011*  sprite_y:               equ 14 ; 3 bytes 16.8 fractional y position in pixels
045263             0012*  sprite_xvel:            equ 17 ; 3 bytes x-component velocity, 16.8 fixed, pixels
045263             0013*  sprite_yvel:            equ 20 ; 3 bytes y-component velocity, 16.8 fixed, pixels
045263             0014*  sprite_vel:             equ 23 ; 3 bytes velocity px/frame (16.8 fixed)
045263             0015*  sprite_heading:         equ 26 ; 3 bytes sprite movement direction deg256 16.8 fixed
045263             0016*  sprite_orientation:     equ 29 ; 3 bytes orientation bits
045263             0017*  sprite_animation:       equ 32 ; 1 bytes current animation index, zero-based
045263             0018*  sprite_animation_timer: equ 33 ; 1 bytes when hits zero, draw next animation
045263             0019*  sprite_move_timer:      equ 34 ; 1 bytes when zero, go to next move program, or step
045263             0020*  sprite_move_step:       equ 35 ; 1 bytes stage in a move program sequence, varies
045263             0021*  sprite_points:          equ 36 ; 1 bytes points awarded for killing this sprite type, BCD
045263             0022*  sprite_shield_damage:   equ 37 ; 1 bytes shield points deducted for collision, binary
045263             0023*  
045263             0024*  ; ###### SPRITE TABLE VARIABLES ######
045263             0025*  ; maximum number of sprites
045263             0026*  table_max_records: equ 4 ; it can handle more but this is pushing it
045263             0027*  table_total_bytes: equ table_max_records*table_bytes_per_record
045263             0028*  
045263             0029*  ; #### THIS IS THE SPACE ALLOCATED TO THE SPRITE TABLE ####
045263             0030*  table_base:
045263 00 00 00 00 0031*  sprite_start_variables:  blkb table_total_bytes, 0 ; fill with zeroes
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0452FB             0032*  sprite_end_variables: ; in case we want to traverse the table in reverse
0452FB             0033*  
0452FB             0034*  ; pointer to top address of current record, initialized to table_base
0452FB 63 52 04    0035*  table_pointer: dl table_base
0452FE             0036*  ; how many active sprites
0452FE 00          0037*  table_active_sprites: db 0x00
0452FF             0038*  ; flag indicating collision with screen edge
0452FF             0039*  ; uses orientation codes to specify which edge(s)
0452FF 00          0040*  sprite_screen_edge: db #00
045300             0041*  ; next sprite id to use
045300 00          0042*  sprite_next_id: db 0
045301             0043*  
045301             0044*  ; ######### COLLISION SPRITE PARAMETERS ##########
045301             0045*  ; integer coordinates are all that are needed for collision calculations
045301 00          0046*  collision_x: db 0x00
045302 00          0047*  collision_y: db 0x00
045303 00          0048*  collision_dim_x: db 0x00
045304 00          0049*  collision_dim_y: db 0x00
045305             0050*  
045305             0051*  ; scratch variables
045305 00          0052*  x: db 0x00 ; 8-bit signed integer
045306 00          0053*  y: db 0x00 ; 8-bit signed integer
045307 00 00 00    0054*  x0: dl 0x000000 ; 16.8 signed fixed place
04530A 00 00 00    0055*  y0: dl 0x000000 ; 16.8 signed fixed place
04530D 00 00 00    0056*  incx1: dl 0x000000 ; 16.8 signed fixed place
045310 00 00 00    0057*  incy1: dl 0x000000 ; 16.8 signed fixed place
045313 00 00 00    0058*  incx2: dl 0x000000 ; 16.8 signed fixed place
045316 00 00 00    0059*  incy2: dl 0x000000 ; 16.8 signed fixed place
045319             0060*  
045319             0061*  ; sprite_heading: dl 0x000000 ; signed fixed 16.8
045319 00 00 00    0062*  radius: dl 0x000000 ; signed fixed 16.8 (but should always be positive)
04531C 00 00 00    0063*  sin_sprite_heading: dl 0x000000 ; signed fixed 16.8
04531F 00 00 00    0064*  cos_sprite_heading: dl 0x000000 ; signed fixed 16.8
045322             0065*  
045322             0066*  ; gets the next available sprite id
045322             0067*  ; inputs; none
045322             0068*  ; returns: if new sprite available, a = sprite id,
045322             0069*  ;           ix pointing to new sprite vars, carry set
045322             0070*  ;      otherwise, a = 0, carry flag reset, ix pointing to highest sprite vars
045322             0071*  ; destroys: a,b,hl,ix
045322             0072*  ; affects: bumps table_active_sprites by one
045322             0073*  table_get_next_id:
045322 DD 21 63 52 0074*      ld ix,table_base
       04          
045327 11 26 00 00 0075*      ld de,table_bytes_per_record
04532B 06 04       0076*      ld b,table_max_records
04532D             0077*  @loop:
04532D DD 7E 01    0078*      ld a,(ix+sprite_type)
045330 A7          0079*      and a
045331 28 06       0080*      jr z,@found
045333 DD 19       0081*      add ix,de
045335 10 F6       0082*      djnz @loop
045337             0083*  @notfound:
045337 AF          0084*      xor a ; a = 0 and reset carry flag indicating that we didn't find a free sprite
045338 C9          0085*      ret
045339             0086*  @found:
045339             0087*  ; bump number of active sprites
045339 21 FE 52 04 0088*      ld hl,table_active_sprites
04533D 34          0089*      inc (hl)
04533E             0090*  ; return sprite id
04533E 3E 04       0091*      ld a,table_max_records
045340 90          0092*      sub b
045341 32 00 53 04 0093*      ld (sprite_next_id),a
045345 37          0094*      scf ; sets carry flag indicating we found a free sprite
045346 C9          0095*      ret ; done
045347             0096*  
045347             0097*  ; deactivate the sprite with the given id
045347             0098*  ; inputs: a = sprite id
045347             0099*  ; outputs: nothing
045347             0100*  ; destroys: a,ix,de
045347             0101*  ; affects: decrements table_active_sprites by one
045347             0102*  table_deactivate_sprite:
045347 F5          0103*      push af ; save sprite id bc we need it later
045348 CD F9 5D 04 0104*      call vdu_sprite_select
04534C CD 7D 5E 04 0105*      call vdu_sprite_hide
045350 F1          0106*      pop af ; restore sprite id
045351 11 00 00 00 0107*      ld de,0 ; clear deu
045355 57          0108*      ld d,a
045356 1E 26       0109*      ld e,table_bytes_per_record
045358 ED 5C       0110*      mlt de
04535A DD 21 63 52 0111*      ld ix,table_base
       04          
04535F DD 19       0112*      add ix,de
045361 AF          0113*      xor a
045362 DD 77 01    0114*      ld (ix+sprite_type),a
045365 DD 21 FE 52 0115*      ld ix,table_active_sprites
       04          
04536A DD 35 00    0116*      dec (ix)
04536D C9          0117*      ret
04536E             0052   ; API includes
04536E             0053       include "src/asm/mos_api.inc"
04536E             0001*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/mos_api.inc
04536E             0002*  ; Title:	AGON MOS - API for user projects
04536E             0003*  ; Author:	Dean Belfield
04536E             0004*  ;			Adapted for agon-ez80asm by Jeroen Venema
04536E             0005*  ;			Added MOS error codes for return in HL
04536E             0006*  ; Created:	03/08/2022
04536E             0007*  ; Last Updated:	10/08/2023
04536E             0008*  ;
04536E             0009*  ; Modinfo:
04536E             0010*  ; 05/08/2022:	Added mos_feof
04536E             0011*  ; 09/08/2022:	Added system variables: cursorX, cursorY
04536E             0012*  ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
04536E             0013*  ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
04536E             0014*  ; 24/09/2022:	Added mos_getError, mos_mkdir
04536E             0015*  ; 13/10/2022:	Added mos_oscli
04536E             0016*  ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
04536E             0017*  ; 04/03/2023:	Added sysvar_scrpixelIndex
04536E             0018*  ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
04536E             0019*  ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
04536E             0020*  ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
04536E             0021*  ; 22/03/2023:	The VDP commands are now indexed from 0x80
04536E             0022*  ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
04536E             0023*  ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
04536E             0024*  ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
04536E             0025*  ; 19/05/2023:	Added sysvar_scrMode
04536E             0026*  ; 05/06/2023:	Added sysvar_rtcEnable
04536E             0027*  ; 03/08/2023:	Added mos_setkbvector
04536E             0028*  ; 10/08/2023:	Added mos_getkbmap
04536E             0029*  
04536E             0030*  ; VDP control (VDU 23, 0, n)
04536E             0031*  ;
04536E             0032*  vdp_gp:				EQU 80h
04536E             0033*  vdp_keycode:		EQU 81h
04536E             0034*  vdp_cursor:			EQU	82h
04536E             0035*  vdp_scrchar:		EQU	83h
04536E             0036*  vdp_scrpixel:		EQU	84h
04536E             0037*  vdp_audio:			EQU	85h
04536E             0038*  vdp_mode:			EQU	86h
04536E             0039*  vdp_rtc:			EQU	87h
04536E             0040*  vdp_keystate:		EQU	88h
04536E             0041*  vdp_logicalcoords:	EQU	C0h
04536E             0042*  vdp_terminalmode:	EQU	FFh
04536E             0043*  
04536E             0044*  ; MOS high level functions
04536E             0045*  ;
04536E             0046*  mos_getkey:			EQU	00h
04536E             0047*  mos_load:			EQU	01h
04536E             0048*  mos_save:			EQU	02h
04536E             0049*  mos_cd:				EQU	03h
04536E             0050*  mos_dir:			EQU	04h
04536E             0051*  mos_del:			EQU	05h
04536E             0052*  mos_ren:			EQU	06h
04536E             0053*  mos_mkdir:			EQU	07h
04536E             0054*  mos_sysvars:		EQU	08h
04536E             0055*  mos_editline:		EQU	09h
04536E             0056*  mos_fopen:			EQU	0Ah
04536E             0057*  mos_fclose:			EQU	0Bh
04536E             0058*  mos_fgetc:			EQU	0Ch
04536E             0059*  mos_fputc:			EQU	0Dh
04536E             0060*  mos_feof:			EQU	0Eh
04536E             0061*  mos_getError:		EQU	0Fh
04536E             0062*  mos_oscli:			EQU	10h
04536E             0063*  mos_copy:			EQU	11h
04536E             0064*  mos_getrtc:			EQU	12h
04536E             0065*  mos_setrtc:			EQU	13h
04536E             0066*  mos_setintvector:	EQU	14h
04536E             0067*  mos_uopen:			EQU	15h
04536E             0068*  mos_uclose:			EQU	16h
04536E             0069*  mos_ugetc:			EQU	17h
04536E             0070*  mos_uputc:			EQU	18h
04536E             0071*  mos_getfil:			EQU	19h
04536E             0072*  mos_fread:			EQU	1Ah
04536E             0073*  mos_fwrite:			EQU	1Bh
04536E             0074*  mos_flseek:			EQU	1Ch
04536E             0075*  mos_setkbvector:	EQU	1Dh
04536E             0076*  mos_getkbmap:		EQU	1Eh
04536E             0077*  
04536E             0078*  ; MOS program exit codes
04536E             0079*  ;
04536E             0080*  EXIT_OK:				EQU  0;	"OK",
04536E             0081*  EXIT_ERROR_SD_ACCESS:	EQU	 1;	"Error accessing SD card",
04536E             0082*  EXIT_ERROR_ASSERTION:	EQU  2;	"Assertion failed",
04536E             0083*  EXIT_SD_CARDFAILURE:	EQU  3;	"SD card failure",
04536E             0084*  EXIT_FILENOTFOUND:		EQU  4;	"Could not find file",
04536E             0085*  EXIT_PATHNOTFOUND:		EQU  5;	"Could not find path",
04536E             0086*  EXIT_INVALIDPATHNAME:	EQU  6;	"Invalid path name",
04536E             0087*  EXIT_ACCESSDENIED_FULL:	EQU  7;	"Access denied or directory full",
04536E             0088*  EXIT_ACCESSDENIED:		EQU  8;	"Access denied",
04536E             0089*  EXIT_INVALIDOBJECT:		EQU  9;	"Invalid file/directory object",
04536E             0090*  EXIT_SD_WRITEPROTECTED:	EQU 10;	"SD card is write protected",
04536E             0091*  EXIT_INVALIDDRIVENUMBER:EQU 11;	"Logical drive number is invalid",
04536E             0092*  EXIT_NOVOLUMEWORKAREA:	EQU 12;	"Volume has no work area",
04536E             0093*  EXIT_NOVALIDFATVOLUME:	EQU 13;	"No valid FAT volume",
04536E             0094*  EXIT_ERRORMKFS:			EQU 14;	"Error occurred during mkfs",
04536E             0095*  EXIT_VOLUMETIMEOUT:		EQU 15;	"Volume timeout",
04536E             0096*  EXIT_VOLUMELOCKED:		EQU 16;	"Volume locked",
04536E             0097*  EXIT_LFNALLOCATION:		EQU 17;	"LFN working buffer could not be allocated",
04536E             0098*  EXIT_MAXOPENFILES:		EQU 18;	"Too many open files",
04536E             0099*  EXIT_INVALIDPARAMETER:	EQU 19;	"Invalid parameter",
04536E             0100*  EXIT_INVALIDCOMMAND:	EQU 20;	"Invalid command",
04536E             0101*  EXIT_INVALIDEXECUTABLE:	EQU 21;	"Invalid executable",
04536E             0102*  ; FatFS file access functions
04536E             0103*  ;
04536E             0104*  ffs_fopen:			EQU	80h
04536E             0105*  ffs_fclose:			EQU	81h
04536E             0106*  ffs_fread:			EQU	82h
04536E             0107*  ffs_fwrite:			EQU	83h
04536E             0108*  ffs_flseek:			EQU	84h
04536E             0109*  ffs_ftruncate:		EQU	85h
04536E             0110*  ffs_fsync:			EQU	86h
04536E             0111*  ffs_fforward:		EQU	87h
04536E             0112*  ffs_fexpand:		EQU	88h
04536E             0113*  ffs_fgets:			EQU	89h
04536E             0114*  ffs_fputc:			EQU	8Ah
04536E             0115*  ffs_fputs:			EQU	8Bh
04536E             0116*  ffs_fprintf:		EQU	8Ch
04536E             0117*  ffs_ftell:			EQU	8Dh
04536E             0118*  ffs_feof:			EQU	8Eh
04536E             0119*  ffs_fsize:			EQU	8Fh
04536E             0120*  ffs_ferror:			EQU	90h
04536E             0121*  
04536E             0122*  ; FatFS directory access functions
04536E             0123*  ;
04536E             0124*  ffs_dopen:			EQU	91h
04536E             0125*  ffs_dclose:			EQU	92h
04536E             0126*  ffs_dread:			EQU	93h
04536E             0127*  ffs_dfindfirst:		EQU	94h
04536E             0128*  ffs_dfindnext:		EQU	95h
04536E             0129*  
04536E             0130*  ; FatFS file and directory management functions
04536E             0131*  ;
04536E             0132*  ffs_stat:			EQU	96h
04536E             0133*  ffs_unlink:			EQU	97h
04536E             0134*  ffs_rename:			EQU	98h
04536E             0135*  ffs_chmod:			EQU	99h
04536E             0136*  ffs_utime:			EQU	9Ah
04536E             0137*  ffs_mkdir:			EQU	9Bh
04536E             0138*  ffs_chdir:			EQU	9Ch
04536E             0139*  ffs_chdrive:		EQU	9Dh
04536E             0140*  ffs_getcwd:			EQU	9Eh
04536E             0141*  
04536E             0142*  ; FatFS volume management and system configuration functions
04536E             0143*  ;
04536E             0144*  ffs_mount:			EQU	9Fh
04536E             0145*  ffs_mkfs:			EQU	A0h
04536E             0146*  ffs_fdisk:			EQU	A1h
04536E             0147*  ffs_getfree:		EQU	A2h
04536E             0148*  ffs_getlabel:		EQU	A3h
04536E             0149*  ffs_setlabel:		EQU	A4h
04536E             0150*  ffs_setcp:			EQU	A5h
04536E             0151*  
04536E             0152*  ; File access modes
04536E             0153*  ;
04536E             0154*  fa_read:			EQU	01h
04536E             0155*  fa_write:			EQU	02h
04536E             0156*  fa_open_existing:	EQU	00h
04536E             0157*  fa_create_new:		EQU	04h
04536E             0158*  fa_create_always:	EQU	08h
04536E             0159*  fa_open_always:		EQU	10h
04536E             0160*  fa_open_append:		EQU	30h
04536E             0161*  
04536E             0162*  ; System variable indexes for api_sysvars
04536E             0163*  ; Index into _sysvars in globals.inc
04536E             0164*  ;
04536E             0165*  sysvar_time:			EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
04536E             0166*  sysvar_vpd_pflags:		EQU	04h	; 1: Flags to indicate completion of VDP commands
04536E             0167*  sysvar_keyascii:		EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
04536E             0168*  sysvar_keymods:			EQU	06h	; 1: Keycode modifiers
04536E             0169*  sysvar_cursorX:			EQU	07h	; 1: Cursor X position
04536E             0170*  sysvar_cursorY:			EQU	08h	; 1: Cursor Y position
04536E             0171*  sysvar_scrchar:			EQU	09h	; 1: Character read from screen
04536E             0172*  sysvar_scrpixel:		EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
04536E             0173*  sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
04536E             0174*  sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
04536E             0175*  sysvar_scrWidth:		EQU	0Fh	; 2: Screen width in pixels
04536E             0176*  sysvar_scrHeight:		EQU	11h	; 2: Screen height in pixels
04536E             0177*  sysvar_scrCols:			EQU	13h	; 1: Screen columns in characters
04536E             0178*  sysvar_scrRows:			EQU	14h	; 1: Screen rows in characters
04536E             0179*  sysvar_scrColours:		EQU	15h	; 1: Number of colours displayed
04536E             0180*  sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
04536E             0181*  sysvar_vkeycode:		EQU	17h	; 1: Virtual key code from FabGL
04536E             0182*  sysvar_vkeydown:		EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
04536E             0183*  sysvar_vkeycount:		EQU	19h	; 1: Incremented every time a key packet is received
04536E             0184*  sysvar_rtc:				EQU	1Ah	; 6: Real time clock data
04536E             0185*  sysvar_spare:			EQU	20h	; 2: Spare, previously used by rtc
04536E             0186*  sysvar_keydelay:		EQU	22h	; 2: Keyboard repeat delay
04536E             0187*  sysvar_keyrate:			EQU	24h	; 2: Keyboard repeat reat
04536E             0188*  sysvar_keyled:			EQU	26h	; 1: Keyboard LED status
04536E             0189*  sysvar_scrMode:			EQU	27h	; 1: Screen mode
04536E             0190*  sysvar_rtcEnable:		EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
04536E             0191*  
04536E             0192*  ; Flags for the VPD protocol
04536E             0193*  ;
04536E             0194*  vdp_pflag_cursor:		EQU	00000001b
04536E             0195*  vdp_pflag_scrchar:		EQU	00000010b
04536E             0196*  vdp_pflag_point:		EQU	00000100b
04536E             0197*  vdp_pflag_audio:		EQU	00001000b
04536E             0198*  vdp_pflag_mode:			EQU	00010000b
04536E             0199*  vdp_pflag_rtc:			EQU	00100000b
04536E             0200*  
04536E             0201*  ;
04536E             0202*  ; FatFS structures
04536E             0203*  ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
04536E             0204*  ;
04536E             0205*  ; Object ID and allocation information (FFOBJID)
04536E             0206*  ;
04536E             0207*  ; Indexes into FFOBJID structure
04536E             0208*  ffobjid_fs:			EQU	0	; 3: Pointer to the hosting volume of this object
04536E             0209*  ffobjid_id:			EQU	3	; 2: Hosting volume mount ID
04536E             0210*  ffobjid_attr:		EQU	5	; 1: Object attribute
04536E             0211*  ffobjid_stat:		EQU	6	; 1: Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
04536E             0212*  ffobjid_sclust:		EQU	7	; 4: Object data start cluster (0:no cluster or root directory)
04536E             0213*  ffobjid_objsize:	EQU	11	; 4: Object size (valid when sclust != 0)
04536E             0214*  ;
04536E             0215*  ; File object structure (FIL)
04536E             0216*  ;
04536E             0217*  ; Indexes into FIL structure
04536E             0218*  fil_obj:		EQU 0	; 15: Object identifier
04536E             0219*  fil_flag:		EQU	15 	;  1: File status flags
04536E             0220*  fil_err:		EQU	16	;  1: Abort flag (error code)
04536E             0221*  fil_fptr:		EQU	17	;  4: File read/write pointer (Zeroed on file open)
04536E             0222*  fil_clust:		EQU	21	;  4: Current cluster of fpter (invalid when fptr is 0)
04536E             0223*  fil_sect:		EQU	25	;  4: Sector number appearing in buf[] (0:invalid)
04536E             0224*  fil_dir_sect:	EQU	29	;  4: Sector number containing the directory entry
04536E             0225*  fil_dir_ptr:	EQU	33	;  3: Pointer to the directory entry in the win[]
04536E             0226*  ;
04536E             0227*  ; Directory object structure (DIR)
04536E             0228*  ; Indexes into DIR structure
04536E             0229*  dir_obj:		EQU  0	; 15: Object identifier
04536E             0230*  dir_dptr:		EQU	15	;  4: Current read/write offset
04536E             0231*  dir_clust:		EQU	19	;  4: Current cluster
04536E             0232*  dir_sect:		EQU	23	;  4: Current sector (0:Read operation has terminated)
04536E             0233*  dir_dir:		EQU	27	;  3: Pointer to the directory item in the win[]
04536E             0234*  dir_fn:			EQU	30	; 12: SFN (in/out) {body[8],ext[3],status[1]}
04536E             0235*  dir_blk_ofs:	EQU	42	;  4: Offset of current entry block being processed (0xFFFFFFFF:Invalid)
04536E             0236*  ;
04536E             0237*  ; File information structure (FILINFO)
04536E             0238*  ;
04536E             0239*  ; Indexes into FILINFO structure
04536E             0240*  filinfo_fsize:		EQU 0	;   4: File size
04536E             0241*  filinfo_fdate:		EQU	4	;   2: Modified date
04536E             0242*  filinfo_ftime:		EQU	6	;   2: Modified time
04536E             0243*  filinfo_fattrib:	EQU	8	;   1: File attribute
04536E             0244*  filinfo_altname:	EQU	9	;  13: Alternative file name
04536E             0245*  filinfo_fname:		EQU	22	; 256: Primary file name
04536E             0246*  ;
04536E             0247*  ; Macro for calling the API
04536E             0248*  ; Parameters:
04536E             0249*  ; - function: One of the function numbers listed above
04536E             0250*  ;
04536E             0251*  	MACRO	MOSCALL	function
04536E             0252*  			LD	A, function
04536E             0253*  			RST.LIL	08h
04536E             0254*  	ENDMACRO
04536E             0054       include "src/asm/functions.inc"
04536E             0001*  ; hlu 1 byte right shift, unsigned
04536E             0002*  ; returns: hlu / 256, fractional portion in a
04536E             0003*  ; destroys: af
04536E             0004*  hlu_udiv256:
04536E AF          0005*  	xor a
04536F 32 80 53 04 0006*  	ld (@buffer+3),a
045373 7D          0007*  	ld a,l ; save the fractional portion
045374 22 7D 53 04 0008*  	ld (@buffer),hl
045378 2A 7E 53 04 0009*  	ld hl,(@buffer+1)
04537C C9          0010*  	ret
04537D             0011*  @buffer: ds 4
045381             0012*  
045381             0013*  ; absolute value of hlu
045381             0014*  ; returns: abs(hlu), flags set according to the incoming sign of hlu:
045381             0015*  ;         s1,z0,pv0,n1,c0 if hlu was negative
045381             0016*  ;         s0,z1,pv0,n1,c0 if hlu was zero
045381             0017*  ;         s0,z0,pv0,n1,c0 if hlu was positive
045381             0018*  ; destroys: a
045381             0019*  hlu_abs:
045381 19          0020*      add hl,de
045382 B7          0021*      or a
045383 ED 52       0022*      sbc hl,de
045385 FA 8A 53 04 0023*      jp m,@is_neg
045389 C9          0024*      ret         ; hlu is positive or zero so we're done
04538A             0025*  @is_neg:
04538A F5          0026*      push af     ; otherwise, save current flags for return
04538B CD 24 60 04 0027*      call neg_hlu ; negate hlu
04538F F1          0028*      pop af      ; get back flags
045390 C9          0029*      ret
045391             0030*  
045391             0031*      MACRO hlu_mul256
045391             0032*          add hl,hl ; * 2
045391             0033*          add hl,hl ; * 4
045391             0034*          add hl,hl ; * 8
045391             0035*          add hl,hl ; * 16
045391             0036*          add hl,hl ; * 32
045391             0037*          add hl,hl ; * 64
045391             0038*          add hl,hl ; * 128
045391             0039*          add hl,hl ; * 256
045391             0040*      ENDMACRO
045391             0041*  
045391             0042*      MACRO printChar char
045391             0043*          LD A, char
045391             0044*          RST.LIL 10h
045391             0045*      ENDMACRO
045391             0046*  
045391             0047*  ; test the sign of HL
045391             0048*  ; inputs: HL obviously
045391             0049*  ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
045391             0050*  ; destroys: flags
045391             0051*      MACRO sign_hlu
045391             0052*          add hl,de
045391             0053*          or a
045391             0054*          sbc hl,de
045391             0055*      ENDMACRO
045391             0056*  
045391             0057*  ; Simulated call to subroutine at HL
045391             0058*  ; inputs: HL pointing to the subroutine address plus whatever the called function expects
045391             0059*  ; outputs: whatever the subroutine does, including HL and BC
045391             0060*  ; destroys: only what the subroutine does, but always BC
045391             0061*      MACRO callHL
045391             0062*          ld bc,$+7     ; Address of first instruction after the jump
045391             0063*          push bc       ; which constitutes the return address
045391             0064*          jp   (hl)     ; Jump to the address in HL
045391             0065*      ENDMACRO
045391             0066*  
045391             0067*  ; Simulated call to subroutine at IX
045391             0068*  ; inputs: IX pointing to the subroutine address plus whatever the called function expects
045391             0069*  ; outputs: whatever the subroutine does, including IX and BC
045391             0070*  ; destroys: only what the subroutine does, but always BC
045391             0071*      MACRO callIX
045391             0072*          ld bc,$+7     ; Address of first instruction after the jump
045391             0073*          push bc       ; which constitutes the return address
045391             0074*          jp   (ix)     ; Jump to the address in IX
045391             0075*      ENDMACRO
045391             0076*  
045391             0077*  ; Simulated call to soubroutinte at IY
045391             0078*  ; inputs: IY pointing to the subroutine address plus whatever the called function expects
045391             0079*  ; outputs: whatever the subroutine does, including IY and BC
045391             0080*  ; destroys: only what the subroutine does, but always BC
045391             0081*      MACRO callIY
045391             0082*          ld bc,$+7     ; Address of first instruction after the jump
045391             0083*          push bc       ; which constitutes the return address
045391             0084*          jp   (iy)     ; Jump to the address in IY
045391             0085*      ENDMACRO
045391             0086*  
045391             0087*  ; put the value in HLU into the accumulator
045391             0088*  ; destroys: af
045391             0089*      MACRO HLU_TO_A
045391             0090*          push hl ; 4 cycles
045391             0091*          inc sp ; 1 cycle
045391             0092*          pop af  ; 4 cycles
045391             0093*          dec sp ; 1 cycle
045391             0094*                 ; 10 cycles total
045391             0095*      ENDMACRO
045391             0096*  
045391             0097*  A_TO_HLU:
045391             0098*      ; call is 7 cycles
045391 22 9E 53 04 0099*      ld (@scratch),hl ; 7 cycles
045395 32 A0 53 04 0100*      ld (@scratch+2),a ; 5 cycles
045399 2A 9E 53 04 0101*      ld hl,(@scratch) ; 7 cycles
04539D C9          0102*      ret ; 6 cycles
04539E             0103*          ; 25 cycles total
04539E 00 00 00    0104*  @scratch: dl 0
0453A1             0105*  
0453A1             0106*      ; TODO: implement this
0453A1             0107*      ; MACRO A_TO_HLU
0453A1             0108*      ;     push.s af
0453A1             0109*      ;     inc sp
0453A1             0110*      ;     push.s hl
0453A1             0111*      ;     pop hl
0453A1             0112*      ;     inc sp
0453A1             0113*      ;     inc sp
0453A1             0114*      ; ENDMACRO
0453A1             0115*  
0453A1             0116*      MACRO PUSH_ALL
0453A1             0117*          ex af,af'
0453A1             0118*          exx
0453A1             0119*          push af
0453A1             0120*          push hl
0453A1             0121*          push bc
0453A1             0122*          push de
0453A1             0123*  
0453A1             0124*          ex af,af'
0453A1             0125*          exx
0453A1             0126*          push af
0453A1             0127*          push hl
0453A1             0128*          push bc
0453A1             0129*          push de
0453A1             0130*          push ix
0453A1             0131*          push iy
0453A1             0132*      ENDMACRO
0453A1             0133*  
0453A1             0134*      MACRO POP_ALL
0453A1             0135*          pop iy
0453A1             0136*          pop ix
0453A1             0137*          pop de
0453A1             0138*          pop bc
0453A1             0139*          pop hl
0453A1             0140*          pop af
0453A1             0141*          ex af,af'
0453A1             0142*          exx
0453A1             0143*  
0453A1             0144*          pop de
0453A1             0145*          pop bc
0453A1             0146*          pop hl
0453A1             0147*          pop af
0453A1             0148*          ex af,af'
0453A1             0149*          exx
0453A1             0150*      ENDMACRO
0453A1             0151*  
0453A1             0152*  ; Print a zero-terminated string inline with code, e.g.:
0453A1             0153*  ;
0453A1             0154*  ;    call printInline
0453A1             0155*  ;    ASCIZ "Hello, world!\r\n"
0453A1             0156*  ;
0453A1             0157*  ; Destroys: HL,AF
0453A1             0158*  printInline:
0453A1 E1          0159*      pop hl ; get the return address = pointer to start of string
0453A2 CD A8 53 04 0160*      call printString ; HL advances to end of string
0453A6 E5          0161*      push hl ; restore the return address = pointer to end of string
0453A7 C9          0162*      ret
0453A8             0163*  
0453A8             0164*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
0453A8             0165*  ; Print a zero-terminated string
0453A8             0166*  ; HL: Pointer to string
0453A8             0167*  printString:
0453A8 C5          0168*  	PUSH	BC
0453A9 01 00 00 00 0169*  	LD		BC,0
0453AD 3E 00       0170*  	LD 	 	A,0
0453AF 5B DF       0171*  	RST.LIL 18h
0453B1 C1          0172*  	POP		BC
0453B2 C9          0173*  	RET
0453B3             0174*  ; print a VDU sequence
0453B3             0175*  ; HL: Pointer to VDU sequence - <1 byte length> <data>
0453B3             0176*  sendVDUsequence:
0453B3 C5          0177*  	PUSH	BC
0453B4 01 00 00 00 0178*  	LD		BC, 0
0453B8 4E          0179*  	LD		C, (HL)
0453B9 5B DF       0180*  	RST.LIL	18h
0453BB C1          0181*  	POP		BC
0453BC C9          0182*  	RET
0453BD             0183*  ; Print Newline sequence to VDP
0453BD             0184*  printNewLine:
0453BD F5          0185*      push af ; for some reason rst.lil 10h sets carry flag
0453BE 3E 0D       0186*  	LD	A, '\r'
0453C0 5B D7       0187*  	RST.LIL 10h
0453C2 3E 0A       0188*  	LD	A, '\n'
0453C4 5B D7       0189*  	RST.LIL 10h
0453C6 F1          0190*      pop af
0453C7 C9          0191*  	RET
0453C8             0192*  
0453C8             0193*  ; Print a 24-bit HEX number
0453C8             0194*  ; HLU: Number to print
0453C8             0195*  printHex24:
0453C8             0196*      HLU_TO_A
0453C8 E5          0001*M         push hl ; 4 cycles
0453C9 33          0002*M         inc sp ; 1 cycle
0453CA F1          0003*M         pop af  ; 4 cycles
0453CB 3B          0004*M         dec sp ; 1 cycle
0453CC             0005*M                ; 10 cycles total
0453CC CD D6 53 04 0197*  	CALL	printHex8
0453D0             0198*  ; Print a 16-bit HEX number
0453D0             0199*  ; HL: Number to print
0453D0             0200*  printHex16:
0453D0 7C          0201*  	LD		A,H
0453D1 CD D6 53 04 0202*  	CALL	printHex8
0453D5 7D          0203*  	LD		A,L
0453D6             0204*  ; Print an 8-bit HEX number
0453D6             0205*  ; A: Number to print
0453D6             0206*  printHex8:
0453D6 4F          0207*  	LD		C,A
0453D7 1F          0208*  	RRA
0453D8 1F          0209*  	RRA
0453D9 1F          0210*  	RRA
0453DA 1F          0211*  	RRA
0453DB CD E0 53 04 0212*  	CALL	@F
0453DF 79          0213*  	LD		A,C
0453E0             0214*  @@:
0453E0 E6 0F       0215*  	AND		0Fh
0453E2 C6 90       0216*  	ADD		A,90h
0453E4 27          0217*  	DAA
0453E5 CE 40       0218*  	ADC		A,40h
0453E7 27          0219*  	DAA
0453E8 5B D7       0220*  	RST.LIL	10h
0453EA C9          0221*  	RET
0453EB             0222*  
0453EB             0223*  printHexA:
0453EB F5          0224*      push af
0453EC C5          0225*      push bc
0453ED CD D6 53 04 0226*      call printHex8
0453F1 3E 20       0227*      ld a,' '
0453F3 5B D7       0228*      rst.lil 10h
0453F5 C1          0229*      pop bc
0453F6 F1          0230*      pop af
0453F7 C9          0231*      ret
0453F8             0232*  
0453F8             0233*  printHexHL:
0453F8 F5          0234*      push af
0453F9 C5          0235*      push bc
0453FA CD D0 53 04 0236*      call printHex16
0453FE 3E 20       0237*      ld a,' '
045400 5B D7       0238*      rst.lil 10h
045402 C1          0239*      pop bc
045403 F1          0240*      pop af
045404 C9          0241*      ret
045405             0242*  
045405             0243*  printHexUHL:
045405 F5          0244*      push af
045406 C5          0245*      push bc
045407 CD C8 53 04 0246*      call printHex24
04540B 3E 20       0247*      ld a,' '
04540D 5B D7       0248*      rst.lil 10h
04540F C1          0249*      pop bc
045410 F1          0250*      pop af
045411 C9          0251*      ret
045412             0252*  
045412             0253*  printHexAUHL:
045412 F5          0254*      push af
045413 C5          0255*      push bc
045414 CD D6 53 04 0256*      call printHex8
045418 3E 2E       0257*      ld a,'.'
04541A 5B D7       0258*      rst.lil 10h
04541C CD C8 53 04 0259*      call printHex24
045420 3E 20       0260*      ld a,' '
045422 5B D7       0261*      rst.lil 10h
045424 C1          0262*      pop bc
045425 F1          0263*      pop af
045426 C9          0264*      ret
045427             0265*  
045427             0266*  printHexABHL:
045427             0267*  ; preserve registers
045427 C5          0268*      push bc ; b will be ok c will not
045428 F5          0269*      push af ; will get totally destroyed
045429             0270*  ; print a
045429 CD D6 53 04 0271*      call printHex8
04542D             0272*  ; print b
04542D 78          0273*      ld a,b
04542E CD D6 53 04 0274*      call printHex8
045432             0275*  ; print hl
045432 CD D0 53 04 0276*      call printHex16
045436             0277*  ; restore registers
045436 F1          0278*      pop af
045437 C1          0279*      pop bc
045438 C9          0280*      ret
045439             0281*  
045439             0282*  printHexBHL:
045439             0283*  ; preserve registers
045439 C5          0284*      push bc ; b will be ok c will not
04543A F5          0285*      push af ; will get totally destroyed
04543B             0286*  ; print b
04543B 78          0287*      ld a,b
04543C CD D6 53 04 0288*      call printHex8
045440             0289*  ; print hl
045440 CD D0 53 04 0290*      call printHex16
045444             0291*  ; restore registers
045444 F1          0292*      pop af
045445 C1          0293*      pop bc
045446 C9          0294*      ret
045447             0295*  
045447             0296*  printHexCDE:
045447             0297*  ; preserve registers
045447 C5          0298*      push bc ; b will be ok c will not
045448 F5          0299*      push af ; will get totally destroyed
045449             0300*  ; print c
045449 79          0301*      ld a,c
04544A CD D6 53 04 0302*      call printHex8
04544E             0303*  ; print de
04544E EB          0304*      ex de,hl
04544F CD D0 53 04 0305*      call printHex16
045453 EB          0306*      ex de,hl
045454             0307*  ; restore registers
045454 F1          0308*      pop af
045455 C1          0309*      pop bc
045456 C9          0310*      ret
045457             0311*  
045457             0312*  printHexUIX:
045457             0313*  ; store everything in scratch
045457 22 D0 58 04 0314*      ld (uhl),hl
04545B ED 43 D3 58 0315*      ld (ubc),bc
       04          
045460 ED 53 D6 58 0316*      ld (ude),de
       04          
045465 DD 22 D9 58 0317*      ld (uix),ix
       04          
04546A FD 22 DC 58 0318*      ld (uiy),iy
       04          
04546F F5          0319*      push af ; fml
045470             0320*  
045470 21 67 58 04 0321*      ld hl,str_ixu
045474 CD A8 53 04 0322*      call printString
045478 2A D9 58 04 0323*      ld hl,(uix)
04547C CD C8 53 04 0324*      call printHex24
045480 CD BD 53 04 0325*      call printNewLine
045484             0326*  
045484             0327*  ; restore everything
045484 2A D0 58 04 0328*      ld hl, (uhl)
045488 ED 4B D3 58 0329*      ld bc, (ubc)
       04          
04548D ED 5B D6 58 0330*      ld de, (ude)
       04          
045492 DD 2A D9 58 0331*      ld ix, (uix)
       04          
045497 FD 2A DC 58 0332*      ld iy, (uiy)
       04          
04549C F1          0333*      pop af
04549D             0334*  ; all done
04549D C9          0335*      ret
04549E             0336*  
04549E             0337*  ; Print a 0x HEX prefix
04549E             0338*  DisplayHexPrefix:
04549E 3E 30       0339*  	LD	A, '0'
0454A0 5B D7       0340*  	RST.LIL 10h
0454A2 3E 78       0341*  	LD	A, 'x'
0454A4 5B D7       0342*  	RST.LIL 10h
0454A6 C9          0343*  	RET
0454A7             0344*  
0454A7             0345*      MACRO printDecBC
0454A7             0346*          push hl
0454A7             0347*          push bc
0454A7             0348*          pop hl
0454A7             0349*          call printDec
0454A7             0350*          pop hl
0454A7             0351*      ENDMACRO
0454A7             0352*  
0454A7             0353*      MACRO printDecDE
0454A7             0354*          push hl
0454A7             0355*          push de
0454A7             0356*          pop hl
0454A7             0357*          call printDec
0454A7             0358*          pop hl
0454A7             0359*      ENDMACRO
0454A7             0360*  
0454A7             0361*      MACRO printDecHL
0454A7             0362*          call printDec
0454A7             0363*      ENDMACRO
0454A7             0364*  
0454A7             0365*      MACRO printDecIX
0454A7             0366*          push hl
0454A7             0367*          push ix
0454A7             0368*          pop hl
0454A7             0369*          call printDec
0454A7             0370*          pop hl
0454A7             0371*      ENDMACRO
0454A7             0372*  
0454A7             0373*      MACRO printDecIY
0454A7             0374*          push hl
0454A7             0375*          push iy
0454A7             0376*          pop hl
0454A7             0377*          call printDec
0454A7             0378*          pop hl
0454A7             0379*      ENDMACRO
0454A7             0380*  
0454A7             0381*  
0454A7             0382*  ; Prints the right justified decimal value in HL without leading zeroes
0454A7             0383*  ; HL : Value to print
0454A7             0384*  ; preserves all registers and flags
0454A7             0385*  printDec:
0454A7             0386*  ; BEGIN MY CODE
0454A7             0387*  ; back up all the things
0454A7 F5          0388*      push af
0454A8 C5          0389*      push bc
0454A9 D5          0390*      push de
0454AA E5          0391*      push hl
0454AB             0392*  ; END MY CODE
0454AB 11 D3 54 04 0393*  	LD	 DE, _printDecBuffer
0454AF CD E3 54 04 0394*  	CALL u24_to_ascii
0454B3             0395*  ; BEGIN MY CODE
0454B3             0396*  ; replace leading zeroes with spaces
0454B3 21 D3 54 04 0397*      LD	 HL, _printDecBuffer
0454B7 06 07       0398*      ld   B, 7 ; if HL was 0, we want to keep the final zero
0454B9             0399*  @loop:
0454B9 7E          0400*      LD	 A, (HL)
0454BA FE 30       0401*      CP	 '0'
0454BC C2 C6 54 04 0402*      JP	 NZ, @done
0454C0 3E 20       0403*      LD   A, ' '
0454C2 77          0404*      LD	 (HL), A
0454C3 23          0405*      INC	 HL
0454C4             0406*      ; CALL vdu_cursor_forward
0454C4 10 F3       0407*      DJNZ @loop
0454C6             0408*  @done:
0454C6             0409*  ; END MY CODE
0454C6 21 D3 54 04 0410*  	LD	 HL, _printDecBuffer
0454CA CD A8 53 04 0411*  	CALL printString
0454CE             0412*  ; BEGIN MY CODE
0454CE             0413*  ; restore all the things
0454CE E1          0414*      pop hl
0454CF D1          0415*      pop de
0454D0 C1          0416*      pop bc
0454D1 F1          0417*      pop af
0454D2             0418*  ; END MY CODE
0454D2 C9          0419*  	RET
0454D3 00 00 00 00 0420*  _printDecBuffer: blkb 16,0 ; a few bytes extra just to be sure
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0454E3             0421*  
0454E3             0422*  ; This routine converts the unsigned 24-bit value in HLU into it's ASCII representation,
0454E3             0423*  ; starting to memory location pointing by DE, in decimal form and with leading zeroes
0454E3             0424*  ; so it will allways be 8 characters length
0454E3             0425*  ; HL : Value to convert to string
0454E3             0426*  ; DE : pointer to buffer, at least 8 byte + 0
0454E3             0427*  u24_to_ascii:
0454E3 01 80 69 67 0428*  	LD	 BC,-10000000
0454E7 CD 1A 55 04 0429*  	CALL @one_digit
0454EB 01 C0 BD F0 0430*  	LD	 BC,-1000000
0454EF CD 1A 55 04 0431*  	CALL @one_digit
0454F3 01 60 79 FE 0432*  	LD	 BC,-100000
0454F7 CD 1A 55 04 0433*  	CALL @one_digit
0454FB 01 F0 D8 FF 0434*  	LD   BC,-10000
0454FF CD 1A 55 04 0435*  	CALL @one_digit
045503 01 18 FC FF 0436*  	LD   BC,-1000
045507 CD 1A 55 04 0437*  	CALL @one_digit
04550B 01 9C FF FF 0438*  	LD   BC,-100
04550F CD 1A 55 04 0439*  	CALL @one_digit
045513 0E F6       0440*  	LD   C,-10
045515 CD 1A 55 04 0441*  	CALL @one_digit
045519 48          0442*  	LD   C,B
04551A             0443*  @one_digit:
04551A 3E 2F       0444*  	LD   A,'0'-1
04551C             0445*  @divide_me:
04551C 3C          0446*  	INC  A
04551D 09          0447*  	ADD  HL,BC
04551E 38 FC       0448*  	JR   C,@divide_me
045520 ED 42       0449*  	SBC  HL,BC
045522 12          0450*  	LD   (DE),A
045523 13          0451*  	INC  DE
045524 C9          0452*  	RET
045525             0453*  
045525             0454*  print_u24:
045525 D5          0455*      push de
045526 E5          0456*      push hl
045527 11 D3 54 04 0457*      ld de,_printDecBuffer
04552B CD E3 54 04 0458*      call u24_to_ascii
04552F 21 D3 54 04 0459*      ld hl,_printDecBuffer
045533 CD A8 53 04 0460*      call printString
045537 3E 20       0461*      ld a,' '
045539 5B D7       0462*      rst.lil 10h
04553B E1          0463*      pop hl
04553C D1          0464*      pop de
04553D C9          0465*      ret
04553E             0466*  
04553E             0467*  ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
04553E             0468*  ; HL : Value to convert to string (integer part in H, fractional part in L)
04553E             0469*  ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
04553E             0470*  u168_to_ascii:
04553E             0471*  ; add a leading space to make room for sign flag if needed
04553E 3E 20       0472*      ld a,' '
045540 12          0473*      ld (de),a
045541 13          0474*      inc de
045542             0475*  ; Convert integer part
045542 E5          0476*      push hl               ; Save HL (we’ll need the fractional part later)
045543 CD 6E 53 04 0477*      call hlu_udiv256    ; Shift to get integer portion in HL
045547 01 F0 D8 FF 0478*      ld   bc, -10000
04554B CD 6E 55 04 0479*      call @one_int
04554F 01 18 FC FF 0480*      ld   bc, -1000
045553 CD 6E 55 04 0481*      call @one_int
045557 01 9C FF FF 0482*      ld   bc, -100
04555B CD 6E 55 04 0483*      call @one_int
04555F 0E F6       0484*      ld   c, -10
045561 CD 6E 55 04 0485*      call @one_int
045565 48          0486*      ld   c, b
045566 CD 6E 55 04 0487*      call @one_int
04556A C3 79 55 04 0488*      jp   @frac            ; Jump to fractional part conversion
04556E             0489*  @one_int:
04556E 3E 2F       0490*      ld   a, '0' - 1       ; Start ASCII character at '0'
045570             0491*  @divide_me:
045570 3C          0492*      inc  a
045571 09          0493*      add  hl, bc           ; Accumulate until overflow
045572 38 FC       0494*      jr   c, @divide_me
045574 ED 42       0495*      sbc  hl, bc           ; Remove excess after overflow
045576 12          0496*      ld   (de), a          ; Store ASCII digit
045577 13          0497*      inc  de
045578 C9          0498*      ret
045579             0499*  ; Convert fractional part
045579             0500*  @frac:
045579 3E 2E       0501*      ld   a, '.'           ; Decimal point
04557B 12          0502*      ld   (de), a
04557C 13          0503*      inc  de
04557D E1          0504*      pop  hl               ; Restore HL with original fraction
04557E 06 03       0505*      ld   b, 3             ; Loop counter for 3 fractional digits
045580             0506*  @frac_loop:
045580 26 0A       0507*      ld   h, 10            ; Load multiplier for fractional part
045582 ED 6C       0508*      mlt  hl               ; Multiply by 10, result in HL (H holds the integer part)
045584 3E 30       0509*      ld   a, '0'
045586 84          0510*      add  a, h             ; Convert integer part to ASCII
045587 12          0511*      ld   (de), a
045588 13          0512*      inc  de
045589 10 F5       0513*      djnz @frac_loop       ; Repeat for each fractional digit
04558B             0514*  ; Add null terminator
04558B AF          0515*      xor  a                ; Null terminator
04558C 12          0516*      ld   (de), a
04558D C9          0517*      ret
04558E             0518*  
04558E             0519*  print_u168:
04558E D5          0520*      push de
04558F E5          0521*      push hl
045590 11 D3 54 04 0522*      ld de,_printDecBuffer
045594 CD 3E 55 04 0523*      call u168_to_ascii
045598 21 D3 54 04 0524*      ld hl,_printDecBuffer
04559C CD A8 53 04 0525*      call printString
0455A0 E1          0526*      pop hl
0455A1 D1          0527*      pop de
0455A2 C9          0528*      ret
0455A3             0529*  
0455A3             0530*  ; signed version of u168_to_ascii
0455A3             0531*  s168_to_ascii:
0455A3 D5          0532*      push de ; save starting address of buffer
0455A4 CD 81 53 04 0533*      call hlu_abs
0455A8 F5          0534*      push af ; save sign flag
0455A9 CD 3E 55 04 0535*      call u168_to_ascii
0455AD F1          0536*      pop af ; restore sign flag
0455AE D1          0537*      pop de ; restore starting address of buffer
0455AF F0          0538*      ret p ; hlu was positive so nothing to do
0455B0 3E 2D       0539*      ld a,'-'
0455B2 12          0540*      ld (de),a
0455B3 C9          0541*      ret
0455B4             0542*  
0455B4             0543*  print_s168:
0455B4 D5          0544*      push de
0455B5 E5          0545*      push hl
0455B6 11 D3 54 04 0546*      ld de,_printDecBuffer
0455BA CD A3 55 04 0547*      call s168_to_ascii
0455BE 21 D3 54 04 0548*      ld hl,_printDecBuffer
0455C2 CD A8 53 04 0549*      call printString
0455C6 E1          0550*      pop hl
0455C7 D1          0551*      pop de
0455C8 C9          0552*      ret
0455C9             0553*  
0455C9             0554*  print_s168_hl:
0455C9 F5          0555*      push af
0455CA E5          0556*      push hl
0455CB CD B4 55 04 0557*      call print_s168
0455CF 3E 20       0558*      ld a,' '
0455D1 5B D7       0559*      rst.lil 10h
0455D3 E1          0560*      pop hl
0455D4 F1          0561*      pop af
0455D5 C9          0562*      ret
0455D6             0563*  
0455D6             0564*  print_s168_bc:
0455D6 F5          0565*      push af
0455D7 C5          0566*      push bc
0455D8 E5          0567*      push hl
0455D9 C5          0568*      push bc
0455DA E1          0569*      pop hl
0455DB CD B4 55 04 0570*      call print_s168
0455DF 3E 20       0571*      ld a,' '
0455E1 5B D7       0572*      rst.lil 10h
0455E3 E1          0573*      pop hl
0455E4 C1          0574*      pop bc
0455E5 F1          0575*      pop af
0455E6 C9          0576*      ret
0455E7             0577*  
0455E7             0578*  print_s168_de:
0455E7 F5          0579*      push af
0455E8 D5          0580*      push de
0455E9 E5          0581*      push hl
0455EA EB          0582*      ex de,hl
0455EB CD B4 55 04 0583*      call print_s168
0455EF 3E 20       0584*      ld a,' '
0455F1 5B D7       0585*      rst.lil 10h
0455F3 E1          0586*      pop hl
0455F4 D1          0587*      pop de
0455F5 F1          0588*      pop af
0455F6 C9          0589*      ret
0455F7             0590*  
0455F7             0591*  print_s168_hl_bc_de:
0455F7 F5          0592*      push af
0455F8 C5          0593*      push bc
0455F9 D5          0594*      push de
0455FA E5          0595*      push hl
0455FB CD B4 55 04 0596*      call print_s168
0455FF 3E 20       0597*      ld a,' '
045601 5B D7       0598*      rst.lil 10h
045603 C5          0599*      push bc
045604 E1          0600*      pop hl
045605 CD B4 55 04 0601*      call print_s168
045609 3E 20       0602*      ld a,' '
04560B 5B D7       0603*      rst.lil 10h
04560D EB          0604*      ex de,hl
04560E CD B4 55 04 0605*      call print_s168
045612 3E 20       0606*      ld a,' '
045614 5B D7       0607*      rst.lil 10h
045616 E1          0608*      pop hl
045617 D1          0609*      pop de
045618 C1          0610*      pop bc
045619 F1          0611*      pop af
04561A C9          0612*      ret
04561B             0613*  
04561B             0614*  print_s168_bc_de:
04561B F5          0615*      push af
04561C C5          0616*      push bc
04561D D5          0617*      push de
04561E C5          0618*      push bc
04561F E1          0619*      pop hl
045620 CD B4 55 04 0620*      call print_s168
045624 3E 20       0621*      ld a,' '
045626 5B D7       0622*      rst.lil 10h
045628 EB          0623*      ex de,hl
045629 CD B4 55 04 0624*      call print_s168
04562D 3E 20       0625*      ld a,' '
04562F 5B D7       0626*      rst.lil 10h
045631 E1          0627*      pop hl
045632 D1          0628*      pop de
045633 C1          0629*      pop bc
045634 F1          0630*      pop af
045635 C9          0631*      ret
045636             0632*  
045636             0633*  print_s168_a:
045636 F5          0634*      push af
045637 C5          0635*      push bc
045638 E5          0636*      push hl
045639 21 00 00 00 0637*      ld hl,0
04563D 6F          0638*      ld l,a
04563E CD C9 55 04 0639*      call print_s168_hl
045642 E1          0640*      pop hl
045643 C1          0641*      pop bc
045644 F1          0642*      pop af
045645 C9          0643*      ret
045646             0644*  
045646             0645*  ; #### new functions added by Brandon R. Gates ####
045646             0646*  
045646             0647*  ; print the binary representation of the 8-bit value in a
045646             0648*  ; destroys a, hl, bc
045646             0649*  printBin8:
045646 06 08       0650*      ld b,8      ; loop counter for 8 bits
045648 21 63 56 04 0651*      ld hl,@cmd  ; set hl to the low byte of the output string
04564C             0652*                  ; (which will be the high bit of the value in a)
04564C             0653*  @loop:
04564C 07          0654*      rlca ; put the next highest bit into carry
04564D 38 04       0655*      jr c,@one
04564F 36 30       0656*      ld (hl),'0'
045651 18 02       0657*      jr @next_bit
045653             0658*  @one:
045653 36 31       0659*      ld (hl),'1'
045655             0660*  @next_bit:
045655 23          0661*      inc hl
045656 10 F4       0662*      djnz @loop
045658             0663*  ; print it
045658 21 63 56 04 0664*  	ld hl,@cmd
04565C 01 08 00 00 0665*  	ld bc,@end-@cmd
045660 5B DF       0666*  	rst.lil $18
045662 C9          0667*  	ret
045663             0668*  @cmd: ds 8 ; eight bytes for eight bits
04566B             0669*  @end:
04566B             0670*  
04566B             0671*  ; print the binary representation of the 8-bit value in a
04566B             0672*  ; in reverse order (lsb first)
04566B             0673*  ; destroys a, hl, bc
04566B             0674*  printBin8Rev:
04566B 06 08       0675*      ld b,8      ; loop counter for 8 bits
04566D 21 88 56 04 0676*      ld hl,@cmd  ; set hl to the low byte of the output string
045671             0677*                  ; (which will be the high bit of the value in a)
045671             0678*  @loop:
045671 0F          0679*      rrca ; put the next lowest bit into carry
045672 38 04       0680*      jr c,@one
045674 36 30       0681*      ld (hl),'0'
045676 18 02       0682*      jr @next_bit
045678             0683*  @one:
045678 36 31       0684*      ld (hl),'1'
04567A             0685*  @next_bit:
04567A 23          0686*      inc hl
04567B 10 F4       0687*      djnz @loop
04567D             0688*  ; print it
04567D 21 88 56 04 0689*  	ld hl,@cmd
045681 01 08 00 00 0690*  	ld bc,@end-@cmd
045685 5B DF       0691*  	rst.lil $18
045687 C9          0692*  	ret
045688             0693*  @cmd: ds 8 ; eight bytes for eight bits
045690             0694*  @end:
045690             0695*  
045690             0696*  ; print registers to screen in hexidecimal format
045690             0697*  ; inputs: none
045690             0698*  ; outputs: values of every register printed to screen
045690             0699*  ;    values of each register in global scratch memory
045690             0700*  ; destroys: nothing
045690             0701*  stepRegistersHex:
045690             0702*  ; store everything in scratch
045690 22 D0 58 04 0703*      ld (uhl),hl
045694 ED 43 D3 58 0704*      ld (ubc),bc
       04          
045699 ED 53 D6 58 0705*      ld (ude),de
       04          
04569E DD 22 D9 58 0706*      ld (uix),ix
       04          
0456A3 FD 22 DC 58 0707*      ld (uiy),iy
       04          
0456A8 F5          0708*      push af ; fml
0456A9 E1          0709*      pop hl  ; thanks, zilog
0456AA 22 CD 58 04 0710*      ld (uaf),hl
0456AE F5          0711*      push af ; dammit
0456AF             0712*  
0456AF             0713*  ; home the cursor
0456AF             0714*      ; call vdu_home_cursor
0456AF             0715*  
0456AF             0716*  ; print each register
0456AF 21 53 58 04 0717*      ld hl,str_afu
0456B3 CD A8 53 04 0718*      call printString
0456B7 2A CD 58 04 0719*      ld hl,(uaf)
0456BB CD C8 53 04 0720*      call printHex24
0456BF CD BD 53 04 0721*      call printNewLine
0456C3             0722*  
0456C3 21 58 58 04 0723*      ld hl,str_hlu
0456C7 CD A8 53 04 0724*      call printString
0456CB 2A D0 58 04 0725*      ld hl,(uhl)
0456CF CD C8 53 04 0726*      call printHex24
0456D3 CD BD 53 04 0727*      call printNewLine
0456D7             0728*  
0456D7 21 5D 58 04 0729*      ld hl,str_bcu
0456DB CD A8 53 04 0730*      call printString
0456DF 2A D3 58 04 0731*      ld hl,(ubc)
0456E3 CD C8 53 04 0732*      call printHex24
0456E7 CD BD 53 04 0733*      call printNewLine
0456EB             0734*  
0456EB 21 62 58 04 0735*      ld hl,str_deu
0456EF CD A8 53 04 0736*      call printString
0456F3 2A D6 58 04 0737*      ld hl,(ude)
0456F7 CD C8 53 04 0738*      call printHex24
0456FB CD BD 53 04 0739*      call printNewLine
0456FF             0740*  
0456FF 21 67 58 04 0741*      ld hl,str_ixu
045703 CD A8 53 04 0742*      call printString
045707 2A D9 58 04 0743*      ld hl,(uix)
04570B CD C8 53 04 0744*      call printHex24
04570F CD BD 53 04 0745*      call printNewLine
045713             0746*  
045713 21 6C 58 04 0747*      ld hl,str_iyu
045717 CD A8 53 04 0748*      call printString
04571B 2A DC 58 04 0749*      ld hl,(uiy)
04571F CD C8 53 04 0750*      call printHex24
045723 CD BD 53 04 0751*      call printNewLine
045727             0752*  
045727             0753*      ; call vsync
045727             0754*  
045727 CD BD 53 04 0755*      call printNewLine
04572B             0756*  
04572B             0757*  ; check for right shift key and quit if pressed
04572B             0758*  	MOSCALL mos_getkbmap
04572B 3E 1E       0001*M 			LD	A, function
04572D 5B CF       0002*M 			RST.LIL	08h
04572F             0759*  @stayhere:
04572F             0760*  ; 7 RightShift
04572F DD CB 00 76 0761*      bit 6,(ix+0)
045733 20 02       0762*      jr nz,@RightShift
045735 18 F8       0763*      jr @stayhere
045737             0764*  @RightShift:
045737 DD CB 0E 86 0765*      res 0,(ix+14) ; debounce the key (hopefully)
04573B 3E 80       0766*      ld a,%10000000
04573D             0767*      ; call multiPurposeDelay
04573D             0768*  
04573D             0769*  ; restore everything
04573D 2A D0 58 04 0770*      ld hl, (uhl)
045741 ED 4B D3 58 0771*      ld bc, (ubc)
       04          
045746 ED 5B D6 58 0772*      ld de, (ude)
       04          
04574B DD 2A D9 58 0773*      ld ix, (uix)
       04          
045750 FD 2A DC 58 0774*      ld iy, (uiy)
       04          
045755 F1          0775*      pop af
045756             0776*  ; all done
045756 C9          0777*      ret
045757             0778*  
045757             0779*  ; print registers to screen in hexidecimal format
045757             0780*  ; inputs: none
045757             0781*  ; outputs: values of every register printed to screen
045757             0782*  ;    values of each register in global scratch memory
045757             0783*  ; destroys: nothing
045757             0784*  dumpRegistersHex:
045757             0785*  ; store everything in scratch
045757 22 D0 58 04 0786*      ld (uhl),hl
04575B ED 43 D3 58 0787*      ld (ubc),bc
       04          
045760 ED 53 D6 58 0788*      ld (ude),de
       04          
045765 DD 22 D9 58 0789*      ld (uix),ix
       04          
04576A FD 22 DC 58 0790*      ld (uiy),iy
       04          
04576F F5          0791*      push af ; fml
045770 E1          0792*      pop hl  ; thanks, zilog
045771 22 CD 58 04 0793*      ld (uaf),hl
045775 F5          0794*      push af ; dammit
045776             0795*  
045776             0796*  ; home the cursor
045776             0797*      ; call vdu_home_cursor
045776             0798*      ; call printNewLine
045776             0799*  
045776             0800*  ; print each register
045776 21 53 58 04 0801*      ld hl,str_afu
04577A CD A8 53 04 0802*      call printString
04577E 2A CD 58 04 0803*      ld hl,(uaf)
045782 CD C8 53 04 0804*      call printHex24
045786             0805*      ; call printNewLine
045786             0806*  
045786 21 58 58 04 0807*      ld hl,str_hlu
04578A CD A8 53 04 0808*      call printString
04578E 2A D0 58 04 0809*      ld hl,(uhl)
045792 CD C8 53 04 0810*      call printHex24
045796             0811*      ; call printNewLine
045796             0812*  
045796 21 5D 58 04 0813*      ld hl,str_bcu
04579A CD A8 53 04 0814*      call printString
04579E 2A D3 58 04 0815*      ld hl,(ubc)
0457A2 CD C8 53 04 0816*      call printHex24
0457A6             0817*      ; call printNewLine
0457A6             0818*  
0457A6 21 62 58 04 0819*      ld hl,str_deu
0457AA CD A8 53 04 0820*      call printString
0457AE 2A D6 58 04 0821*      ld hl,(ude)
0457B2 CD C8 53 04 0822*      call printHex24
0457B6             0823*      ; call printNewLine
0457B6             0824*  
0457B6 21 67 58 04 0825*      ld hl,str_ixu
0457BA CD A8 53 04 0826*      call printString
0457BE 2A D9 58 04 0827*      ld hl,(uix)
0457C2 CD C8 53 04 0828*      call printHex24
0457C6             0829*      ; call printNewLine
0457C6             0830*  
0457C6 21 6C 58 04 0831*      ld hl,str_iyu
0457CA CD A8 53 04 0832*      call printString
0457CE 2A DC 58 04 0833*      ld hl,(uiy)
0457D2 CD C8 53 04 0834*      call printHex24
0457D6             0835*      ; call printNewLine
0457D6             0836*  
0457D6             0837*      ; call vdu_vblank
0457D6             0838*  
0457D6 CD BD 53 04 0839*      call printNewLine
0457DA             0840*  ; restore everything
0457DA 2A D0 58 04 0841*      ld hl, (uhl)
0457DE ED 4B D3 58 0842*      ld bc, (ubc)
       04          
0457E3 ED 5B D6 58 0843*      ld de, (ude)
       04          
0457E8 DD 2A D9 58 0844*      ld ix, (uix)
       04          
0457ED FD 2A DC 58 0845*      ld iy, (uiy)
       04          
0457F2 F1          0846*      pop af
0457F3             0847*  ; all done
0457F3 C9          0848*      ret
0457F4             0849*  
0457F4             0850*  dumpRegistersHexPrime:
0457F4 D9          0851*      exx
0457F5 08          0852*      ex af,af'
0457F6 CD 57 57 04 0853*      call dumpRegistersHex
0457FA 08          0854*      ex af,af'
0457FB D9          0855*      exx
0457FC C9          0856*      ret
0457FD             0857*  
0457FD             0858*  ; additionally dump prime registers
0457FD             0859*  ; inputs: none
0457FD             0860*  ; outputs: values of every register printed to screen
0457FD             0861*  ; destroys: nothing
0457FD             0862*  dumpRegistersHexAll:
0457FD CD 57 57 04 0863*      call dumpRegistersHex
045801 08          0864*      ex af,af'
045802 D9          0865*      exx
045803 CD 57 57 04 0866*      call dumpRegistersHex
045807 08          0867*      ex af,af'
045808 D9          0868*      exx
045809 C9          0869*      ret
04580A             0870*  
04580A             0871*  ; print hlu to screen in hexidecimal format
04580A             0872*  ; inputs: none
04580A             0873*  ; destroys: nothing
04580A             0874*  print_hex_hl:
04580A F5          0875*      push af
04580B E5          0876*      push hl
04580C 21 58 58 04 0877*      ld hl,str_hlu
045810 CD A8 53 04 0878*      call printString
045814 E1          0879*      pop hl
045815 E5          0880*      push hl
045816 CD C8 53 04 0881*      call printHex24
04581A 3E 20       0882*      ld a,' '
04581C 5B D7       0883*      rst.lil 10h
04581E E1          0884*      pop hl
04581F F1          0885*      pop af
045820 C9          0886*      ret
045821             0887*  
045821             0888*  ; print bcu to screen in hexidecimal format
045821             0889*  ; inputs: none
045821             0890*  ; destroys: nothing
045821             0891*  print_hex_bc:
045821 F5          0892*      push af
045822 E5          0893*      push hl
045823 C5          0894*      push bc
045824 21 5D 58 04 0895*      ld hl,str_bcu
045828 CD A8 53 04 0896*      call printString
04582C E1          0897*      pop hl
04582D E5          0898*      push hl
04582E CD C8 53 04 0899*      call printHex24
045832 3E 20       0900*      ld a,' '
045834 5B D7       0901*      rst.lil 10h
045836 C1          0902*      pop bc
045837 E1          0903*      pop hl
045838 F1          0904*      pop af
045839 C9          0905*      ret
04583A             0906*  
04583A             0907*  ; print deu to screen in hexidecimal format
04583A             0908*  ; inputs: none
04583A             0909*  ; destroys: nothing
04583A             0910*  print_hex_de:
04583A F5          0911*      push af
04583B E5          0912*      push hl
04583C D5          0913*      push de
04583D 21 62 58 04 0914*      ld hl,str_deu
045841 CD A8 53 04 0915*      call printString
045845 E1          0916*      pop hl
045846 E5          0917*      push hl
045847 CD C8 53 04 0918*      call printHex24
04584B 3E 20       0919*      ld a,' '
04584D 5B D7       0920*      rst.lil 10h
04584F D1          0921*      pop de
045850 E1          0922*      pop hl
045851 F1          0923*      pop af
045852 C9          0924*      ret
045853             0925*  
045853 20 61 66 3D 0926*  str_afu: db " af=",0
       00          
045858 20 68 6C 3D 0927*  str_hlu: db " hl=",0
       00          
04585D 20 62 63 3D 0928*  str_bcu: db " bc=",0
       00          
045862 20 64 65 3D 0929*  str_deu: db " de=",0
       00          
045867 20 69 78 3D 0930*  str_ixu: db " ix=",0
       00          
04586C 20 69 79 3D 0931*  str_iyu: db " iy=",0
       00          
045871             0932*  
045871             0933*  ; print udeuhl to screen in hexidecimal format
045871             0934*  ; inputs: none
045871             0935*  ; outputs: concatenated hexidecimal udeuhl
045871             0936*  ; destroys: nothing
045871             0937*  dumpUDEUHLHex:
045871             0938*  ; store everything in scratch
045871 22 D0 58 04 0939*      ld (uhl),hl
045875 ED 43 D3 58 0940*      ld (ubc),bc
       04          
04587A ED 53 D6 58 0941*      ld (ude),de
       04          
04587F DD 22 D9 58 0942*      ld (uix),ix
       04          
045884 FD 22 DC 58 0943*      ld (uiy),iy
       04          
045889 F5          0944*      push af
04588A             0945*  
04588A             0946*  ; print each register
04588A             0947*  
04588A 21 C4 58 04 0948*      ld hl,str_udeuhl
04588E CD A8 53 04 0949*      call printString
045892 2A D6 58 04 0950*      ld hl,(ude)
045896 CD C8 53 04 0951*      call printHex24
04589A 3E 2E       0952*  	ld a,'.'	; print a dot to separate the values
04589C 5B D7       0953*  	rst.lil 10h
04589E 2A D0 58 04 0954*      ld hl,(uhl)
0458A2 CD C8 53 04 0955*      call printHex24
0458A6 CD BD 53 04 0956*      call printNewLine
0458AA             0957*  
0458AA             0958*  ; restore everything
0458AA 2A D0 58 04 0959*      ld hl, (uhl)
0458AE ED 4B D3 58 0960*      ld bc, (ubc)
       04          
0458B3 ED 5B D6 58 0961*      ld de, (ude)
       04          
0458B8 DD 2A D9 58 0962*      ld ix, (uix)
       04          
0458BD FD 2A DC 58 0963*      ld iy, (uiy)
       04          
0458C2 F1          0964*      pop af
0458C3             0965*  ; all done
0458C3 C9          0966*      ret
0458C4             0967*  
0458C4 75 64 65 2E 0968*  str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
0458CD             0969*  
0458CD             0970*  ; global scratch memory for registers
0458CD 00 00 00    0971*  uaf: dl 0
0458D0 00 00 00    0972*  uhl: dl 0
0458D3 00 00 00    0973*  ubc: dl 0
0458D6 00 00 00    0974*  ude: dl 0
0458D9 00 00 00    0975*  uix: dl 0
0458DC 00 00 00    0976*  uiy: dl 0
0458DF 00 00 00    0977*  usp: dl 0
0458E2 00 00 00    0978*  upc: dl 0
0458E5             0979*  
0458E5             0980*  ; inputs: whatever is in the flags register
0458E5             0981*  ; outputs: binary representation of flags
0458E5             0982*  ;          with a header so we know which is what
0458E5             0983*  ; destroys: nothing
0458E5             0984*  ; preserves: everything
0458E5             0985*  dumpFlags:
0458E5             0986*  ; first we curse zilog for not giving direct access to flags
0458E5 F5          0987*      push af ; this is so we can send it back unharmed
0458E6 F5          0988*      push af ; this is so we can pop it to hl
0458E7             0989*  ; store everything in scratch
0458E7 22 D0 58 04 0990*      ld (uhl),hl
0458EB ED 43 D3 58 0991*      ld (ubc),bc
       04          
0458F0 ED 53 D6 58 0992*      ld (ude),de
       04          
0458F5 DD 22 D9 58 0993*      ld (uix),ix
       04          
0458FA FD 22 DC 58 0994*      ld (uiy),iy
       04          
0458FF             0995*  ; next we print the header
0458FF 21 2B 59 04 0996*      ld hl,@header
045903 CD A8 53 04 0997*      call printString
045907 E1          0998*      pop hl ; flags are now in l
045908 7D          0999*      ld a,l ; flags are now in a
045909 CD 46 56 04 1000*      call printBin8
04590D CD BD 53 04 1001*  	call printNewLine
045911             1002*  ; restore everything
045911 2A D0 58 04 1003*      ld hl, (uhl)
045915 ED 4B D3 58 1004*      ld bc, (ubc)
       04          
04591A ED 5B D6 58 1005*      ld de, (ude)
       04          
04591F DD 2A D9 58 1006*      ld ix, (uix)
       04          
045924 FD 2A DC 58 1007*      ld iy, (uiy)
       04          
045929 F1          1008*      pop af ; send her home the way she came
04592A C9          1009*      ret
04592B             1010*  ; Bit 7 (S): Sign flag
04592B             1011*  ; Bit 6 (Z): Zero flag
04592B             1012*  ; Bit 5 (5): Reserved (copy of bit 5 of the result)
04592B             1013*  ; Bit 4 (H): Half Carry flag
04592B             1014*  ; Bit 3 (3): Reserved (copy of bit 3 of the result)
04592B             1015*  ; Bit 2 (PV): Parity/Overflow flag
04592B             1016*  ; Bit 1 (N): Subtract flag
04592B             1017*  ; Bit 0 (C): Carry flag
04592B 53 5A 78 48 1018*  @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
       78 50 4E 43 
       0D 0A 00    
045936             1019*  
045936             1020*  ; set all the bits in the flag register
045936             1021*  ; more of an academic exercise than anything useful
045936             1022*  ; inputs; none
045936             1023*  ; outputs; a=0,f=255
045936             1024*  ; destroys: flags, hl
045936             1025*  ; preserves: a, because why not
045936             1026*  setAllFlags:
045936 21 FF 00 00 1027*      ld hl,255
04593A 67          1028*      ld h,a ; four cycles to preserve a is cheap
04593B E5          1029*      push hl
04593C F1          1030*      pop af
04593D C9          1031*      ret
04593E             1032*  
04593E             1033*  ; reset all the bits in the flag register
04593E             1034*  ; unlike its inverse counterpart, this may actually be useful
04593E             1035*  ; inputs; none
04593E             1036*  ; outputs; a=0,f=0
04593E             1037*  ; destroys: flags, hl
04593E             1038*  ; preserves: a, because why not
04593E             1039*  resetAllFlags:
04593E 21 00 00 00 1040*      ld hl,0
045942 67          1041*      ld h,a ; four cycles to preserve a is cheap
045943 E5          1042*      push hl
045944 F1          1043*      pop af
045945 C9          1044*      ret
045946             1045*  
045946             1046*  ; wait until user presses a key
045946             1047*  ; inputs: none
045946             1048*  ; outputs: ascii code of key pressed in a
045946             1049*  ; destroys: af,ix
045946             1050*  waitKeypress:
045946             1051*      MOSCALL mos_getkey
045946 3E 00       0001*M 			LD	A, function
045948 5B CF       0002*M 			RST.LIL	08h
04594A C9          1052*      ret
04594B             1053*  
04594B             1054*  ; print bytes from an address to the screen in hexidecimal format
04594B             1055*  ; inputs: hl = address of first byte to print, a = number of bytes to print
04594B             1056*  ; outputs: values of each byte printed to screen separated by spaces
04594B             1057*  ; destroys: nothing
04594B             1058*  dumpMemoryHex:
04594B             1059*  ; save registers to the stack
04594B C5          1060*      push bc
04594C E5          1061*      push hl
04594D F5          1062*      push af
04594E             1063*  
04594E             1064*  ; print the address and separator
04594E CD C8 53 04 1065*      call printHex24
045952 3E 3A       1066*      ld a,':'
045954 5B D7       1067*      rst.lil 10h
045956 3E 20       1068*      ld a,' '
045958 5B D7       1069*      rst.lil 10h
04595A             1070*  
04595A             1071*  ; set b to be our loop counter
04595A F1          1072*      pop af
04595B 47          1073*      ld b,a
04595C E1          1074*      pop hl
04595D E5          1075*      push hl
04595E F5          1076*      push af
04595F             1077*  @loop:
04595F             1078*  ; print the byte
04595F 7E          1079*      ld a,(hl)
045960 CD D6 53 04 1080*      call printHex8
045964             1081*  ; print a space
045964 3E 20       1082*      ld a,' '
045966 5B D7       1083*      rst.lil 10h
045968 23          1084*      inc hl
045969 10 F4       1085*      djnz @loop
04596B CD BD 53 04 1086*      call printNewLine
04596F             1087*  
04596F             1088*  ; restore everything
04596F F1          1089*      pop af
045970 E1          1090*      pop hl
045971 C1          1091*      pop bc
045972             1092*  
045972             1093*  ; all done
045972 C9          1094*      ret
045973             1095*  
045973             1096*  
045973             1097*  ; print bytes from an address to the screen in binary format
045973             1098*  ; inputs: hl = address of first byte to print, a = number of bytes to print
045973             1099*  ; outputs: values of each byte printed to screen separated by spaces
045973             1100*  ; destroys: nothing
045973             1101*  dumpMemoryBin:
045973             1102*  ; save all registers to the stack
045973 F5          1103*      push af
045974 C5          1104*      push bc
045975 D5          1105*      push de
045976 E5          1106*      push hl
045977 DD E5       1107*      push ix
045979 FD E5       1108*      push iy
04597B             1109*  
04597B             1110*  ; set b to be our loop counter
04597B 47          1111*      ld b,a
04597C             1112*  @loop:
04597C             1113*  ; print the byte
04597C 7E          1114*      ld a,(hl)
04597D E5          1115*      push hl
04597E C5          1116*      push bc
04597F CD 46 56 04 1117*      call printBin8
045983 C1          1118*      pop bc
045984             1119*  ; print a space
045984 3E 20       1120*      ld a,' '
045986 5B D7       1121*      rst.lil 10h
045988 E1          1122*      pop hl
045989 23          1123*      inc hl
04598A 10 F0       1124*      djnz @loop
04598C CD BD 53 04 1125*      call printNewLine
045990             1126*  
045990             1127*  ; restore everything
045990 FD E1       1128*      pop iy
045992 DD E1       1129*      pop ix
045994 E1          1130*      pop hl
045995 D1          1131*      pop de
045996 C1          1132*      pop bc
045997 F1          1133*      pop af
045998             1134*  ; all done
045998 C9          1135*      ret
045999             1136*  
045999             1137*  ; print bytes from an address to the screen in binary format
045999             1138*  ; with the bits of each byte in reverse order (lsb first)
045999             1139*  ; inputs: hl = address of first byte to print, a = number of bytes to print
045999             1140*  ; outputs: values of each byte printed to screen separated by spaces
045999             1141*  ; destroys: nothing
045999             1142*  dumpMemoryBinRev:
045999             1143*  ; save all registers to the stack
045999 F5          1144*      push af
04599A C5          1145*      push bc
04599B D5          1146*      push de
04599C E5          1147*      push hl
04599D DD E5       1148*      push ix
04599F FD E5       1149*      push iy
0459A1             1150*  
0459A1             1151*  ; set b to be our loop counter
0459A1 47          1152*      ld b,a
0459A2             1153*  @loop:
0459A2             1154*  ; print the byte
0459A2 7E          1155*      ld a,(hl)
0459A3 E5          1156*      push hl
0459A4 C5          1157*      push bc
0459A5 CD 6B 56 04 1158*      call printBin8Rev
0459A9 C1          1159*      pop bc
0459AA             1160*  ; print a space
0459AA 3E 20       1161*      ld a,' '
0459AC 5B D7       1162*      rst.lil 10h
0459AE E1          1163*      pop hl
0459AF 23          1164*      inc hl
0459B0 10 F0       1165*      djnz @loop
0459B2 CD BD 53 04 1166*      call printNewLine
0459B6             1167*  
0459B6             1168*  ; restore everything
0459B6 FD E1       1169*      pop iy
0459B8 DD E1       1170*      pop ix
0459BA E1          1171*      pop hl
0459BB D1          1172*      pop de
0459BC C1          1173*      pop bc
0459BD F1          1174*      pop af
0459BE             1175*  ; all done
0459BE C9          1176*      ret
0459BF             0055       include "src/asm/vdu.inc"
0459BF             0001*  ; The following is a high-level list of the VDU sequences that are supported:
0459BF             0002*  ; VDU 0: Null (no operation)
0459BF             0003*  ; VDU 1: Send next character to “printer” (if “printer” is enabled) §§
0459BF             0004*  ; VDU 2: Enable “printer” §§
0459BF             0005*  ; VDU 3: Disable “printer” §§
0459BF             0006*  ; VDU 4: Write text at text cursor
0459BF             0007*  ; VDU 5: Write text at graphics cursor
0459BF             0008*  ; VDU 6: Enable screen (opposite of VDU 21) §§
0459BF             0009*  ; VDU 7: Make a short beep (BEL)
0459BF             0010*  ; VDU 8: Move cursor back one character
0459BF             0011*  ; VDU 9: Move cursor forward one character
0459BF             0012*  ; VDU 10: Move cursor down one line
0459BF             0013*  ; VDU 11: Move cursor up one line
0459BF             0014*  ; VDU 12: Clear text area (CLS)
0459BF             0015*  ; VDU 13: Carriage return
0459BF             0016*  ; VDU 14: Page mode On *
0459BF             0017*  ; VDU 15: Page mode Off *
0459BF             0018*  ; VDU 16: Clear graphics area (CLG)
0459BF             0019*  ; VDU 17, colour: Define text colour (COLOUR)
0459BF             0020*  ; VDU 18, mode, colour: Define graphics colour (GCOL mode, colour)
0459BF             0021*  ; VDU 19, l, p, r, g, b: Define logical colour (COLOUR l, p / COLOUR l, r, g, b)
0459BF             0022*  ; VDU 20: Reset palette and text/graphics colours and drawing modes §§
0459BF             0023*  ; VDU 21: Disable screen (turns of VDU command processing, except for VDU 1 and VDU 6) §§
0459BF             0024*  ; VDU 22, n: Select screen mode (MODE n)
0459BF             0025*  ; VDU 23, n: Re-program display character / System Commands
0459BF             0026*  ; VDU 24, left; bottom; right; top;: Set graphics viewport **
0459BF             0027*  ; VDU 25, mode, x; y;: PLOT command
0459BF             0028*  ; VDU 26: Reset graphics and text viewports **
0459BF             0029*  ; VDU 27, char: Output character to screen §
0459BF             0030*  ; VDU 28, left, bottom, right, top: Set text viewport **
0459BF             0031*  ; VDU 29, x; y;: Set graphics origin
0459BF             0032*  ; VDU 30: Home cursor
0459BF             0033*  ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
0459BF             0034*  ; VDU 127: Backspace
0459BF             0035*  
0459BF             0036*  ; VDU 0: Null (no operation)
0459BF             0037*  ;     On encountering a VDU 0 command, the VDP will do nothing.
0459BF             0038*  ;     This may be useful for padding out a VDU command sequence,
0459BF             0039*  ;     or for inserting a placeholder for a command that will be added later.
0459BF             0040*  ; inputs: none
0459BF             0041*  ; outputs: an empty byte somewhere in VDU
0459BF             0042*  ; destroys: a
0459BF             0043*  vdu_null:
0459BF AF          0044*      xor a
0459C0 5B D7       0045*  	rst.lil $10
0459C2 C9          0046*  	ret
0459C3             0047*  
0459C3             0048*  ; VDU 1: Send next character to “printer” (if “printer” is enabled) §§
0459C3             0049*  ;     Ensures that the next character received by the VDP is sent through to
0459C3             0050*  ;     the “printer”, and not to the screen. This is useful for sending control
0459C3             0051*  ;     codes to the “printer”, or for sending data to the “printer” that is not
0459C3             0052*  ;     intended to be displayed on the screen. It allows characters that would
0459C3             0053*  ;     not otherwise normally be sent through to the “printer” to be sent.
0459C3             0054*  ;     If the “printer” has not been enabled then this command will just discard
0459C3             0055*  ;     the next byte sent to the VDP.
0459C3             0056*  ; inputs: a is the ascii code of the character to send
0459C3             0057*  ; prerequisites: "printer" must first be activated with VDU 2 (see below)
0459C3             0058*  ; outputs: a character on the serial terminal connected to the USB port
0459C3             0059*  ;           and the same character on the screen at the current text cursor location
0459C3             0060*  ; QUESTION: does it also advance the text cursor?
0459C3             0061*  ; destroys: hl, bc
0459C3             0062*  vdu_char_to_printer:
0459C3 32 D3 59 04 0063*  	ld (@arg),a
0459C7 21 D2 59 04 0064*  	ld hl,@cmd
0459CB 01 02 00 00 0065*  	ld bc,@end-@cmd
0459CF 5B DF       0066*  	rst.lil $18
0459D1 C9          0067*  	ret
0459D2 01          0068*  @cmd: db 1
0459D3 00          0069*  @arg: db 0
0459D4             0070*  @end:
0459D4             0071*  
0459D4             0072*  ; VDU 2: Enable “printer” §§
0459D4             0073*  ;     Enables the “printer”.
0459D4             0074*  ;     In the context of the Agon platform, the “printer” is a serial
0459D4             0075*  ;     terminal that is connected to the VDP’s USB port. Typically
0459D4             0076*  ;     this port is used for power, but it can also be used to send and
0459D4             0077*  ;     receive data to and from the VDP.
0459D4             0078*  ;     When the “printer” is enabled, the VDP will send characters it receives
0459D4             0079*  ;     to the “printer” as well as to the screen. It will additionally send
0459D4             0080*  ;     through control codes 8-13. To send other control codes to the “printer”,
0459D4             0081*  ;     use the VDU 1 command.
0459D4             0082*  ;     The VDP will not send through other control codes to the printer,
0459D4             0083*  ;     and will will not send through data it receives as part of other commands.
0459D4             0084*  vdu_enable_printer:
0459D4 3E 02       0085*      ld a,2
0459D6 5B D7       0086*  	rst.lil $10
0459D8 C9          0087*  	ret
0459D9             0088*  
0459D9             0089*  ; VDU 3: Disable “printer” §§
0459D9             0090*  ; inputs: none
0459D9             0091*  ; outputs: a USB port bereft of communication with the VDP
0459D9             0092*  ; destroys: a
0459D9             0093*  vdu_disable_printer:
0459D9 3E 03       0094*      ld a,3
0459DB 5B D7       0095*  	rst.lil $10
0459DD C9          0096*  	ret
0459DE             0097*  
0459DE             0098*  ; VDU 4: Write text at text cursor
0459DE             0099*  ;     This causes text to be written at the current text cursor position.
0459DE             0100*  ;     This is the default mode for text display.
0459DE             0101*  ;     Text is written using the current text foreground and background colours.
0459DE             0102*  ; inputs: a is the character to write to the screen
0459DE             0103*  ; prerequisites: the text cursor at the intended position on screen
0459DE             0104*  ; outputs: prints the character and moves text cursor right one position
0459DE             0105*  ; destroys: a, hl, bc
0459DE             0106*  vdu_char_to_text_cursor:
0459DE 32 EE 59 04 0107*  	ld (@arg),a
0459E2 21 ED 59 04 0108*  	ld hl,@cmd
0459E6 01 02 00 00 0109*  	ld bc,@end-@cmd
0459EA 5B DF       0110*  	rst.lil $18
0459EC C9          0111*  	ret
0459ED 04          0112*  @cmd: db 4
0459EE 00          0113*  @arg: db 0
0459EF             0114*  @end:
0459EF             0115*  
0459EF             0116*  ; VDU 5: Write text at graphics cursor
0459EF             0117*  ;     This causes text to be written at the current graphics cursor position.
0459EF             0118*  ;     Using this, characters may be positioned at any graphics coordinate within
0459EF             0119*  ;     the graphics viewport. This is useful for positioning text over graphics,
0459EF             0120*  ;     or for positioning text at a specific location on the screen.
0459EF             0121*  ;     Characters are plotted using the current graphics foreground colour,
0459EF             0122*  ;     using the current graphics foreground plotting mode (see VDU 18).
0459EF             0123*  ;     The character background is transparent, and will not overwrite any
0459EF             0124*  ;     graphics that are already present at the character’s location.
0459EF             0125*  ;     The exception to this is VDU 27, the “delete” character, which backspaces
0459EF             0126*  ;     and deletes as per its usual behaviour, but will erase using the current
0459EF             0127*  ;     graphics background colour.
0459EF             0128*  ; inputs: a is the character to write to the screen
0459EF             0129*  ; prerequisites: the graphics cursor at the intended position on screen
0459EF             0130*  ; outputs: see the name of the function
0459EF             0131*  ; destroys: a, hl, bc
0459EF             0132*  vdu_char_to_gfx_cursor:
0459EF 32 FF 59 04 0133*  	ld (@arg),a
0459F3 21 FE 59 04 0134*  	ld hl,@cmd
0459F7 01 02 00 00 0135*  	ld bc,@end-@cmd
0459FB 5B DF       0136*  	rst.lil $18
0459FD C9          0137*  	ret
0459FE 05          0138*  @cmd: db 5
0459FF 00          0139*  @arg: db 0
045A00             0140*  @end:
045A00             0141*  
045A00             0142*  ; VDU 6: Enable screen (opposite of VDU 21) §§
045A00             0143*  ;     This enables the screen, and re-enables VDU command processing,
045A00             0144*  ;     reversing the effect of VDU 21.
045A00             0145*  ; inputs: none
045A00             0146*  ; outputs: a functioning screen and VDU
045A00             0147*  ; destroys: a
045A00             0148*  vdu_enable_screen:
045A00 3E 06       0149*      ld a,6
045A02 5B D7       0150*  	rst.lil $10
045A04 C9          0151*  	ret
045A05             0152*  
045A05             0153*  ; PASSES
045A05             0154*  ; VDU 7: Make a short beep (BEL)
045A05             0155*  ;     Plays a short beep sound on audio channel 0. If the audio channel
045A05             0156*  ;     is already in use, or has been disabled, then this command will have no effect.
045A05             0157*  ; inputs: none
045A05             0158*  ; outputs: an unpleasant but thankfully short-lived audio tone
045A05             0159*  ; destroys: a
045A05             0160*  vdu_beep:
045A05 3E 07       0161*      ld a,7
045A07 5B D7       0162*  	rst.lil $10
045A09 C9          0163*  	ret
045A0A             0164*  
045A0A             0165*  ; VDU 8: Move cursor back one character
045A0A             0166*  ;     Moves the text cursor one character in the negative “X” direction.
045A0A             0167*  ;     By default, when at the start of a line it will move to the end of
045A0A             0168*  ;     the previous line (as defined by the current text viewport).
045A0A             0169*  ;     If the cursor is also at the top of the screen then the viewport will scroll down.
045A0A             0170*  ;     The cursor remains constrained to the current text viewport.
045A0A             0171*  ;     When in VDU 5 mode and the graphics cursor is active, the viewport will not scroll.
045A0A             0172*  ;     The cursor is just moved left by one character width.
045A0A             0173*  ;     Further behaviour of the cursor can be controlled using the VDU 23,16 command.
045A0A             0174*  ;     It should be noted that as of Console8 VDP 2.5.0, the cursor system does not
045A0A             0175*  ;     support adjusting the direction of the cursor’s X axis, so this command
045A0A             0176*  ;     will move the cursor to the left. This is likely to change in the future.
045A0A             0177*  vdu_cursor_back:
045A0A 3E 08       0178*      ld a,8
045A0C 5B D7       0179*  	rst.lil $10
045A0E C9          0180*  	ret
045A0F             0181*  
045A0F             0182*  ; VDU 9: Move cursor forward one character
045A0F             0183*  vdu_cursor_forward:
045A0F 3E 09       0184*      ld a,9
045A11 5B D7       0185*  	rst.lil $10
045A13 C9          0186*  	ret
045A14             0187*  
045A14             0188*  ; VDU 10: Move cursor down one line
045A14             0189*  vdu_cursor_down:
045A14 3E 0A       0190*      ld a,10
045A16 5B D7       0191*  	rst.lil $10
045A18 C9          0192*  	ret
045A19             0193*  
045A19             0194*  ; VDU 11: Move cursor up one line
045A19             0195*  vdu_cursor_up:
045A19 3E 0B       0196*      ld a,11
045A1B 5B D7       0197*  	rst.lil $10
045A1D C9          0198*  	ret
045A1E             0199*  
045A1E             0200*  ; VDU 12: Clear text area (CLS)
045A1E             0201*  vdu_cls:
045A1E 3E 0C       0202*      ld a,12
045A20 5B D7       0203*  	rst.lil $10
045A22 C9          0204*  	ret
045A23             0205*  
045A23             0206*  ; VDU 13: Carriage return
045A23             0207*  vdu_cr:
045A23 3E 0D       0208*      ld a,13
045A25 5B D7       0209*  	rst.lil $10
045A27 C9          0210*  	ret
045A28             0211*  
045A28             0212*  ; VDU 14: Page mode On *
045A28             0213*  vdu_page_on:
045A28 3E 0E       0214*      ld a,14
045A2A 5B D7       0215*  	rst.lil $10
045A2C C9          0216*  	ret
045A2D             0217*  
045A2D             0218*  ; VDU 15: Page mode Off *
045A2D             0219*  vdu_page_off:
045A2D 3E 0F       0220*      ld a,15
045A2F 5B D7       0221*  	rst.lil $10
045A31 C9          0222*  	ret
045A32             0223*  
045A32             0224*  ; VDU 16: Clear graphics area (CLG)
045A32             0225*  vdu_clg:
045A32 3E 10       0226*      ld a,16
045A34 5B D7       0227*  	rst.lil $10
045A36 C9          0228*  	ret
045A37             0229*  
045A37             0230*  ; VDU 17, colour: Define text colour (COLOUR)
045A37             0231*  vdu_colour_text:
045A37 32 47 5A 04 0232*  	ld (@arg),a
045A3B 21 46 5A 04 0233*  	ld hl,@cmd
045A3F 01 02 00 00 0234*  	ld bc,@end-@cmd
045A43 5B DF       0235*  	rst.lil $18
045A45 C9          0236*  	ret
045A46 11          0237*  @cmd: db 17
045A47 00          0238*  @arg: db 0
045A48             0239*  @end:
045A48             0240*  
045A48             0241*  ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
045A48             0242*  ; inputs: a is the plotting mode, c is the colour
045A48             0243*  ; outputs: a VDU set to put pixels on the screen with the selected mode/colour
045A48             0244*  vdu_gcol_fg:
045A48             0245*  ; This command will set both the current graphics colour,
045A48             0246*  ; and the current graphics plotting mode.
045A48             0247*  ; As with VDU 17 the colour number will set the foreground colour
045A48             0248*  ; if it is in the range 0-127, or the background colour if it is
045A48             0249*  ; in the range 128-255, and will be interpreted in the same manner.
045A48             0250*  ; Support for different plotting modes on Agon is currently very limited.
045A48             0251*  ; The only fully supported mode is mode 0, which is the default mode.
045A48             0252*  ; This mode will plot the given colour at the given graphics coordinate,
045A48             0253*  ; and will overwrite any existing graphics at that coordinate. There is
045A48             0254*  ; very limited support for mode 4, which will invert the colour of any
045A48             0255*  ; existing graphics at the given coordinate, but this is not fully supported
045A48             0256*  ; and may not work as expected.
045A48             0257*  ; Support for other plotting modes, matching those provided by Acorn’s
045A48             0258*  ; original VDU system, may be added in the future.
045A48             0259*  ; This command is identical to the BASIC GCOL keyword.
045A48 32 5D 5A 04 0260*  	ld (@mode),a
045A4C 79          0261*      ld a,c
045A4D 32 5E 5A 04 0262*      ld (@col),a
045A51 21 5C 5A 04 0263*  	ld hl,@cmd
045A55 01 03 00 00 0264*  	ld bc,@end-@cmd
045A59 5B DF       0265*  	rst.lil $18
045A5B C9          0266*  	ret
045A5C 12          0267*  @cmd: db 18
045A5D 00          0268*  @mode: db 0
045A5E 00          0269*  @col: db 0
045A5F             0270*  @end:
045A5F             0271*  
045A5F             0272*  vdu_gcol_bg:
045A5F 32 76 5A 04 0273*  	ld (@mode),a
045A63 79          0274*      ld a,c
045A64 C6 80       0275*      add a,128
045A66 32 77 5A 04 0276*      ld (@col),a
045A6A 21 75 5A 04 0277*  	ld hl,@cmd
045A6E 01 03 00 00 0278*  	ld bc,@end-@cmd
045A72 5B DF       0279*  	rst.lil $18
045A74 C9          0280*  	ret
045A75 12          0281*  @cmd:  db 18
045A76 00          0282*  @mode: db 0
045A77 00          0283*  @col:  db 0
045A78             0284*  @end:
045A78             0285*  
045A78             0286*  ; VDU 19, l, p, r, g, b: Define logical colour (COLOUR l, p / COLOUR l, r, g, b)
045A78             0287*  ;     This command sets the colour palette, by mapping a logical colour
045A78             0288*  ;     to a physical colour. This is useful for defining custom colours,
045A78             0289*  ;     or for redefining the default colours.
045A78             0290*  ;     If the physical colour number is given as 255 then the colour will
045A78             0291*  ;     be defined using the red, green, and blue values given. If the physical
045A78             0292*  ;     colour number is given as any other value then the colour will be defined
045A78             0293*  ;     using the colour palette entry given by that number, up to colour number 63.
045A78             0294*  ;     If the physical colour is not 255 then the red, green, and blue values
045A78             0295*  ;     must still be provided, but will be ignored.
045A78             0296*  ;     The values for red, green and blue must be given in the range 0-255.
045A78             0297*  ;     You should note that the physical Agon hardware only supports 64 colours,
045A78             0298*  ;     so the actual colour displayed may not be exactly the same as the colour
045A78             0299*  ;     requested. The nearest colour will be chosen.
045A78             0300*  ;     This command is equivalent to the BASIC COLOUR keyword.
045A78             0301*  ; inputs: a=physcial colour, b=logical colour, chl=r,g,b
045A78             0302*  vdu_def_log_colour:
045A78 32 9D 5A 04 0303*  	ld (@physical),a
045A7C 47          0304*      ld b,a
045A7D 32 9C 5A 04 0305*      ld (@logical),a
045A81 79          0306*      ld a,c
045A82 32 9E 5A 04 0307*      ld (@red),a
045A86 7C          0308*      ld a,h
045A87 32 9F 5A 04 0309*      ld (@green),a
045A8B 7D          0310*      ld a,l
045A8C 32 A0 5A 04 0311*      ld (@blue),a
045A90 21 9B 5A 04 0312*  	ld hl,@cmd
045A94 01 06 00 00 0313*  	ld bc,@end-@cmd
045A98 5B DF       0314*  	rst.lil $18
045A9A C9          0315*  	ret
045A9B 13          0316*  @cmd: db 19
045A9C 00          0317*  @logical: db 0
045A9D 00          0318*  @physical: db 0
045A9E 00          0319*  @red: db 0
045A9F 00          0320*  @green: db 0
045AA0 00          0321*  @blue: db 0
045AA1             0322*  @end:
045AA1             0323*  
045AA1             0324*  ; VDU 20: Reset palette and text/graphics colours and drawing modes §§
045AA1             0325*  vdu_reset_gfx:
045AA1 3E 14       0326*      ld a,20
045AA3 5B D7       0327*  	rst.lil $10
045AA5 C9          0328*  	ret
045AA6             0329*  
045AA6             0330*  ; VDU 21: Disable screen (turns off VDU command processing,
045AA6             0331*  ; except for VDU 1 and VDU 6) §§
045AA6             0332*  vdu_disable_screen:
045AA6 3E 15       0333*      ld a,21
045AA8 5B D7       0334*  	rst.lil $10
045AAA C9          0335*  	ret
045AAB             0336*  
045AAB             0337*  ; VDU 22, n: Select screen mode (MODE n)
045AAB             0338*  ; Inputs: a, screen mode (8-bit unsigned integer), in the following list:
045AAB             0339*  ; https://agonconsole8.github.io/agon-docs/VDP---Screen-Modes.html
045AAB             0340*  ; Screen modes
045AAB             0341*  ; Modes over 128 are double-buffered
045AAB             0342*  ; From Version 1.04 or greater
045AAB             0343*  ; Mode 	Horz 	Vert 	Cols 	Refresh
045AAB             0344*  ; 0 	640 	480 	16 	    60hz
045AAB             0345*  ; * 1 	640 	480 	4 	    60hz
045AAB             0346*  ; 2 	640 	480 	2 	    60hz
045AAB             0347*  ; 3 	640 	240 	64 	    60hz
045AAB             0348*  ; 4 	640 	240 	16 	    60hz
045AAB             0349*  ; 5 	640 	240 	4 	    60hz
045AAB             0350*  ; 6 	640 	240 	2 	    60hz
045AAB             0351*  ; ** 7 	n/a 	n/a 	16 	    60hz
045AAB             0352*  ; 8 	320 	240 	64 	    60hz
045AAB             0353*  ; 9 	320 	240 	16 	    60hz
045AAB             0354*  ; 10 	320 	240 	4 	    60hz
045AAB             0355*  ; 11 	320 	240 	2 	    60hz
045AAB             0356*  ; 12 	320 	200 	64 	    70hz
045AAB             0357*  ; 13 	320 	200 	16 	    70hz
045AAB             0358*  ; 14 	320 	200 	4 	    70hz
045AAB             0359*  ; 15 	320 	200 	2 	    70hz
045AAB             0360*  ; 16 	800 	600 	4 	    60hz
045AAB             0361*  ; 17 	800 	600 	2 	    60hz
045AAB             0362*  ; 18 	1024 	768 	2 	    60hz
045AAB             0363*  ; 129 	640 	480 	4 	    60hz
045AAB             0364*  ; 130 	640 	480 	2 	    60hz
045AAB             0365*  ; 132 	640 	240 	16 	    60hz
045AAB             0366*  ; 133 	640 	240 	4 	    60hz
045AAB             0367*  ; 134 	640 	240 	2 	    60hz
045AAB             0368*  ; 136 	320 	240 	64 	    60hz
045AAB             0369*  ; 137 	320 	240 	16 	    60hz
045AAB             0370*  ; 138 	320 	240 	4 	    60hz
045AAB             0371*  ; 139 	320 	240 	2 	    60hz
045AAB             0372*  ; 140 	320 	200 	64 	    70hz
045AAB             0373*  ; 141 	320 	200 	16 	    70hz
045AAB             0374*  ; 142 	320 	200 	4 	    70hz
045AAB             0375*  ; 143 	320 	200 	2 	    70hz
045AAB             0376*  ; * Mode 1 is the “default” mode, and is the mode that the system will use on startup.
045AAB             0377*  ; It is also the mode that the system will fall back to use if it was not possible to
045AAB             0378*  ; change to the requested mode.
045AAB             0379*  ; ** Mode 7 is the “Teletext” mode, and essentially works in a very similar manner to
045AAB             0380*  ; the BBC Micro’s Teletext mode, which was also mode 7.
045AAB             0381*  vdu_set_screen_mode:
045AAB 32 BB 5A 04 0382*  	ld (@arg),a
045AAF 21 BA 5A 04 0383*  	ld hl,@cmd
045AB3 01 02 00 00 0384*  	ld bc,@end-@cmd
045AB7 5B DF       0385*  	rst.lil $18
045AB9 C9          0386*  	ret
045ABA 16          0387*  @cmd: db 22 ; set screen mode
045ABB 00          0388*  @arg: db 0  ; screen mode parameter
045ABC             0389*  @end:
045ABC             0390*  
045ABC             0391*  ; VDU 23, n: Re-program display character / System Commands
045ABC             0392*  ; inputs: a, ascii code; hl, pointer to bitmask data
045ABC             0393*  vdu_define_character:
045ABC 32 D8 5A 04 0394*  	ld (@ascii),a
045AC0 11 D9 5A 04 0395*  	ld de,@data
045AC4 06 08       0396*  	ld b,8 ; loop counter for 8 bytes of data
045AC6             0397*  @loop:
045AC6 7E          0398*  	ld a,(hl)
045AC7 12          0399*  	ld (de),a
045AC8 23          0400*  	inc hl
045AC9 13          0401*  	inc de
045ACA 10 FA       0402*  	djnz @loop
045ACC 21 D7 5A 04 0403*  	ld hl,@cmd
045AD0 01 0A 00 00 0404*  	ld bc,@end-@cmd
045AD4 5B DF       0405*  	rst.lil $18
045AD6 C9          0406*  	ret
045AD7 17          0407*  @cmd:   db 23
045AD8 00          0408*  @ascii: db 0
045AD9             0409*  @data:  ds 8
045AE1             0410*  @end:
045AE1             0411*  
045AE1             0412*  ; VDU 24, left; bottom; right; top;: Set graphics viewport
045AE1             0413*  ; NOTE: the order of the y-coordinate parameters are inverted
045AE1             0414*  ; 	because we have turned off logical screen scaling
045AE1             0415*  ; inputs: bc=x0,de=y0,ix=x1,iy=y1
045AE1             0416*  ; outputs; nothing
045AE1             0417*  ; destroys: a might make it out alive
045AE1             0418*  vdu_set_gfx_viewport:
045AE1 ED 43 01 5B 0419*      ld (@x0),bc
       04          
045AE6 FD 22 03 5B 0420*      ld (@y1),iy
       04          
045AEB DD 22 05 5B 0421*  	ld (@x1),ix
       04          
045AF0 ED 53 07 5B 0422*  	ld (@y0),de
       04          
045AF5 21 00 5B 04 0423*  	ld hl,@cmd
045AF9 01 09 00 00 0424*  	ld bc,@end-@cmd
045AFD 5B DF       0425*  	rst.lil $18
045AFF C9          0426*  	ret
045B00 18          0427*  @cmd:   db 24 ; set graphics viewport command
045B01 00 00       0428*  @x0: 	dw 0x0000 ; set by bc
045B03 00 00       0429*  @y1: 	dw 0x0000 ; set by iy
045B05 00 00       0430*  @x1: 	dw 0x0000 ; set by ix
045B07 00 00       0431*  @y0: 	dw 0x0000 ; set by de
045B09 00          0432*  @end:   db 0x00	  ; padding
045B0A             0433*  
045B0A             0434*  ; VDU 25, mode, x; y;: PLOT command
045B0A             0435*  ; Implemented in vdu_plot.inc
045B0A             0436*  
045B0A             0437*  ; VDU 26: Reset graphics and text viewports **
045B0A             0438*  vdu_reset_txt_gfx_view:
045B0A 3E 1A       0439*      ld a,26
045B0C 5B D7       0440*  	rst.lil $10
045B0E C9          0441*  	ret
045B0F             0442*  
045B0F             0443*  ; PASSES
045B0F             0444*  ; VDU 27, char: Output character to screen §
045B0F             0445*  ; inputs: a is the ascii code of the character to draw
045B0F             0446*  vdu_draw_char:
045B0F 32 1F 5B 04 0447*  	ld (@arg),a
045B13 21 1E 5B 04 0448*  	ld hl,@cmd
045B17 01 02 00 00 0449*  	ld bc,@end-@cmd
045B1B 5B DF       0450*  	rst.lil $18
045B1D C9          0451*  	ret
045B1E 1B          0452*  @cmd: db 27
045B1F 00          0453*  @arg: db 0  ; ascii code of character to draw
045B20             0454*  @end:
045B20             0455*  
045B20             0456*  ; VDU 28, left, bottom, right, top: Set text viewport **
045B20             0457*  ; MIND THE LITTLE-ENDIANESS
045B20             0458*  ; inputs: c=left,b=bottom,e=right,d=top
045B20             0459*  ; outputs; nothing
045B20             0460*  ; destroys: a might make it out alive
045B20             0461*  vdu_set_txt_viewport:
045B20 ED 43 36 5B 0462*      ld (@lb),bc
       04          
045B25 ED 53 38 5B 0463*  	ld (@rt),de
       04          
045B2A 21 35 5B 04 0464*  	ld hl,@cmd
045B2E 01 05 00 00 0465*  	ld bc,@end-@cmd
045B32 5B DF       0466*  	rst.lil $18
045B34 C9          0467*  	ret
045B35 1C          0468*  @cmd:   db 28 ; set text viewport command
045B36 00 00       0469*  @lb: 	dw 0x0000 ; set by bc
045B38 00 00       0470*  @rt: 	dw 0x0000 ; set by de
045B3A 00          0471*  @end:   db 0x00	  ; padding
045B3B             0472*  
045B3B             0473*  ; PASSES
045B3B             0474*  ; VDU 29, x; y;: Set graphics origin
045B3B             0475*  ; inputs: bc,de x,y coordinates
045B3B             0476*  vdu_set_gfx_origin:
045B3B ED 43 51 5B 0477*      ld (@x0),bc
       04          
045B40 ED 53 53 5B 0478*      ld (@y0),de
       04          
045B45 21 50 5B 04 0479*  	ld hl,@cmd
045B49 01 05 00 00 0480*  	ld bc,@end-@cmd
045B4D 5B DF       0481*  	rst.lil $18
045B4F C9          0482*  	ret
045B50 1D          0483*  @cmd:	db 29
045B51 00 00       0484*  @x0: 	dw 0
045B53 00 00       0485*  @y0: 	dw 0
045B55 00          0486*  @end: 	db 0 ; padding
045B56             0487*  
045B56             0488*  ; PASSES
045B56             0489*  ; VDU 30: Home cursor
045B56             0490*  vdu_home_cursor:
045B56 3E 1E       0491*      ld a,30
045B58 5B D7       0492*  	rst.lil $10
045B5A C9          0493*  	ret
045B5B             0494*  
045B5B             0495*  ; PASSES
045B5B             0496*  ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
045B5B             0497*  ; inputs: c=x, b=y 8-bit unsigned integers
045B5B             0498*  vdu_move_cursor:
045B5B ED 43 6C 5B 0499*      ld (@x0),bc
       04          
045B60 21 6B 5B 04 0500*  	ld hl,@cmd
045B64 01 03 00 00 0501*  	ld bc,@end-@cmd
045B68 5B DF       0502*  	rst.lil $18
045B6A C9          0503*  	ret
045B6B 1F          0504*  @cmd: 	db 31
045B6C 00          0505*  @x0:	db 0
045B6D 00          0506*  @y0: 	db 0
045B6E 00          0507*  @end: 	db 0 ; padding
045B6F             0508*  
045B6F             0509*  
045B6F             0510*  ; VDU 127: Backspace
045B6F             0511*  vdu_bksp:
045B6F 3E 7F       0512*      ld a,127
045B71 5B D7       0513*  	rst.lil $10
045B73 C9          0514*  	ret
045B74             0515*  
045B74             0516*  ; activate a bitmap in preparation to draw it
045B74             0517*  ; inputs: a holding the bitmap index
045B74             0518*  vdu_bmp_select:
045B74 32 86 5B 04 0519*  	ld (@bmp),a
045B78 21 83 5B 04 0520*  	ld hl,@cmd
045B7C 01 04 00 00 0521*  	ld bc,@end-@cmd
045B80 5B DF       0522*  	rst.lil $18
045B82 C9          0523*  	ret
045B83 17 1B 00    0524*  @cmd: db 23,27,0
045B86 00          0525*  @bmp: db 0
045B87             0526*  @end:
045B87             0527*  
045B87             0528*  ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
045B87             0529*  ; inputs: hl=bufferId
045B87             0530*  vdu_buff_select:
045B87 22 99 5B 04 0531*  	ld (@bufferId),hl
045B8B 21 96 5B 04 0532*  	ld hl,@cmd
045B8F 01 05 00 00 0533*  	ld bc,@end-@cmd
045B93 5B DF       0534*  	rst.lil $18
045B95 C9          0535*  	ret
045B96 17 1B 20    0536*  @cmd: db 23,27,0x20
045B99 00 00       0537*  @bufferId: dw 0x0000
045B9B 00          0538*  @end: db 0x00 ; padding
045B9C             0539*  
045B9C             0540*  ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
045B9C             0541*  ; inputs: a=format; bc=width; de=height
045B9C             0542*  ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
045B9C             0543*  ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
045B9C             0544*  ; 0 	RGBA8888 (4-bytes per pixel)
045B9C             0545*  ; 1 	RGBA2222 (1-bytes per pixel)
045B9C             0546*  ; 2 	Mono/Mask (1-bit per pixel)
045B9C             0547*  ; 3 	Reserved for internal use by VDP (“native” format)
045B9C             0548*  vdu_bmp_create:
045B9C ED 43 B8 5B 0549*      ld (@width),bc
       04          
045BA1 ED 53 BA 5B 0550*      ld (@height),de
       04          
045BA6 32 BC 5B 04 0551*      ld (@fmt),a
045BAA 21 B5 5B 04 0552*  	ld hl,@cmd
045BAE 01 08 00 00 0553*  	ld bc,@end-@cmd
045BB2 5B DF       0554*  	rst.lil $18
045BB4 C9          0555*  	ret
045BB5 17 1B 21    0556*  @cmd:       db 23,27,0x21
045BB8 00 00       0557*  @width:     dw 0x0000
045BBA 00 00       0558*  @height:    dw 0x0000
045BBC 00          0559*  @fmt:       db 0x00
045BBD             0560*  @end:
045BBD             0561*  
045BBD             0562*  ; Draw a bitmap on the screen
045BBD             0563*  ; inputs: bc, x-coordinate; de, y-coordinate
045BBD             0564*  ; prerequisite: bitmap index set by e.g. vdu_bmp_select
045BBD             0565*  vdu_bmp_draw:
045BBD ED 43 D5 5B 0566*      ld (@x0),bc
       04          
045BC2 ED 53 D7 5B 0567*      ld (@y0),de
       04          
045BC7 21 D2 5B 04 0568*  	ld hl,@cmd
045BCB 01 07 00 00 0569*  	ld bc,@end-@cmd
045BCF 5B DF       0570*  	rst.lil $18
045BD1 C9          0571*  	ret
045BD2 17 1B 03    0572*  @cmd: db 23,27,3
045BD5 00 00       0573*  @x0:  dw 0x0000
045BD7 00 00       0574*  @y0:  dw 0x0000
045BD9 00          0575*  @end: db 0x00 ; padding
045BDA             0576*  
045BDA             0577*  ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
045BDA             0578*  ; inputs: a is scaling mode, 1=on, 0=off
045BDA             0579*  ; note: default setting on boot is scaling ON
045BDA             0580*  vdu_set_scaling:
045BDA 32 EC 5B 04 0581*  	ld (@arg),a
045BDE 21 E9 5B 04 0582*  	ld hl,@cmd
045BE2 01 04 00 00 0583*  	ld bc,@end-@cmd
045BE6 5B DF       0584*  	rst.lil $18
045BE8 C9          0585*  	ret
045BE9 17 00 C0    0586*  @cmd: db 23,0,0xC0
045BEC 00          0587*  @arg: db 0  ; scaling on/off
045BED             0588*  @end:
045BED             0589*  
045BED             0590*  ; VDU 23, 0, &C3: Swap the screen buffer and/or wait for VSYNC **
045BED             0591*  ; 	Swap the screen buffer (double-buffered modes only) or wait for VSYNC
045BED             0592*  ; 	(all modes).
045BED             0593*  
045BED             0594*  ; 	This command will swap the screen buffer, if the current screen mode
045BED             0595*  ; 	is double-buffered, doing so at the next VSYNC. If the current screen
045BED             0596*  ; 	mode is not double-buffered then this command will wait for the next
045BED             0597*  ; 	VSYNC signal before returning. This can be used to synchronise the
045BED             0598*  ; 	screen with the vertical refresh rate of the monitor.
045BED             0599*  
045BED             0600*  ; 	Waiting for VSYNC can be useful for ensuring smooth graphical animation,
045BED             0601*  ; 	as it will prevent tearing of the screen.
045BED             0602*  ; inputs: none
045BED             0603*  ; outputs: none
045BED             0604*  ; destroys: hl, bc
045BED             0605*  vdu_flip:
045BED 21 F8 5B 04 0606*  	ld hl,@cmd
045BF1 01 03 00 00 0607*  	ld bc,@end-@cmd
045BF5 5B DF       0608*  	rst.lil $18
045BF7 C9          0609*  	ret
045BF8 17 00 C3    0610*  @cmd: db 23,0,0xC3
045BFB             0611*  @end:
045BFB             0612*  
045BFB             0613*  ; Command 64: Compress a buffer
045BFB             0614*  ; VDU 23, 0, &A0, targetBufferId; 64, sourceBufferId;
045BFB             0615*  ; This command will compress the contents of a buffer, replacing the target buffer with the compressed data. Unless the target buffer is the same as the source, the source buffer will be left unchanged.
045BFB             0616*  
045BFB             0617*  
045BFB             0618*  ; Command 65: Decompress a buffer
045BFB             0619*  ; VDU 23, 0, &A0, targetBufferId; 65, sourceBufferId;
045BFB             0620*  ; This command will decompress the contents of a buffer, replacing the target buffer with the decompressed data. Unless the target buffer is the same as the source, the source buffer will be left unchanged.
045BFB             0621*  ; inputs: hl=sourceBufferId/targetBufferId
045BFB             0622*  vdu_decompress_buffer:
045BFB 22 17 5C 04 0623*  	ld (@targetBufferId),hl
045BFF 22 1A 5C 04 0624*  	ld (@sourceBufferId),hl
045C03 3E 41       0625*  	ld a,65
045C05 32 19 5C 04 0626*  	ld (@cmd1),a ; restore the part of command that got stomped on
045C09 21 14 5C 04 0627*  	ld hl,@cmd
045C0D 01 08 00 00 0628*  	ld bc,@end-@cmd
045C11 5B DF       0629*  	rst.lil $18
045C13 C9          0630*  	ret
045C14 17 00 A0    0631*  @cmd: 	db 23,0,0xA0
045C17 00 00       0632*  @targetBufferId: dw 0x0000
045C19 41          0633*  @cmd1:	db 65
045C1A 00 00       0634*  @sourceBufferId: dw 0x0000
045C1C 00          0635*  @end: 	db 0x00 ; padding
045C1D             0636*  
045C1D             0637*  ; Command 65: Decompress a buffer
045C1D             0638*  ; VDU 23, 0, &A0, targetBufferId; 65, sourceBufferId;
045C1D             0639*  ; This command will decompress the contents of a buffer, replacing the target buffer with the decompressed data. Unless the target buffer is the same as the source, the source buffer will be left unchanged.
045C1D             0640*  ; inputs: hl=sourceBufferId/targetBufferId
045C1D             0641*  ; 0x7FFF for the source buffer is just an easy-to remember aribtrary value
045C1D             0642*  vdu_decompress_buffer_different:
045C1D 22 3D 5C 04 0643*  	ld (@targetBufferId),hl
045C21 21 FF 7F 00 0644*      ld hl,0x7FFF
045C25 22 40 5C 04 0645*  	ld (@sourceBufferId),hl
045C29 3E 41       0646*  	ld a,65
045C2B 32 3F 5C 04 0647*  	ld (@cmd1),a ; restore the part of command that got stomped on
045C2F 21 3A 5C 04 0648*  	ld hl,@cmd
045C33 01 08 00 00 0649*  	ld bc,@end-@cmd
045C37 5B DF       0650*  	rst.lil $18
045C39 C9          0651*  	ret
045C3A 17 00 A0    0652*  @cmd: 	db 23,0,0xA0
045C3D 00 00       0653*  @targetBufferId: dw 0x0000
045C3F 41          0654*  @cmd1:	db 65
045C40 00 00       0655*  @sourceBufferId: dw 0x0000
045C42 00          0656*  @end: 	db 0x00 ; padding
045C43             0657*  
045C43             0658*  ; #### from vdp.inc ####
045C43             0659*  
045C43             0660*  ; https://github.com/breakintoprogram/agon-docs/wiki/VDP
045C43             0661*  ; VDU 23, 7: Scrolling
045C43             0662*  ;     VDU 23, 7, extent, direction, speed: Scroll the screen
045C43             0663*  ; inputs: a, extent; l, direction; h; speed
045C43             0664*  vdu_scroll_down:
045C43 32 58 5C 04 0665*  	ld (@extent),a
045C47 22 59 5C 04 0666*  	ld (@dir),hl ; implicitly populates @speed
045C4B 21 56 5C 04 0667*  	ld hl,@cmd
045C4F 01 05 00 00 0668*  	ld bc,@end-@cmd
045C53 5B DF       0669*  	rst.lil $18     ;; Sending command to VDP
045C55 C9          0670*  	ret
045C56 17 07       0671*  @cmd:       db 23,7
045C58 00          0672*  @extent:    db 0x00 ; 0 current text window, 1 entire screen, 2 curr gfx viewport
045C59 00          0673*  @dir:       db 0x00 ; 0 right, 1 left, 2 down, 3 up
045C5A 00          0674*  @speed:     db 0x00 ; pixels
045C5B 00          0675*  @end:		db 0x00 ; padding
045C5C             0676*  
045C5C             0677*  cursor_on:
045C5C 21 67 5C 04 0678*  	ld hl,@cmd
045C60 01 03 00 00 0679*  	ld bc,@end-@cmd
045C64 5B DF       0680*  	rst.lil $18
045C66 C9          0681*  	ret
045C67             0682*  @cmd:
045C67 17 01 01    0683*  	db 23,1,1
045C6A             0684*  @end:
045C6A             0685*  
045C6A             0686*  cursor_off:
045C6A 21 75 5C 04 0687*  	ld hl,@cmd
045C6E 01 03 00 00 0688*  	ld bc,@end-@cmd
045C72 5B DF       0689*  	rst.lil $18
045C74 C9          0690*  	ret
045C75             0691*  @cmd:
045C75 17 01 00    0692*  	db 23,1,0
045C78             0693*  @end:
045C78             0694*  
045C78 DD E5       0695*  vdu_vblank:		PUSH 	IX			; Wait for VBLANK interrupt
045C7A             0696*  			MOSCALL	mos_sysvars		; Fetch pointer to system variables
045C7A 3E 08       0001*M 			LD	A, function
045C7C 5B CF       0002*M 			RST.LIL	08h
045C7E DD 7E 00    0697*  			LD	A, (IX + sysvar_time + 0)
045C81 DD BE 00    0698*  @wait:			CP 	A, (IX + sysvar_time + 0)
045C84 28 FB       0699*  			JR	Z, @wait
045C86 DD E1       0700*  			POP	IX
045C88 C9          0701*  			RET
045C89             0702*  
045C89             0703*  ; #### from vdu_bmp.inc ####
045C89             0704*  ; =========================================================================
045C89             0705*  ; Bitmaps
045C89             0706*  ; -------------------------------------------------------------------------
045C89             0707*  ; VDU 23, 27, 0, n: Select bitmap n
045C89             0708*  ; VDU 23, 27, &20, bufferId;: Select bitmap using a 16-bit buffer ID *
045C89             0709*  ; VDU 23, 27, 1, w; h; b1, b2 ... bn: Load colour bitmap data into current bitmap
045C89             0710*  
045C89             0711*  ; VDU 23, 27, 1, n, 0, 0;: Capture screen data into bitmap n *
045C89             0712*  ; VDU 23, 27, &21, bitmapId; 0; : same, but to 16-bit buffer ID *
045C89             0713*  ; Any PLOT, or VDU 25, style command will push the graphics cursor position -
045C89             0714*  ; typically "move" style plot commands are used to define the rectangle.
045C89             0715*  ; To be clear, this command should be performed after two "move" style PLOT commands.
045C89             0716*  ; inputs: hl; target bufferId
045C89             0717*  ; all the following are in 16.8 fixed point format
045C89             0718*  ;   ub.c; top-left x coordinate
045C89             0719*  ;   ud.e; top-left y coordinate
045C89             0720*  ;   ui.x; width
045C89             0721*  ;   ui.y; height
045C89             0722*  vdu_buff_screen_capture168:
045C89 ED 53 C0 5C 0723*          ld (@y0-1),de
       04          
045C8E ED 43 BE 5C 0724*          ld (@x0-1),bc
       04          
045C93 3E 44       0725*          ld a,0x44 ; plot_pt+mv_abs
045C95 32 BE 5C 04 0726*          ld (@x0-1),a
045C99             0727*  
045C99 DD 22 C5 5C 0728*          ld (@x1),ix
       04          
045C9E FD 22 C7 5C 0729*          ld (@y1),iy
       04          
045CA3 3E 17       0730*          ld a,23
045CA5 32 C9 5C 04 0731*          ld (@y1+2),a
045CA9             0732*  
045CA9 22 CC 5C 04 0733*          ld (@bufId),hl
045CAD AF          0734*          xor a
045CAE 32 CE 5C 04 0735*          ld (@bufId+2),a
045CB2             0736*  
045CB2 21 BD 5C 04 0737*          ld hl,@begin
045CB6 01 13 00 00 0738*          ld bc,@end-@begin
045CBA 5B DF       0739*          rst.lil $18
045CBC C9          0740*          ret
045CBD             0741*  @begin:
045CBD             0742*  ; absolute move gfx cursor to top-left screen coordinate
045CBD             0743*  ; VDU 25, mode, x; y;: PLOT command
045CBD 19 44       0744*          db 25,0x44 ; plot_pt+mv_abs
045CBF 40 00       0745*  @x0: 	dw 64
045CC1 40 00       0746*  @y0: 	dw 64
045CC3             0747*  ; relative move gfx cursor to bottom-right screen coordinate
045CC3             0748*  ; VDU 25, mode, x; y;: PLOT command
045CC3 19 40       0749*          db 25,0x40 ; plot_pt+mv_rel
045CC5 0F 00       0750*  @x1: 	dw 15
045CC7 0F 00       0751*  @y1: 	dw 15
045CC9             0752*  ; now the main event
045CC9             0753*  ; VDU 23, 27, &21, bitmapId; 0;
045CC9 17 1B 21    0754*          db 23,27,0x21
045CCC 00 20 00 00 0755*  @bufId: dw 0x2000,0x0000
045CD0             0756*  @end: ; no padding required
045CD0             0757*  
045CD0             0758*  vdu_buff_screen_capture_full:
045CD0 21 DB 5C 04 0759*          ld hl,@begin
045CD4 01 13 00 00 0760*          ld bc,@end-@begin
045CD8 5B DF       0761*          rst.lil $18
045CDA C9          0762*          ret
045CDB             0763*  @begin:
045CDB             0764*  ; absolute move gfx cursor to top-left screen coordinate
045CDB             0765*  ; VDU 25, mode, x; y;: PLOT command
045CDB 19 44       0766*          db 25,0x44 ; plot_pt+mv_abs
045CDD 00 00       0767*  @x0: 	dw 0
045CDF 00 00       0768*  @y0: 	dw 0
045CE1             0769*  ; relative move gfx cursor to bottom-right screen coordinate
045CE1             0770*  ; VDU 25, mode, x; y;: PLOT command
045CE1 19 40       0771*          db 25,0x40 ; plot_pt+mv_rel
045CE3 3F 01       0772*  @x1: 	dw 319
045CE5 EF 00       0773*  @y1: 	dw 239
045CE7             0774*  ; now the main event
045CE7             0775*  ; VDU 23, 27, &21, bitmapId; 0;
045CE7 17 1B 21    0776*          db 23,27,0x21
045CEA 00 20 00 00 0777*  @bufId: dw 0x2000,0x0000
045CEE             0778*  @end: ; no padding required
045CEE             0779*  
045CEE             0780*  vdu_buff_screen_paste_full:
045CEE 21 F9 5C 04 0781*          ld hl,@begin
045CF2 01 0B 00 00 0782*          ld bc,@end-@begin
045CF6 5B DF       0783*          rst.lil $18
045CF8 C9          0784*          ret
045CF9             0785*  ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
045CF9 17 1B 20    0786*  @begin:    db 23,27,0x20
045CFC 00 20       0787*  @bufferId: dw 0x2000
045CFE             0788*  ; VDU 25, mode, x; y;: PLOT command
045CFE 19 ED       0789*             db 25,0xED ; plot_bmp+dr_abs_fg
045D00 00 00 00 00 0790*             dw 0x0000,0x0000
045D04             0791*  @end: ; no padding required
045D04             0792*  
045D04             0793*  vdu_buff_screen_capture_tiles:
045D04 21 0F 5D 04 0794*          ld hl,@begin
045D08 01 13 00 00 0795*          ld bc,@end-@begin
045D0C 5B DF       0796*          rst.lil $18
045D0E C9          0797*          ret
045D0F             0798*  @begin:
045D0F             0799*  ; absolute move gfx cursor to top-left screen coordinate
045D0F             0800*  ; VDU 25, mode, x; y;: PLOT command
045D0F 19 44       0801*          db 25,0x44 ; plot_pt+mv_abs
045D11 00 00       0802*  @x0: 	dw 0
045D13 00 00       0803*  @y0: 	dw 0
045D15             0804*  ; relative move gfx cursor to bottom-right screen coordinate
045D15             0805*  ; VDU 25, mode, x; y;: PLOT command
045D15 19 40       0806*          db 25,0x40 ; plot_pt+mv_rel
045D17 FF 00       0807*  @x1: 	dw 319-64
045D19 EF 00       0808*  @y1: 	dw 239
045D1B             0809*  ; now the main event
045D1B             0810*  ; VDU 23, 27, &21, bitmapId; 0;
045D1B 17 1B 21    0811*          db 23,27,0x21
045D1E 00 20 00 00 0812*  @bufId: dw 0x2000,0x0000
045D22             0813*  @end: ; no padding required
045D22             0814*  
045D22             0815*  vdu_buff_screen_paste_tiles:
045D22 21 2D 5D 04 0816*          ld hl,@begin
045D26 01 0B 00 00 0817*          ld bc,@end-@begin
045D2A 5B DF       0818*          rst.lil $18
045D2C C9          0819*          ret
045D2D             0820*  ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
045D2D 17 1B 20    0821*  @begin:    db 23,27,0x20
045D30 00 20       0822*  @bufferId: dw 0x2000
045D32             0823*  ; VDU 25, mode, x; y;: PLOT command
045D32 19 ED       0824*             db 25,0xED ; plot_bmp+dr_abs_fg
045D34 00 00 01 00 0825*             dw 0x0000,0x0001
045D38             0826*  @end: ; no padding required
045D38             0827*  
045D38             0828*  ; VDU 23, 27, 2, w; h; col1; col2;: Create a solid colour rectangular bitmap
045D38             0829*  ; VDU 23, 27, 3, x; y;: Draw current bitmap on screen at pixel position x, y
045D38             0830*  ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer *
045D38             0831*  ; Value	Meaning
045D38             0832*  ; 0	RGBA8888 (4-bytes per pixel)
045D38             0833*  ; 1	RGBA2222 (1-bytes per pixel)
045D38             0834*  ; 2	Mono/Mask (1-bit per pixel)
045D38             0835*  ; 3	Reserved for internal use by VDP ("native" format)VDP.
045D38             0836*  ;     They have some significant limitations, and are not intended for general use.
045D38             0837*  
045D38             0838*  ; =========================================================================
045D38             0839*  ; Sprites
045D38             0840*  ; -------------------------------------------------------------------------
045D38             0841*  ; VDU 23, 27, 4, n: Select sprite n
045D38             0842*  ; VDU 23, 27, 5: Clear frames in current sprite
045D38             0843*  ; VDU 23, 27, 6, n: Add bitmap n as a frame to current sprite (where bitmap's buffer ID is 64000+n)
045D38             0844*  ; VDU 23, 27, &26, n;: Add bitmap n as a frame to current sprite using a 16-bit buffer ID
045D38             0845*  ; VDU 23, 27, 7, n: Activate n sprites
045D38             0846*  ; VDU 23, 27, 8: Select next frame of current sprite
045D38             0847*  ; VDU 23, 27, 9: Select previous frame of current sprite
045D38             0848*  ; VDU 23, 27, 10, n: Select the nth frame of current sprite
045D38             0849*  ; VDU 23, 27, 11: Show current sprite
045D38             0850*  ; VDU 23, 27, 12: Hide current sprite
045D38             0851*  ; VDU 23, 27, 13, x; y;: Move current sprite to pixel position x, y
045D38             0852*  ; VDU 23, 27, 14, x; y;: Move current sprite by x, y pixels
045D38             0853*  ; VDU 23, 27, 15: Update the sprites in the GPU
045D38             0854*  ; VDU 23, 27, 16: Reset bitmaps and sprites and clear all data
045D38             0855*  ; VDU 23, 27, 17: Reset sprites (only) and clear all data
045D38             0856*  ; VDU 23, 27, 18, n: Set the current sprite GCOL paint mode to n **
045D38             0857*  
045D38             0858*  ; =========================================================================
045D38             0859*  ; Mouse cursor
045D38             0860*  ; -------------------------------------------------------------------------
045D38             0861*  ; VDU 23, 27, &40, hotX, hotY: Setup a mouse cursor with a hot spot at hotX, hotY
045D38             0862*  
045D38             0863*  ; #### from vdu_plot.inc ####
045D38             0864*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
045D38             0865*  ; PLOT code 	(Decimal) 	Effect
045D38             0866*  ; &00-&07 	0-7 	Solid line, includes both ends
045D38             0867*  plot_sl_both: equ 0x00
045D38             0868*  
045D38             0869*  ; &08-&0F 	8-15 	Solid line, final point omitted
045D38             0870*  plot_sl_first: equ 0x08
045D38             0871*  
045D38             0872*  ; &10-&17 	16-23 	Not supported (Dot-dash line, includes both ends, pattern restarted)
045D38             0873*  ; &18-&1F 	24-31 	Not supported (Dot-dash line, first point omitted, pattern restarted)
045D38             0874*  
045D38             0875*  ; &20-&27 	32-39 	Solid line, first point omitted
045D38             0876*  plot_sl_last: equ 0x20
045D38             0877*  
045D38             0878*  ; &28-&2F 	40-47 	Solid line, both points omitted
045D38             0879*  plot_sl_none: equ 0x28
045D38             0880*  
045D38             0881*  ; &30-&37 	48-55 	Not supported (Dot-dash line, first point omitted, pattern continued)
045D38             0882*  ; &38-&3F 	56-63 	Not supported (Dot-dash line, both points omitted, pattern continued)
045D38             0883*  
045D38             0884*  ; &40-&47 	64-71 	Point plot
045D38             0885*  plot_pt: equ 0x40
045D38             0886*  
045D38             0887*  ; &48-&4F 	72-79 	Line fill left and right to non-background §§
045D38             0888*  plot_lf_lr_non_bg: equ 0x48
045D38             0889*  
045D38             0890*  ; &50-&57 	80-87 	Triangle fill
045D38             0891*  plot_tf: equ 0x50
045D38             0892*  
045D38             0893*  ; &58-&5F 	88-95 	Line fill right to background §§
045D38             0894*  plot_lf_r_bg: equ 0x58
045D38             0895*  
045D38             0896*  ; &60-&67 	96-103 	Rectangle fill
045D38             0897*  plot_rf: equ 0x60
045D38             0898*  
045D38             0899*  ; &68-&6F 	104-111 	Line fill left and right to foreground §§
045D38             0900*  plot_lf_lr_fg: equ 0x60
045D38             0901*  
045D38             0902*  ; &70-&77 	112-119 	Parallelogram fill
045D38             0903*  plot_pf: equ 0x70
045D38             0904*  
045D38             0905*  ; &78-&7F 	120-127 	Line fill right to non-foreground §§
045D38             0906*  plot_lf_r_non_fg: equ 0x78
045D38             0907*  
045D38             0908*  ; &80-&87 	128-135 	Not supported (Flood until non-background)
045D38             0909*  ; &88-&8F 	136-143 	Not supported (Flood until foreground)
045D38             0910*  
045D38             0911*  ; &90-&97 	144-151 	Circle outline
045D38             0912*  plot_co: equ 0x90
045D38             0913*  
045D38             0914*  ; &98-&9F 	152-159 	Circle fill
045D38             0915*  plot_cf: equ 0x98
045D38             0916*  
045D38             0917*  ; &A0-&A7 	160-167 	Not supported (Circular arc)
045D38             0918*  ; &A8-&AF 	168-175 	Not supported (Circular segment)
045D38             0919*  ; &B0-&B7 	176-183 	Not supported (Circular sector)
045D38             0920*  
045D38             0921*  ; &B8-&BF 	184-191 	Rectangle copy/move
045D38             0922*  plot_rcm: equ 0xB8
045D38             0923*  
045D38             0924*  ; &C0-&C7 	192-199 	Not supported (Ellipse outline)
045D38             0925*  ; &C8-&CF 	200-207 	Not supported (Ellipse fill)
045D38             0926*  ; &D0-&D7 	208-215 	Not defined
045D38             0927*  ; &D8-&DF 	216-223 	Not defined
045D38             0928*  ; &E0-&E7 	224-231 	Not defined
045D38             0929*  
045D38             0930*  ; &E8-&EF 	232-239 	Bitmap plot §
045D38             0931*  plot_bmp: equ 0xE8
045D38             0932*  
045D38             0933*  ; &F0-&F7 	240-247 	Not defined
045D38             0934*  ; &F8-&FF 	248-255 	Not defined
045D38             0935*  
045D38             0936*  ; § Support added in Agon Console8 VDP 2.1.0 §§ Support added in
045D38             0937*  ; Agon Console8 VDP 2.2.0
045D38             0938*  
045D38             0939*  ; Within each group of eight plot codes, the effects are as follows:
045D38             0940*  ; Plot code 	Effect
045D38             0941*  ; 0 	Move relative
045D38             0942*  mv_rel: equ 0
045D38             0943*  
045D38             0944*  ; 1 	Plot relative in current foreground colour
045D38             0945*  dr_rel_fg: equ 1
045D38             0946*  
045D38             0947*  ; 2 	Not supported (Plot relative in logical inverse colour)
045D38             0948*  ; 3 	Plot relative in current background colour
045D38             0949*  dr_rel_bg: equ 3
045D38             0950*  
045D38             0951*  ; 4 	Move absolute
045D38             0952*  mv_abs: equ 4
045D38             0953*  
045D38             0954*  ; 5 	Plot absolute in current foreground colour
045D38             0955*  dr_abs_fg: equ 5
045D38             0956*  
045D38             0957*  ; 6 	Not supported (Plot absolute in logical inverse colour)
045D38             0958*  ; 7 	Plot absolute in current background colour
045D38             0959*  dr_abs_bg: equ 7
045D38             0960*  
045D38             0961*  ; Codes 0-3 use the position data provided as part of the command
045D38             0962*  ; as a relative position, adding the position given to the current
045D38             0963*  ; graphical cursor position. Codes 4-7 use the position data provided
045D38             0964*  ; as part of the command as an absolute position, setting the current
045D38             0965*  ; graphical cursor position to the position given.
045D38             0966*  
045D38             0967*  ; Codes 2 and 6 on Acorn systems plot using a logical inverse of the
045D38             0968*  ; current pixel colour. These operations cannot currently be supported
045D38             0969*  ; by the graphics system the Agon VDP uses, so these codes are not
045D38             0970*  ; supported. Support for these codes may be added in a future version
045D38             0971*  ; of the VDP firmware.
045D38             0972*  
045D38             0973*  ; 16 colour palette constants
045D38             0974*  c_black: equ 0
045D38             0975*  c_red_dk: equ 1
045D38             0976*  c_green_dk: equ 2
045D38             0977*  c_yellow_dk: equ 3
045D38             0978*  c_blue_dk: equ 4
045D38             0979*  c_magenta_dk: equ 5
045D38             0980*  c_cyan_dk: equ 6
045D38             0981*  c_grey: equ 7
045D38             0982*  c_grey_dk: equ 8
045D38             0983*  c_red: equ 9
045D38             0984*  c_green: equ 10
045D38             0985*  c_yellow: equ 11
045D38             0986*  c_blue: equ 12
045D38             0987*  c_magenta: equ 13
045D38             0988*  c_cyan: equ 14
045D38             0989*  c_white: equ 15
045D38             0990*  
045D38             0991*  ; VDU 25, mode, x; y;: PLOT command
045D38             0992*  ; inputs: a=mode, bc=x0, de=y0
045D38             0993*  vdu_plot:
045D38 32 52 5D 04 0994*      ld (@mode),a
045D3C ED 43 53 5D 0995*      ld (@x0),bc
       04          
045D41 ED 53 55 5D 0996*      ld (@y0),de
       04          
045D46 21 51 5D 04 0997*  	ld hl,@cmd
045D4A 01 06 00 00 0998*  	ld bc,@end-@cmd
045D4E 5B DF       0999*  	rst.lil $18
045D50 C9          1000*  	ret
045D51 19          1001*  @cmd:   db 25
045D52 00          1002*  @mode:  db 0
045D53 00 00       1003*  @x0: 	dw 0
045D55 00 00       1004*  @y0: 	dw 0
045D57 00          1005*  @end:   db 0 ; extra byte to soak up deu
045D58             1006*  
045D58             1007*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
045D58             1008*  ; &E8-&EF 	232-239 	Bitmap plot §
045D58             1009*  ; VDU 25, mode, x; y;: PLOT command
045D58             1010*  ; inputs: bc=x0, de=y0
045D58             1011*  ; prerequisites: vdu_buff_select
045D58             1012*  vdu_plot_bmp:
045D58 ED 43 6F 5D 1013*      ld (@x0),bc
       04          
045D5D ED 53 71 5D 1014*      ld (@y0),de
       04          
045D62 21 6D 5D 04 1015*  	ld hl,@cmd
045D66 01 06 00 00 1016*  	ld bc,@end-@cmd
045D6A 5B DF       1017*  	rst.lil $18
045D6C C9          1018*  	ret
045D6D 19          1019*  @cmd:   db 25
045D6E ED          1020*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
045D6F 00 00       1021*  @x0: 	dw 0x0000
045D71 00 00       1022*  @y0: 	dw 0x0000
045D73 00          1023*  @end:   db 0x00 ; padding
045D74             1024*  
045D74             1025*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
045D74             1026*  ; &E8-&EF 	232-239 	Bitmap plot §
045D74             1027*  ; VDU 25, mode, x; y;: PLOT command
045D74             1028*  ; inputs: bc=x0, de=y0
045D74             1029*  ; USING 16.8 FIXED POINT COORDINATES
045D74             1030*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
045D74             1031*  ;   the fractional portiion of the inputs are truncated
045D74             1032*  ;   leaving only the 16-bit integer portion
045D74             1033*  ; prerequisites: vdu_buff_select
045D74             1034*  vdu_plot_bmp168:
045D74             1035*  ; populate in the reverse of normal to keep the
045D74             1036*  ; inputs from stomping on each other
045D74 ED 53 92 5D 1037*      ld (@y0-1),de
       04          
045D79 ED 43 90 5D 1038*      ld (@x0-1),bc
       04          
045D7E 3E ED       1039*      ld a,plot_bmp+dr_abs_fg ; 0xED
045D80 32 90 5D 04 1040*      ld (@mode),a ; restore the mode byte that got stomped on by bcu
045D84 21 8F 5D 04 1041*  	ld hl,@cmd
045D88 01 06 00 00 1042*  	ld bc,@end-@cmd
045D8C 5B DF       1043*  	rst.lil $18
045D8E C9          1044*  	ret
045D8F 19          1045*  @cmd:   db 25
045D90 ED          1046*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
045D91 00 00       1047*  @x0: 	dw 0x0000
045D93 00 00       1048*  @y0: 	dw 0x0000
045D95             1049*  @end:  ; no padding required b/c we shifted de right
045D95             1050*  
045D95             1051*  ; draw a filled rectangle
045D95             1052*  vdu_plot_rf:
045D95 ED 43 BC 5D 1053*      ld (@x0),bc
       04          
045D9A ED 53 BE 5D 1054*      ld (@y0),de
       04          
045D9F DD 22 C2 5D 1055*      ld (@x1),ix
       04          
045DA4 FD 22 C4 5D 1056*      ld (@y1),iy
       04          
045DA9 3E 19       1057*      ld a,25 ; we have to reload the 2nd plot command
045DAB 32 C0 5D 04 1058*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
045DAF 21 BA 5D 04 1059*  	ld hl,@cmd0
045DB3 01 0C 00 00 1060*  	ld bc,@end-@cmd0
045DB7 5B DF       1061*  	rst.lil $18
045DB9 C9          1062*      ret
045DBA 19          1063*  @cmd0:  db 25 ; plot
045DBB 04          1064*  @arg0:  db plot_sl_both+mv_abs
045DBC 00 00       1065*  @x0:    dw 0x0000
045DBE 00 00       1066*  @y0:    dw 0x0000
045DC0 19          1067*  @cmd1:  db 25 ; plot
045DC1 65          1068*  @arg1:  db plot_rf+dr_abs_fg
045DC2 00 00       1069*  @x1:    dw 0x0000
045DC4 00 00       1070*  @y1:    dw 0x0000
045DC6 00          1071*  @end:   db 0x00 ; padding
045DC7             1072*  
045DC7             1073*  ; draw a filled circle
045DC7             1074*  vdu_plot_cf:
045DC7 ED 43 EE 5D 1075*      ld (@x0),bc
       04          
045DCC ED 53 F0 5D 1076*      ld (@y0),de
       04          
045DD1 DD 22 F4 5D 1077*      ld (@x1),ix
       04          
045DD6 FD 22 F6 5D 1078*      ld (@y1),iy
       04          
045DDB 3E 19       1079*      ld a,25 ; we have to reload the 2nd plot command
045DDD 32 F2 5D 04 1080*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
045DE1 21 EC 5D 04 1081*  	ld hl,@cmd0
045DE5 01 0C 00 00 1082*  	ld bc,@end-@cmd0
045DE9 5B DF       1083*  	rst.lil $18
045DEB C9          1084*      ret
045DEC 19          1085*  @cmd0:  db 25 ; plot
045DED 04          1086*  @arg0:  db plot_sl_both+mv_abs
045DEE 00 00       1087*  @x0:    dw 0x0000
045DF0 00 00       1088*  @y0:    dw 0x0000
045DF2 19          1089*  @cmd1:  db 25 ; plot
045DF3 9D          1090*  @arg1:  db plot_cf+dr_abs_fg
045DF4 00 00       1091*  @x1:    dw 0x0000
045DF6 00 00       1092*  @y1:    dw 0x0000
045DF8 00          1093*  @end:   db 0x00 ; padding
045DF9             1094*  
045DF9             1095*  ; #### from vdu_sprites.inc ####
045DF9             1096*  ; ; https://github.com/AgonConsole8/agon-docs/blob/main/VDP---Bitmaps-API.md
045DF9             1097*  ; the VDP can support up to 256 sprites. They must be defined
045DF9             1098*  ; contiguously, and so the first sprite is sprite 0.
045DF9             1099*  ; (In contrast, bitmaps can have any ID from 0 to 65534.)
045DF9             1100*  ; Once a selection of sprites have been defined, you can activate
045DF9             1101*  ; them using the VDU 23, 27, 7, n command, where n is the number
045DF9             1102*  ; of sprites to activate. This will activate the first n sprites,
045DF9             1103*  ; starting with sprite 0. All sprites from 0 to n-1 must be defined.
045DF9             1104*  
045DF9             1105*  ; A single sprite can have multiple "frames", referring to
045DF9             1106*  ; different bitmaps.
045DF9             1107*  ; (These bitmaps do not need to be the same size.)
045DF9             1108*  ; This allows a sprite to include an animation sequence,
045DF9             1109*  ; which can be stepped through one frame at a time, or picked
045DF9             1110*  ; in any order.
045DF9             1111*  
045DF9             1112*  ; Any format of bitmap can be used as a sprite frame. It should
045DF9             1113*  ; be noted however that "native" format bitmaps are not
045DF9             1114*  ; recommended for use as sprite frames, as they cannot get
045DF9             1115*  ; erased from the screen. (As noted above, the "native" bitmap
045DF9             1116*  ; format is not really intended for general use.) This is part
045DF9             1117*  ; of why from Agon Console8 VDP 2.6.0 bitmaps captured from the
045DF9             1118*  ; screen are now stored in RGBA2222 format.
045DF9             1119*  
045DF9             1120*  ; An "active" sprite can be hidden, so it will stop being drawn,
045DF9             1121*  ; and then later shown again.
045DF9             1122*  
045DF9             1123*  ; Moving sprites around the screen is done by changing the
045DF9             1124*  ; position of the sprite. This can be done either by setting
045DF9             1125*  ; the absolute position of the sprite, or by moving the sprite
045DF9             1126*  ; by a given number of pixels. (Sprites are positioned using
045DF9             1127*  ; pixel coordinates, and not by the logical OS coordinate system.)
045DF9             1128*  ; In the current sprite system, sprites will not update their
045DF9             1129*  ; position on-screen until either another drawing operation is
045DF9             1130*  ; performed or an explicit VDU 23, 27, 15 command is performed.
045DF9             1131*  
045DF9             1132*  ; Here are the sprite commands:
045DF9             1133*  ;
045DF9             1134*  ; VDU 23, 27, 4,  n: Select sprite n
045DF9             1135*  ; inputs: a is the 8-bit sprite id
045DF9             1136*  ; vdu_sprite_select:
045DF9             1137*  
045DF9             1138*  ; VDU 23, 27, 5:  Clear frames in current sprite
045DF9             1139*  ; inputs: none
045DF9             1140*  ; prerequisites: vdu_sprite_select
045DF9             1141*  ; vdu_sprite_clear_frames:
045DF9             1142*  
045DF9             1143*  ; VDU 23, 27, 6,  n: Add bitmap n as a frame to current sprite (where bitmap's buffer ID is 64000+n)
045DF9             1144*  ; inputs: a is the 8-bit bitmap number
045DF9             1145*  ; prerequisites: vdu_sprite_select
045DF9             1146*  ; vdu_sprite_add_bmp:
045DF9             1147*  
045DF9             1148*  ; VDU 23, 27, 7,  n: Activate n sprites
045DF9             1149*  ; inputs: a is the number of sprites to activate
045DF9             1150*  ; vdu_sprite_activate:
045DF9             1151*  
045DF9             1152*  ; VDU 23, 27, 8:  Select next frame of current sprite
045DF9             1153*  ; inputs: none
045DF9             1154*  ; prerequisites: vdu_sprite_select
045DF9             1155*  ; vdu_sprite_next_frame:
045DF9             1156*  
045DF9             1157*  ; VDU 23, 27, 9:  Select previous frame of current sprite
045DF9             1158*  ; inputs: none
045DF9             1159*  ; prerequisites: vdu_sprite_select
045DF9             1160*  ; vdu_sprite_prev_frame:
045DF9             1161*  
045DF9             1162*  ; VDU 23, 27, 10, n: Select the nth frame of current sprite
045DF9             1163*  ; inputs: a is frame number to select
045DF9             1164*  ; prerequisites: vdu_sprite_select
045DF9             1165*  ; vdu_sprite_select_frame:
045DF9             1166*  
045DF9             1167*  ; VDU 23, 27, 11: Show current sprite
045DF9             1168*  ; inputs: none
045DF9             1169*  ; prerequisites: vdu_sprite_select
045DF9             1170*  ; vdu_sprite_show:
045DF9             1171*  
045DF9             1172*  ; VDU 23, 27, 12: Hide current sprite
045DF9             1173*  ; inputs: none
045DF9             1174*  ; prerequisites: vdu_sprite_select
045DF9             1175*  ; vdu_sprite_hide:
045DF9             1176*  
045DF9             1177*  ; VDU 23, 27, 13, x; y;: Move current sprite to pixel position x, y
045DF9             1178*  ; inputs: bc is x coordinate, de is y coordinate
045DF9             1179*  ; prerequisites: vdu_sprite_select
045DF9             1180*  ; vdu_sprite_move_abs:
045DF9             1181*  ;
045DF9             1182*  ; USING 16.8 FIXED POINT COORDINATES
045DF9             1183*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
045DF9             1184*  ;   the fractional portiion of the inputs are truncated
045DF9             1185*  ;   leaving only the 16-bit integer portion
045DF9             1186*  ; prerequisites: vdu_sprite_select
045DF9             1187*  ; vdu_sprite_move_abs168:
045DF9             1188*  
045DF9             1189*  ; VDU 23, 27, 14, x; y;: Move current sprite by x, y pixels
045DF9             1190*  ; inputs: bc is x coordinate, de is y coordinate
045DF9             1191*  ; prerequisites: vdu_sprite_select
045DF9             1192*  ; vdu_sprite_move_rel:
045DF9             1193*  ;
045DF9             1194*  ; USING 16.8 FIXED POINT COORDINATES
045DF9             1195*  ; inputs: ub.c is dx, ud.e is dy
045DF9             1196*  ;   the fractional portiion of the inputs are truncated
045DF9             1197*  ;   leaving only the 16-bit integer portion
045DF9             1198*  ; prerequisites: vdu_sprite_select
045DF9             1199*  ; vdu_sprite_move_rel168:
045DF9             1200*  
045DF9             1201*  ; VDU 23, 27, 15: Update the sprites in the GPU
045DF9             1202*  ; inputs: none
045DF9             1203*  ; vdu_sprite_update:
045DF9             1204*  
045DF9             1205*  ; VDU 23, 27, 16: Reset bitmaps and sprites and clear all data
045DF9             1206*  ; inputs: none
045DF9             1207*  ; vdu_sprite_bmp_reset:
045DF9             1208*  
045DF9             1209*  ; VDU 23, 27, 17: Reset sprites (only) and clear all data
045DF9             1210*  ; inputs: none
045DF9             1211*  ; vdu_sprite_reset:
045DF9             1212*  
045DF9             1213*  ; VDU 23, 27, 18, n: Set the current sprite GCOL paint mode to n **
045DF9             1214*  ; inputs: a is the GCOL paint mode
045DF9             1215*  ; prerequisites: vdu_sprite_select
045DF9             1216*  ; vdu_sprite_set_gcol:
045DF9             1217*  
045DF9             1218*  ; VDU 23, 27, &26, n;: Add bitmap n as a frame to current sprite using a 16-bit buffer ID
045DF9             1219*  ; inputs: hl=bufferId
045DF9             1220*  ; prerequisites: vdu_sprite_select
045DF9             1221*  ; vdu_sprite_add_buff:
045DF9             1222*  
045DF9             1223*  @dummy_label: ; dummy label to serve as a break from the above comments and the below code
045DF9             1224*  
045DF9             1225*  ; VDU 23, 27, 4, n: Select sprite n
045DF9             1226*  ; inputs: a is the 8-bit sprite id
045DF9             1227*  vdu_sprite_select:
045DF9 32 0B 5E 04 1228*      ld (@sprite),a
045DFD 21 08 5E 04 1229*      ld hl,@cmd
045E01 01 04 00 00 1230*      ld bc,@end-@cmd
045E05 5B DF       1231*      rst.lil $18
045E07 C9          1232*      ret
045E08 17 1B 04    1233*  @cmd:    db 23,27,4
045E0B 00          1234*  @sprite: db 0x00
045E0C             1235*  @end:
045E0C             1236*  
045E0C             1237*  ; VDU 23, 27, 5: Clear frames in current sprite
045E0C             1238*  ; inputs: none
045E0C             1239*  ; prerequisites: vdu_sprite_select
045E0C             1240*  vdu_sprite_clear_frames:
045E0C 21 17 5E 04 1241*      ld hl,@cmd
045E10 01 03 00 00 1242*      ld bc,@end-@cmd
045E14 5B DF       1243*      rst.lil $18
045E16 C9          1244*      ret
045E17 17 1B 05    1245*  @cmd: db 23,27,5
045E1A             1246*  @end:
045E1A             1247*  
045E1A             1248*  ; VDU 23, 27, 6, n: Add bitmap n as a frame to current sprite (where bitmap's buffer ID is 64000+n)
045E1A             1249*  ; inputs: a is the 8-bit bitmap number
045E1A             1250*  ; prerequisites: vdu_sprite_select
045E1A             1251*  vdu_sprite_add_bmp:
045E1A 32 2C 5E 04 1252*      ld (@bmp),a
045E1E 21 29 5E 04 1253*      ld hl,@cmd
045E22 01 04 00 00 1254*      ld bc,@end-@cmd
045E26 5B DF       1255*      rst.lil $18
045E28 C9          1256*      ret
045E29 17 1B 06    1257*  @cmd: db 23,27,6
045E2C 00          1258*  @bmp: db 0x00
045E2D             1259*  @end:
045E2D             1260*  
045E2D             1261*  ; VDU 23, 27, 7, n: Activate n sprites
045E2D             1262*  ; inputs: a is the number of sprites to activate
045E2D             1263*  vdu_sprite_activate:
045E2D 32 3F 5E 04 1264*      ld (@num),a
045E31 21 3C 5E 04 1265*      ld hl,@cmd
045E35 01 04 00 00 1266*      ld bc,@end-@cmd
045E39 5B DF       1267*      rst.lil $18
045E3B C9          1268*      ret
045E3C 17 1B 07    1269*  @cmd: db 23,27,7
045E3F 00          1270*  @num: db 0x00
045E40             1271*  @end:
045E40             1272*  
045E40             1273*  ; VDU 23, 27, 8: Select next frame of current sprite
045E40             1274*  ; inputs: none
045E40             1275*  ; prerequisites: vdu_sprite_select
045E40             1276*  vdu_sprite_next_frame:
045E40 21 4B 5E 04 1277*      ld hl,@cmd
045E44 01 03 00 00 1278*      ld bc,@end-@cmd
045E48 5B DF       1279*      rst.lil $18
045E4A C9          1280*      ret
045E4B 17 1B 08    1281*  @cmd: db 23,27,8
045E4E             1282*  @end:
045E4E             1283*  
045E4E             1284*  ; VDU 23, 27, 9: Select previous frame of current sprite
045E4E             1285*  ; inputs: none
045E4E             1286*  ; prerequisites: vdu_sprite_select
045E4E             1287*  vdu_sprite_prev_frame:
045E4E 21 59 5E 04 1288*      ld hl,@cmd
045E52 01 03 00 00 1289*      ld bc,@end-@cmd
045E56 5B DF       1290*      rst.lil $18
045E58 C9          1291*      ret
045E59 17 1B 09    1292*  @cmd: db 23,27,9
045E5C             1293*  @end:
045E5C             1294*  
045E5C             1295*  ; VDU 23, 27, 10, n: Select the nth frame of current sprite
045E5C             1296*  ; inputs: a is frame number to select
045E5C             1297*  ; prerequisites: vdu_sprite_select
045E5C             1298*  vdu_sprite_select_frame:
045E5C 32 6E 5E 04 1299*      ld (@frame),a
045E60 21 6B 5E 04 1300*      ld hl,@cmd
045E64 01 04 00 00 1301*      ld bc,@end-@cmd
045E68 5B DF       1302*      rst.lil $18
045E6A C9          1303*      ret
045E6B 17 1B 0A    1304*  @cmd:    db 23,27,10
045E6E 00          1305*  @frame:  db 0x00
045E6F             1306*  @end:
045E6F             1307*  
045E6F             1308*  ; VDU 23, 27, 11: Show current sprite
045E6F             1309*  ; inputs: none
045E6F             1310*  ; prerequisites: vdu_sprite_select
045E6F             1311*  vdu_sprite_show:
045E6F 21 7A 5E 04 1312*      ld hl,@cmd
045E73 01 03 00 00 1313*      ld bc,@end-@cmd
045E77 5B DF       1314*      rst.lil $18
045E79 C9          1315*      ret
045E7A 17 1B 0B    1316*  @cmd: db 23,27,11
045E7D             1317*  @end:
045E7D             1318*  
045E7D             1319*  ; VDU 23, 27, 12: Hide current sprite
045E7D             1320*  ; inputs: none
045E7D             1321*  ; prerequisites: vdu_sprite_select
045E7D             1322*  vdu_sprite_hide:
045E7D 21 88 5E 04 1323*      ld hl,@cmd
045E81 01 03 00 00 1324*      ld bc,@end-@cmd
045E85 5B DF       1325*      rst.lil $18
045E87 C9          1326*      ret
045E88 17 1B 0C    1327*  @cmd: db 23,27,12
045E8B             1328*  @end:
045E8B             1329*  
045E8B             1330*  ; VDU 23, 27, 13, x; y;: Move current sprite to pixel position x, y
045E8B             1331*  ; inputs: bc is x coordinate, de is y coordinate
045E8B             1332*  ; prerequisites: vdu_sprite_select
045E8B             1333*  vdu_sprite_move_abs:
045E8B ED 43 A3 5E 1334*      ld (@xpos),bc
       04          
045E90 ED 53 A5 5E 1335*      ld (@ypos),de
       04          
045E95 21 A0 5E 04 1336*      ld hl,@cmd
045E99 01 07 00 00 1337*      ld bc,@end-@cmd
045E9D 5B DF       1338*      rst.lil $18
045E9F C9          1339*      ret
045EA0 17 1B 0D    1340*  @cmd:  db 23,27,13
045EA3 00 00       1341*  @xpos: dw 0x0000
045EA5 00 00       1342*  @ypos: dw 0x0000
045EA7 00          1343*  @end:  db 0x00 ; padding
045EA8             1344*  
045EA8             1345*  ; VDU 23, 27, 14, x; y;: Move current sprite by x, y pixels
045EA8             1346*  ; inputs: bc is x coordinate, de is y coordinate
045EA8             1347*  ; prerequisites: vdu_sprite_select
045EA8             1348*  vdu_sprite_move_rel:
045EA8 ED 43 C0 5E 1349*      ld (@dx),bc
       04          
045EAD ED 53 C2 5E 1350*      ld (@dy),de
       04          
045EB2 21 BD 5E 04 1351*      ld hl,@cmd
045EB6 01 07 00 00 1352*      ld bc,@end-@cmd
045EBA 5B DF       1353*      rst.lil $18
045EBC C9          1354*      ret
045EBD 17 1B 0E    1355*  @cmd: db 23,27,14
045EC0 00 00       1356*  @dx:  dw 0x0000
045EC2 00 00       1357*  @dy:  dw 0x0000
045EC4 00          1358*  @end: db 0x00 ; padding
045EC5             1359*  
045EC5             1360*  ; VDU 23, 27, 13, x; y;: Move current sprite to pixel position x, y
045EC5             1361*  ; USING 16.8 FIXED POINT COORDINATES
045EC5             1362*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
045EC5             1363*  ;   the fractional portiion of the inputs are truncated
045EC5             1364*  ;   leaving only the 16-bit integer portion
045EC5             1365*  ; prerequisites: vdu_sprite_select
045EC5             1366*  vdu_sprite_move_abs168:
045EC5             1367*  ; populate in the reverse of normal to keep the
045EC5             1368*  ; inputs from stomping on each other
045EC5 ED 53 E4 5E 1369*      ld (@ypos-1),de
       04          
045ECA ED 43 E2 5E 1370*      ld (@xpos-1),bc
       04          
045ECF 3E 0D       1371*      ld a,13       ; restore the final byte of the command
045ED1 32 E2 5E 04 1372*      ld (@cmd+2),a ; string that got stomped on by bcu
045ED5 21 E0 5E 04 1373*      ld hl,@cmd
045ED9 01 07 00 00 1374*      ld bc,@end-@cmd
045EDD 5B DF       1375*      rst.lil $18
045EDF C9          1376*      ret
045EE0 17 1B 0D    1377*  @cmd:  db 23,27,13
045EE3 00 00       1378*  @xpos: dw 0x0000
045EE5 00 00       1379*  @ypos: dw 0x0000
045EE7             1380*  @end:  ; no padding required b/c we shifted de right
045EE7             1381*  
045EE7             1382*  ; VDU 23, 27, 14, x; y;: Move current sprite by x, y pixels
045EE7             1383*  ; USING 16.8 FIXED POINT COORDINATES
045EE7             1384*  ; inputs: ub.c is dx, ud.e is dy
045EE7             1385*  ;   the fractional portiion of the inputs are truncated
045EE7             1386*  ;   leaving only the 16-bit integer portion
045EE7             1387*  ; prerequisites: vdu_sprite_select
045EE7             1388*  vdu_sprite_move_rel168:
045EE7             1389*  ; populate in the reverse of normal to keep the
045EE7             1390*  ; inputs from stomping on each other
045EE7 ED 53 06 5F 1391*      ld (@dy-1),de
       04          
045EEC ED 43 04 5F 1392*      ld (@dx-1),bc
       04          
045EF1 3E 0E       1393*      ld a,14       ; restore the final byte of the command
045EF3 32 04 5F 04 1394*      ld (@cmd+2),a ; string that got stomped on by bcu
045EF7 21 02 5F 04 1395*      ld hl,@cmd
045EFB 01 07 00 00 1396*      ld bc,@end-@cmd
045EFF 5B DF       1397*      rst.lil $18
045F01 C9          1398*      ret
045F02 17 1B 0E    1399*  @cmd:  db 23,27,14
045F05 00 00       1400*  @dx: dw 0x0000
045F07 00 00       1401*  @dy: dw 0x0000
045F09             1402*  @end:  ; no padding required b/c we shifted de right
045F09             1403*  
045F09             1404*  ; VDU 23, 27, 15: Update the sprites in the GPU
045F09             1405*  ; inputs: none
045F09             1406*  vdu_sprite_update:
045F09 21 14 5F 04 1407*      ld hl,@cmd
045F0D 01 03 00 00 1408*      ld bc,@end-@cmd
045F11 5B DF       1409*      rst.lil $18
045F13 C9          1410*      ret
045F14 17 1B 0F    1411*  @cmd: db 23,27,15
045F17             1412*  @end:
045F17             1413*  
045F17             1414*  ; VDU 23, 27, 16: Reset bitmaps and sprites and clear all data
045F17             1415*  ; inputs: none
045F17             1416*  vdu_sprite_bmp_reset:
045F17 21 22 5F 04 1417*      ld hl,@cmd
045F1B 01 03 00 00 1418*      ld bc,@end-@cmd
045F1F 5B DF       1419*      rst.lil $18
045F21 C9          1420*      ret
045F22 17 1B 10    1421*  @cmd: db 23,27,16
045F25             1422*  @end:
045F25             1423*  
045F25             1424*  ; VDU 23, 27, 17: Reset sprites (only) and clear all data
045F25             1425*  ; inputs: none
045F25             1426*  vdu_sprite_reset:
045F25 21 30 5F 04 1427*      ld hl,@cmd
045F29 01 03 00 00 1428*      ld bc,@end-@cmd
045F2D 5B DF       1429*      rst.lil $18
045F2F C9          1430*      ret
045F30 17 1B 11    1431*  @cmd: db 23,27,17
045F33             1432*  @end:
045F33             1433*  
045F33             1434*  ; VDU 23, 27, 18, n: Set the current sprite GCOL paint mode to n **
045F33             1435*  ; inputs: a is the GCOL paint mode
045F33             1436*  ; prerequisites: vdu_sprite_select
045F33             1437*  vdu_sprite_set_gcol:
045F33 32 45 5F 04 1438*      ld (@mode),a
045F37 21 42 5F 04 1439*      ld hl,@cmd
045F3B 01 04 00 00 1440*      ld bc,@end-@cmd
045F3F 5B DF       1441*      rst.lil $18
045F41 C9          1442*      ret
045F42 17 1B 12    1443*  @cmd:  db 23,27,18
045F45 00          1444*  @mode: db 0x00
045F46             1445*  @end:
045F46             1446*  
045F46             1447*  ; VDU 23, 27, &26, n;: Add bitmap bufferId
045F46             1448*  ;     as a frame to current sprite using a 16-bit buffer ID
045F46             1449*  ; inputs: hl=bufferId
045F46             1450*  ; prerequisites: vdu_sprite_select
045F46             1451*  vdu_sprite_add_buff:
045F46 22 58 5F 04 1452*      ld (@bufferId),hl
045F4A 21 55 5F 04 1453*      ld hl,@cmd
045F4E 01 05 00 00 1454*      ld bc,@end-@cmd
045F52 5B DF       1455*      rst.lil $18
045F54 C9          1456*      ret
045F55 17 1B 26    1457*  @cmd:      db 23,27,0x26
045F58 00 00       1458*  @bufferId: dw 0x0000
045F5A 00          1459*  @end:      db 0x00 ; padding
045F5B             1460*  
045F5B             1461*  
045F5B             1462*  ; #### from sfx.inc ####
045F5B 00          1463*  sfx_last_channel: db 0x00 ; 8-bit value between 0 and 31
045F5C             1464*  
045F5C             1465*  ; ; play a sound effect on the next available channel at full volume for its full duration
045F5C             1466*  ; ; inputs: hl = bufferId
045F5C             1467*  ; sfx_play:
045F5C             1468*  ; 	ld iy,sfx_last_channel
045F5C             1469*  ; 	ld a,(iy+0)
045F5C             1470*  ; 	ld (@bufferId),hl
045F5C             1471*  ; @find_next_channel:
045F5C             1472*  ; 	inc a ; bump to next channel
045F5C             1473*  ; 	and 31 ; modulo 32 channel
045F5C             1474*  ; 	cp (iy+0) ; if this is zero we've wrapped around and not found a free channel
045F5C             1475*  ; 	ret z ; so we return to caller without doing anything
045F5C             1476*  ; 	push af ; back up channel
045F5C             1477*  ; 	call vdu_channel_status ; a comes back with channel status bitmask
045F5C             1478*  ; 	and %00000010 ; bit 1 is the "is playing" flag
045F5C             1479*  ; 	jr z,@play_sfx ; if not playing, we can use this channel
045F5C             1480*  ; 	pop af ; restore channel
045F5C             1481*  ; 	jr @find_next_channel ; try the next channel
045F5C             1482*  ; @play_sfx:
045F5C             1483*  ; 	pop af ; restore channel
045F5C             1484*  ; 	ld (iy+0),a ; store channel
045F5C             1485*  ; 	ld hl,(@bufferId)
045F5C             1486*  ; 	ld c,a ; channel
045F5C             1487*  ; 	ld b,127 ; full volume
045F5C             1488*  ; 	ld de,1000 ; 1 second duration (should have no effect)
045F5C             1489*  ; 	jp vdu_play_sample
045F5C             1490*  ; @bufferId:
045F5C             1491*  ; 	dw 0x0000 ; 16-bit value
045F5C             1492*  
045F5C             1493*  vdu_clear_all_buffers:
045F5C             1494*  ; clear all buffers
045F5C 21 67 5F 04 1495*      ld hl,@beg
045F60 01 06 00 00 1496*      ld bc,@end-@beg
045F64 5B DF       1497*      rst.lil $18
045F66 C9          1498*      ret
045F67 17 00 A0    1499*  @beg: db 23,0,$A0
045F6A FF FF       1500*        dw -1 ; clear all buffers
045F6C 02          1501*        db 2  ; command 2: clear a buffer
045F6D             1502*  @end:
045F6D             0056       include "src/asm/vdu_buff.inc"
045F6D             0001*  ; VDP Buffered Commands API
045F6D             0002*  ; https://agonconsole8.github.io/agon-docs/VDP---Buffered-Commands-API.html
045F6D             0003*  
045F6D             0004*  ; VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
045F6D             0005*  ; This command is used to store a data block (a sequence of bytes)
045F6D             0006*  ; in a buffer on the VDP. The exact nature of this data may vary.
045F6D             0007*  ; It could be a sequence of VDU commands which can be executed
045F6D             0008*  ; later, a bitmap, a sound sample, or just a sequence of bytes.
045F6D             0009*  ; When used for a sequence of VDU commands, this effectively
045F6D             0010*  ; allows for functions or stored procedures to be created.
045F6D             0011*  
045F6D             0012*  ; This is the most common command to use to send data to the VDP.
045F6D             0013*  ; Typically you will call command 2 first to ensure that the
045F6D             0014*  ; buffer is empty, and then make a series of calls to this command
045F6D             0015*  ; to send data to the buffer.
045F6D             0016*  
045F6D             0017*  ; The bufferId is a 16-bit integer that identifies the buffer to
045F6D             0018*  ; write to. Writing to the same buffer ID multiple times will add
045F6D             0019*  ; new blocks to that buffer. This allows a buffer to be built up
045F6D             0020*  ; over time, essentially allowing for a command to be sent across
045F6D             0021*  ; to the VDP in multiple separate packets.
045F6D             0022*  
045F6D             0023*  ; Whilst the length of an individual block added using this command
045F6D             0024*  ; is restricted to 65535 bytes (as the largest value that can be
045F6D             0025*  ; sent in a 16-bit number) the total size of a buffer is not
045F6D             0026*  ; restricted to this size, as multiple blocks can be added to a
045F6D             0027*  ; buffer. Given how long it takes to send data to the VDP it is
045F6D             0028*  ; advisable to send data across in smaller chunks, such as 1kb of
045F6D             0029*  ; data or less at a time.
045F6D             0030*  
045F6D             0031*  ; As writing to a single buffer ID is cumulative with this command,
045F6D             0032*  ; care should be taken to ensure that the buffer is cleared out
045F6D             0033*  ; before writing to it.
045F6D             0034*  
045F6D             0035*  ; When building up a complex sequence of commands it is often
045F6D             0036*  ; advisable to use multiple blocks within a buffer. Typically
045F6D             0037*  ; this is easier to code, as otherwise working out exactly how
045F6D             0038*  ; many bytes long a command sequence is can be can be onerously
045F6D             0039*  ; difficult. It is also easier to modify a command sequences that
045F6D             0040*  ; are broken up into multiple blocks.
045F6D             0041*  
045F6D             0042*  ; As mentioned above it is advisable to send large pieces of data,
045F6D             0043*  ; such as bitmaps or sound samples, in smaller chunks. In between
045F6D             0044*  ; each packet of data sent to a buffer, the user can then perform
045F6D             0045*  ; other operations, such as updating the screen to indicate
045F6D             0046*  ; progress. This allows for long-running operations to be performed
045F6D             0047*  ; without blocking the screen, and larger amounts of data to be
045F6D             0048*  ; transferred over to the VDP than may otherwise be practical given
045F6D             0049*  ; the limitations of the eZ80.
045F6D             0050*  
045F6D             0051*  ; If a buffer ID of 65535 is used then this command will be
045F6D             0052*  ; ignored, and the data discarded. This is because this buffer ID
045F6D             0053*  ; is reserved for special functions.
045F6D             0054*  
045F6D             0055*  ; Using buffers for bitmaps
045F6D             0056*  
045F6D             0057*  ; Whilst it is advisable to send bitmaps over in multiple blocks,
045F6D             0058*  ; they cannot be used if they are spread over multiple blocks.
045F6D             0059*  ; To use a bitmap its data must be in a single contiguous block,
045F6D             0060*  ; and this is achieved by using the “consolidate” command &0E.
045F6D             0061*  
045F6D             0062*  ; Once you have a block that is ready to be used for a bitmap,
045F6D             0063*  ; the buffer must be selected, and then a bitmap created for that
045F6D             0064*  ; buffer using the bitmap and sprites API. This is done with the
045F6D             0065*  ; following commands:
045F6D             0066*  
045F6D             0067*  ; VDU 23, 27, &20, bufferId;              : REM Select bitmap (using a buffer ID)
045F6D             0068*  ; VDU 23, 27, &21, width; height; format  : REM Create bitmap from buffer
045F6D             0069*  
045F6D             0070*  ; Until the “create bitmap” call has been made the buffer cannot
045F6D             0071*  ; be used as a bitmap. That is because the system needs to
045F6D             0072*  ; understand the dimensions of the bitmap, as well as the format
045F6D             0073*  ; of the data. Usually this only needs to be done once. The format
045F6D             0074*  ; is given as an 8-bit value, with the following values supported:
045F6D             0075*  ; Value 	Type 	Description
045F6D             0076*  ; 0 	RGBA8888 	RGBA, 8-bits per channel, with bytes ordered sequentially for red, green, blue and alpha
045F6D             0077*  ; 1 	RGBA2222 	RGBA, 2-bits per channel, with bits ordered from highest bits as alpha, blue, green and red
045F6D             0078*  ; 2 	Mono 	Monochrome, 1-bit per pixel
045F6D             0079*  
045F6D             0080*  ; The existing bitmap API uses an 8-bit number to select bitmaps,
045F6D             0081*  ; and these are automatically stored in buffers numbered 64000-64255
045F6D             0082*  ; (&FA00-&FAFF). Working out the buffer number for a bitmap is
045F6D             0083*  ; simply a matter of adding 64000. All bitmaps created with that
045F6D             0084*  ; API will be RGBA8888 format.
045F6D             0085*  
045F6D             0086*  ; There is one other additional call added to the bitmap and
045F6D             0087*  ; sprites API, which allows for bitmaps referenced with a
045F6D             0088*  ; buffer ID to be added to sprites. This is done with the
045F6D             0089*  ; following command:
045F6D             0090*  
045F6D             0091*  ; VDU 23, 27, &26, bufferId;              : REM Add bitmap to the current sprite
045F6D             0092*  
045F6D             0093*  ; This command otherwise works identically to VDU 23, 27, 6.
045F6D             0094*  
045F6D             0095*  ; It should be noted that it is possible to modify the buffer
045F6D             0096*  ; that a bitmap is stored in using the “adjust buffer contents”
045F6D             0097*  ; and “reverse contents” commands (5 and 24 respectively). This
045F6D             0098*  ; can allow you to do things such as changing colours in a bitmap,
045F6D             0099*  ; or flipping an image horizontally or vertically. This will even
045F6D             0100*  ; work on bitmaps that are being used inside sprites.
045F6D             0101*  
045F6D             0102*  ; Using commands targetting a buffer that create new blocks,
045F6D             0103*  ; such as “consolidate” or “split”, will invalidate the bitmap
045F6D             0104*  ; and remove it from use.
045F6D             0105*  
045F6D             0106*  ; Using buffers for sound samples
045F6D             0107*  
045F6D             0108*  ; Much like with bitmaps, it is advisable to send samples over
045F6D             0109*  ; to the VDP in multiple blocks for the same reasons.
045F6D             0110*  
045F6D             0111*  ; In contrast to bitmaps, the sound system can play back samples
045F6D             0112*  ; that are spread over multiple blocks, so there is no need to
045F6D             0113*  ; consolidate buffers. As a result of this, the sample playback
045F6D             0114*  ; system is also more tolerant of modifications being made to
045F6D             0115*  ; the buffer after a sample has been created from it, even if
045F6D             0116*  ; the sample is currently playing. It should be noted that
045F6D             0117*  ; splitting a buffer may result in unexpected behaviour if
045F6D             0118*  ; the sample is currently playing, such as skipping to other
045F6D             0119*  ; parts of the sample.
045F6D             0120*  
045F6D             0121*  ; Once you have a buffer that contains block(s) that are ready
045F6D             0122*  ; to be used for a sound sample, the following command must be
045F6D             0123*  ; used to indicate that a sample should be created from that buffer:
045F6D             0124*  
045F6D             0125*  ; VDU 23, 0, &85, 0, 5, 2, bufferId; format
045F6D             0126*  
045F6D             0127*  ; The format parameter is an 8-bit value that indicates the
045F6D             0128*  ; format of the sample data. The following values are supported:
045F6D             0129*  ; Value 	Description
045F6D             0130*  ; 0 	8-bit signed, 16KHz
045F6D             0131*  ; 1 	8-bit unsigned, 16KHz
045F6D             0132*  
045F6D             0133*  ; Once a sample has been created in this way, the sample can
045F6D             0134*  ; be selected for use on a channel using the following command:
045F6D             0135*  
045F6D             0136*  ; VDU 23, 0, &85, channel, 4, 8, bufferId;
045F6D             0137*  
045F6D             0138*  ; Samples uploaded using the existing “load sample” command
045F6D             0139*  ; (VDU 23, 0, &85, sampleNumber, 5, 0, length; lengthHighByte, <sample data>)
045F6D             0140*  ; are also stored in buffers automatically. A sample number using this system is in
045F6D             0141*  ; the range of -1 to -128, but these are stored in the range 64256-64383 (&FB00-&FB7F).
045F6D             0142*  ; To map a number to a buffer range, you need to negate it, subtract 1, and then add
045F6D             0143*  ; it to 64256. This means sample number -1 is stored in buffer 64256, -2 is stored in
045F6D             0144*  ; buffer 64257, and so on.
045F6D             0145*  ; Command 1: Call a buffer
045F6D             0146*  
045F6D             0147*  ; VDU 23, 0 &A0, bufferId; 1
045F6D             0148*  
045F6D             0149*  ; This command will attempt to execute all of the commands
045F6D             0150*  ; stored in the buffer with the given ID. If the buffer does
045F6D             0151*  ; not exist, or is empty, then this command will do nothing.
045F6D             0152*  
045F6D             0153*  ; Essentially, this command passes the contents of the buffer
045F6D             0154*  ; to the VDP’s VDU command processor system, and executes them
045F6D             0155*  ; as if they were sent directly to the VDP.
045F6D             0156*  
045F6D             0157*  ; As noted against command 0, it is possible to build up a
045F6D             0158*  ; buffer over time by sending across multiple commands to write
045F6D             0159*  ; to the same buffer ID. When calling a buffer with multiple
045F6D             0160*  ; blocks, the blocks are executed in order.
045F6D             0161*  
045F6D             0162*  ; Care should be taken when using this command within a buffer,
045F6D             0163*  ; as it is possible to create an infinite loop. For instance,
045F6D             0164*  ; if a buffer contains a command to call itself, then this will
045F6D             0165*  ; result in an infinite loop. This will cause the VDP to hang,
045F6D             0166*  ; and the only way to recover from this is to reset the VDP.
045F6D             0167*  
045F6D             0168*  ; Using a bufferId of -1 (65535) will cause the current buffer
045F6D             0169*  ; to be executed. This can be useful for creating loops within
045F6D             0170*  ; a buffer. It will be ignored if used outside of a buffered
045F6D             0171*  ; command sequence.
045F6D             0172*  
045F6D             0173*  ; Command 2: Clear a buffer
045F6D             0174*  ; VDU 23, 0 &A0, bufferId; 2
045F6D             0175*  
045F6D             0176*  ; This command will clear the buffer with the given ID. If
045F6D             0177*  ; the buffer does not exist then this command will do nothing.
045F6D             0178*  
045F6D             0179*  ; Please note that this clears out all of the blocks sent to
045F6D             0180*  ; a buffer via command 0, not just the last one. i.e. if you
045F6D             0181*  ; have built up a buffer over time by sending multiple commands
045F6D             0182*  ; to write to the same buffer ID, this command will clear out
045F6D             0183*  ; all of those commands.
045F6D             0184*  
045F6D             0185*  ; Calling this command with a bufferId value of -1 (65535) will
045F6D             0186*  ; clear out all buffers.
045F6D             0187*  
045F6D             0188*  ; Command 3: Create a writeable buffer
045F6D             0189*  ; VDU 23, 0 &A0, bufferId; 3, length;
045F6D             0190*  ; This command will create a new writeable buffer with the given
045F6D             0191*  ; ID. If a buffer with the given ID already exists then this
045F6D             0192*  ; command will do nothing. This command is primarily intended
045F6D             0193*  ; for use to create a buffer that can be used to capture output
045F6D             0194*  ; using the “set output stream” command (see below), or to store
045F6D             0195*  ; data that can be used for other commands.
045F6D             0196*  
045F6D             0197*  ; It is generally quite rare that you will want to use this
045F6D             0198*  ; command. Typically you will instead want to use command 0
045F6D             0199*  ; to write data to a buffer. It is not necessary to use this
045F6D             0200*  ; command before using command 0, and indeed doing so will
045F6D             0201*  ; lead to errors as you will end up with two blocks in the
045F6D             0202*  ; buffer, the first of which will be empty. If you do wish
045F6D             0203*  ; to use this command to create a buffer for data and then
045F6D             0204*  ; write to it, you would need to use operation 2 of command 5,
045F6D             0205*  ; the “set” operation in the “buffer adjust” command, to set a
045F6D             0206*  ; sequence of bytes in the buffer to the data you want to write.
045F6D             0207*  ; This is not recommended, as it is much easier to just use
045F6D             0208*  ; command 0 to write a data block to a buffer.
045F6D             0209*  
045F6D             0210*  ; This new buffer will be a single empty single block upon
045F6D             0211*  ; creation, containing zeros.
045F6D             0212*  
045F6D             0213*  ; The length parameter is a 16-bit integer that specifies
045F6D             0214*  ; the maximum size of the buffer. This is the maximum number
045F6D             0215*  ; of bytes that can be stored in the buffer. If the buffer
045F6D             0216*  ; is full then no more data can be written to it, and subsequent
045F6D             0217*  ; writes will be ignored.
045F6D             0218*  
045F6D             0219*  ; After creating a buffer with this command it is possible to
045F6D             0220*  ; use command 0 to write further blocks to the buffer, however
045F6D             0221*  ; this is probably not advisable.
045F6D             0222*  
045F6D             0223*  ; A bufferId of -1 (65535) and 0 will be ignored, as these
045F6D             0224*  ; values have special meanings for writable buffers. See command 4.
045F6D             0225*  
045F6D             0226*  ; Command 4: Set output stream to a buffer
045F6D             0227*  ; VDU 23, 0 &A0, bufferId; 4
045F6D             0228*  
045F6D             0229*  ; Sets then current output stream to the buffer with the given ID.
045F6D             0230*  ; With two exceptions, noted below, this needs to be a writable
045F6D             0231*  ; buffer created with command 3. If the buffer does not exist,
045F6D             0232*  ; or the first block within the buffer is not writable, then
045F6D             0233*  ; this command will do nothing.
045F6D             0234*  
045F6D             0235*  ; Following this command, any subsequent VDU commands that send
045F6D             0236*  ; response packets will have those packets written to the specified
045F6D             0237*  ; output buffer. This allows the user to capture the response
045F6D             0238*  ; packets from a command sent to the VDP.
045F6D             0239*  
045F6D             0240*  ; By default, the output stream (for the main VDU command processor)
045F6D             0241*  ; is the communications channel from the VDP to MOS running on the
045F6D             0242*  ; eZ80.
045F6D             0243*  
045F6D             0244*  ; Passing a buffer ID of -1 (65535) to this command will
045F6D             0245*  ; remove/detach the output buffer. From that point onwards,
045F6D             0246*  ; any subsequent VDU commands that send response packets will
045F6D             0247*  ; have those responses discarded/ignored.
045F6D             0248*  
045F6D             0249*  ; Passing a buffer ID of 0 to this command will set the output
045F6D             0250*  ; buffer back to its original value for the current command stream.
045F6D             0251*  ; Typically that will be the communications channel from the VDP to
045F6D             0252*  ; MOS running on the eZ80, but this may not be the case if a nested
045F6D             0253*  ; call has been made.
045F6D             0254*  
045F6D             0255*  ; When used inside a buffered command sequence, this command will
045F6D             0256*  ; only affect the output stream for that sequence of commands, and
045F6D             0257*  ; any other buffered command sequences that are called from within
045F6D             0258*  ; that sequence. Once the buffered command sequence has completed,
045F6D             0259*  ; the output stream will effectively be reset to its original value.
045F6D             0260*  
045F6D             0261*  ; It is strongly recommended to only use this command from within a
045F6D             0262*  ; buffered command sequence. Whilst it is possible to use this
045F6D             0263*  ; command from within a normal VDU command sequence, it is not
045F6D             0264*  ; recommended as it may cause unexpected behaviour. If you do use
045F6D             0265*  ; it in that context, it is very important to remember to restore
045F6D             0266*  ; the original output channel using VDU 23, 0, &A0, 0; 4. (In the
045F6D             0267*  ; future, this command may be disabled from being used outside of
045F6D             0268*  ; a buffered command sequence.)
045F6D             0269*  
045F6D             0270*  ; At present, writable buffers can only be written to until the end
045F6D             0271*  ; of the buffer has been reached; once that happens no more data
045F6D             0272*  ; will be written to the buffer. It is not currently possible to
045F6D             0273*  ; “rewind” an output stream. It is therefore advisable to ensure
045F6D             0274*  ; that the buffer is large enough to capture all of the data that
045F6D             0275*  ; is expected to be written to it. The only current way to “rewind”
045F6D             0276*  ; an output stream would be to clear the buffer and create a new
045F6D             0277*  ; one, and then call set output stream again with the newly created
045F6D             0278*  ; buffer.
045F6D             0279*  
045F6D             0280*  ; Command 5: Adjust buffer contents
045F6D             0281*  ; VDU 23, 0, &A0, bufferId; 5, operation, offset; [count;] <operand>, [arguments]
045F6D             0282*  
045F6D             0283*  ; This command will adjust the contents of a buffer, at a given
045F6D             0284*  ; offset. The exact nature of the adjustment will depend on the
045F6D             0285*  ; operation used.
045F6D             0286*  
045F6D             0287*  ; Passing a bufferId of -1 (65535) to this command will adjust
045F6D             0288*  ; the contents of the current buffer. This will only work if this
045F6D             0289*  ; command is used within a buffered command sequence, otherwise the
045F6D             0290*  ; command will not do anything.
045F6D             0291*  
045F6D             0292*  ; The basic set of adjustment operations are as follows:
045F6D             0293*  ; Operation 	Description
045F6D             0294*  ; 0 	NOT
045F6D             0295*  ; 1 	Negate
045F6D             0296*  ; 2 	Set value
045F6D             0297*  ; 3 	Add
045F6D             0298*  ; 4 	Add with carry
045F6D             0299*  ; 5 	AND
045F6D             0300*  ; 6 	OR
045F6D             0301*  ; 7 	XOR
045F6D             0302*  
045F6D             0303*  ; All of these operations will modify a byte found at the given
045F6D             0304*  ; offset in the buffer. The only exception to that is the “Add with
045F6D             0305*  ; carry” operation, which will also store the “carry” value in the
045F6D             0306*  ; byte at the next offset. With the exception of NOT and Negate,
045F6D             0307*  ; each command requires an operand value to be specified.
045F6D             0308*  
045F6D             0309*  ; To flip the bits of a byte at offset 12 in buffer 3, you would
045F6D             0310*  ; need to use the NOT operation, and so the following command would
045F6D             0311*  ; be used:
045F6D             0312*  
045F6D             0313*  ; VDU 23, 0, &A0, 3; 5, 0, 12;
045F6D             0314*  
045F6D             0315*  ; To add 42 to the byte at offset 12 in buffer 3, you would need
045F6D             0316*  ; to use the Add operation, and so the following command would be
045F6D             0317*  ; used:
045F6D             0318*  
045F6D             0319*  ; VDU 23, 0, &A0, 3; 5, 3, 12; 42
045F6D             0320*  
045F6D             0321*  ; When using add with carry, the carry value is stored in the byte
045F6D             0322*  ; at the next offset. So to add 42 to the byte at offset 12 in
045F6D             0323*  ; buffer 3, and store the carry value in the byte at offset 13,
045F6D             0324*  ; you would need to use the Add with carry operation, and so the
045F6D             0325*  ; following command would be used:
045F6D             0326*  
045F6D             0327*  ; VDU 23, 0, &A0, 3; 5, 4, 12; 42
045F6D             0328*  
045F6D             0329*  ; Advanced operations
045F6D             0330*  
045F6D             0331*  ; Whilst these operations are useful, they are not particularly
045F6D             0332*  ; powerful as they only operate one one byte at a time, with a
045F6D             0333*  ; fixed operand value, and potentially cannot reach all bytes in
045F6D             0334*  ; a buffer. To address this, the API supports a number of advanced
045F6D             0335*  ; operations.
045F6D             0336*  
045F6D             0337*  ; The operation value used is an 8-bit value that can have bits
045F6D             0338*  ; set to modify the behaviour of the operation. The following bits
045F6D             0339*  ; are defined:
045F6D             0340*  ; Bit 	Description
045F6D             0341*  ; &10 	Use “advanced” offsets
045F6D             0342*  ; &20 	Operand is a buffer-fetched value (buffer ID and an offset)
045F6D             0343*  ; &40 	Multiple target values should be adjusted
045F6D             0344*  ; &80 	Multiple operand values should be used
045F6D             0345*  
045F6D             0346*  ; These bits can be combined together to modify the behaviour of
045F6D             0347*  ; the operation.
045F6D             0348*  
045F6D             0349*  ; Fundamentally, this command adjusts values of a buffer at a given
045F6D             0350*  ; offset one byte at a time. When either of the “multiple” variants
045F6D             0351*  ; are used, a 16-bit count must be provided to indicate how many
045F6D             0352*  ; bytes should be altered.
045F6D             0353*  
045F6D             0354*  ; Advanced offsets are sent as a 24-bit value in little-endian
045F6D             0355*  ; order, which can allow for buffers that are larger than 64kb
045F6D             0356*  ; to be adjusted. If the top-bit of this 24-bit value is set, then
045F6D             0357*  ; the 16-bit value immediately following the offset is used as a
045F6D             0358*  ; block index number, and the remaining 23-bits of the offset value
045F6D             0359*  ; are used as an offset within that block. When the “advanced”
045F6D             0360*  ; offset mode bit has been set then all offsets associated with
045F6D             0361*  ; this command must be sent as advanced offsets.
045F6D             0362*  
045F6D             0363*  ; The “buffer-fetched value” mode allows for the operand value to
045F6D             0364*  ; be fetched from a buffer. The operand sent as part of the
045F6D             0365*  ; command in this case is a pair of 16-bit values giving the
045F6D             0366*  ; buffer ID and offset to indicate where the actual operand value
045F6D             0367*  ; should be fetched from. An operand buffer ID of -1 (65535) will
045F6D             0368*  ; be interpretted as meaning “this buffer”, and thus can only be
045F6D             0369*  ; used inside a buffered command sequence. If the advanced offset
045F6D             0370*  ; mode is used, then the operand value is an advanced offset value.
045F6D             0371*  
045F6D             0372*  ; The “multiple target values” mode allows for multiple bytes to
045F6D             0373*  ; be adjusted at once. When this mode is used, the count value
045F6D             0374*  ; must be provided to indicate how many bytes should be adjusted.
045F6D             0375*  ; Unless the “multiple operand values” mode is also used, the
045F6D             0376*  ; operand value is used for all bytes adjusted.
045F6D             0377*  
045F6D             0378*  ; The “multiple operand values” mode allows for multiple operand
045F6D             0379*  ; values to be used. When this mode is used, the count value must
045F6D             0380*  ; be provided to indicate how many operand values should be used.
045F6D             0381*  ; This can allow, for instance, to add together several bytes in a
045F6D             0382*  ; buffer. When this mode is used in conjunction with the “multiple
045F6D             0383*  ; target values” mode, the number of operand values must match the
045F6D             0384*  ; number of target values, and the operation happens one byte at a
045F6D             0385*  ; time.
045F6D             0386*  
045F6D             0387*  ; Some examples of advanced operations are as follows:
045F6D             0388*  
045F6D             0389*  ; Flip the bits of 7 bytes in buffer 3 starting at offset 12:
045F6D             0390*  
045F6D             0391*  ; VDU 23, 0, &A0, 3; 5, &40, 12; 7;
045F6D             0392*  
045F6D             0393*  ; This uses operation 0 (NOT) with the “multiple target values”
045F6D             0394*  ; modifier (&40).
045F6D             0395*  
045F6D             0396*  ; Add 42 to each of the 7 bytes in buffer 3 starting at offset 12:
045F6D             0397*  
045F6D             0398*  ; VDU 23, 0, &A0, 3; 5, &43, 12; 7; 42
045F6D             0399*  
045F6D             0400*  ; Set the byte at offset 12 in the fourth block of buffer 3 to 42:
045F6D             0401*  
045F6D             0402*  ; VDU 23, 0, &A0, 3; 5, &12, 12; &80, 4; 42
045F6D             0403*  
045F6D             0404*  ; This is using operation 2 (Set) with the “advanced offsets”
045F6D             0405*  ; modifier (&10). As BBC BASIC doesn’t natively understand how
045F6D             0406*  ; to send 24-bit values it is sent as the 16-bit value 12; followed
045F6D             0407*  ; by a byte with its top bit set &80 to complete the 24-bit offset
045F6D             0408*  ; in little-endian order. As the top bit of the offset is set, this
045F6D             0409*  ; indicates that the next 16-bit value will be a block index, 4;.
045F6D             0410*  ; Finally the value to write is sent, 42.
045F6D             0411*  
045F6D             0412*  ; An operation like this could be used to set the position as part
045F6D             0413*  ; of a draw command.
045F6D             0414*  
045F6D             0415*  ; Set the value in buffer 3 at offset 12 to the sum of the five
045F6D             0416*  ; values 1, 2, 3, 4, 5:
045F6D             0417*  
045F6D             0418*  ; VDU 23, 0, &A0, 3; 5, 2, 12; 0  : REM clear out the value at
045F6D             0419*  ; offset 12 (set it to 0)
045F6D             0420*  ; VDU 23, 0, &A0, 3; 5, &83, 12; 5; 1, 2, 3, 4, 5
045F6D             0421*  
045F6D             0422*  ; AND together 7 bytes in buffer 3 starting at offset 12 with the
045F6D             0423*  ; 7 bytes in buffer 4 starting at offset 42:
045F6D             0424*  
045F6D             0425*  ; VDU 23, 0, &A0, 3; 5, &E5, 12; 7; 4; 42;
045F6D             0426*  
045F6D             0427*  ; As we are working on a little-endian system, integers longer
045F6D             0428*  ; than one byte are sent with their least significant byte first.
045F6D             0429*  ; This means that the add with carry operation can be used to add
045F6D             0430*  ; together integers of any size, so long as they are the same size.
045F6D             0431*  ; To do this, both the “multiple target values” and “multiple
045F6D             0432*  ; operand values” modes must be used.
045F6D             0433*  
045F6D             0434*  ; The following commands will add together a 16-bit, 24-bit,
045F6D             0435*  ; 32-bit, and 40-bit integers, all targetting the value stored
045F6D             0436*  ; in buffer 3 starting at offset 12, and all using the operand
045F6D             0437*  ; value of 42:
045F6D             0438*  
045F6D             0439*  ; VDU 23, 0, &A0, 3; 5, &C4, 12; 2; 42;  : REM 2 bytes; a 16-bit integer
045F6D             0440*  ; VDU 23, 0, &A0, 3; 5, &C4, 12; 3; 42; 0  : REM 3 bytes; a 24-bit integer
045F6D             0441*  ; VDU 23, 0, &A0, 3; 5, &C4, 12; 4; 42; 0;  : REM 4 bytes; a 32-bit integer
045F6D             0442*  ; VDU 23, 0, &A0, 3; 5, &C4, 12; 5; 42; 0; 0  : REM 5 bytes; a 40-bit integer
045F6D             0443*  
045F6D             0444*  ; Take note of how the operand value is padded out with zeros
045F6D             0445*  ; to match the size of the target value. 42; is used as a base
045F6D             0446*  ; to send a 16-bit value, with zeros added of either 8-bit or
045F6D             0447*  ; 16-bits to pad it out to the required size. The “carry” value
045F6D             0448*  ; will be stored at the next offset in the target buffer after
045F6D             0449*  ; the complete target value. So for a 16-bit value, the carry
045F6D             0450*  ; will be stored at offset 14, for a 24-bit value it will be stored
045F6D             0451*  ; at offset 15, and so on.
045F6D             0452*  
045F6D             0453*  ; Command 6: Conditionally call a buffer
045F6D             0454*  
045F6D             0455*  ; VDU 23, 0, &A0, bufferId; 6, operation, checkBufferId; checkOffset; [arguments]
045F6D             0456*  
045F6D             0457*  ; This command will conditionally call a buffer if the condition
045F6D             0458*  ; operation passes. This command works in a similar manner to the
045F6D             0459*  ; “Adjust buffer contents” command.
045F6D             0460*  
045F6D             0461*  ; With this command a buffer ID of 65535 (-1) is always
045F6D             0462*  ; interpretted as “current buffer”, and so can only be used
045F6D             0463*  ; within a buffered command sequence. If used outside of a
045F6D             0464*  ; buffered command sequence then this command will do nothing.
045F6D             0465*  
045F6D             0466*  ; The basic set of condition operations are as follows:
045F6D             0467*  ; Operation 	Description
045F6D             0468*  ; 0 	Exists (value is non-zero)
045F6D             0469*  ; 1 	Not exists (value is zero)
045F6D             0470*  ; 2 	Equal
045F6D             0471*  ; 3 	Not equal
045F6D             0472*  ; 4 	Less than
045F6D             0473*  ; 5 	Greater than
045F6D             0474*  ; 6 	Less than or equal
045F6D             0475*  ; 7 	Greater than or equal
045F6D             0476*  ; 8 	AND
045F6D             0477*  ; 9 	OR
045F6D             0478*  
045F6D             0479*  ; The value that is being checked is fetched from the specified
045F6D             0480*  ; check buffer ID and offset. With the exception of “Exists” and
045F6D             0481*  ; “Not exists”, each command requires an operand value to be
045F6D             0482*  ; specified to check against.
045F6D             0483*  
045F6D             0484*  ; The operation value used is an 8-bit value that can have bits
045F6D             0485*  ; set to modify the behaviour of the operation. The following bits
045F6D             0486*  ; are defined:
045F6D             0487*  ; Bit value 	Description
045F6D             0488*  ; &10 	Use advanced offsets
045F6D             0489*  ; &20 	Operand is a buffer-fetched value (buffer ID and an offset)
045F6D             0490*  
045F6D             0491*  ; These modifiers can be combined together to modify the behaviour
045F6D             0492*  ; of the operation.
045F6D             0493*  
045F6D             0494*  ; At this time, unlike with the “adjust” command, multiple target
045F6D             0495*  ; values and multiple operand values are not supported. All
045F6D             0496*  ; comparisons are therefore only conducted on single 8-bit values.
045F6D             0497*  ; (If comparisons of 16-bit values are required, multiple calls
045F6D             0498*  ; can be combined.) Support for them may be added in the future.
045F6D             0499*  
045F6D             0500*  ; The AND and OR operations are logical operations, and so the
045F6D             0501*  ; operand value is used as a boolean value. Any non-zero value is
045F6D             0502*  ; considered to be true, and zero is considered to be false. These
045F6D             0503*  ; operations therefore are most useful when used with buffer-fetched
045F6D             0504*  ; operand values (operations &28, &29, &38 and &39).
045F6D             0505*  
045F6D             0506*  ; Some examples of condition operations are as follows:
045F6D             0507*  
045F6D             0508*  ; Call buffer 7 if the value in buffer 12 at offset 5 exists
045F6D             0509*  ; (is non-zero):
045F6D             0510*  
045F6D             0511*  ; VDU 23, 0, &A0, 7; 6, 0, 12; 5;
045F6D             0512*  
045F6D             0513*  ; Call buffer 8 if the value in buffer 12 at offset 5 does not
045F6D             0514*  ; exist (is zero):
045F6D             0515*  
045F6D             0516*  ; VDU 23, 0, &A0, 8; 6, 1, 12; 5;
045F6D             0517*  
045F6D             0518*  ; Combining the above two examples is effectively equivalent to
045F6D             0519*  ; “if the value exists, call buffer 7, otherwise call buffer 8”:
045F6D             0520*  
045F6D             0521*  ; VDU 23, 0, &A0, 7; 6, 0, 12; 5;
045F6D             0522*  ; VDU 23, 0, &A0, 8; 6, 1, 12; 5;
045F6D             0523*  
045F6D             0524*  ; Call buffer 3 if the value in buffer 4 at offset 12 is equal to 42:
045F6D             0525*  
045F6D             0526*  ; VDU 23, 0, &A0, 3; 6, 2, 4; 12; 42
045F6D             0527*  
045F6D             0528*  ; Call buffer 5 if the value in buffer 2 at offset 7 is less than
045F6D             0529*  ; the value in buffer 2 at offset 8:
045F6D             0530*  
045F6D             0531*  ; VDU 23, 0, &A0, 5; 6, &24, 2; 7; 2; 8;
045F6D             0532*  
045F6D             0533*  ; Command 7: Jump to a buffer
045F6D             0534*  
045F6D             0535*  ; VDU 23, 0, &A0, bufferId; 7
045F6D             0536*  
045F6D             0537*  ; This command will jump to the buffer with the given ID. If
045F6D             0538*  ; the buffer does not exist, or is empty, then this command will
045F6D             0539*  ; do nothing.
045F6D             0540*  
045F6D             0541*  ; This essentially works the same as the call command (command 1),
045F6D             0542*  ;  except that it does not return to the caller. This command is
045F6D             0543*  ;  therefore useful for creating loops.
045F6D             0544*  
045F6D             0545*  ; Using this command to jump to buffer 65535 (buffer ID -1) is
045F6D             0546*  ; treated as a “jump to end of current buffer”. This will return
045F6D             0547*  ; execution to the caller, and can be useful for exiting a loop.
045F6D             0548*  
045F6D             0549*  ; ## Command 8: Conditional Jump to a buffer
045F6D             0550*  
045F6D             0551*  ; VDU 23, 0, &A0, bufferId; 8, operation, checkBufferId; checkOffset; [arguments]
045F6D             0552*  
045F6D             0553*  ; This command operates in a similar manner to the “Conditionally
045F6D             0554*  ; call a buffer” command (command 6), except that it will jump to
045F6D             0555*  ; the buffer if the condition operation passes.
045F6D             0556*  
045F6D             0557*  ; As with the “Jump to a buffer” command (command 7), a jump to
045F6D             0558*  ; buffer 65535 is treated as a “jump to end of current buffer”.
045F6D             0559*  ; Command 9: Jump to an offset in a buffer
045F6D             0560*  
045F6D             0561*  ; VDU 23, 0, &A0, bufferId; 9, offset; offsetHighByte, [blockNumber;]
045F6D             0562*  
045F6D             0563*  ; This command will jump to the given offset in the buffer with the
045F6D             0564*  ; given ID. If the buffer does not exist, or is empty, then this
045F6D             0565*  ; command will do nothing.
045F6D             0566*  
045F6D             0567*  ; The offset in this command is always an “advanced” offset, given
045F6D             0568*  ; as a 24-bit value in little-endian order. As with other uses of
045F6D             0569*  ; advanced offsets, if the top-bit is set in the high byte of the
045F6D             0570*  ; offset value, a block number must also be provided.
045F6D             0571*  
045F6D             0572*  ; When jumping to an offset, using buffer ID 65535 is treated as
045F6D             0573*  ; meaning “jump within current buffer”. This can be useful for
045F6D             0574*  ; creating loops within a buffer, or when building up command
045F6D             0575*  ; sequences that may be copied across multiple buffers.
045F6D             0576*  
045F6D             0577*  ; Jumping to an offset that is beyond the end of the buffer is
045F6D             0578*  ; equivalent to jumping to the end of the buffer.
045F6D             0579*  ; Command 10: Conditional jump to an offset in a buffer
045F6D             0580*  
045F6D             0581*  ; VDU 23, 0, &A0, bufferId; 10, offset; offsetHighByte, [blockNumber;] [arguments]
045F6D             0582*  
045F6D             0583*  ; A conditional jump with an offset works in a similar manner to
045F6D             0584*  ; the “Conditional call a buffer” command (command 6), except that
045F6D             0585*  ; it will jump to the given offset in the buffer if the condition
045F6D             0586*  ; operation passes.
045F6D             0587*  
045F6D             0588*  ; As with the “Jump to an offset in a buffer” command (command 9),
045F6D             0589*  ; the offset in this command is always an “advanced” offset, given
045F6D             0590*  ; as a 24-bit value in little-endian order, and the usual advanced
045F6D             0591*  ; offset rules apply. And similarly, using buffer ID 65535 is
045F6D             0592*  ; treated as meaning “jump within current buffer”.
045F6D             0593*  ; Command 11: Call buffer with an offset
045F6D             0594*  
045F6D             0595*  ; VDU 23, 0, &A0, bufferId; 11, offset; offsetHighByte, [blockNumber;]
045F6D             0596*  
045F6D             0597*  ; Works just like “Call a buffer” (command 1), except that it also
045F6D             0598*  ; accepts an advanced offset.
045F6D             0599*  
045F6D             0600*  ; Command 12: Conditional call buffer with an offset
045F6D             0601*  
045F6D             0602*  ; VDU 23, 0, &A0, bufferId; 12, offset; offsetHighByte, [blockNumber;] [arguments]
045F6D             0603*  
045F6D             0604*  ; Works just like the “Conditional call a buffer” command
045F6D             0605*  ; (command 6), except that it also accepts an advanced offset.
045F6D             0606*  
045F6D             0607*  ; Command 13: Copy blocks from multiple buffers into a single buffer
045F6D             0608*  
045F6D             0609*  ; VDU 23, 0, &A0, targetBufferId; 13, sourceBufferId1; sourceBufferId2; ... 65535;
045F6D             0610*  
045F6D             0611*  ; This command will copy the contents of multiple buffers into a
045F6D             0612*  ; single buffer. The buffers to copy from are specified as a list
045F6D             0613*  ; of buffer IDs, terminated by a buffer ID of -1 (65535). The
045F6D             0614*  ; buffers are copied in the order they are specified.
045F6D             0615*  
045F6D             0616*  ; This is a block-wise copy, so the blocks from the source buffers
045F6D             0617*  ; are copied into the target buffer. The blocks are copied in the
045F6D             0618*  ; order they are found in the source buffers.
045F6D             0619*  
045F6D             0620*  ; The target buffer will be overwritten with the contents of the
045F6D             0621*  ; source buffers. This will not be done however until after all the
045F6D             0622*  ; data has been gathered and copied. The target buffer can therefore
045F6D             0623*  ; included in the list of the source buffers.
045F6D             0624*  
045F6D             0625*  ; If a source buffer that does not exist is specified, or a source
045F6D             0626*  ; buffer that is empty is specified, then that buffer will be ignored. If no source buffers are specified, or all of the source buffers are empty, then the target buffer will be cleared out.
045F6D             0627*  
045F6D             0628*  ; The list of source buffers can contain repeated buffer IDs. If a
045F6D             0629*  ; buffer ID is repeated, then the blocks from that buffer will be
045F6D             0630*  ; copied multiple times into the target buffer.
045F6D             0631*  
045F6D             0632*  ; If there is insufficient memory available on the VDP to complete
045F6D             0633*  ; this command then it will fail, and the target buffer will be
045F6D             0634*  ; left unchanged.
045F6D             0635*  
045F6D             0636*  
045F6D             0637*  ; Command 14: Consolidate blocks in a buffer
045F6D             0638*  
045F6D             0639*  ; VDU 23, 0, &A0, bufferId; 14
045F6D             0640*  
045F6D             0641*  ; Takes all the blocks in a buffer and consolidates them into a
045F6D             0642*  ; single block. This is useful for bitmaps, as it allows for a
045F6D             0643*  ; bitmap to be built up over time in multiple blocks, and then
045F6D             0644*  ; consolidated into a single block for use as a bitmap.
045F6D             0645*  
045F6D             0646*  ; If there is insufficient memory available on the VDP to complete
045F6D             0647*  ; this command then it will fail, and the buffer will be left
045F6D             0648*  ; unchanged.
045F6D             0649*  
045F6D             0650*  ; Command 15: Split a buffer into multiple blocks
045F6D             0651*  
045F6D             0652*  ; VDU 23, 0, &A0, bufferId; 15, blockSize;
045F6D             0653*  
045F6D             0654*  ; Splits a buffer into multiple blocks. The blockSize parameter
045F6D             0655*  ; is a 16-bit integer that specifies the target size of each block.
045F6D             0656*  ; If the source data is not a multiple of the block size then the
045F6D             0657*  ; last block will be smaller than the specified block size.
045F6D             0658*  
045F6D             0659*  ; If this command is used on a buffer that is already split into
045F6D             0660*  ; multiple blocks, then the blocks will be consolidated first,
045F6D             0661*  ; and then re-split into the new block size.
045F6D             0662*  
045F6D             0663*  ; If there is insufficient memory available on the VDP to complete
045F6D             0664*  ; this command then it will fail, and the buffer will be left
045F6D             0665*  ; unchanged.
045F6D             0666*  ; Command 16: Split a buffer into multiple blocks and spread across
045F6D             0667*  ; multiple buffers
045F6D             0668*  
045F6D             0669*  ; VDU 23, 0, &A0, bufferId; 16, blockSize; [targetBufferId1;] [targetBufferId2;] ... 65535;
045F6D             0670*  
045F6D             0671*  ; Splits a buffer into multiple blocks, as per command 15, but
045F6D             0672*  ; then spreads the resultant blocks across the target buffers.
045F6D             0673*  ; The target buffers are specified as a list of buffer IDs,
045F6D             0674*  ; terminated by a buffer ID of -1 (65535).
045F6D             0675*  
045F6D             0676*  ; The blocks are spread across the target buffers in the order
045F6D             0677*  ; they are specified, and the spread will loop around the buffers
045F6D             0678*  ; until all the blocks have been distributed. The target buffers
045F6D             0679*  ; will be cleared out before the blocks are spread across them.
045F6D             0680*  
045F6D             0681*  ; What this means is that if the source buffer is, let’s say,
045F6D             0682*  ; 100 bytes in size and we split using a block size of 10 bytes
045F6D             0683*  ; then we will end up with 10 blocks. If we then spread those
045F6D             0684*  ; blocks across 3 target buffers, then the first buffer will
045F6D             0685*  ; contain blocks 1, 4, 7 and 10, the second buffer will contain
045F6D             0686*  ; blocks 2, 5 and 8, and the third buffer will contain
045F6D             0687*  ; blocks 3, 6 and 9.
045F6D             0688*  
045F6D             0689*  ; This command attempts to ensure that, in the event of
045F6D             0690*  ; insufficient memory being available on the VDP to complete
045F6D             0691*  ; the command, it will leave the targets as they were before
045F6D             0692*  ; the command was executed. However this may not always be
045F6D             0693*  ; possible. The first step of this command is to consolidate
045F6D             0694*  ; the source buffer into a single block, and this may fail from
045F6D             0695*  ; insufficient memory. If that happens then all the buffers will
045F6D             0696*  ; be left as they were. After this however the target buffers
045F6D             0697*  ; will be cleared. If there is insufficient memory to successfully
045F6D             0698*  ; split the buffer into multiple blocks then the call will exit,
045F6D             0699*  ; and the target buffers will be left empty.
045F6D             0700*  ; Command 17: Split a buffer and spread across blocks, starting
045F6D             0701*  ; at target buffer ID
045F6D             0702*  
045F6D             0703*  ; VDU 23, 0, &A0, bufferId; 17, blockSize; targetBufferId;
045F6D             0704*  
045F6D             0705*  ; As per the above two commands, this will split a buffer into
045F6D             0706*  ; multiple blocks. It will then spread the blocks across buffers
045F6D             0707*  ; starting at the target buffer ID, incrementing the target buffer
045F6D             0708*  ; ID until all the blocks have been distributed.
045F6D             0709*  
045F6D             0710*  ; Target blocks will be cleared before a block is stored in them.
045F6D             0711*  ; Each target will contain a single block. The exception to this
045F6D             0712*  ; is if the target buffer ID reaches 65534, as it is not possible
045F6D             0713*  ; to store a block in buffer 65535. In this case, multiple blocks
045F6D             0714*  ; will be placed into buffer 65534.
045F6D             0715*  
045F6D             0716*  ; With this command if there is insufficient memory available on
045F6D             0717*  ; the VDP to complete the command then it will fail, and the target
045F6D             0718*  ; buffers will be left unchanged.
045F6D             0719*  
045F6D             0720*  ; Command 18: Split a buffer into blocks by width
045F6D             0721*  
045F6D             0722*  ; VDU 23, 0, &A0, bufferId; 18, width; blockCount;
045F6D             0723*  
045F6D             0724*  ; This command splits a buffer into a given number of blocks by
045F6D             0725*  ; first of all splitting the buffer into blocks of a given width
045F6D             0726*  ; (number of bytes), and then consolidating those blocks into the
045F6D             0727*  ; given number of blocks.
045F6D             0728*  
045F6D             0729*  ; This is useful for splitting a bitmap into a number of separate
045F6D             0730*  ; columns, which can then be manipulated individually. This can be
045F6D             0731*  ; useful for dealing with sprite sheets.
045F6D             0732*  ; Command 19: Split by width into blocks and spread across target
045F6D             0733*  ; buffers
045F6D             0734*  
045F6D             0735*  ; VDU 23, 0, &A0, bufferId; 19, width; [targetBufferId1;] [targetBufferId2;] ... 65535;
045F6D             0736*  
045F6D             0737*  ; This command essentially operates the same as command 18, but the
045F6D             0738*  ; block count is determined by the number of target buffers specified. The blocks are spread across the target buffers in the order they are specified, with one block placed in each target.
045F6D             0739*  
045F6D             0740*  ; Command 20: Split by width into blocks and spread across blocks
045F6D             0741*  ; starting at target buffer ID
045F6D             0742*  
045F6D             0743*  ; VDU 23, 0, &A0, bufferId; 20, width; blockCount; targetBufferId;
045F6D             0744*  
045F6D             0745*  ; This command essentially operates the same as command 18, but
045F6D             0746*  ; the generated blocks are spread across blocks starting at the
045F6D             0747*  ; target buffer ID, as per command 17.
045F6D             0748*  
045F6D             0749*  ; Command 21: Spread blocks from a buffer across multiple target
045F6D             0750*  ; buffers
045F6D             0751*  
045F6D             0752*  ; VDU 23, 0, &A0, bufferId; 21, [targetBufferId1;] [targetBufferId2;] ... 65535;
045F6D             0753*  
045F6D             0754*  ; Spreads the blocks from a buffer across multiple target buffers.
045F6D             0755*  ; The target buffers are specified as a list of buffer IDs,
045F6D             0756*  ; terminated by a buffer ID of -1 (65535). The blocks are spread
045F6D             0757*  ; across the target buffers in the order they are specified, and
045F6D             0758*  ; the spread will loop around the buffers until all the blocks have
045F6D             0759*  ; been distributed.
045F6D             0760*  
045F6D             0761*  ; It should be noted that this command does not copy the blocks,
045F6D             0762*  ; and nor does it move them. Unless the source buffer has been
045F6D             0763*  ; included in the list of targets, it will remain completely
045F6D             0764*  ; intact. The blocks distributed across the target buffers will
045F6D             0765*  ; point to the same memory as the blocks in the source buffer.
045F6D             0766*  ; Operations to modify data in the source buffer will also modify
045F6D             0767*  ; the data in the target buffers. Clearing the source buffer
045F6D             0768*  ; however will not clear the target buffers.
045F6D             0769*  
045F6D             0770*  ; Command 22: Spread blocks from a buffer across blocks starting
045F6D             0771*  ; at target buffer ID
045F6D             0772*  
045F6D             0773*  ; VDU 23, 0, &A0, bufferId; 22, targetBufferId;
045F6D             0774*  
045F6D             0775*  ; Spreads the blocks from a buffer across blocks starting at
045F6D             0776*  ; the target buffer ID.
045F6D             0777*  
045F6D             0778*  ; This essentially works the same as command 21, and the same
045F6D             0779*  ; notes about copying and moving blocks apply. Blocks are spread
045F6D             0780*  ; in the same manner as commands 17 and 20.
045F6D             0781*  
045F6D             0782*  ; Command 23: Reverse the order of blocks in a buffer
045F6D             0783*  
045F6D             0784*  ; VDU 23, 0, &A0, bufferId; 23
045F6D             0785*  
045F6D             0786*  ; Reverses the order of the blocks in a buffer.
045F6D             0787*  ; Command 24: Reverse the order of data of blocks within a buffer
045F6D             0788*  
045F6D             0789*  ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
045F6D             0790*  
045F6D             0791*  ; Reverses the order of the data within the blocks of a buffer.
045F6D             0792*  ; The options parameter is an 8-bit value that can have bits set
045F6D             0793*  ; to modify the behaviour of the operation. The following bits
045F6D             0794*  ; are defined:
045F6D             0795*  ; Bit value 	Description
045F6D             0796*  ; 1 	Values are 16-bits in size
045F6D             0797*  ; 2 	Values are 32-bits in size
045F6D             0798*  ; 3 (1+2) 	If both value size bits are set, then the value size is sent as a 16-bit value
045F6D             0799*  ; 4 	Reverse data of the value size within chunk of data of the specified size, sent as a 16-bit value
045F6D             0800*  ; 8 	Reverse blocks
045F6D             0801*  
045F6D             0802*  ; These modifiers can be combined together to modify the behaviour
045F6D             0803*  ; of the operation.
045F6D             0804*  
045F6D             0805*  ; If no value size is set in the options (i.e. the value of the
045F6D             0806*  ; bottom two bits of the options is zero) then the value size is
045F6D             0807*  ; assumed to be 8-bits.
045F6D             0808*  
045F6D             0809*  ; It is probably easiest to understand what this operation is
045F6D             0810*  ; capable of by going through some examples of how it can be used
045F6D             0811*  ; to manipulate bitmaps. The VDP supports two different formats
045F6D             0812*  ; of color bitmap, either RGBA8888 which uses 4-bytes per pixel,
045F6D             0813*  ; i.e. 32-bit values, or RGBA2222 which uses a single byte per
045F6D             0814*  ; pixel.
045F6D             0815*  
045F6D             0816*  ; The simplest example is rotating an RGBA2222 bitmap by 180
045F6D             0817*  ; degrees, which can be done by just reversing the order of
045F6D             0818*  ; bytes in the buffer:
045F6D             0819*  
045F6D             0820*  ; VDU 23, 0, &A0, bufferId; 24, 0
045F6D             0821*  
045F6D             0822*  ; Rotating an RGBA8888 bitmap by 180 degrees is in principle a
045F6D             0823*  ; little more complex, as each pixel is made up of 4 bytes.
045F6D             0824*  ; However with this command it is still a simple operation, as
045F6D             0825*  ; we can just reverse the order of the 32-bit values that make
045F6D             0826*  ; up the bitmap by using an options value of 2:
045F6D             0827*  
045F6D             0828*  ; VDU 23, 0, &A0, bufferId; 24, 2
045F6D             0829*  
045F6D             0830*  ; Mirroring a bitmap around the x-axis is a matter of reversing
045F6D             0831*  ; the order of rows of pixels. To do this we can set a custom
045F6D             0832*  ; value size that corresponds to our bitmap width. For an RGBA2222
045F6D             0833*  ; bitmap we can just set a custom value size to our bitmap width:
045F6D             0834*  
045F6D             0835*  ; VDU 23, 0, &A0, bufferId; 24, 3, width
045F6D             0836*  
045F6D             0837*  ; As an RGBA8888 bitmap uses 4 bytes per pixel we need to multiply
045F6D             0838*  ; our width by 4:
045F6D             0839*  
045F6D             0840*  ; VDU 23, 0, &A0, bufferId; 24, 3, width * 4
045F6D             0841*  
045F6D             0842*  ; To mirror a bitmap around the y-axis, we need to reverse the
045F6D             0843*  ; order of pixels within each row. For an RGBA2222 bitmap we can
045F6D             0844*  ; just set a custom chunk size to our bitmap width:
045F6D             0845*  
045F6D             0846*  ; VDU 23, 0, &A0, bufferId; 24, 4, width
045F6D             0847*  
045F6D             0848*  ; For an RGBA8888 bitmap we need to set our options to indicate
045F6D             0849*  ; 32-bit values as well as a custom chunk size:
045F6D             0850*  
045F6D             0851*  ; VDU 23, 0, &A0, bufferId; 24, 6, width * 4
045F6D             0852*  
045F6D             0853*  ; Command 25: Copy blocks from multiple buffers by reference
045F6D             0854*  
045F6D             0855*  ; VDU 23, 0, &A0, targetBufferId; 25, sourceBufferId1; sourceBufferId2; ...; 65535;
045F6D             0856*  
045F6D             0857*  ; This command is essentially a version of command 13 that copies
045F6D             0858*  ; blocks by reference rather than by value. The parameters for
045F6D             0859*  ; this command are the same as for command 13, and the same rules
045F6D             0860*  ; apply.
045F6D             0861*  
045F6D             0862*  ; If the target buffer is included in the list of source buffers
045F6D             0863*  ; then it will be skipped to prevent a reference loop.
045F6D             0864*  
045F6D             0865*  ; Copying by reference means that the blocks in the target buffer
045F6D             0866*  ; will point to the same memory as the blocks in the source
045F6D             0867*  ; buffers. Operations to modify data blocks in the source buffers
045F6D             0868*  ; will therefore also modify those blocks in the target buffer.
045F6D             0869*  ; Clearing the source buffers will not clear the target buffer -
045F6D             0870*  ; it will still point to the original data blocks. Data blocks
045F6D             0871*  ; are only freed from memory when no buffers are left with any
045F6D             0872*  ; references to them.
045F6D             0873*  
045F6D             0874*  ; Buffers that get consolidated become new blocks, so will lose
045F6D             0875*  ; their links to the original blocks, thus after a “consolidate”
045F6D             0876*  ; operation modifications to the original blocks will no longer be
045F6D             0877*  ; reflected in the consolidated buffer.
045F6D             0878*  
045F6D             0879*  ; This command is useful to construct a single buffer from multiple
045F6D             0880*  ; sources without the copy overhead, which can be costly. For
045F6D             0881*  ; example, this can be useful for constructing a bitmap from
045F6D             0882*  ; multiple constituent parts before consolidating it into a
045F6D             0883*  ; single block. In such an example, using command 13 instead
045F6D             0884*  ; would first make a copy of the contents of the source buffers,
045F6D             0885*  ; and then consolidate them into a single block. Using this
045F6D             0886*  ; command does not make that first copy, and so would be faster.
045F6D             0887*  
045F6D             0888*  ; This command is also useful for creating multiple buffers that
045F6D             0889*  ; all point to the same data.
045F6D             0890*  
045F6D             0891*  ; Command 26: Copy blocks from multiple buffers and consolidate
045F6D             0892*  
045F6D             0893*  ; VDU 23, 0, &A0, targetBufferId; 26, sourceBufferId1; sourceBufferId2; ...; 65535;
045F6D             0057       ; include "src/asm/vdu_plot.inc"
045F6D             0058   	; include "src/asm/vdu_sprites.inc"
045F6D             0059   	; include "src/asm/vdp.inc"
045F6D             0060   	include "src/asm/div_168_signed.inc"
045F6D             0001*  ; 24-bit integer and 16.8 fixed point division routines
045F6D             0002*  ; by Brandon R. Gates (BeeGee747)
045F6D             0003*  ; have undergone cursory testing and seem to be generating
045F6D             0004*  ; correct results (assuming no overflows) but seem very inefficient,
045F6D             0005*  ; so they have been published for review and improvement
045F6D             0006*  ; see: https://discord.com/channels/1158535358624039014/1158536711148675072/1212136741608099910
045F6D             0007*  ;
045F6D             0008*  ; ---------------------------------------------------------
045F6D             0009*  ; BEGIN DIVISION ROUTINES
045F6D             0010*  ; ---------------------------------------------------------
045F6D             0011*  ;
045F6D             0012*  ; perform signed division of 16.8 fixed place values
045F6D             0013*  ; with an signed 16.8 fixed place result
045F6D             0014*  ; inputs: ub.c is dividend,ud.e is divisor
045F6D             0015*  ; outputs: uh.l is quotient
045F6D             0016*  ; destroys: a,bc
045F6D             0017*  ; note: uses carry flag to test for sign of operands and result
045F6D             0018*  ;       which can be confusing and should perhaps be changed
045F6D             0019*  ; note2: helper functions abs_hlu and neg_hlu have been modified
045F6D             0020*  ;       to return accurate flags according to the origional signs
045F6D             0021*  ;       (or zero) of this function's inputs
045F6D             0022*  sdiv168:
045F6D             0023*  ; make everything positive and save signs
045F6D C5          0024*      push bc         ; get bc to hl
045F6E E1          0025*      pop hl          ; for the next call
045F6F CD 14 60 04 0026*      call abs_hlu    ; sets sign flag if hlu was negative, zero if zero
045F73 CA A6 5F 04 0027*      jp z,@is_zero   ; if bc is zero, answer is zero and we're done
045F77 F5          0028*      push af         ; save sign of bc
045F78 E5          0029*      push hl         ; now put abs(hl)
045F79 C1          0030*      pop bc          ; back into bc = abs(bc)
045F7A EB          0031*      ex de,hl        ; now we do de same way
045F7B CD 14 60 04 0032*      call abs_hlu
045F7F CA A8 5F 04 0033*      jp z,@div_by_zero  ; if de was zero, answer is undefined and we're done
045F83 EB          0034*      ex de,hl        ; hl back to de = abs(de)
045F84             0035*  ; determine sign of result
045F84 F2 8F 5F 04 0036*      jp p,@de_pos    ; sign positive,de is positive
045F88 F1          0037*      pop af          ; get back sign of bc
045F89 FA 98 5F 04 0038*      jp m,@result_pos  ; bc and de negative, result is positive
045F8D 18 05       0039*      jr @result_neg
045F8F             0040*  @de_pos:
045F8F F1          0041*      pop af          ; get back sign of bc
045F90 F2 98 5F 04 0042*      jp p,@result_pos   ; bc and de are both positive so result is positive
045F94             0043*                      ; fall through to result_neg
045F94             0044*  @result_neg:
045F94 AF          0045*      xor a           ; zero a and clear carry
045F95 3D          0046*      dec a           ; set sign flag to negative
045F96 18 02       0047*      jr @do_div
045F98             0048*  @result_pos:
045F98 AF          0049*      xor a           ; zero a and clear carry
045F99 3C          0050*      inc a           ; set sign flag to negative
045F9A             0051*                      ; fall through to do_div
045F9A             0052*  @do_div:
045F9A F5          0053*      push af         ; save sign of result
045F9B CD AB 5F 04 0054*      call udiv168
045F9F F1          0055*      pop af          ; get back sign of result
045FA0 F0          0056*      ret p           ; result is positive so nothing to do
045FA1 CD 24 60 04 0057*      call neg_hlu    ; result is negative so negate it
045FA5 C9          0058*      ret
045FA6             0059*  @is_zero:           ; result is zero
045FA6 AF          0060*      xor a           ; sets zero flag, which we want,
045FA7             0061*                      ; sets pv flag which we might not (zero is parity even)
045FA7             0062*                      ; resets all others which is okay
045FA7 C9          0063*      ret
045FA8             0064*  @div_by_zero:       ; result is undefined, which isn't defined in binary
045FA8             0065*                      ; so we'll just return zero until i can think of something better
045FA8 F1          0066*      pop af          ; dummy pop
045FA9 AF          0067*      xor a           ; sets zero flag, which is ok,
045FAA             0068*                      ; sets pv flag which could be interpreted as overflow, which is good
045FAA             0069*                      ; resets all others which is okay
045FAA C9          0070*      ret
045FAB             0071*  
045FAB             0072*  ; ; perform unsigned division of 16.8 fixed place values
045FAB             0073*  ; ; with an unsigned 16.8 fixed place result
045FAB             0074*  ; ; inputs: ub.c is dividend,ud.e is divisor
045FAB             0075*  ; ; outputs: uh.l is quotient
045FAB             0076*  ; ; destroys: a,bc
045FAB             0077*  ; udiv168:
045FAB             0078*  ; ; get the 16-bit integer part of the quotient
045FAB             0079*  ;     ; call div_24
045FAB             0080*  ;     call udiv24
045FAB             0081*  ;     ; call dumpRegistersHex
045FAB             0082*  ; ; load quotient to upper three bytes of output
045FAB             0083*  ;     ld (div168_out+1),bc
045FAB             0084*  ; ; TODO: THIS MAY BE BUGGED
045FAB             0085*  ; ; check remainder for zero, and if it is
045FAB             0086*  ; ; we can skip calculating the fractional part
045FAB             0087*  ;     add hl,de
045FAB             0088*  ;     or a
045FAB             0089*  ;     sbc hl,de
045FAB             0090*  ;     jr nz,@div256
045FAB             0091*  ;     xor a
045FAB             0092*  ;     jr @write_frac
045FAB             0093*  ; ; END TODO
045FAB             0094*  ; @div256:
045FAB             0095*  ; ; divide divisor by 256
045FAB             0096*  ;     push hl ; save remainder
045FAB             0097*  ; ; TODO: it feels like this could be more efficient
045FAB             0098*  ;     ld (ude),de
045FAB             0099*  ;     ld a,d
045FAB             0100*  ;     ld (ude),a
045FAB             0101*  ;     ld a,(ude+2)
045FAB             0102*  ;     ld (ude+1),a
045FAB             0103*  ;     xor a
045FAB             0104*  ;     ld (ude+2),a
045FAB             0105*  ;     ld hl,(ude) ; (just for now, we want it in de eventually)
045FAB             0106*  ; ; TODO: THIS MAY BE BUGGED
045FAB             0107*  ; ; now we check the shifted divisor for zero, and if it is
045FAB             0108*  ; ; we again set the fractional part to zero
045FAB             0109*  ;     add hl,de
045FAB             0110*  ;     or a
045FAB             0111*  ;     sbc hl,de
045FAB             0112*  ;     ex de,hl ; now de is where it's supposed to be
045FAB             0113*  ;     pop hl ; get remainder back
045FAB             0114*  ; ; TODO: THIS MAY BE BUGGED
045FAB             0115*  ;     jr nz,@div_frac
045FAB             0116*  ;     xor a
045FAB             0117*  ;     jr @write_frac
045FAB             0118*  ; ; END TODO
045FAB             0119*  ; ; now divide the remainder by the shifted divisor
045FAB             0120*  ; @div_frac:
045FAB             0121*  ;     push hl ; my kingdom for ld bc,hl
045FAB             0122*  ;     pop bc  ; or even ex bc,hl
045FAB             0123*  ;     ; call div_24
045FAB             0124*  ;     call udiv24
045FAB             0125*  ; ; load low byte of quotient to low byte of output
045FAB             0126*  ;     ld a,c
045FAB             0127*  ; @write_frac:
045FAB             0128*  ;     ld (div168_out),a
045FAB             0129*  ; ; load hl with return value
045FAB             0130*  ;     ld hl,(div168_out)
045FAB             0131*  ; ; load a with any overflow
045FAB             0132*  ;     ld a,(div168_out+3)
045FAB             0133*  ;     ret ; uh.l is the 16.8 result
045FAB             0134*  ; div168_out: ds 4 ; the extra byte is for overflow
045FAB             0135*  
045FAB             0136*  ; perform unsigned division of fixed place values
045FAB             0137*  ; with an unsigned 16.8 fixed place result
045FAB             0138*  ; inputs: b.c is 8.8 dividend, ud.e is 16.8 divisor
045FAB             0139*  ; outputs: uh.l is the 16.8 quotient ub.c is the 16.8 remainder
045FAB             0140*  ; destroys: a,bc
045FAB             0141*  udiv168:
045FAB             0142*  ; shift dividend left 8 bits
045FAB ED 43 D4 58 0143*      ld (ubc+1),bc
       04          
045FB0 AF          0144*      xor a
045FB1 32 D3 58 04 0145*      ld (ubc),a
045FB5 ED 4B D3 58 0146*      ld bc,(ubc)
       04          
045FBA CD 41 60 04 0147*      call udiv24
045FBE             0148*  ; flip-flop outptuts to satisfy downstream consumers
045FBE             0149*  ; TODO: this is a hack and should be fixed
045FBE             0150*  ; (so says copilot ... but it's not wrong)
045FBE E5          0151*      push hl
045FBF C5          0152*      push bc
045FC0 E1          0153*      pop hl
045FC1 C1          0154*      pop bc
045FC2 C9          0155*      ret
045FC3             0156*  
045FC3             0157*  ; this is an adaptation of Div16 extended to 24 bits
045FC3             0158*  ; from https://map.grauw.nl/articles/mult_div_shifts.php
045FC3             0159*  ; it works by shifting each byte of the dividend left into carry 8 times
045FC3             0160*  ; and adding the dividend into hl if the carry is set
045FC3             0161*  ; thus hl accumulates a remainder depending on the result of each iteration
045FC3             0162*  ; ---------------------------------------------------------
045FC3             0163*  ; Divide 24-bit unsigned values
045FC3             0164*  ;   with 24-bit unsigned result
045FC3             0165*  ;   and 24-bit remainder
045FC3             0166*  ; In: Divide ubc by ude
045FC3             0167*  ; Out: ubc = result, uhl = remainder
045FC3             0168*  ; Destroys: a,hl,bc
045FC3             0169*  div_24:
045FC3 21 00 00 00 0170*      ld hl,0     ; Clear accumulator for remainder
045FC7             0171*  ; put dividend in scratch so we can get at all its bytes
045FC7 ED 43 D3 58 0172*      ld (ubc),bc ; scratch ubc also accumulates the quotient
       04          
045FCC 3A D5 58 04 0173*      ld a,(ubc+2); grab the upper byte of the dividend
045FD0 06 08       0174*      ld b,8      ; loop counter for 8 bits in a byte
045FD2             0175*  @loop0:
045FD2 17          0176*      rla         ; shift the next bit of dividend into the carry flag
045FD3 ED 6A       0177*      adc hl,hl   ; shift the remainder left one bit and add carry if any
045FD5 ED 52       0178*      sbc hl,de   ; subtract divisor from remainder
045FD7 30 01       0179*      jr nc,@noadd0   ; if no carry,remainder is <= divisor
045FD9             0180*                  ; meaning remainder is divisible by divisor
045FD9 19          0181*      add hl,de   ; otherwise add divisor back to remainder
045FDA             0182*                  ; reversing the previous subtraction
045FDA             0183*  @noadd0:
045FDA 10 F6       0184*      djnz @loop0 ; repeat for all 8 bits
045FDC 17          0185*      rla         ; now we shift a left one more time
045FDD 2F          0186*      cpl         ; then flip its bits for some reason
045FDE 32 D5 58 04 0187*      ld (ubc+2),a; magically this is the upper byte of the quotient
045FE2 3A D4 58 04 0188*      ld a,(ubc+1); now we pick up the middle byte of the dividend
045FE6 06 08       0189*      ld b,8      ; set up the next loop and do it all again ...
045FE8             0190*  @loop1:
045FE8 17          0191*      rla
045FE9 ED 6A       0192*      adc hl,hl
045FEB ED 52       0193*      sbc hl,de
045FED 30 01       0194*      jr nc,@noadd1
045FEF 19          0195*      add hl,de
045FF0             0196*  @noadd1:
045FF0 10 F6       0197*      djnz @loop1
045FF2 17          0198*      rla
045FF3 2F          0199*      cpl
045FF4 32 D4 58 04 0200*      ld (ubc+1),a ; writing the middle byte of quotient
045FF8 3A D3 58 04 0201*      ld a,(ubc)
045FFC 06 08       0202*      ld b,8
045FFE             0203*  @loop2:          ; compute low byte of quotient
045FFE 17          0204*      rla
045FFF ED 6A       0205*      adc hl,hl
046001 ED 52       0206*      sbc hl,de
046003 30 01       0207*      jr nc,@noadd2
046005 19          0208*      add hl,de
046006             0209*  @noadd2:
046006 10 F6       0210*      djnz @loop2
046008 17          0211*      rla
046009 2F          0212*      cpl
04600A 32 D3 58 04 0213*      ld (ubc),a  ; ... write low byte of quotient
04600E ED 4B D3 58 0214*      ld bc,(ubc) ; load quotient into bc for return
       04          
046013 C9          0215*      ret         ; hl already contains remainder so we're done
046014             0216*  
046014             0217*  ; ---------------------------------------------------------
046014             0218*  ; BEGIN HELPER ROUTINES
046014             0219*  ; ---------------------------------------------------------
046014             0220*  ;
046014             0221*  ; absolute value of hlu
046014             0222*  ; returns: abs(hlu), flags set according to the incoming sign of hlu:
046014             0223*  ;         s1,z0,pv0,n1,c0 if hlu was negative
046014             0224*  ;         s0,z1,pv0,n1,c0 if hlu was zero
046014             0225*  ;         s0,z0,pv0,n1,c0 if hlu was positive
046014             0226*  ; destroys: a
046014             0227*  abs_hlu:
046014 19          0228*      add hl,de
046015 B7          0229*      or a
046016 ED 52       0230*      sbc hl,de
046018 FA 1D 60 04 0231*      jp m,@is_neg
04601C C9          0232*      ret         ; hlu is positive or zero so we're done
04601D             0233*  @is_neg:
04601D F5          0234*      push af     ; otherwise, save current flags for return
04601E CD 24 60 04 0235*      call neg_hlu ; negate hlu
046022 F1          0236*      pop af      ; get back flags
046023 C9          0237*      ret
046024             0238*  
046024             0239*  ; flip the sign of hlu
046024             0240*  ; inputs: hlu
046024             0241*  ; returns: 0-hlu, flags set appropriately for the result:
046024             0242*  ;         s1,z0,pv0,n1,c1 if result is negative
046024             0243*  ;         s0,z1,pv0,n1,c0 if result is zero
046024             0244*  ;         s0,z0,pv0,n1,c1 if result is positive
046024             0245*  ; destroys a
046024             0246*  neg_hlu:
046024 D5          0247*      push de     ; save de
046025 EB          0248*      ex de,hl    ; put hl into de
046026 21 00 00 00 0249*      ld hl,0     ; clear hl
04602A AF          0250*      xor a       ; clear carry
04602B ED 52       0251*      sbc hl,de   ; 0-hlu = -hlu
04602D D1          0252*      pop de      ; get de back
04602E C9          0253*      ret         ; easy peasy
04602F             0254*  
04602F             0255*  ; -----------------------------------------------------------------------
04602F             0256*  ; https://github.com/sijnstra/agon-projects/blob/main/calc24/arith24.asm
04602F             0257*  ;------------------------------------------------------------------------
04602F             0258*  ;  arith24.asm
04602F             0259*  ;  24-bit ez80 arithmetic routines
04602F             0260*  ;  Copyright (c) Shawn Sijnstra 2024
04602F             0261*  ;  MIT license
04602F             0262*  ;
04602F             0263*  ;  This library was created as a tool to help make ez80
04602F             0264*  ;  24-bit native assembly routines for simple mathematical problems
04602F             0265*  ;  more widely available.
04602F             0266*  ;
04602F             0267*  ;------------------------------------------------------------------------
04602F             0268*  
04602F             0269*  ;------------------------------------------------------------------------
04602F             0270*  ; umul24:	HLU = BCU*DEU (unsigned)
04602F             0271*  ; Preserves AF, BCU, DEU
04602F             0272*  ; Uses a fast multiply routine.
04602F             0273*  ;------------------------------------------------------------------------
04602F             0274*  ; modified to take BCU as multiplier instead of HLU
04602F             0275*  umul24:
04602F             0276*  	; push	DE
04602F             0277*  	; push	BC
04602F             0278*  	; push	AF
04602F             0279*  	; push	HL
04602F             0280*  	; pop		BC
04602F 3E 18       0281*      ld	 	a,24 ; No. of bits to process
046031 21 00 00 00 0282*      ld	 	hl,0 ; Result
046035             0283*  umul24_lp:
046035 29          0284*  	add	hl,hl
046036 EB          0285*  	ex	de,hl
046037 29          0286*  	add	hl,hl
046038 EB          0287*  	ex	de,hl
046039 30 01       0288*  	jr	nc,umul24_nc
04603B 09          0289*  	add	hl,bc
04603C             0290*  umul24_nc:
04603C 3D          0291*  	dec	a
04603D 20 F6       0292*  	jr	nz,umul24_lp
04603F 0B          0293*      dec bc ; debug
046040             0294*  	; pop	af
046040             0295*  	; pop	bc
046040             0296*  	; pop	de
046040 C9          0297*  	ret
046041             0298*  
046041             0299*  
046041             0300*  ;------------------------------------------------------------------------
046041             0301*  ; udiv24
046041             0302*  ; Unsigned 24-bit division
046041             0303*  ; Divides BCU by DEU. Gives result in BCU, remainder in HLU.
046041             0304*  ;
046041             0305*  ; Uses AF BC DE HL
046041             0306*  ; Uses Restoring Division algorithm
046041             0307*  ;------------------------------------------------------------------------
046041             0308*  ; modified to take BCU as dividend instead of HLU
046041             0309*  ; and give BCU as quotient instead of DEU
046041             0310*  ; -----------------------------------------------------------------------
046041             0311*  udiv24:
046041             0312*  	; push	hl
046041             0313*  	; pop		bc	;move dividend to BCU
046041 21 00 00 00 0314*  	ld		hl,0	;result
046045 A7          0315*  	and		a
046046 ED 52       0316*  	sbc		hl,de	;test for div by 0
046048 C8          0317*  	ret		z		;it's zero, carry flag is clear
046049 19          0318*  	add		hl,de	;HL is 0 again
04604A 3E 18       0319*  	ld		a,24	;number of loops through.
04604C             0320*  udiv1:
04604C C5          0321*  	push	bc	;complicated way of doing this because of lack of access to top bits
04604D E3          0322*  	ex		(sp),hl
04604E 37          0323*  	scf
04604F ED 6A       0324*  	adc	hl,hl
046051 E3          0325*  	ex	(sp),hl
046052 C1          0326*  	pop	bc		;we now have bc = (bc * 2) + 1
046053             0327*  
046053 ED 6A       0328*  	adc	hl,hl
046055 A7          0329*  	and	a		;is this the bug
046056 ED 52       0330*  	sbc	hl,de
046058 30 02       0331*  	jr	nc,udiv2
04605A 19          0332*  	add	hl,de
04605B             0333*  ;	dec	c
04605B 0B          0334*  	dec	bc
04605C             0335*  udiv2:
04605C 3D          0336*  	dec	a
04605D 20 ED       0337*  	jr	nz,udiv1
04605F 37          0338*  	scf		;flag used for div0 error
046060             0339*  	; push	bc
046060             0340*  	; pop		de	;remainder
046060 C9          0341*  	ret
046061             0342*  
046061             0343*  
046061             0344*  
046061             0345*  ;------------------------------------------------------------------------
046061             0346*  ; neg24
046061             0347*  ; Returns: HLU = 0-HLU
046061             0348*  ; preserves all other registers
046061             0349*  ;------------------------------------------------------------------------
046061             0350*  neg24:
046061 D5          0351*  	push	de
046062 EB          0352*  	ex		de,hl
046063 21 00 00 00 0353*  	ld		hl,0
046067 B7          0354*  	or		a
046068 ED 52       0355*  	sbc		hl,de
04606A D1          0356*  	pop		de
04606B C9          0357*  	ret
04606C             0358*  
04606C             0359*  ;------------------------------------------------------------------------
04606C             0360*  ; or_hlu_deu: 24 bit bitwise OR
04606C             0361*  ; Returns: hlu = hlu OR deu
04606C             0362*  ; preserves all other registers
04606C             0363*  ;------------------------------------------------------------------------
04606C             0364*  or_hlu_deu:
04606C 22 28 61 04 0365*  	ld	(bitbuf1),hl
046070 ED 53 2B 61 0366*  	ld	(bitbuf2),de
       04          
046075 D5          0367*  	push	de	;preserve DEU
046076 C5          0368*  	push	bc	;preserve BCU
046077 06 03       0369*  	ld		b,3
046079 21 28 61 04 0370*  	ld	hl,bitbuf1
04607D 11 28 61 04 0371*  	ld	de,bitbuf1
046081             0372*  orloop_24:
046081 1A          0373*  	ld	a,(de)
046082 B6          0374*  	or	(hl)
046083 12          0375*  	ld	(de),a
046084 13          0376*  	inc	de
046085 23          0377*  	inc	hl
046086 10 F9       0378*  	djnz	orloop_24
046088 2A 2B 61 04 0379*  	ld	hl,(bitbuf2)
04608C C1          0380*  	pop		bc	;restore BC
04608D D1          0381*  	pop		de	;restore DE
04608E             0382*  
04608E             0383*  ;------------------------------------------------------------------------
04608E             0384*  ; and_hlu_deu: 24 bit bitwise AND
04608E             0385*  ; Returns: hlu = hlu AND deu
04608E             0386*  ; preserves all other registers
04608E             0387*  ;------------------------------------------------------------------------
04608E             0388*  and_hlu_deu:
04608E 22 28 61 04 0389*  	ld	(bitbuf1),hl
046092 ED 53 2B 61 0390*  	ld	(bitbuf2),de
       04          
046097 D5          0391*  	push	de	;preserve DEU
046098 C5          0392*  	push	bc	;preserve BCU
046099 06 03       0393*  	ld		b,3
04609B 21 28 61 04 0394*  	ld	hl,bitbuf1
04609F 11 28 61 04 0395*  	ld	de,bitbuf1
0460A3             0396*  andloop_24:
0460A3 1A          0397*  	ld	a,(de)
0460A4 A6          0398*  	and	(hl)
0460A5 12          0399*  	ld	(de),a
0460A6 13          0400*  	inc	de
0460A7 23          0401*  	inc	hl
0460A8 10 F9       0402*  	djnz	andloop_24
0460AA 2A 2B 61 04 0403*  	ld	hl,(bitbuf2)
0460AE C1          0404*  	pop		bc	;restore BC
0460AF D1          0405*  	pop		de	;restore DE
0460B0             0406*  
0460B0             0407*  ;------------------------------------------------------------------------
0460B0             0408*  ; xor_hlu_deu: 24 bit bitwise XOR
0460B0             0409*  ; Returns: hlu = hlu XOR deu
0460B0             0410*  ; preserves all other registers
0460B0             0411*  ;------------------------------------------------------------------------
0460B0             0412*  xor_hlu_deu:
0460B0 22 28 61 04 0413*  	ld	(bitbuf1),hl
0460B4 ED 53 2B 61 0414*  	ld	(bitbuf2),de
       04          
0460B9 D5          0415*  	push	de	;preserve DEU
0460BA C5          0416*  	push	bc	;preserve BCU
0460BB 06 03       0417*  	ld		b,3
0460BD 21 28 61 04 0418*  	ld	hl,bitbuf1
0460C1 11 28 61 04 0419*  	ld	de,bitbuf1
0460C5             0420*  xorloop_24:
0460C5 1A          0421*  	ld	a,(de)
0460C6 AE          0422*  	xor	(hl)
0460C7 12          0423*  	ld	(de),a
0460C8 13          0424*  	inc	de
0460C9 23          0425*  	inc	hl
0460CA 10 F9       0426*  	djnz	xorloop_24
0460CC 2A 2B 61 04 0427*  	ld	hl,(bitbuf2)
0460D0 C1          0428*  	pop		bc	;restore BC
0460D1 D1          0429*  	pop		de	;restore DE
0460D2             0430*  
0460D2             0431*  ;------------------------------------------------------------------------
0460D2             0432*  ; shl_hlu: 24 bit shift left hlu by deu positions
0460D2             0433*  ; Returns: hlu = hlu << deu
0460D2             0434*  ;		   de = 0
0460D2             0435*  ; NOTE: only considers deu up to 16 bits.
0460D2             0436*  ; preserves all other registers
0460D2             0437*  ;------------------------------------------------------------------------
0460D2             0438*  shl_hlu:
0460D2 7A          0439*  	ld		a,d		;up to 16 bit.
0460D3 B3          0440*  	or		e
0460D4 C8          0441*  	ret		z		;we're done
0460D5 29          0442*  	add		hl,hl	;shift HLU left
0460D6 1B          0443*  	dec		de
0460D7 18 F9       0444*  	jr		shl_hlu
0460D9             0445*  
0460D9             0446*  ;------------------------------------------------------------------------
0460D9             0447*  ; shr_hlu: 24 bit shift right hlu by deu positions
0460D9             0448*  ; Returns: hlu = hlu >> deu
0460D9             0449*  ;		   de = 0
0460D9             0450*  ; NOTE: only considers deu up to 16 bits.
0460D9             0451*  ; preserves all other registers
0460D9             0452*  ;------------------------------------------------------------------------
0460D9             0453*  shr_hlu:
0460D9 22 28 61 04 0454*  	ld		(bitbuf1),hl
0460DD 21 2A 61 04 0455*  	ld		hl,bitbuf1+2
0460E1             0456*  shr_loop:
0460E1 7A          0457*  	ld		a,d		;up to 16 bit.
0460E2 B3          0458*  	or		e
0460E3 28 0D       0459*  	jr		z,shr_done		;we're done
0460E5             0460*  ;carry is clear from or instruction
0460E5 CB 1E       0461*  	rr		(hl)
0460E7 2B          0462*  	dec		hl
0460E8 CB 1E       0463*  	rr		(hl)
0460EA 2B          0464*  	dec		hl
0460EB CB 1E       0465*  	rr		(hl)
0460ED 23          0466*  	inc		hl
0460EE 23          0467*  	inc		hl
0460EF 1B          0468*  	dec		de
0460F0 18 EF       0469*  	jr		shr_loop
0460F2             0470*  shr_done:
0460F2 2A 28 61 04 0471*  	ld		hl,(bitbuf1)	;collect result
0460F6 C9          0472*  	ret
0460F7             0473*  
0460F7             0474*  ;------------------------------------------------------------------------
0460F7             0475*  ; divide hlu by 2, inspired by above
0460F7             0476*  ;------------------------------------------------------------------------
0460F7             0477*  hlu_div2:
0460F7 22 28 61 04 0478*  	ld		(bitbuf1),hl
0460FB 21 2A 61 04 0479*  	ld		hl,bitbuf1+2
0460FF CB 1E       0480*  	rr		(hl)
046101 2B          0481*  	dec		hl
046102 CB 1E       0482*  	rr		(hl)
046104 2B          0483*  	dec		hl
046105 CB 1E       0484*  	rr		(hl)
046107 23          0485*  	inc		hl
046108 23          0486*  	inc		hl
046109 2A 28 61 04 0487*      ld hl,(bitbuf1)
04610D C9          0488*      ret
04610E             0489*  
04610E             0490*  ; this is my little hack to divide by 16
04610E             0491*  hlu_div16:
04610E AF          0492*      xor a
04610F 29          0493*      add hl,hl
046110 17          0494*      rla
046111 29          0495*      add hl,hl
046112 17          0496*      rla
046113 29          0497*      add hl,hl
046114 17          0498*      rla
046115 29          0499*      add hl,hl
046116 17          0500*      rla
046117 22 24 61 04 0501*      ld (@scratch),hl
04611B 32 27 61 04 0502*      ld (@scratch+3),a
04611F 2A 25 61 04 0503*      ld hl,(@scratch+1)
046123 C9          0504*      ret
046124             0505*  @scratch: ds 4
046128             0506*  
046128             0507*  ;------------------------------------------------------------------------
046128             0508*  ; Scratch area for calculations
046128             0509*  ;------------------------------------------------------------------------
046128 00 00 00    0510*  bitbuf1:	dw24	0	;bit manipulation buffer 1
04612B 00 00 00    0511*  bitbuf2:	dw24	0	;bit manipulation buffer 2
04612E             0512*  
04612E             0513*  
04612E             0514*  ; -----------------------------------------------------------------------
04612E             0515*  ; EEMES TUTORIALS
04612E             0516*  ; -----------------------------------------------------------------------
04612E             0517*  ; https://tutorials.eeems.ca/Z80ASM/part4.htm
04612E             0518*  ; DEHL=BC*DE
04612E             0519*  Mul16:
04612E 21 00 00 00 0520*      ld hl,0
046132 3E 10       0521*      ld a,16
046134             0522*  Mul16Loop:
046134 29          0523*      add hl,hl
046135 CB 13       0524*      rl e
046137 CB 12       0525*      rl d
046139 D2 43 61 04 0526*      jp nc,NoMul16
04613D 09          0527*      add hl,bc
04613E D2 43 61 04 0528*      jp nc,NoMul16
046142 13          0529*      inc de
046143             0530*  NoMul16:
046143 3D          0531*      dec a
046144 C2 34 61 04 0532*      jp nz,Mul16Loop
046148 C9          0533*      ret
046149             0534*  
046149             0535*  ; DEUHLU=BCU*DEU
046149             0536*  umul2448:
046149 21 00 00 00 0537*      ld hl,0
04614D 3E 18       0538*      ld a,24
04614F             0539*  umul2448Loop:
04614F 29          0540*      add hl,hl
046150 EB          0541*      ex de,hl
046151 ED 6A       0542*      adc hl,hl
046153 EB          0543*      ex de,hl
046154 D2 5E 61 04 0544*      jp nc,Noumul2448
046158 09          0545*      add hl,bc
046159 D2 5E 61 04 0546*      jp nc,Noumul2448
04615D 13          0547*      inc de
04615E             0548*  Noumul2448:
04615E 3D          0549*      dec a
04615F C2 4F 61 04 0550*      jp nz,umul2448Loop
046163 C9          0551*      ret
046164             0552*  
046164             0553*  umul168:
046164 CD 49 61 04 0554*      call umul2448
046168             0555*  
046168             0556*      ; call dumpUDEUHLHex
046168             0557*  
046168             0558*  ; UDEU.HL is the 32.16 fixed result
046168             0559*  ; we want UH.L to be the 16.8 fixed result
046168             0560*  ; so we divide by 256 by shiftng down a byte
046168             0561*  ; easiest way is to write deu and hlu to scratch
046168 ED 53 7D 61 0562*      ld (umul168out+3),de
       04          
04616D 22 7A 61 04 0563*      ld (umul168out),hl
046171             0564*  ; then load hlu from scratch shfited forward a byte
046171 2A 7B 61 04 0565*      ld hl,(umul168out+1)
046175 3A 7F 61 04 0566*      ld a,(umul168out+5) ; send a back with any overflow
046179 C9          0567*      ret
04617A             0568*  umul168out: ds 6
046180             0569*  
046180             0570*  ; perform signed multiplication of 16.8 fixed place values
046180             0571*  ; with an signed 16.8 fixed place result
046180             0572*  ; inputs: ub.c and ud.e are the operands
046180             0573*  ; outputs: uh.l is the product
046180             0574*  ; destroys: a,bc
046180             0575*  ; TODO: make flags appropriate to the sign of the result
046180             0576*  smul168:
046180             0577*  ; make everything positive and save signs
046180 C5          0578*      push bc         ; get bc to hl
046181 E1          0579*      pop hl          ; for the next call
046182 CD 14 60 04 0580*      call abs_hlu    ; sets sign flag if ubc was negative, zero if zero
046186             0581*  
046186             0582*      ; call dumpFlags ; passes
046186             0583*  
046186 CA B9 61 04 0584*      jp z,@is_zero   ; if bc is zero, answer is zero and we're done
04618A F5          0585*      push af         ; save sign of bc
04618B E5          0586*      push hl         ; now put abs(hl)
04618C C1          0587*      pop bc          ; back into bc = abs(bc)
04618D EB          0588*      ex de,hl        ; now we do de same way
04618E CD 14 60 04 0589*      call abs_hlu    ; sets sign flag if ude was negative, zero if zero
046192             0590*  
046192             0591*      ; call dumpFlags ; passes
046192             0592*  
046192 CA B9 61 04 0593*      jp z,@is_zero  ; if de was zero, answer is zero and we're done
046196 EB          0594*      ex de,hl        ; hl back to de = abs(de)
046197             0595*  ; determine sign of result
046197 F2 A2 61 04 0596*      jp p,@de_pos    ; sign positive,de is positive
04619B             0597*  
04619B             0598*      ; call dumpFlags ; correctly doesnt make it here
04619B             0599*  
04619B F1          0600*      pop af          ; get back sign of bc
04619C             0601*  
04619C             0602*      ; call dumpFlags ; correctly doesn't make it here
04619C             0603*  
04619C FA AB 61 04 0604*      jp m,@result_pos  ; bc and de negative, result is positive
0461A0             0605*  
0461A0             0606*      ; call dumpFlags  ; corectly doesn't make it here
0461A0             0607*  
0461A0 18 05       0608*      jr @result_neg
0461A2             0609*  @de_pos:
0461A2 F1          0610*      pop af          ; get back sign of bc
0461A3             0611*  
0461A3             0612*      ; call dumpFlags  ; passes
0461A3             0613*  
0461A3 F2 AB 61 04 0614*      jp p,@result_pos   ; bc and de are both positive so result is positive
0461A7             0615*  
0461A7             0616*      ; call dumpFlags ; correctly makes it here
0461A7             0617*  
0461A7             0618*                      ; fall through to result_neg
0461A7             0619*  @result_neg:
0461A7 AF          0620*      xor a           ; zero a and clear carry
0461A8 3D          0621*      dec a           ; set sign flag to negative
0461A9             0622*  
0461A9             0623*      ; call dumpFlags ; passes
0461A9             0624*  
0461A9 18 02       0625*      jr @do_mul
0461AB             0626*  @result_pos:
0461AB AF          0627*      xor a           ; zero a and clear carry
0461AC 3C          0628*      inc a           ; set sign flag to positive
0461AD             0629*                      ; fall through to do_mul
0461AD             0630*  
0461AD             0631*      ; call dumpFlags ; correctly doesn't make it here
0461AD             0632*  
0461AD             0633*  @do_mul:
0461AD F5          0634*      push af         ; save sign of result
0461AE CD 64 61 04 0635*      call umul168
0461B2 F1          0636*      pop af          ; get back sign of result
0461B3             0637*  
0461B3             0638*      ; call dumpFlags ; passes
0461B3             0639*  
0461B3 F0          0640*      ret p           ; result is positive so nothing to do
0461B4             0641*  
0461B4             0642*      ; call dumpRegistersHex ; passes
0461B4             0643*  
0461B4 CD 24 60 04 0644*      call neg_hlu    ; result is negative so negate it
0461B8             0645*  
0461B8             0646*      ; call dumpRegistersHex ; passes
0461B8 C9          0647*      ret
0461B9             0648*  @is_zero:           ; result is zero
0461B9 AF          0649*      xor a           ; sets zero flag, which we want,
0461BA             0650*                      ; sets pv flag which we might not (zero is parity even)
0461BA             0651*                      ; resets all others which is okay
0461BA C9          0652*      ret
0461BB             0061   	include "src/asm/maths24.inc"
0461BB             0001*  ; http://www.z80.info/pseudo-random.txt
0461BB             0002*  rand_8:
0461BB C5          0003*      push bc
0461BC 3A CF 61 04 0004*      ld a,(r_seed)
0461C0 4F          0005*      ld c,a
0461C1             0006*  
0461C1 0F          0007*      rrca ; multiply by 32
0461C2 0F          0008*      rrca
0461C3 0F          0009*      rrca
0461C4 EE 1F       0010*      xor 0x1f
0461C6             0011*  
0461C6 81          0012*      add a,c
0461C7 DE FF       0013*      sbc a,255 ; carry
0461C9             0014*  
0461C9 32 CF 61 04 0015*      ld (r_seed),a
0461CD C1          0016*      pop bc
0461CE C9          0017*      ret
0461CF 50          0018*  r_seed: defb $50
0461D0             0019*  
0461D0             0020*  ; tests the sign of 24-bit register hlu
0461D0             0021*  ; returns: a in [-1,0,1]
0461D0             0022*  ;   sign and zero flags as expected
0461D0             0023*  ;   hl is untouched
0461D0             0024*  ; GPT-4 wrote most of this. the or l was inspired. it did bit 7,a instead of h
0461D0             0025*  ; and it left the zero flag set after ld a,1,which i fixed by anding it
0461D0             0026*  get_sign_hlu:
0461D0             0027*      ; Load the upper byte of HLU into A
0461D0 E5          0028*      push hl
0461D1 DD 21 00 00 0029*      ld ix,0
       00          
0461D6 DD 39       0030*      add ix,sp
0461D8 DD 7E 02    0031*      ld a,(ix+2)
0461DB E1          0032*      pop hl
0461DC             0033*  
0461DC B5          0034*      or l                ; OR with the low byte to check if HL is zero
0461DD C8          0035*      ret z               ; Return if HL is zero
0461DE             0036*  
0461DE 3E FF       0037*      ld a,-1             ; Send A back as -1 if the sign flag is set
0461E0 CB 7C       0038*      bit 7,h            ; Test the sign bit (7th bit) of the high byte
0461E2 C0          0039*      ret nz              ; If set,HL is negative,return with the sign flag set
0461E3             0040*  
0461E3 3E 01       0041*      ld a,1             ; Otherwise,HL is positive
0461E5 A7          0042*      and a               ; Reset the zero flag
0461E6 C9          0043*      ret                 ; Return with A set to 1
0461E7             0044*  
0461E7             0045*  ; 16.8 fixed inputs / outputs
0461E7             0046*  ; takes: uh.l as angle in degrees 256
0461E7             0047*  ;        ud.e as radius
0461E7             0048*  ; returns ub.c as dx, ud.e as dy
0461E7             0049*  ;        displacements from origin (0,0)
0461E7             0050*  ; destroys: everything except indexes
0461E7             0051*  polar_to_cartesian:
0461E7             0052*  ; back up input parameters
0461E7 22 D0 58 04 0053*      ld (uhl),hl
0461EB ED 53 D6 58 0054*      ld (ude),de
       04          
0461F0             0055*  ; compute dx = sin(uh.l) * ud.e
0461F0 CD 1F 62 04 0056*      call sin168
0461F4 E5          0057*      push hl
0461F5 C1          0058*      pop bc ; ub.c = sin(uh.l)
0461F6 ED 5B D6 58 0059*  	ld de,(ude) ; get radius back
       04          
0461FB CD 80 61 04 0060*  	call smul168 ; uh.l = ub.c * ud.e = dx
0461FF E5          0061*      push hl ; store dx for output
046200             0062*  ; compute dy = -cos(uh.l) * ud.e
046200 2A D0 58 04 0063*      ld hl,(uhl)
046204 CD 1A 62 04 0064*      call cos168
046208 CD 24 60 04 0065*  	call neg_hlu ; invert dy for screen coords convention
04620C E5          0066*      push hl
04620D C1          0067*      pop bc ; ub.c = -cos(uh.l)
04620E ED 5B D6 58 0068*      ld de,(ude) ; get radius back
       04          
046213 CD 80 61 04 0069*      call smul168 ; uh.l = ub.c * ud.e = dy
046217 EB          0070*      ex de,hl    ; de = dy for output
046218 C1          0071*      pop bc      ; bc = dx for output
046219             0072*  ; and out
046219 C9          0073*      ret
04621A             0074*  
04621A             0075*  ; fixed 16.8 routine
04621A             0076*  ; cos(uh.l) --> uh.l
04621A             0077*  ; destroys: de
04621A             0078*  cos168:
04621A             0079*  ; for cos we simply increment the angle by 90 degrees
04621A             0080*  ; or 0x004000 in 16.8 degrees256
04621A             0081*  ; which makes it a sin problem
04621A 11 00 40 00 0082*      ld de,0x004000
04621E 19          0083*      add hl,de ; modulo 256 happens below
04621F             0084*  ; fall through to sin168
04621F             0085*  ; ---------------------
04621F             0086*  ; fixed 16.8 routine
04621F             0087*  ; sin(uh.l) --> uh.l
04621F             0088*  ; destroys: de
04621F             0089*  sin168:
04621F             0090*  ; h contains the integer portion of our angle
04621F             0091*  ; we multiply it by three to get our lookup table index
04621F 2E 03       0092*      ld l,3
046221 ED 6C       0093*      mlt hl ; gosh that is handy
046223 11 00 00 00 0094*      ld de,0 ; clear deu
046227 54          0095*      ld d,h ; copy hl to de
046228 5D          0096*      ld e,l ; de contains our index
046229 21 30 64 04 0097*      ld hl,sin_lut_168 ; grab the lut address
04622D 19          0098*      add hl,de ; bump hl by the index
04622E ED 27       0099*      ld hl,(hl) ; don't try this on a z80!
046230 C9          0100*      ret ; and out
046231             0101*  
046231             0102*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
046231             0103*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
046231             0104*  ; output: ub.c and ud.e are dx and dy in 16.8 fixed format
046231             0105*  ;         also populates scratch locations dx168 and dy168
046231             0106*  ; destroys: a,hl,bc,de
046231             0107*  dxy168:
046231             0108*  ; compute dx = x1-x0
046231 AF          0109*      xor a ; clear carry
046232 DD E5       0110*      push ix ; move ix to hl via the stack
046234 E1          0111*      pop hl ; hl = x1
046235 ED 42       0112*      sbc hl,bc ; hl = dx
046237 22 8C 62 04 0113*      ld (dx168),hl ; dx to scratch
04623B             0114*  ; compute dy = y1-y0
04623B AF          0115*      xor a ; clear carry
04623C FD E5       0116*      push iy ; move iy to hl via the stack
04623E E1          0117*      pop hl ; hl = y1
04623F ED 52       0118*      sbc hl,de ; hl = dy
046241 22 92 62 04 0119*      ld (dy168),hl ; dy to scratch
046245             0120*  ; populate output registers and return
046245 EB          0121*      ex de,hl        ; ud.e = dy
046246 ED 4B 8C 62 0122*      ld bc,(dx168)   ; ub.c = dx
       04          
04624B C9          0123*      ret
04624C             0124*  
04624C             0125*  ; compute the euclidian distance between two cartesian coordinates
04624C             0126*  ; using the formula d = sqrt(dx^2+dy^2
04624C             0127*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
04624C             0128*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
04624C             0129*  ; output; uh.l is the 16.8 fixed format distance
04624C             0130*  ;       dx168/y are the 16.8 fixed format dx and dy
04624C             0131*  ; destroys: a,hl,bc,de
04624C             0132*  distance168:
04624C             0133*  ; compute dx = x1-x0
04624C AF          0134*      xor a ; clear carry
04624D DD E5       0135*      push ix ; move ix to hl via the stack
04624F E1          0136*      pop hl ; hl = x1
046250 ED 42       0137*      sbc hl,bc ; hl = dx
046252 22 8C 62 04 0138*      ld (dx168),hl ; dx to scratch
046256             0139*  ; ; test dx for overflow
046256             0140*  ; 	ld de,0x007F00 ; max positive 16.8 value we can square without overflow
046256             0141*  ; 	ex de,hl
046256             0142*  ; 	sbc hl,de ; test for overflow
046256             0143*  ; 	push af ; carry indicates overflow
046256             0144*  ; compute dy = y1-y0
046256 AF          0145*      xor a ; clear carry
046257 FD E5       0146*      push iy ; move iy to hl via the stack
046259 E1          0147*      pop hl ; hl = y1
04625A ED 52       0148*      sbc hl,de ; hl = dy
04625C 22 92 62 04 0149*      ld (dy168),hl ; dy to scratch
046260             0150*  ; ; test dy for overflow
046260             0151*  ; 	ld de,0x007F00 ; max positive 16.8 value we can square without overflow
046260             0152*  ; 	ex de,hl
046260             0153*  ; 	sbc hl,de ; test for overflow
046260             0154*  ; 	push af ; carry indicates overflow
046260             0155*  ; compute dy^2
046260 2A 92 62 04 0156*  	ld hl,(dy168)
046264 CD 14 60 04 0157*      call abs_hlu  ; make dy positive so we can use unsigned multiply
046268             0158*      ; call hlu_div2 ; divide hlu by 2 to give us some headroom
046268 E5          0159*      push hl ; load hl/2 to bc via the stack
046269 C1          0160*      pop bc ; bc = dy/2
04626A EB          0161*      ex de,hl ; de = dy/2
04626B CD 64 61 04 0162*      call umul168 ; uh.l = dy^2/2
04626F E5          0163*      push hl ; dy^2/2 to the stack
046270             0164*  ; compute dx^2
046270 2A 8C 62 04 0165*      ld hl,(dx168) ; get back dx
046274 CD 14 60 04 0166*      call abs_hlu  ; make dx positive so we can use unsigned multiply
046278             0167*      ; call hlu_div2 ; divide hlu by 2 to give us some headroom
046278 E5          0168*      push hl ; load hl/2 to bc via the stack
046279 C1          0169*      pop bc ; bc = dx/2
04627A EB          0170*      ex de,hl ; de = dx/2
04627B CD 64 61 04 0171*      call umul168 ; uh.l = dx^2/2
04627F             0172*  ; commpute dy^2+dx^2
04627F D1          0173*      pop de ; get back dx^2/2
046280 19          0174*      add hl,de ; hl = dx^2/2+dy^2/2
046281             0175*  ; compute sqrt(dx^2/2+dy^2/2)
046281 CD 45 63 04 0176*      call sqrt168 ; uh.l = distance/2
046285             0177*      ; add hl,hl ; hl = distance
046285             0178*  ; ; check for overflow
046285             0179*  ; 	pop af ; get back the overflow flags
046285             0180*  ; 	sbc a,a ; will be -1 if overflow, 0 if not
046285             0181*  ; 	ld b,a ; save the overflow flag
046285             0182*  ; 	pop af ; get back the overflow flags
046285             0183*  ; 	sbc a,a ; will be -1 if overflow, 0 if not
046285             0184*  ; 	add a,b ; if a != 0 then we had overflow
046285             0185*  ;     ret z ; no overflow we're done
046285             0186*  ; @overflow:
046285             0187*  ; 	ld hl,0x7FFFFF ; max positive 16.8 fixed value indicates overflow
046285 C9          0188*  	ret
046286             0189*  @scratch: ds 6
04628C             0190*  dx168: ds 6
046292             0191*  dy168: ds 6
046298             0192*  
046298             0193*  ; atan2(ub.c,ud.e) --> uh.l
046298             0194*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
046298             0195*  ;   whether inputs are integers or fractional doesn't matter
046298             0196*  ;   so long as the sign bit of the upper byte is correct
046298             0197*  ; output: uh.l is the 16.8 fixed angle in degrees 256
046298             0198*  ; angles are COMPASS HEADINGS based on
046298             0199*  ; screen coordinate conventions,where the y axis is flipped
046298             0200*  ; #E0 315      0       45 #20
046298             0201*  ;        -x,-y | +x,-y
046298             0202*  ; #C0 270------+------ 90 #40
046298             0203*  ;        -x,+y | +x,+y
046298             0204*  ; #A0 225   180 #80   135 #60
046298             0205*  atan2_168game:
046298             0206*  ; get signs and make everything positive
046298             0207*  ; get abs(x) and store its original sign
046298 C5          0208*      push bc
046299 E1          0209*      pop hl
04629A CD 14 60 04 0210*      call abs_hlu ; if x was negative this also sets the sign flag
04629E E5          0211*      push hl ; store abs(x)
04629F C1          0212*      pop bc ; bc = abs(x)
0462A0 F5          0213*      push af ; store sign of x
0462A1             0214*  ; get abs(y) and store its original sign
0462A1 EB          0215*      ex de,hl ; hl = y
0462A2 CD 14 60 04 0216*      call abs_hlu ; if y was negative this also sets the sign flag
0462A6 EB          0217*      ex de,hl ; de = abs(y)
0462A7 F5          0218*      push af ; store sign of y
0462A8             0219*  ; if abs(bc) < abs(de),then we do bc/de,otherwise de/bc
0462A8             0220*  ; this ensures that our lookup value is between 0 and 1 inclusive
0462A8 AF          0221*      xor a ; clear the carry flag
0462A9 D5          0222*      push de
0462AA E1          0223*      pop hl
0462AB ED 42       0224*      sbc hl,bc
0462AD F5          0225*      push af ; save sign of de - bc
0462AE F2 B7 62 04 0226*      jp p,@1 ; bc <= de, so we skip ahead
0462B2             0227*  ; otherwise we swap bc and de
0462B2 C5          0228*      push bc
0462B3 E1          0229*      pop hl
0462B4 EB          0230*      ex de,hl
0462B5 E5          0231*      push hl
0462B6 C1          0232*      pop bc
0462B7             0233*  @1:
0462B7             0234*  ; now we're ready to snag our preliminary result
0462B7 CD 25 63 04 0235*      call atan_168game ; uh.l comes back with prelim result
0462BB             0236*  ; now we adjust uh.l based on sign of de - bc
0462BB F1          0237*      pop af
0462BC F2 C8 62 04 0238*      jp p,@2 ; bc <= de,so we skip ahead
0462C0 EB          0239*      ex de,hl
0462C1 21 00 40 00 0240*      ld hl,0x004000 ; 90 degrees
0462C5 AF          0241*      xor a ; clear the carry flag
0462C6 ED 52       0242*      sbc hl,de ; subtract result from 90 degrees
0462C8             0243*      ; ld de,0 ; prep to clear hlu
0462C8             0244*      ; ld d,h
0462C8             0245*      ; ld e,l
0462C8             0246*      ; ex de,hl ; now we have 0 <= uh.l < 256 in 16.8 fixed format
0462C8             0247*      ; fall through
0462C8             0248*  @2:
0462C8             0249*  ; now the fun part of adjusting the result
0462C8             0250*  ; based on which quadrant (x,y) is in
0462C8             0251*  ; #E0 315      0       45 #20
0462C8             0252*  ;        -x,-y | +x,-y
0462C8             0253*  ; #C0 270------+------ 90 #40
0462C8             0254*  ;        -x,+y | +x,+y
0462C8             0255*  ; #A0 225   180 #80   135 #60
0462C8 F1          0256*      pop af ; sign of y
0462C9 CA 06 63 04 0257*      jp z,@y_zero
0462CD F2 E6 62 04 0258*      jp p,@y_pos
0462D1             0259*  ; y neg,check x
0462D1 F1          0260*      pop af ; sign of x
0462D2 CA E0 62 04 0261*      jp z,@y_neg_x_zero
0462D6 F2 E5 62 04 0262*      jp p,@y_neg_x_pos
0462DA             0263*  ; y neg,x neg
0462DA             0264*  ; angle is 270-360
0462DA             0265*  ; negating the intermediate does the trick
0462DA CD 24 60 04 0266*      call neg_hlu
0462DE 18 31       0267*      jr @zero_hlu
0462E0             0268*  
0462E0             0269*  @y_neg_x_zero:
0462E0             0270*  ; y neg,x zero
0462E0             0271*  ; angle is 0
0462E0 21 00 00 00 0272*      ld hl,0
0462E4 C9          0273*      ret
0462E5             0274*  @y_neg_x_pos:
0462E5             0275*  ; y neg,x pos
0462E5             0276*  ; angle is 0 to 90
0462E5             0277*  ; so we're good
0462E5 C9          0278*      ret
0462E6             0279*  
0462E6             0280*  @y_pos:
0462E6 F1          0281*      pop af ; sign of x
0462E7 CA F6 62 04 0282*      jp z,@y_pos_x_zero
0462EB F2 FB 62 04 0283*      jp p,@y_pos_x_pos
0462EF             0284*  ; y pos,x neg
0462EF             0285*  ; angle is 180-270
0462EF             0286*  ; so we add 180 to intermediate
0462EF 11 00 80 00 0287*      ld de,0x008000
0462F3 19          0288*      add hl,de
0462F4 18 1B       0289*      jr @zero_hlu
0462F6             0290*  @y_pos_x_zero:
0462F6             0291*  ; y pos,x zero
0462F6             0292*  ; angle is 180
0462F6 21 00 80 00 0293*      ld hl,0x008000
0462FA C9          0294*      ret
0462FB             0295*  @y_pos_x_pos:
0462FB             0296*  ; y pos,x pos
0462FB             0297*  ; angle is 90-180
0462FB             0298*  ; neg the intermediate and add 180 degrees
0462FB CD 24 60 04 0299*      call neg_hlu
0462FF 11 00 80 00 0300*      ld de,0x008000
046303 19          0301*      add hl,de
046304 18 0B       0302*      jr @zero_hlu
046306             0303*  
046306             0304*  @y_zero:
046306 F1          0305*      pop af ; sign of x
046307 FA 0C 63 04 0306*      jp m,@y_zero_x_neg
04630B             0307*  ; y zero,x pos
04630B             0308*  ; angle is 90,nothing to do
04630B C9          0309*      ret
04630C             0310*  @y_zero_x_neg:
04630C             0311*  ; y zero ,x neg
04630C             0312*  ; angle is 270
04630C 21 00 C0 00 0313*      ld hl,0x00C000
046310 C9          0314*      ret
046311             0315*  @zero_hlu:
046311 AF          0316*      xor a
046312 22 1F 63 04 0317*      ld (@scratch),hl
046316 32 21 63 04 0318*      ld (@scratch+2),a
04631A 2A 1F 63 04 0319*      ld hl,(@scratch)
04631E C9          0320*      ret
04631F             0321*  @scratch: ds 6
046325             0322*  
046325             0323*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
046325             0324*  ; output: uh.l is the 16.8 fixed format angle
046325             0325*  ; destroys: a,hl,bc,de
046325             0326*  ; the following note was written by github copilot:
046325             0327*  ; note: this routine is a bit of a hack
046325             0328*  ;      but it works
046325             0329*  ;      and it's fast
046325             0330*  ;      and it's small
046325             0331*  ;      and it's accurate
046325             0332*  ;      and it's easy to understand
046325             0333*  ;      and it's easy to modify
046325             0334*  ;      and it's easy to use
046325             0335*  ;      and it's easy to remember
046325             0336*  ;      and it's easy to love
046325             0337*  ;      and it's easy to hate
046325             0338*  ;      and it's easy to ignore
046325             0339*  ;      and it's easy to forget
046325             0340*  ;      and it's easy to remember
046325             0341*  ;      and it's easy to forget
046325             0342*  ;      and it's easy to remember
046325             0343*  ;      (ok the bot is stuck in a loop)
046325             0344*  ; REAL NOTE: only works for angles from 0 to 45 degrees
046325             0345*  ;   use atan2_168 (which calls this proc) to handle the full 360 degrees
046325             0346*  atan_168game:
046325             0347*  ; because we use compass headings instead of geometric angles
046325             0348*  ; we compute dx/dy which is 1/tan(theta) in the maths world
046325             0349*  ; we can do faster unsigned division here because we know dx and dy are positive
046325 CD AB 5F 04 0350*  	call udiv168 ; uh.l = dx/dy
046329             0351*  ; ; TODO: IMPLEMENT THIS, RIGHT NOW IS IS BUGGED
046329             0352*  ; ; test uh.l for 0
046329             0353*  ;     add hl,de
046329             0354*  ;     or a
046329             0355*  ;     sbc hl,de
046329             0356*  ;     jr z,@is_zero
046329             0357*  ; ; test uh.l for 1
046329             0358*  ;     xor a ; clear carry
046329             0359*  ;     ex de,hl
046329             0360*  ;     ld hl,0x000100 ; 1 in 16.8 fixed format
046329             0361*  ;     sbc hl,de
046329             0362*  ;     jr z,@is_45
046329             0363*  ; ; END TODO
046329             0364*  
046329             0365*  ; no special cases so we move on
046329             0366*  ; l contains the fractional portion of tan(uh.l)
046329             0367*  ; we multiply it by three to get our lookup table index
046329 26 03       0368*      ld h,3
04632B ED 6C       0369*      mlt hl ; gosh that is handy
04632D 11 00 00 00 0370*      ld de,0 ; clear deu
046331 54          0371*      ld d,h ; copy hl to de
046332 5D          0372*      ld e,l ; de contains our index
046333 21 30 67 04 0373*      ld hl,atan_lut_168 ; grab the lut address
046337 19          0374*      add hl,de ; bump hl by the index
046338 ED 27       0375*      ld hl,(hl) ; don't try this on a z80!
04633A C9          0376*      ret ; and out
04633B             0377*  @is_45:
04633B 21 00 20 00 0378*      ld hl,0x002000 ; 45 degrees decimal
04633F C9          0379*      ret
046340             0380*  ; for the case tan(0)
046340             0381*  @is_zero:
046340 21 00 00 00 0382*      ld hl,0x000000
046344 C9          0383*      ret
046345             0384*  
046345             0385*  ; Expects  ADL mode
046345             0386*  ; Inputs:  UH.L
046345             0387*  ; Outputs: UH.L is the 16.8 square root
046345             0388*  ;          UD.E is the difference inputHL-DE^2
046345             0389*  ;          c flag reset
046345             0390*  sqrt168:
046345 CD 4F 63 04 0391*      call sqrt24
046349 EB          0392*      ex de,hl
04634A 29          0393*      add hl,hl
04634B 29          0394*      add hl,hl
04634C 29          0395*      add hl,hl
04634D 29          0396*      add hl,hl
04634E C9          0397*      ret
04634F             0398*  
04634F             0399*  ; Expects  ADL mode
04634F             0400*  ; Inputs:  HL
04634F             0401*  ; Outputs: DE is the integer square root
04634F             0402*  ;          HL is the difference inputHL-DE^2
04634F             0403*  ;          c flag reset
04634F             0404*  sqrt24:
04634F AF          0405*      xor a
046350 45          0406*      ld b,l
046351 C5          0407*      push bc
046352 47          0408*      ld b,a
046353 57          0409*      ld d,a
046354 4F          0410*      ld c,a
046355 6F          0411*      ld l,a
046356 5F          0412*      ld e,a
046357             0413*  
046357             0414*      ;Iteration 1
046357 29          0415*      add hl,hl
046358 CB 11       0416*      rl c
04635A 29          0417*      add hl,hl
04635B CB 11       0418*      rl c
04635D 91          0419*      sub c
04635E 30 04       0420*      jr nc,$+6
046360 1C          0421*      inc e
046361 1C          0422*      inc e
046362 2F          0423*      cpl
046363 4F          0424*      ld c,a
046364             0425*  
046364             0426*      ;Iteration 2
046364 29          0427*      add hl,hl
046365 CB 11       0428*      rl c
046367 29          0429*      add hl,hl
046368 CB 11       0430*      rl c
04636A CB 13       0431*      rl e
04636C 7B          0432*      ld a,e
04636D 91          0433*      sub c
04636E 30 04       0434*      jr nc,$+6
046370 1C          0435*      inc e
046371 1C          0436*      inc e
046372 2F          0437*      cpl
046373 4F          0438*      ld c,a
046374             0439*  
046374             0440*      ;Iteration 3
046374 29          0441*      add hl,hl
046375 CB 11       0442*      rl c
046377 29          0443*      add hl,hl
046378 CB 11       0444*      rl c
04637A CB 13       0445*      rl e
04637C 7B          0446*      ld a,e
04637D 91          0447*      sub c
04637E 30 04       0448*      jr nc,$+6
046380 1C          0449*      inc e
046381 1C          0450*      inc e
046382 2F          0451*      cpl
046383 4F          0452*      ld c,a
046384             0453*  
046384             0454*      ;Iteration 4
046384 29          0455*      add hl,hl
046385 CB 11       0456*      rl c
046387 29          0457*      add hl,hl
046388 CB 11       0458*      rl c
04638A CB 13       0459*      rl e
04638C 7B          0460*      ld a,e
04638D 91          0461*      sub c
04638E 30 04       0462*      jr nc,$+6
046390 1C          0463*      inc e
046391 1C          0464*      inc e
046392 2F          0465*      cpl
046393 4F          0466*      ld c,a
046394             0467*  
046394             0468*      ;Iteration 5
046394 29          0469*      add hl,hl
046395 CB 11       0470*      rl c
046397 29          0471*      add hl,hl
046398 CB 11       0472*      rl c
04639A CB 13       0473*      rl e
04639C 7B          0474*      ld a,e
04639D 91          0475*      sub c
04639E 30 04       0476*      jr nc,$+6
0463A0 1C          0477*      inc e
0463A1 1C          0478*      inc e
0463A2 2F          0479*      cpl
0463A3 4F          0480*      ld c,a
0463A4             0481*  
0463A4             0482*      ;Iteration 6
0463A4 29          0483*      add hl,hl
0463A5 CB 11       0484*      rl c
0463A7 29          0485*      add hl,hl
0463A8 CB 11       0486*      rl c
0463AA CB 13       0487*      rl e
0463AC 7B          0488*      ld a,e
0463AD 91          0489*      sub c
0463AE 30 04       0490*      jr nc,$+6
0463B0 1C          0491*      inc e
0463B1 1C          0492*      inc e
0463B2 2F          0493*      cpl
0463B3 4F          0494*      ld c,a
0463B4             0495*  
0463B4             0496*      ;Iteration 7
0463B4 29          0497*      add hl,hl
0463B5 CB 11       0498*      rl c
0463B7 29          0499*      add hl,hl
0463B8 CB 11       0500*      rl c
0463BA CB 10       0501*      rl b
0463BC EB          0502*      ex de,hl
0463BD 29          0503*      add hl,hl
0463BE E5          0504*      push hl
0463BF ED 42       0505*      sbc hl,bc
0463C1 30 06       0506*      jr nc,$+8
0463C3 7C          0507*      ld a,h
0463C4 2F          0508*      cpl
0463C5 47          0509*      ld b,a
0463C6 7D          0510*      ld a,l
0463C7 2F          0511*      cpl
0463C8 4F          0512*      ld c,a
0463C9 E1          0513*      pop hl
0463CA 30 02       0514*      jr nc,$+4
0463CC 23          0515*      inc hl
0463CD 23          0516*      inc hl
0463CE EB          0517*      ex de,hl
0463CF             0518*  
0463CF             0519*      ;Iteration 8
0463CF 29          0520*      add hl,hl
0463D0 69          0521*      ld l,c
0463D1 60          0522*      ld h,b
0463D2 ED 6A       0523*      adc hl,hl
0463D4 ED 6A       0524*      adc hl,hl
0463D6 EB          0525*      ex de,hl
0463D7 29          0526*      add hl,hl
0463D8 ED 52       0527*      sbc hl,de
0463DA 19          0528*      add hl,de
0463DB EB          0529*      ex de,hl
0463DC 30 04       0530*      jr nc,$+6
0463DE ED 52       0531*      sbc hl,de
0463E0 13          0532*      inc de
0463E1 13          0533*      inc de
0463E2             0534*  
0463E2             0535*      ;Iteration 9
0463E2 F1          0536*      pop af
0463E3 17          0537*      rla
0463E4 ED 6A       0538*      adc hl,hl
0463E6 17          0539*      rla
0463E7 ED 6A       0540*      adc hl,hl
0463E9 EB          0541*      ex de,hl
0463EA 29          0542*      add hl,hl
0463EB ED 52       0543*      sbc hl,de
0463ED 19          0544*      add hl,de
0463EE EB          0545*      ex de,hl
0463EF 30 04       0546*      jr nc,$+6
0463F1 ED 52       0547*      sbc hl,de
0463F3 13          0548*      inc de
0463F4 13          0549*      inc de
0463F5             0550*  
0463F5             0551*      ;Iteration 10
0463F5 17          0552*      rla
0463F6 ED 6A       0553*      adc hl,hl
0463F8 17          0554*      rla
0463F9 ED 6A       0555*      adc hl,hl
0463FB EB          0556*      ex de,hl
0463FC 29          0557*      add hl,hl
0463FD ED 52       0558*      sbc hl,de
0463FF 19          0559*      add hl,de
046400 EB          0560*      ex de,hl
046401 30 04       0561*      jr nc,$+6
046403 ED 52       0562*      sbc hl,de
046405 13          0563*      inc de
046406 13          0564*      inc de
046407             0565*  
046407             0566*      ;Iteration 11
046407 17          0567*      rla
046408 ED 6A       0568*      adc hl,hl
04640A 17          0569*      rla
04640B ED 6A       0570*      adc hl,hl
04640D EB          0571*      ex de,hl
04640E 29          0572*      add hl,hl
04640F ED 52       0573*      sbc hl,de
046411 19          0574*      add hl,de
046412 EB          0575*      ex de,hl
046413 30 04       0576*      jr nc,$+6
046415 ED 52       0577*      sbc hl,de
046417 13          0578*      inc de
046418 13          0579*      inc de
046419             0580*  
046419             0581*      ;Iteration 11
046419 17          0582*      rla
04641A ED 6A       0583*      adc hl,hl
04641C 17          0584*      rla
04641D ED 6A       0585*      adc hl,hl
04641F EB          0586*      ex de,hl
046420 29          0587*      add hl,hl
046421 ED 52       0588*      sbc hl,de
046423 19          0589*      add hl,de
046424 EB          0590*      ex de,hl
046425 30 04       0591*      jr nc,$+6
046427 ED 52       0592*      sbc hl,de
046429 13          0593*      inc de
04642A 13          0594*      inc de
04642B             0595*  
04642B CB 1A       0596*      rr d
04642D CB 1B       0597*      rr e
04642F C9          0598*      ret
046430             0599*  
046430             0600*  sin_lut_168:
046430 00 00 00    0601*  	dl 0x000000 ; 0.000 00, 0.000
046433 06 00 00    0602*  	dl 0x000006 ; 1.406 01, 0.025
046436 0C 00 00    0603*  	dl 0x00000C ; 2.813 02, 0.049
046439 12 00 00    0604*  	dl 0x000012 ; 4.219 03, 0.074
04643C 19 00 00    0605*  	dl 0x000019 ; 5.625 04, 0.098
04643F 1F 00 00    0606*  	dl 0x00001F ; 7.031 05, 0.122
046442 25 00 00    0607*  	dl 0x000025 ; 8.438 06, 0.147
046445 2B 00 00    0608*  	dl 0x00002B ; 9.844 07, 0.171
046448 31 00 00    0609*  	dl 0x000031 ; 11.250 08, 0.195
04644B 38 00 00    0610*  	dl 0x000038 ; 12.656 09, 0.219
04644E 3E 00 00    0611*  	dl 0x00003E ; 14.063 0A, 0.243
046451 44 00 00    0612*  	dl 0x000044 ; 15.469 0B, 0.267
046454 4A 00 00    0613*  	dl 0x00004A ; 16.875 0C, 0.290
046457 50 00 00    0614*  	dl 0x000050 ; 18.281 0D, 0.314
04645A 56 00 00    0615*  	dl 0x000056 ; 19.688 0E, 0.337
04645D 5C 00 00    0616*  	dl 0x00005C ; 21.094 0F, 0.360
046460 61 00 00    0617*  	dl 0x000061 ; 22.500 10, 0.383
046463 67 00 00    0618*  	dl 0x000067 ; 23.906 11, 0.405
046466 6D 00 00    0619*  	dl 0x00006D ; 25.313 12, 0.428
046469 73 00 00    0620*  	dl 0x000073 ; 26.719 13, 0.450
04646C 78 00 00    0621*  	dl 0x000078 ; 28.125 14, 0.471
04646F 7E 00 00    0622*  	dl 0x00007E ; 29.531 15, 0.493
046472 83 00 00    0623*  	dl 0x000083 ; 30.938 16, 0.514
046475 88 00 00    0624*  	dl 0x000088 ; 32.344 17, 0.535
046478 8E 00 00    0625*  	dl 0x00008E ; 33.750 18, 0.556
04647B 93 00 00    0626*  	dl 0x000093 ; 35.156 19, 0.576
04647E 98 00 00    0627*  	dl 0x000098 ; 36.563 1A, 0.596
046481 9D 00 00    0628*  	dl 0x00009D ; 37.969 1B, 0.615
046484 A2 00 00    0629*  	dl 0x0000A2 ; 39.375 1C, 0.634
046487 A7 00 00    0630*  	dl 0x0000A7 ; 40.781 1D, 0.653
04648A AB 00 00    0631*  	dl 0x0000AB ; 42.188 1E, 0.672
04648D B0 00 00    0632*  	dl 0x0000B0 ; 43.594 1F, 0.690
046490 B5 00 00    0633*  	dl 0x0000B5 ; 45.000 20, 0.707
046493 B9 00 00    0634*  	dl 0x0000B9 ; 46.406 21, 0.724
046496 BD 00 00    0635*  	dl 0x0000BD ; 47.813 22, 0.741
046499 C1 00 00    0636*  	dl 0x0000C1 ; 49.219 23, 0.757
04649C C5 00 00    0637*  	dl 0x0000C5 ; 50.625 24, 0.773
04649F C9 00 00    0638*  	dl 0x0000C9 ; 52.031 25, 0.788
0464A2 CD 00 00    0639*  	dl 0x0000CD ; 53.438 26, 0.803
0464A5 D1 00 00    0640*  	dl 0x0000D1 ; 54.844 27, 0.818
0464A8 D4 00 00    0641*  	dl 0x0000D4 ; 56.250 28, 0.831
0464AB D8 00 00    0642*  	dl 0x0000D8 ; 57.656 29, 0.845
0464AE DB 00 00    0643*  	dl 0x0000DB ; 59.063 2A, 0.858
0464B1 DE 00 00    0644*  	dl 0x0000DE ; 60.469 2B, 0.870
0464B4 E1 00 00    0645*  	dl 0x0000E1 ; 61.875 2C, 0.882
0464B7 E4 00 00    0646*  	dl 0x0000E4 ; 63.281 2D, 0.893
0464BA E7 00 00    0647*  	dl 0x0000E7 ; 64.688 2E, 0.904
0464BD EA 00 00    0648*  	dl 0x0000EA ; 66.094 2F, 0.914
0464C0 EC 00 00    0649*  	dl 0x0000EC ; 67.500 30, 0.924
0464C3 EE 00 00    0650*  	dl 0x0000EE ; 68.906 31, 0.933
0464C6 F1 00 00    0651*  	dl 0x0000F1 ; 70.313 32, 0.942
0464C9 F3 00 00    0652*  	dl 0x0000F3 ; 71.719 33, 0.950
0464CC F4 00 00    0653*  	dl 0x0000F4 ; 73.125 34, 0.957
0464CF F6 00 00    0654*  	dl 0x0000F6 ; 74.531 35, 0.964
0464D2 F8 00 00    0655*  	dl 0x0000F8 ; 75.938 36, 0.970
0464D5 F9 00 00    0656*  	dl 0x0000F9 ; 77.344 37, 0.976
0464D8 FB 00 00    0657*  	dl 0x0000FB ; 78.750 38, 0.981
0464DB FC 00 00    0658*  	dl 0x0000FC ; 80.156 39, 0.985
0464DE FD 00 00    0659*  	dl 0x0000FD ; 81.563 3A, 0.989
0464E1 FE 00 00    0660*  	dl 0x0000FE ; 82.969 3B, 0.992
0464E4 FE 00 00    0661*  	dl 0x0000FE ; 84.375 3C, 0.995
0464E7 FF 00 00    0662*  	dl 0x0000FF ; 85.781 3D, 0.997
0464EA FF 00 00    0663*  	dl 0x0000FF ; 87.188 3E, 0.999
0464ED FF 00 00    0664*  	dl 0x0000FF ; 88.594 3F, 1.000
0464F0 00 01 00    0665*  	dl 0x000100 ; 90.000 40, 1.000
0464F3 FF 00 00    0666*  	dl 0x0000FF ; 91.406 41, 1.000
0464F6 FF 00 00    0667*  	dl 0x0000FF ; 92.813 42, 0.999
0464F9 FF 00 00    0668*  	dl 0x0000FF ; 94.219 43, 0.997
0464FC FE 00 00    0669*  	dl 0x0000FE ; 95.625 44, 0.995
0464FF FE 00 00    0670*  	dl 0x0000FE ; 97.031 45, 0.992
046502 FD 00 00    0671*  	dl 0x0000FD ; 98.438 46, 0.989
046505 FC 00 00    0672*  	dl 0x0000FC ; 99.844 47, 0.985
046508 FB 00 00    0673*  	dl 0x0000FB ; 101.250 48, 0.981
04650B F9 00 00    0674*  	dl 0x0000F9 ; 102.656 49, 0.976
04650E F8 00 00    0675*  	dl 0x0000F8 ; 104.063 4A, 0.970
046511 F6 00 00    0676*  	dl 0x0000F6 ; 105.469 4B, 0.964
046514 F4 00 00    0677*  	dl 0x0000F4 ; 106.875 4C, 0.957
046517 F3 00 00    0678*  	dl 0x0000F3 ; 108.281 4D, 0.950
04651A F1 00 00    0679*  	dl 0x0000F1 ; 109.688 4E, 0.942
04651D EE 00 00    0680*  	dl 0x0000EE ; 111.094 4F, 0.933
046520 EC 00 00    0681*  	dl 0x0000EC ; 112.500 50, 0.924
046523 EA 00 00    0682*  	dl 0x0000EA ; 113.906 51, 0.914
046526 E7 00 00    0683*  	dl 0x0000E7 ; 115.313 52, 0.904
046529 E4 00 00    0684*  	dl 0x0000E4 ; 116.719 53, 0.893
04652C E1 00 00    0685*  	dl 0x0000E1 ; 118.125 54, 0.882
04652F DE 00 00    0686*  	dl 0x0000DE ; 119.531 55, 0.870
046532 DB 00 00    0687*  	dl 0x0000DB ; 120.938 56, 0.858
046535 D8 00 00    0688*  	dl 0x0000D8 ; 122.344 57, 0.845
046538 D4 00 00    0689*  	dl 0x0000D4 ; 123.750 58, 0.831
04653B D1 00 00    0690*  	dl 0x0000D1 ; 125.156 59, 0.818
04653E CD 00 00    0691*  	dl 0x0000CD ; 126.563 5A, 0.803
046541 C9 00 00    0692*  	dl 0x0000C9 ; 127.969 5B, 0.788
046544 C5 00 00    0693*  	dl 0x0000C5 ; 129.375 5C, 0.773
046547 C1 00 00    0694*  	dl 0x0000C1 ; 130.781 5D, 0.757
04654A BD 00 00    0695*  	dl 0x0000BD ; 132.188 5E, 0.741
04654D B9 00 00    0696*  	dl 0x0000B9 ; 133.594 5F, 0.724
046550 B5 00 00    0697*  	dl 0x0000B5 ; 135.000 60, 0.707
046553 B0 00 00    0698*  	dl 0x0000B0 ; 136.406 61, 0.690
046556 AB 00 00    0699*  	dl 0x0000AB ; 137.813 62, 0.672
046559 A7 00 00    0700*  	dl 0x0000A7 ; 139.219 63, 0.653
04655C A2 00 00    0701*  	dl 0x0000A2 ; 140.625 64, 0.634
04655F 9D 00 00    0702*  	dl 0x00009D ; 142.031 65, 0.615
046562 98 00 00    0703*  	dl 0x000098 ; 143.438 66, 0.596
046565 93 00 00    0704*  	dl 0x000093 ; 144.844 67, 0.576
046568 8E 00 00    0705*  	dl 0x00008E ; 146.250 68, 0.556
04656B 88 00 00    0706*  	dl 0x000088 ; 147.656 69, 0.535
04656E 83 00 00    0707*  	dl 0x000083 ; 149.063 6A, 0.514
046571 7E 00 00    0708*  	dl 0x00007E ; 150.469 6B, 0.493
046574 78 00 00    0709*  	dl 0x000078 ; 151.875 6C, 0.471
046577 73 00 00    0710*  	dl 0x000073 ; 153.281 6D, 0.450
04657A 6D 00 00    0711*  	dl 0x00006D ; 154.688 6E, 0.428
04657D 67 00 00    0712*  	dl 0x000067 ; 156.094 6F, 0.405
046580 61 00 00    0713*  	dl 0x000061 ; 157.500 70, 0.383
046583 5C 00 00    0714*  	dl 0x00005C ; 158.906 71, 0.360
046586 56 00 00    0715*  	dl 0x000056 ; 160.313 72, 0.337
046589 50 00 00    0716*  	dl 0x000050 ; 161.719 73, 0.314
04658C 4A 00 00    0717*  	dl 0x00004A ; 163.125 74, 0.290
04658F 44 00 00    0718*  	dl 0x000044 ; 164.531 75, 0.267
046592 3E 00 00    0719*  	dl 0x00003E ; 165.938 76, 0.243
046595 38 00 00    0720*  	dl 0x000038 ; 167.344 77, 0.219
046598 31 00 00    0721*  	dl 0x000031 ; 168.750 78, 0.195
04659B 2B 00 00    0722*  	dl 0x00002B ; 170.156 79, 0.171
04659E 25 00 00    0723*  	dl 0x000025 ; 171.563 7A, 0.147
0465A1 1F 00 00    0724*  	dl 0x00001F ; 172.969 7B, 0.122
0465A4 19 00 00    0725*  	dl 0x000019 ; 174.375 7C, 0.098
0465A7 12 00 00    0726*  	dl 0x000012 ; 175.781 7D, 0.074
0465AA 0C 00 00    0727*  	dl 0x00000C ; 177.188 7E, 0.049
0465AD 06 00 00    0728*  	dl 0x000006 ; 178.594 7F, 0.025
0465B0 00 00 00    0729*  	dl 0x000000 ; 180.000 80, 0.000
0465B3 FA FF FF    0730*  	dl 0xFFFFFA ; 181.406 81, -0.025
0465B6 F4 FF FF    0731*  	dl 0xFFFFF4 ; 182.813 82, -0.049
0465B9 EE FF FF    0732*  	dl 0xFFFFEE ; 184.219 83, -0.074
0465BC E7 FF FF    0733*  	dl 0xFFFFE7 ; 185.625 84, -0.098
0465BF E1 FF FF    0734*  	dl 0xFFFFE1 ; 187.031 85, -0.122
0465C2 DB FF FF    0735*  	dl 0xFFFFDB ; 188.438 86, -0.147
0465C5 D5 FF FF    0736*  	dl 0xFFFFD5 ; 189.844 87, -0.171
0465C8 CF FF FF    0737*  	dl 0xFFFFCF ; 191.250 88, -0.195
0465CB C8 FF FF    0738*  	dl 0xFFFFC8 ; 192.656 89, -0.219
0465CE C2 FF FF    0739*  	dl 0xFFFFC2 ; 194.063 8A, -0.243
0465D1 BC FF FF    0740*  	dl 0xFFFFBC ; 195.469 8B, -0.267
0465D4 B6 FF FF    0741*  	dl 0xFFFFB6 ; 196.875 8C, -0.290
0465D7 B0 FF FF    0742*  	dl 0xFFFFB0 ; 198.281 8D, -0.314
0465DA AA FF FF    0743*  	dl 0xFFFFAA ; 199.688 8E, -0.337
0465DD A4 FF FF    0744*  	dl 0xFFFFA4 ; 201.094 8F, -0.360
0465E0 9F FF FF    0745*  	dl 0xFFFF9F ; 202.500 90, -0.383
0465E3 99 FF FF    0746*  	dl 0xFFFF99 ; 203.906 91, -0.405
0465E6 93 FF FF    0747*  	dl 0xFFFF93 ; 205.313 92, -0.428
0465E9 8D FF FF    0748*  	dl 0xFFFF8D ; 206.719 93, -0.450
0465EC 88 FF FF    0749*  	dl 0xFFFF88 ; 208.125 94, -0.471
0465EF 82 FF FF    0750*  	dl 0xFFFF82 ; 209.531 95, -0.493
0465F2 7D FF FF    0751*  	dl 0xFFFF7D ; 210.938 96, -0.514
0465F5 78 FF FF    0752*  	dl 0xFFFF78 ; 212.344 97, -0.535
0465F8 72 FF FF    0753*  	dl 0xFFFF72 ; 213.750 98, -0.556
0465FB 6D FF FF    0754*  	dl 0xFFFF6D ; 215.156 99, -0.576
0465FE 68 FF FF    0755*  	dl 0xFFFF68 ; 216.563 9A, -0.596
046601 63 FF FF    0756*  	dl 0xFFFF63 ; 217.969 9B, -0.615
046604 5E FF FF    0757*  	dl 0xFFFF5E ; 219.375 9C, -0.634
046607 59 FF FF    0758*  	dl 0xFFFF59 ; 220.781 9D, -0.653
04660A 55 FF FF    0759*  	dl 0xFFFF55 ; 222.188 9E, -0.672
04660D 50 FF FF    0760*  	dl 0xFFFF50 ; 223.594 9F, -0.690
046610 4B FF FF    0761*  	dl 0xFFFF4B ; 225.000 A0, -0.707
046613 47 FF FF    0762*  	dl 0xFFFF47 ; 226.406 A1, -0.724
046616 43 FF FF    0763*  	dl 0xFFFF43 ; 227.813 A2, -0.741
046619 3F FF FF    0764*  	dl 0xFFFF3F ; 229.219 A3, -0.757
04661C 3B FF FF    0765*  	dl 0xFFFF3B ; 230.625 A4, -0.773
04661F 37 FF FF    0766*  	dl 0xFFFF37 ; 232.031 A5, -0.788
046622 33 FF FF    0767*  	dl 0xFFFF33 ; 233.438 A6, -0.803
046625 2F FF FF    0768*  	dl 0xFFFF2F ; 234.844 A7, -0.818
046628 2C FF FF    0769*  	dl 0xFFFF2C ; 236.250 A8, -0.831
04662B 28 FF FF    0770*  	dl 0xFFFF28 ; 237.656 A9, -0.845
04662E 25 FF FF    0771*  	dl 0xFFFF25 ; 239.063 AA, -0.858
046631 22 FF FF    0772*  	dl 0xFFFF22 ; 240.469 AB, -0.870
046634 1F FF FF    0773*  	dl 0xFFFF1F ; 241.875 AC, -0.882
046637 1C FF FF    0774*  	dl 0xFFFF1C ; 243.281 AD, -0.893
04663A 19 FF FF    0775*  	dl 0xFFFF19 ; 244.688 AE, -0.904
04663D 16 FF FF    0776*  	dl 0xFFFF16 ; 246.094 AF, -0.914
046640 14 FF FF    0777*  	dl 0xFFFF14 ; 247.500 B0, -0.924
046643 12 FF FF    0778*  	dl 0xFFFF12 ; 248.906 B1, -0.933
046646 0F FF FF    0779*  	dl 0xFFFF0F ; 250.313 B2, -0.942
046649 0D FF FF    0780*  	dl 0xFFFF0D ; 251.719 B3, -0.950
04664C 0C FF FF    0781*  	dl 0xFFFF0C ; 253.125 B4, -0.957
04664F 0A FF FF    0782*  	dl 0xFFFF0A ; 254.531 B5, -0.964
046652 08 FF FF    0783*  	dl 0xFFFF08 ; 255.938 B6, -0.970
046655 07 FF FF    0784*  	dl 0xFFFF07 ; 257.344 B7, -0.976
046658 05 FF FF    0785*  	dl 0xFFFF05 ; 258.750 B8, -0.981
04665B 04 FF FF    0786*  	dl 0xFFFF04 ; 260.156 B9, -0.985
04665E 03 FF FF    0787*  	dl 0xFFFF03 ; 261.563 BA, -0.989
046661 02 FF FF    0788*  	dl 0xFFFF02 ; 262.969 BB, -0.992
046664 02 FF FF    0789*  	dl 0xFFFF02 ; 264.375 BC, -0.995
046667 01 FF FF    0790*  	dl 0xFFFF01 ; 265.781 BD, -0.997
04666A 01 FF FF    0791*  	dl 0xFFFF01 ; 267.188 BE, -0.999
04666D 01 FF FF    0792*  	dl 0xFFFF01 ; 268.594 BF, -1.000
046670 00 FF FF    0793*  	dl 0xFFFF00 ; 270.000 C0, -1.000
046673 01 FF FF    0794*  	dl 0xFFFF01 ; 271.406 C1, -1.000
046676 01 FF FF    0795*  	dl 0xFFFF01 ; 272.813 C2, -0.999
046679 01 FF FF    0796*  	dl 0xFFFF01 ; 274.219 C3, -0.997
04667C 02 FF FF    0797*  	dl 0xFFFF02 ; 275.625 C4, -0.995
04667F 02 FF FF    0798*  	dl 0xFFFF02 ; 277.031 C5, -0.992
046682 03 FF FF    0799*  	dl 0xFFFF03 ; 278.438 C6, -0.989
046685 04 FF FF    0800*  	dl 0xFFFF04 ; 279.844 C7, -0.985
046688 05 FF FF    0801*  	dl 0xFFFF05 ; 281.250 C8, -0.981
04668B 07 FF FF    0802*  	dl 0xFFFF07 ; 282.656 C9, -0.976
04668E 08 FF FF    0803*  	dl 0xFFFF08 ; 284.063 CA, -0.970
046691 0A FF FF    0804*  	dl 0xFFFF0A ; 285.469 CB, -0.964
046694 0C FF FF    0805*  	dl 0xFFFF0C ; 286.875 CC, -0.957
046697 0D FF FF    0806*  	dl 0xFFFF0D ; 288.281 CD, -0.950
04669A 0F FF FF    0807*  	dl 0xFFFF0F ; 289.688 CE, -0.942
04669D 12 FF FF    0808*  	dl 0xFFFF12 ; 291.094 CF, -0.933
0466A0 14 FF FF    0809*  	dl 0xFFFF14 ; 292.500 D0, -0.924
0466A3 16 FF FF    0810*  	dl 0xFFFF16 ; 293.906 D1, -0.914
0466A6 19 FF FF    0811*  	dl 0xFFFF19 ; 295.313 D2, -0.904
0466A9 1C FF FF    0812*  	dl 0xFFFF1C ; 296.719 D3, -0.893
0466AC 1F FF FF    0813*  	dl 0xFFFF1F ; 298.125 D4, -0.882
0466AF 22 FF FF    0814*  	dl 0xFFFF22 ; 299.531 D5, -0.870
0466B2 25 FF FF    0815*  	dl 0xFFFF25 ; 300.938 D6, -0.858
0466B5 28 FF FF    0816*  	dl 0xFFFF28 ; 302.344 D7, -0.845
0466B8 2C FF FF    0817*  	dl 0xFFFF2C ; 303.750 D8, -0.831
0466BB 2F FF FF    0818*  	dl 0xFFFF2F ; 305.156 D9, -0.818
0466BE 33 FF FF    0819*  	dl 0xFFFF33 ; 306.563 DA, -0.803
0466C1 37 FF FF    0820*  	dl 0xFFFF37 ; 307.969 DB, -0.788
0466C4 3B FF FF    0821*  	dl 0xFFFF3B ; 309.375 DC, -0.773
0466C7 3F FF FF    0822*  	dl 0xFFFF3F ; 310.781 DD, -0.757
0466CA 43 FF FF    0823*  	dl 0xFFFF43 ; 312.188 DE, -0.741
0466CD 47 FF FF    0824*  	dl 0xFFFF47 ; 313.594 DF, -0.724
0466D0 4B FF FF    0825*  	dl 0xFFFF4B ; 315.000 E0, -0.707
0466D3 50 FF FF    0826*  	dl 0xFFFF50 ; 316.406 E1, -0.690
0466D6 55 FF FF    0827*  	dl 0xFFFF55 ; 317.813 E2, -0.672
0466D9 59 FF FF    0828*  	dl 0xFFFF59 ; 319.219 E3, -0.653
0466DC 5E FF FF    0829*  	dl 0xFFFF5E ; 320.625 E4, -0.634
0466DF 63 FF FF    0830*  	dl 0xFFFF63 ; 322.031 E5, -0.615
0466E2 68 FF FF    0831*  	dl 0xFFFF68 ; 323.438 E6, -0.596
0466E5 6D FF FF    0832*  	dl 0xFFFF6D ; 324.844 E7, -0.576
0466E8 72 FF FF    0833*  	dl 0xFFFF72 ; 326.250 E8, -0.556
0466EB 78 FF FF    0834*  	dl 0xFFFF78 ; 327.656 E9, -0.535
0466EE 7D FF FF    0835*  	dl 0xFFFF7D ; 329.063 EA, -0.514
0466F1 82 FF FF    0836*  	dl 0xFFFF82 ; 330.469 EB, -0.493
0466F4 88 FF FF    0837*  	dl 0xFFFF88 ; 331.875 EC, -0.471
0466F7 8D FF FF    0838*  	dl 0xFFFF8D ; 333.281 ED, -0.450
0466FA 93 FF FF    0839*  	dl 0xFFFF93 ; 334.688 EE, -0.428
0466FD 99 FF FF    0840*  	dl 0xFFFF99 ; 336.094 EF, -0.405
046700 9F FF FF    0841*  	dl 0xFFFF9F ; 337.500 F0, -0.383
046703 A4 FF FF    0842*  	dl 0xFFFFA4 ; 338.906 F1, -0.360
046706 AA FF FF    0843*  	dl 0xFFFFAA ; 340.313 F2, -0.337
046709 B0 FF FF    0844*  	dl 0xFFFFB0 ; 341.719 F3, -0.314
04670C B6 FF FF    0845*  	dl 0xFFFFB6 ; 343.125 F4, -0.290
04670F BC FF FF    0846*  	dl 0xFFFFBC ; 344.531 F5, -0.267
046712 C2 FF FF    0847*  	dl 0xFFFFC2 ; 345.938 F6, -0.243
046715 C8 FF FF    0848*  	dl 0xFFFFC8 ; 347.344 F7, -0.219
046718 CF FF FF    0849*  	dl 0xFFFFCF ; 348.750 F8, -0.195
04671B D5 FF FF    0850*  	dl 0xFFFFD5 ; 350.156 F9, -0.171
04671E DB FF FF    0851*  	dl 0xFFFFDB ; 351.563 FA, -0.147
046721 E1 FF FF    0852*  	dl 0xFFFFE1 ; 352.969 FB, -0.122
046724 E7 FF FF    0853*  	dl 0xFFFFE7 ; 354.375 FC, -0.098
046727 EE FF FF    0854*  	dl 0xFFFFEE ; 355.781 FD, -0.074
04672A F4 FF FF    0855*  	dl 0xFFFFF4 ; 357.188 FE, -0.049
04672D FA FF FF    0856*  	dl 0xFFFFFA ; 358.594 FF, -0.025
046730             0857*  
046730             0858*  atan_lut_168:
046730 00 00 00    0859*  	dl 0x000000 ; 000000, 0.000
046733 28 00 00    0860*  	dl 0x000028 ; 000001, 0.224
046736 51 00 00    0861*  	dl 0x000051 ; 000002, 0.448
046739 7A 00 00    0862*  	dl 0x00007A ; 000003, 0.671
04673C A2 00 00    0863*  	dl 0x0000A2 ; 000004, 0.895
04673F CB 00 00    0864*  	dl 0x0000CB ; 000005, 1.119
046742 F4 00 00    0865*  	dl 0x0000F4 ; 000006, 1.343
046745 1D 01 00    0866*  	dl 0x00011D ; 000007, 1.566
046748 45 01 00    0867*  	dl 0x000145 ; 000008, 1.790
04674B 6E 01 00    0868*  	dl 0x00016E ; 000009, 2.013
04674E 97 01 00    0869*  	dl 0x000197 ; 00000A, 2.237
046751 BF 01 00    0870*  	dl 0x0001BF ; 00000B, 2.460
046754 E8 01 00    0871*  	dl 0x0001E8 ; 00000C, 2.684
046757 11 02 00    0872*  	dl 0x000211 ; 00000D, 2.907
04675A 39 02 00    0873*  	dl 0x000239 ; 00000E, 3.130
04675D 62 02 00    0874*  	dl 0x000262 ; 00000F, 3.353
046760 8B 02 00    0875*  	dl 0x00028B ; 000010, 3.576
046763 B3 02 00    0876*  	dl 0x0002B3 ; 000011, 3.799
046766 DC 02 00    0877*  	dl 0x0002DC ; 000012, 4.022
046769 04 03 00    0878*  	dl 0x000304 ; 000013, 4.245
04676C 2D 03 00    0879*  	dl 0x00032D ; 000014, 4.467
04676F 55 03 00    0880*  	dl 0x000355 ; 000015, 4.690
046772 7E 03 00    0881*  	dl 0x00037E ; 000016, 4.912
046775 A6 03 00    0882*  	dl 0x0003A6 ; 000017, 5.134
046778 CE 03 00    0883*  	dl 0x0003CE ; 000018, 5.356
04677B F7 03 00    0884*  	dl 0x0003F7 ; 000019, 5.578
04677E 1F 04 00    0885*  	dl 0x00041F ; 00001A, 5.799
046781 48 04 00    0886*  	dl 0x000448 ; 00001B, 6.021
046784 70 04 00    0887*  	dl 0x000470 ; 00001C, 6.242
046787 98 04 00    0888*  	dl 0x000498 ; 00001D, 6.463
04678A C0 04 00    0889*  	dl 0x0004C0 ; 00001E, 6.684
04678D E8 04 00    0890*  	dl 0x0004E8 ; 00001F, 6.905
046790 11 05 00    0891*  	dl 0x000511 ; 000020, 7.125
046793 39 05 00    0892*  	dl 0x000539 ; 000021, 7.345
046796 61 05 00    0893*  	dl 0x000561 ; 000022, 7.565
046799 89 05 00    0894*  	dl 0x000589 ; 000023, 7.785
04679C B1 05 00    0895*  	dl 0x0005B1 ; 000024, 8.005
04679F D9 05 00    0896*  	dl 0x0005D9 ; 000025, 8.224
0467A2 01 06 00    0897*  	dl 0x000601 ; 000026, 8.443
0467A5 28 06 00    0898*  	dl 0x000628 ; 000027, 8.662
0467A8 50 06 00    0899*  	dl 0x000650 ; 000028, 8.881
0467AB 78 06 00    0900*  	dl 0x000678 ; 000029, 9.099
0467AE A0 06 00    0901*  	dl 0x0006A0 ; 00002A, 9.317
0467B1 C7 06 00    0902*  	dl 0x0006C7 ; 00002B, 9.535
0467B4 EF 06 00    0903*  	dl 0x0006EF ; 00002C, 9.752
0467B7 16 07 00    0904*  	dl 0x000716 ; 00002D, 9.970
0467BA 3E 07 00    0905*  	dl 0x00073E ; 00002E, 10.187
0467BD 65 07 00    0906*  	dl 0x000765 ; 00002F, 10.403
0467C0 8D 07 00    0907*  	dl 0x00078D ; 000030, 10.620
0467C3 B4 07 00    0908*  	dl 0x0007B4 ; 000031, 10.836
0467C6 DB 07 00    0909*  	dl 0x0007DB ; 000032, 11.051
0467C9 03 08 00    0910*  	dl 0x000803 ; 000033, 11.267
0467CC 2A 08 00    0911*  	dl 0x00082A ; 000034, 11.482
0467CF 51 08 00    0912*  	dl 0x000851 ; 000035, 11.697
0467D2 78 08 00    0913*  	dl 0x000878 ; 000036, 11.911
0467D5 9F 08 00    0914*  	dl 0x00089F ; 000037, 12.125
0467D8 C6 08 00    0915*  	dl 0x0008C6 ; 000038, 12.339
0467DB ED 08 00    0916*  	dl 0x0008ED ; 000039, 12.553
0467DE 13 09 00    0917*  	dl 0x000913 ; 00003A, 12.766
0467E1 3A 09 00    0918*  	dl 0x00093A ; 00003B, 12.978
0467E4 61 09 00    0919*  	dl 0x000961 ; 00003C, 13.191
0467E7 87 09 00    0920*  	dl 0x000987 ; 00003D, 13.403
0467EA AE 09 00    0921*  	dl 0x0009AE ; 00003E, 13.614
0467ED D4 09 00    0922*  	dl 0x0009D4 ; 00003F, 13.825
0467F0 FB 09 00    0923*  	dl 0x0009FB ; 000040, 14.036
0467F3 21 0A 00    0924*  	dl 0x000A21 ; 000041, 14.247
0467F6 47 0A 00    0925*  	dl 0x000A47 ; 000042, 14.457
0467F9 6D 0A 00    0926*  	dl 0x000A6D ; 000043, 14.666
0467FC 94 0A 00    0927*  	dl 0x000A94 ; 000044, 14.876
0467FF BA 0A 00    0928*  	dl 0x000ABA ; 000045, 15.085
046802 E0 0A 00    0929*  	dl 0x000AE0 ; 000046, 15.293
046805 05 0B 00    0930*  	dl 0x000B05 ; 000047, 15.501
046808 2B 0B 00    0931*  	dl 0x000B2B ; 000048, 15.709
04680B 51 0B 00    0932*  	dl 0x000B51 ; 000049, 15.916
04680E 77 0B 00    0933*  	dl 0x000B77 ; 00004A, 16.123
046811 9C 0B 00    0934*  	dl 0x000B9C ; 00004B, 16.329
046814 C2 0B 00    0935*  	dl 0x000BC2 ; 00004C, 16.535
046817 E7 0B 00    0936*  	dl 0x000BE7 ; 00004D, 16.740
04681A 0C 0C 00    0937*  	dl 0x000C0C ; 00004E, 16.945
04681D 32 0C 00    0938*  	dl 0x000C32 ; 00004F, 17.150
046820 57 0C 00    0939*  	dl 0x000C57 ; 000050, 17.354
046823 7C 0C 00    0940*  	dl 0x000C7C ; 000051, 17.558
046826 A1 0C 00    0941*  	dl 0x000CA1 ; 000052, 17.761
046829 C6 0C 00    0942*  	dl 0x000CC6 ; 000053, 17.964
04682C EB 0C 00    0943*  	dl 0x000CEB ; 000054, 18.166
04682F 0F 0D 00    0944*  	dl 0x000D0F ; 000055, 18.368
046832 34 0D 00    0945*  	dl 0x000D34 ; 000056, 18.569
046835 58 0D 00    0946*  	dl 0x000D58 ; 000057, 18.770
046838 7D 0D 00    0947*  	dl 0x000D7D ; 000058, 18.970
04683B A1 0D 00    0948*  	dl 0x000DA1 ; 000059, 19.170
04683E C6 0D 00    0949*  	dl 0x000DC6 ; 00005A, 19.370
046841 EA 0D 00    0950*  	dl 0x000DEA ; 00005B, 19.569
046844 0E 0E 00    0951*  	dl 0x000E0E ; 00005C, 19.767
046847 32 0E 00    0952*  	dl 0x000E32 ; 00005D, 19.965
04684A 56 0E 00    0953*  	dl 0x000E56 ; 00005E, 20.163
04684D 7A 0E 00    0954*  	dl 0x000E7A ; 00005F, 20.360
046850 9E 0E 00    0955*  	dl 0x000E9E ; 000060, 20.556
046853 C1 0E 00    0956*  	dl 0x000EC1 ; 000061, 20.752
046856 E5 0E 00    0957*  	dl 0x000EE5 ; 000062, 20.947
046859 08 0F 00    0958*  	dl 0x000F08 ; 000063, 21.142
04685C 2C 0F 00    0959*  	dl 0x000F2C ; 000064, 21.337
04685F 4F 0F 00    0960*  	dl 0x000F4F ; 000065, 21.531
046862 72 0F 00    0961*  	dl 0x000F72 ; 000066, 21.724
046865 95 0F 00    0962*  	dl 0x000F95 ; 000067, 21.917
046868 B8 0F 00    0963*  	dl 0x000FB8 ; 000068, 22.109
04686B DB 0F 00    0964*  	dl 0x000FDB ; 000069, 22.301
04686E FE 0F 00    0965*  	dl 0x000FFE ; 00006A, 22.493
046871 21 10 00    0966*  	dl 0x001021 ; 00006B, 22.683
046874 44 10 00    0967*  	dl 0x001044 ; 00006C, 22.874
046877 66 10 00    0968*  	dl 0x001066 ; 00006D, 23.063
04687A 89 10 00    0969*  	dl 0x001089 ; 00006E, 23.253
04687D AB 10 00    0970*  	dl 0x0010AB ; 00006F, 23.441
046880 CD 10 00    0971*  	dl 0x0010CD ; 000070, 23.629
046883 EF 10 00    0972*  	dl 0x0010EF ; 000071, 23.817
046886 11 11 00    0973*  	dl 0x001111 ; 000072, 24.004
046889 33 11 00    0974*  	dl 0x001133 ; 000073, 24.191
04688C 55 11 00    0975*  	dl 0x001155 ; 000074, 24.376
04688F 77 11 00    0976*  	dl 0x001177 ; 000075, 24.562
046892 99 11 00    0977*  	dl 0x001199 ; 000076, 24.747
046895 BA 11 00    0978*  	dl 0x0011BA ; 000077, 24.931
046898 DC 11 00    0979*  	dl 0x0011DC ; 000078, 25.115
04689B FD 11 00    0980*  	dl 0x0011FD ; 000079, 25.298
04689E 1E 12 00    0981*  	dl 0x00121E ; 00007A, 25.481
0468A1 3F 12 00    0982*  	dl 0x00123F ; 00007B, 25.663
0468A4 60 12 00    0983*  	dl 0x001260 ; 00007C, 25.844
0468A7 81 12 00    0984*  	dl 0x001281 ; 00007D, 26.025
0468AA A2 12 00    0985*  	dl 0x0012A2 ; 00007E, 26.206
0468AD C3 12 00    0986*  	dl 0x0012C3 ; 00007F, 26.386
0468B0 E4 12 00    0987*  	dl 0x0012E4 ; 000080, 26.565
0468B3 04 13 00    0988*  	dl 0x001304 ; 000081, 26.744
0468B6 25 13 00    0989*  	dl 0x001325 ; 000082, 26.922
0468B9 45 13 00    0990*  	dl 0x001345 ; 000083, 27.100
0468BC 65 13 00    0991*  	dl 0x001365 ; 000084, 27.277
0468BF 85 13 00    0992*  	dl 0x001385 ; 000085, 27.453
0468C2 A5 13 00    0993*  	dl 0x0013A5 ; 000086, 27.629
0468C5 C5 13 00    0994*  	dl 0x0013C5 ; 000087, 27.805
0468C8 E5 13 00    0995*  	dl 0x0013E5 ; 000088, 27.979
0468CB 05 14 00    0996*  	dl 0x001405 ; 000089, 28.154
0468CE 24 14 00    0997*  	dl 0x001424 ; 00008A, 28.327
0468D1 44 14 00    0998*  	dl 0x001444 ; 00008B, 28.501
0468D4 63 14 00    0999*  	dl 0x001463 ; 00008C, 28.673
0468D7 83 14 00    1000*  	dl 0x001483 ; 00008D, 28.845
0468DA A2 14 00    1001*  	dl 0x0014A2 ; 00008E, 29.017
0468DD C1 14 00    1002*  	dl 0x0014C1 ; 00008F, 29.187
0468E0 E0 14 00    1003*  	dl 0x0014E0 ; 000090, 29.358
0468E3 FF 14 00    1004*  	dl 0x0014FF ; 000091, 29.527
0468E6 1E 15 00    1005*  	dl 0x00151E ; 000092, 29.697
0468E9 3C 15 00    1006*  	dl 0x00153C ; 000093, 29.865
0468EC 5B 15 00    1007*  	dl 0x00155B ; 000094, 30.033
0468EF 79 15 00    1008*  	dl 0x001579 ; 000095, 30.201
0468F2 98 15 00    1009*  	dl 0x001598 ; 000096, 30.368
0468F5 B6 15 00    1010*  	dl 0x0015B6 ; 000097, 30.534
0468F8 D4 15 00    1011*  	dl 0x0015D4 ; 000098, 30.700
0468FB F2 15 00    1012*  	dl 0x0015F2 ; 000099, 30.865
0468FE 10 16 00    1013*  	dl 0x001610 ; 00009A, 31.030
046901 2E 16 00    1014*  	dl 0x00162E ; 00009B, 31.194
046904 4C 16 00    1015*  	dl 0x00164C ; 00009C, 31.357
046907 6A 16 00    1016*  	dl 0x00166A ; 00009D, 31.520
04690A 87 16 00    1017*  	dl 0x001687 ; 00009E, 31.682
04690D A5 16 00    1018*  	dl 0x0016A5 ; 00009F, 31.844
046910 C2 16 00    1019*  	dl 0x0016C2 ; 0000A0, 32.005
046913 DF 16 00    1020*  	dl 0x0016DF ; 0000A1, 32.166
046916 FC 16 00    1021*  	dl 0x0016FC ; 0000A2, 32.326
046919 19 17 00    1022*  	dl 0x001719 ; 0000A3, 32.486
04691C 36 17 00    1023*  	dl 0x001736 ; 0000A4, 32.645
04691F 53 17 00    1024*  	dl 0x001753 ; 0000A5, 32.803
046922 70 17 00    1025*  	dl 0x001770 ; 0000A6, 32.961
046925 8C 17 00    1026*  	dl 0x00178C ; 0000A7, 33.118
046928 A9 17 00    1027*  	dl 0x0017A9 ; 0000A8, 33.275
04692B C5 17 00    1028*  	dl 0x0017C5 ; 0000A9, 33.431
04692E E2 17 00    1029*  	dl 0x0017E2 ; 0000AA, 33.587
046931 FE 17 00    1030*  	dl 0x0017FE ; 0000AB, 33.742
046934 1A 18 00    1031*  	dl 0x00181A ; 0000AC, 33.896
046937 36 18 00    1032*  	dl 0x001836 ; 0000AD, 34.050
04693A 52 18 00    1033*  	dl 0x001852 ; 0000AE, 34.203
04693D 6E 18 00    1034*  	dl 0x00186E ; 0000AF, 34.356
046940 8A 18 00    1035*  	dl 0x00188A ; 0000B0, 34.509
046943 A5 18 00    1036*  	dl 0x0018A5 ; 0000B1, 34.660
046946 C1 18 00    1037*  	dl 0x0018C1 ; 0000B2, 34.811
046949 DC 18 00    1038*  	dl 0x0018DC ; 0000B3, 34.962
04694C F7 18 00    1039*  	dl 0x0018F7 ; 0000B4, 35.112
04694F 13 19 00    1040*  	dl 0x001913 ; 0000B5, 35.262
046952 2E 19 00    1041*  	dl 0x00192E ; 0000B6, 35.410
046955 49 19 00    1042*  	dl 0x001949 ; 0000B7, 35.559
046958 64 19 00    1043*  	dl 0x001964 ; 0000B8, 35.707
04695B 7F 19 00    1044*  	dl 0x00197F ; 0000B9, 35.854
04695E 99 19 00    1045*  	dl 0x001999 ; 0000BA, 36.001
046961 B4 19 00    1046*  	dl 0x0019B4 ; 0000BB, 36.147
046964 CE 19 00    1047*  	dl 0x0019CE ; 0000BC, 36.293
046967 E9 19 00    1048*  	dl 0x0019E9 ; 0000BD, 36.438
04696A 03 1A 00    1049*  	dl 0x001A03 ; 0000BE, 36.582
04696D 1D 1A 00    1050*  	dl 0x001A1D ; 0000BF, 36.726
046970 37 1A 00    1051*  	dl 0x001A37 ; 0000C0, 36.870
046973 51 1A 00    1052*  	dl 0x001A51 ; 0000C1, 37.013
046976 6B 1A 00    1053*  	dl 0x001A6B ; 0000C2, 37.155
046979 85 1A 00    1054*  	dl 0x001A85 ; 0000C3, 37.297
04697C 9F 1A 00    1055*  	dl 0x001A9F ; 0000C4, 37.439
04697F B9 1A 00    1056*  	dl 0x001AB9 ; 0000C5, 37.579
046982 D2 1A 00    1057*  	dl 0x001AD2 ; 0000C6, 37.720
046985 EC 1A 00    1058*  	dl 0x001AEC ; 0000C7, 37.859
046988 05 1B 00    1059*  	dl 0x001B05 ; 0000C8, 37.999
04698B 1E 1B 00    1060*  	dl 0x001B1E ; 0000C9, 38.137
04698E 37 1B 00    1061*  	dl 0x001B37 ; 0000CA, 38.276
046991 50 1B 00    1062*  	dl 0x001B50 ; 0000CB, 38.413
046994 69 1B 00    1063*  	dl 0x001B69 ; 0000CC, 38.550
046997 82 1B 00    1064*  	dl 0x001B82 ; 0000CD, 38.687
04699A 9B 1B 00    1065*  	dl 0x001B9B ; 0000CE, 38.823
04699D B4 1B 00    1066*  	dl 0x001BB4 ; 0000CF, 38.959
0469A0 CC 1B 00    1067*  	dl 0x001BCC ; 0000D0, 39.094
0469A3 E5 1B 00    1068*  	dl 0x001BE5 ; 0000D1, 39.228
0469A6 FD 1B 00    1069*  	dl 0x001BFD ; 0000D2, 39.362
0469A9 16 1C 00    1070*  	dl 0x001C16 ; 0000D3, 39.496
0469AC 2E 1C 00    1071*  	dl 0x001C2E ; 0000D4, 39.629
0469AF 46 1C 00    1072*  	dl 0x001C46 ; 0000D5, 39.762
0469B2 5E 1C 00    1073*  	dl 0x001C5E ; 0000D6, 39.894
0469B5 76 1C 00    1074*  	dl 0x001C76 ; 0000D7, 40.025
0469B8 8E 1C 00    1075*  	dl 0x001C8E ; 0000D8, 40.156
0469BB A5 1C 00    1076*  	dl 0x001CA5 ; 0000D9, 40.286
0469BE BD 1C 00    1077*  	dl 0x001CBD ; 0000DA, 40.416
0469C1 D5 1C 00    1078*  	dl 0x001CD5 ; 0000DB, 40.546
0469C4 EC 1C 00    1079*  	dl 0x001CEC ; 0000DC, 40.675
0469C7 04 1D 00    1080*  	dl 0x001D04 ; 0000DD, 40.803
0469CA 1B 1D 00    1081*  	dl 0x001D1B ; 0000DE, 40.931
0469CD 32 1D 00    1082*  	dl 0x001D32 ; 0000DF, 41.059
0469D0 49 1D 00    1083*  	dl 0x001D49 ; 0000E0, 41.186
0469D3 60 1D 00    1084*  	dl 0x001D60 ; 0000E1, 41.312
0469D6 77 1D 00    1085*  	dl 0x001D77 ; 0000E2, 41.438
0469D9 8E 1D 00    1086*  	dl 0x001D8E ; 0000E3, 41.564
0469DC A5 1D 00    1087*  	dl 0x001DA5 ; 0000E4, 41.689
0469DF BB 1D 00    1088*  	dl 0x001DBB ; 0000E5, 41.814
0469E2 D2 1D 00    1089*  	dl 0x001DD2 ; 0000E6, 41.938
0469E5 E9 1D 00    1090*  	dl 0x001DE9 ; 0000E7, 42.061
0469E8 FF 1D 00    1091*  	dl 0x001DFF ; 0000E8, 42.184
0469EB 15 1E 00    1092*  	dl 0x001E15 ; 0000E9, 42.307
0469EE 2C 1E 00    1093*  	dl 0x001E2C ; 0000EA, 42.429
0469F1 42 1E 00    1094*  	dl 0x001E42 ; 0000EB, 42.551
0469F4 58 1E 00    1095*  	dl 0x001E58 ; 0000EC, 42.672
0469F7 6E 1E 00    1096*  	dl 0x001E6E ; 0000ED, 42.793
0469FA 84 1E 00    1097*  	dl 0x001E84 ; 0000EE, 42.913
0469FD 99 1E 00    1098*  	dl 0x001E99 ; 0000EF, 43.033
046A00 AF 1E 00    1099*  	dl 0x001EAF ; 0000F0, 43.152
046A03 C5 1E 00    1100*  	dl 0x001EC5 ; 0000F1, 43.271
046A06 DA 1E 00    1101*  	dl 0x001EDA ; 0000F2, 43.390
046A09 F0 1E 00    1102*  	dl 0x001EF0 ; 0000F3, 43.508
046A0C 05 1F 00    1103*  	dl 0x001F05 ; 0000F4, 43.625
046A0F 1B 1F 00    1104*  	dl 0x001F1B ; 0000F5, 43.742
046A12 30 1F 00    1105*  	dl 0x001F30 ; 0000F6, 43.859
046A15 45 1F 00    1106*  	dl 0x001F45 ; 0000F7, 43.975
046A18 5A 1F 00    1107*  	dl 0x001F5A ; 0000F8, 44.091
046A1B 6F 1F 00    1108*  	dl 0x001F6F ; 0000F9, 44.206
046A1E 84 1F 00    1109*  	dl 0x001F84 ; 0000FA, 44.321
046A21 99 1F 00    1110*  	dl 0x001F99 ; 0000FB, 44.435
046A24 AD 1F 00    1111*  	dl 0x001FAD ; 0000FC, 44.549
046A27 C2 1F 00    1112*  	dl 0x001FC2 ; 0000FD, 44.662
046A2A D7 1F 00    1113*  	dl 0x001FD7 ; 0000FE, 44.775
046A2D EB 1F 00    1114*  	dl 0x001FEB ; 0000FF, 44.888
046A30 00 20 00    1115*  	dl 0x002000 ; 000100, 45.000 only needed for interpolation
046A33             0062   ; App-specific includes
046A33             0063   	include "src/asm/player.inc"
046A33             0001*  ; ######## GAME STATE VARIABLES #######
046A33             0002*  ; THESE MUST BE IN THIS ORDER FOR new_game TO WORK PROPERLY
046A33 00 00 00    0003*  player_score: db 0x00,#00,#00 ; bcd
046A36             0004*  ; player current shields,binary
046A36             0005*  ; when < 0 player splodes
046A36             0006*  ; restores to player_max_shields when new ship spawns
046A36 10          0007*  player_shields: db 16 ; binary
046A37             0008*  ; max player shields,binary
046A37             0009*  ; can increase with power-ups (todo)
046A37 10          0010*  player_max_shields: db 16 ; binary
046A38             0011*  ; when reaches zero,game ends
046A38             0012*  ; can increase based on TODO
046A38 03          0013*  player_ships: db 0x03 ; binary
046A39             0014*  
046A39             0015*  ; ######### PLAYER SPRITE PARAMETERS ##########
046A39             0016*  ; uses the same offsets from its table base as the main sprite table:
046A39             0017*  player_start_variables: ; label marking beginning of table
046A39 04          0018*  player_id:               db table_max_records
046A3A 00          0019*  player_type:             db     0x00 ; 1 bytes currently not used
046A3B 34 01 00    0020*  player_base_bufferId:    dl BUF_SHIP_0L ; 3 bytes bitmap bufferId
046A3E 00 00 00    0021*  player_move_program:     dl 0x000000 ; 3 bytes not currently used
046A41 00          0022*  player_collisions:       db     0x00 ; 1 bytes bit 0 set=alive, otherwise dead, bit 1 set=just died
046A42 00          0023*  player_dim_x:            db     0x00 ; 1 bytes sprite width in pixels
046A43 00          0024*  player_dim_y:            db     0x00 ; 1 bytes sprite height in pixels
046A44 00 00 00    0025*  player_x:                dl 0x000000 ; 3 bytes 16.8 fractional x position in pixels
046A47 00 00 00    0026*  player_y:                dl 0x000000 ; 3 bytes 16.8 fractional y position in pixels
046A4A 00 00 00    0027*  player_xvel:             dl 0x000000 ; 3 bytes x-component velocity, 16.8 fixed, pixels
046A4D 00 00 00    0028*  player_yvel:             dl 0x000000 ; 3 bytes y-component velocity, 16.8 fixed, pixels
046A50 00 00 00    0029*  player_vel:              dl 0x000000 ; 3 bytes velocity px/frame (16.8 fixed)
046A53 00 00 00    0030*  player_heading:          dl 0x000000 ; 3 bytes sprite movement direction deg256 16.8 fixed
046A56 00 00 00    0031*  player_orientation:      dl 0x000000 ; 3 bytes not currently used
046A59 00          0032*  player_animation:        db     0x00 ; 1 bytes not currently used
046A5A 00          0033*  player_animation_timer:  db     0x00 ; 1 bytes not currently used
046A5B 00          0034*  player_move_timer:       db     0x00 ; 1 bytes not currently used
046A5C 00          0035*  player_move_step:        db     0x00 ; 1 bytes not currently used
046A5D 00          0036*  player_points:           db     0x00 ; 1 bytes not currently used
046A5E 00          0037*  player_shield_damage:    db     0x00 ; 1 bytes not currently used
046A5F             0038*  player_end_variables: ; for when we want to traverse this table in reverse
046A5F             0039*  
046A5F             0040*  ; set initial player position
046A5F             0041*  ; inputs: none,everything is hardcoded
046A5F             0042*  ; outputs: player_x/y set to bottom-left corner of screen
046A5F             0043*  ; destroys: a
046A5F             0044*  player_init:
046A5F 3E 04       0045*  	ld a,table_max_records ; this is always player spriteId
046A61 CD F9 5D 04 0046*  	call vdu_sprite_select
046A65 CD 0C 5E 04 0047*      call vdu_sprite_clear_frames
046A69 21 34 01 00 0048*      ld hl,BUF_SHIP_0L
046A6D CD 46 5F 04 0049*      call vdu_sprite_add_buff
046A71 21 35 01 00 0050*      ld hl,BUF_SHIP_1C
046A75 CD 46 5F 04 0051*      call vdu_sprite_add_buff
046A79 21 36 01 00 0052*      ld hl,BUF_SHIP_2R
046A7D CD 46 5F 04 0053*      call vdu_sprite_add_buff
046A81 01 00 00 00 0054*      ld bc,0
046A85 ED 43 44 6A 0055*      ld (player_x),bc
       04          
046A8A 11 00 DF 00 0056*      ld de,0x00DF00
046A8E ED 53 47 6A 0057*      ld (player_y),de
       04          
046A93 CD C5 5E 04 0058*      call vdu_sprite_move_abs168
046A97 CD 6F 5E 04 0059*      call vdu_sprite_show
046A9B C9          0060*      ret
046A9C             0061*  
046A9C             0062*  ; process player keyboard input, set player bitmap
046A9C             0063*  ; velocities and draw player bitmap at updated coordinates
046A9C             0064*  ; Inputs: player_x/y set at desired position
046A9C             0065*  ; Returns: player bitmap drawn at updated position
046A9C             0066*  ; Destroys: probably everything except maybe iy
046A9C             0067*  ; NOTE: in mode 9 we draw the ship as a sprite, not a bitmap
046A9C             0068*  ; TODO: requires sprite implementation
046A9C             0069*  player_input:
046A9C             0070*  ; reset player component velocities to zero as the default
046A9C 21 00 00 00 0071*  	ld hl,0
046AA0 22 4A 6A 04 0072*  	ld (player_xvel),hl
046AA4 22 4D 6A 04 0073*  	ld (player_yvel),hl
046AA8             0074*  ; make ship the active sprite
046AA8 3E 04       0075*      ld a,table_max_records ; this is always player spriteId
046AAA CD F9 5D 04 0076*      call vdu_sprite_select
046AAE             0077*  ; check for keypresses and branch accordingly
046AAE             0078*  ; for how this works,see: https://github.com/breakintoprogram/agon-docs/wiki/MOS-API-%E2%80%90-Virtual-Keyboard
046AAE             0079*      MOSCALL	mos_getkbmap ;ix = pointer to MOS virtual keys table
046AAE 3E 1E       0001*M 			LD	A, function
046AB0 5B CF       0002*M 			RST.LIL	08h
046AB2             0080*  ; we test all four arrow keys and add/subract velocities accordingly
046AB2             0081*  ; this handles the case where two opposing movement keys
046AB2             0082*  ; are down simultaneously (velocities will net to zero)
046AB2             0083*  ; and allows diagonal movement when a vertical and horizontal key are down
046AB2             0084*  ; it also allows movement and action keys to be detected simultaneously
046AB2             0085*  ; so we can walk and chew gum at the same time
046AB2 3E 01       0086*      ld a,1 ; set ship's default animation to center
046AB4             0087*          ; if left and right are both down a will net to
046AB4             0088*  
046AB4             0089*  @left:
046AB4 DD CB 03 4E 0090*      bit 1,(ix+3) ; keycode 26
046AB8 28 0E       0091*      jr z,@right
046ABA 2A 4A 6A 04 0092*      ld hl,(player_xvel)
046ABE 01 00 FD FF 0093*      ld bc,-speed_player
046AC2 09          0094*      add hl,bc
046AC3 22 4A 6A 04 0095*      ld (player_xvel),hl
046AC7 3D          0096*      dec a ; set ship's animation to left
046AC8             0097*  @right:
046AC8 DD CB 0F 4E 0098*      bit 1,(ix+15) ; keycode 122
046ACC 28 0E       0099*  	jr z,@up
046ACE 2A 4A 6A 04 0100*      ld hl,(player_xvel)
046AD2 01 00 03 00 0101*      ld bc,speed_player
046AD6 09          0102*      add hl,bc
046AD7 22 4A 6A 04 0103*      ld (player_xvel),hl
046ADB 3C          0104*      inc a ; set ship's animation to right
046ADC             0105*  @up:
046ADC DD CB 07 4E 0106*      bit 1,(ix+7) ; keycode 58
046AE0 28 0D       0107*  	jr z,@down
046AE2 2A 4D 6A 04 0108*      ld hl,(player_yvel)
046AE6 01 00 FD FF 0109*      ld bc,-speed_player
046AEA 09          0110*      add hl,bc
046AEB 22 4D 6A 04 0111*      ld (player_yvel),hl
046AEF             0112*  @down:
046AEF DD CB 05 4E 0113*      bit 1,(ix+5) ; keycode 42
046AF3 28 0D       0114*  	jr z,@done_keyboard
046AF5 2A 4D 6A 04 0115*      ld hl,(player_yvel)
046AF9 01 00 03 00 0116*      ld bc,speed_player
046AFD 09          0117*      add hl,bc
046AFE 22 4D 6A 04 0118*      ld (player_yvel),hl
046B02             0119*  @done_keyboard:
046B02             0120*  ; move player sprite according to velocities set by keypresses
046B02 2A 4A 6A 04 0121*      ld hl,(player_xvel)
046B06             0122*  ; compute new x position
046B06 ED 5B 44 6A 0123*      ld de,(player_x)
       04          
046B0B 19          0124*      add hl,de ; hl = player_x + player_xvel
046B0C             0125*      ; check for horizontal screen edge collisions
046B0C             0126*      ; and adjust coordinate as necessary
046B0C             0127*  ; TODO: make this work using 24-bit registers
046B0C             0128*      ; cp 8 ; 0 + 1/2 bitmap dim_x
046B0C             0129*      ; jr nc,@check_right ; x >= 8, no adjustment necessary
046B0C             0130*      ; ld a,8 ; set x to leftmost allowable position
046B0C             0131*  ; @check_right:
046B0C             0132*  ;     cp 248 ; 256 - 1/2 bitmap dim_x
046B0C             0133*  ;     jr c,@x_ok ; x < 248, no adjustment necessary
046B0C             0134*  ;     ld a,248 ; set x to rightmost allowable position
046B0C             0135*  @x_ok:
046B0C             0136*  ; save the updated drawing coordinate
046B0C 22 44 6A 04 0137*      ld (player_x),hl
046B10             0138*  ;compute new y position
046B10 2A 47 6A 04 0139*      ld hl,(player_y)
046B14 ED 5B 4D 6A 0140*      ld de,(player_yvel)
       04          
046B19 19          0141*      add hl,de ; hl = player_y + player_yvel
046B1A             0142*  ; TODO: make this work using 24-bit registers
046B1A             0143*  ;     ; check for vertical screen edge collisions
046B1A             0144*  ;     ; and adjust coordinate as necessary
046B1A             0145*  ;     cp 8 ; 0 + 1/2 bitmap dim_y
046B1A             0146*  ;     jr nc,@check_top ; y >= 8, no adjustment necessary
046B1A             0147*  ;     ld a,8 ; set y to topmost allowable position
046B1A             0148*  ; @check_top:
046B1A             0149*  ;     cp 232 ; 240 - 1/2 bitmap dim_y
046B1A             0150*  ;     jr c,@y_ok ; y < 248, no adjustment necessary
046B1A             0151*  ;     ld a,232 ; set y to bottommost allowable position
046B1A             0152*  @y_ok:
046B1A 22 47 6A 04 0153*      ld (player_y),hl ; do this here b/c next call destroys hl
046B1E             0154*  ; a should land here loaded with the correct frame
046B1E CD 5C 5E 04 0155*      call vdu_sprite_select_frame
046B22             0156*  ; draw player at updated position
046B22 ED 4B 44 6A 0157*      ld bc,(player_x)
       04          
046B27 ED 5B 47 6A 0158*  	ld de,(player_y)
       04          
046B2C             0159*  
046B2C             0160*      ; call dumpRegistersHex
046B2C             0161*  
046B2C CD C5 5E 04 0162*  	call vdu_sprite_move_abs168
046B30             0163*  
046B30             0164*  ; end player_input
046B30 C9          0165*  	ret
046B31             0166*  
046B31             0167*  ; ; THE BELOW WORKS WITH THE AGON BUT USES INTEGER COORDINATES
046B31             0168*  ; ; INSTEAD OF FRACTIONAL
046B31             0169*  ; ; ----------------------------------------------------------------
046B31             0170*  ; ; process player keyboard input, set player bitmap
046B31             0171*  ; ; velocities and draw player bitmap at updated coordinates
046B31             0172*  ; ; Inputs: player_x/y set at desired position
046B31             0173*  ; ; Returns: player bitmap drawn at updated position
046B31             0174*  ; ; Destroys: probably everything except maybe iy
046B31             0175*  ; ; NOTE: in mode 9 we draw the ship as a sprite, not a bitmap
046B31             0176*  ; ; TODO: requires sprite implementation
046B31             0177*  ; player_input:
046B31             0178*  ; ; reset player component velocities to zero as the default
046B31             0179*  ; 	ld hl,0
046B31             0180*  ; 	ld (player_xvel),hl
046B31             0181*  ; 	ld (player_yvel),hl
046B31             0182*  ; ; check for keypresses and branch accordingly
046B31             0183*  ; ; for how this works,see: https://github.com/breakintoprogram/agon-docs/wiki/MOS-API-%E2%80%90-Virtual-Keyboard
046B31             0184*  ;     MOSCALL	mos_getkbmap ;ix = pointer to MOS virtual keys table
046B31             0185*  ; ; we test all four arrow keys and add/subract velocities accordingly
046B31             0186*  ; ; this handles the case where two opposing movement keys
046B31             0187*  ; ; are down simultaneously (velocities will net to zero)
046B31             0188*  ; ; and allows diagonal movement when a vertical and horizontal key are down
046B31             0189*  ; ; it also allows movement and action keys to be detected simultaneously
046B31             0190*  ; ; so we can walk and chew gum at the same time
046B31             0191*  ; @left:
046B31             0192*  ;     bit 1,(ix+3) ; keycode 26
046B31             0193*  ;     jr z,@right
046B31             0194*  ;     ld hl,(player_xvel)
046B31             0195*  ;     ld bc,-3
046B31             0196*  ;     add hl,bc
046B31             0197*  ;     ld (player_xvel),hl
046B31             0198*  ; @right:
046B31             0199*  ;     bit 1,(ix+15) ; keycode 122
046B31             0200*  ; 	jr z,@up
046B31             0201*  ;     ld hl,(player_xvel)
046B31             0202*  ;     ld bc,3
046B31             0203*  ;     add hl,bc
046B31             0204*  ;     ld (player_xvel),hl
046B31             0205*  ; @up:
046B31             0206*  ;     bit 1,(ix+7) ; keycode 58
046B31             0207*  ; 	jr z,@down
046B31             0208*  ;     ld hl,(player_yvel)
046B31             0209*  ;     ld bc,-3
046B31             0210*  ;     add hl,bc
046B31             0211*  ;     ld (player_yvel),hl
046B31             0212*  ; @down:
046B31             0213*  ;     bit 1,(ix+5) ; keycode 42
046B31             0214*  ; 	jr z,@done_keyboard
046B31             0215*  ;     ld hl,(player_yvel)
046B31             0216*  ;     ld bc,3
046B31             0217*  ;     add hl,bc
046B31             0218*  ;     ld (player_yvel),hl
046B31             0219*  ; @done_keyboard:
046B31             0220*  ; ; move player sprite according to velocities set by keypresses
046B31             0221*  ;     ld hl,(player_xvel)
046B31             0222*  ; ; compute new x position
046B31             0223*  ;     ld de,(player_x)
046B31             0224*  ;     add hl,de ; hl = player_x + player_xvel
046B31             0225*  ;     ; check for horizontal screen edge collisions
046B31             0226*  ;     ; and adjust coordinate as necessary
046B31             0227*  ; ; TODO: make this work using 24-bit registers
046B31             0228*  ;     ; cp 8 ; 0 + 1/2 bitmap dim_x
046B31             0229*  ;     ; jr nc,@check_right ; x >= 8, no adjustment necessary
046B31             0230*  ;     ; ld a,8 ; set x to leftmost allowable position
046B31             0231*  ; ; @check_right:
046B31             0232*  ; ;     cp 248 ; 256 - 1/2 bitmap dim_x
046B31             0233*  ; ;     jr c,@x_ok ; x < 248, no adjustment necessary
046B31             0234*  ; ;     ld a,248 ; set x to rightmost allowable position
046B31             0235*  ; @x_ok:
046B31             0236*  ;     ; save the updated drawing coordinate
046B31             0237*  ;     ld (player_x),hl
046B31             0238*  ; ;compute new y position
046B31             0239*  ;     ld hl,(player_y)
046B31             0240*  ;     ld de,(player_yvel)
046B31             0241*  ;     add hl,de ; hl = player_y + player_yvel
046B31             0242*  ; ; TODO: make this work using 24-bit registers
046B31             0243*  ; ;     ; check for vertical screen edge collisions
046B31             0244*  ; ;     ; and adjust coordinate as necessary
046B31             0245*  ; ;     cp 8 ; 0 + 1/2 bitmap dim_y
046B31             0246*  ; ;     jr nc,@check_top ; y >= 8, no adjustment necessary
046B31             0247*  ; ;     ld a,8 ; set y to topmost allowable position
046B31             0248*  ; ; @check_top:
046B31             0249*  ; ;     cp 232 ; 240 - 1/2 bitmap dim_y
046B31             0250*  ; ;     jr c,@y_ok ; y < 248, no adjustment necessary
046B31             0251*  ; ;     ld a,232 ; set y to bottommost allowable position
046B31             0252*  ; @y_ok:
046B31             0253*  ;     ld (player_y),hl
046B31             0254*  ; ; draw player at updated position
046B31             0255*  ;     ld a,table_max_records ; this is always player spriteId
046B31             0256*  ;     call vdu_sprite_select
046B31             0257*  ;     ld hl,(player_xvel) ; we do a cheeky little hack
046B31             0258*  ;     call get_sign_hlu ; to set the proper animation
046B31             0259*  ;     add a,1 ; ...
046B31             0260*  ;     call vdu_sprite_select_frame
046B31             0261*  ;     ld bc,(player_x)
046B31             0262*  ; 	ld de,(player_y)
046B31             0263*  ; 	call vdu_sprite_move_abs
046B31             0264*  ; ; end player_input
046B31             0265*  ; 	ret
046B31             0266*  
046B31             0267*  
046B31             0268*  ; ###################################################################
046B31             0269*  ; TODO: the below is all stuff from the original code we need to port
046B31             0270*  ; ###################################################################
046B31             0271*  
046B31             0272*  ; kill_player:
046B31             0273*  ; ; set player status to dead
046B31             0274*  ;     xor a; sets all player flags to zero
046B31             0275*  ;     ld (player_collisions),a
046B31             0276*  ; ; deduct a ship from the inventory
046B31             0277*  ;     ld a,(player_ships)
046B31             0278*  ;     dec a
046B31             0279*  ;     ld (player_ships),a
046B31             0280*  ; ; are we out of ships?
046B31             0281*  ;     jp z,game_over
046B31             0282*  ; ; wait a few ticks
046B31             0283*  ;     ld a,32 ; 32-cycle timer ~1/2 second at 60fps
046B31             0284*  ;     ld (player_move_timer),a
046B31             0285*  ; kill_player_loop:
046B31             0286*  ;     call vdu_vblank
046B31             0287*  ;     ld a,(player_move_timer)
046B31             0288*  ;     dec a
046B31             0289*  ;     ld (player_move_timer),a
046B31             0290*  ;     jr nz,kill_player_loop
046B31             0291*  ;     call player_init ; player respawn if timer zero
046B31             0292*  ;     ret ; and out
046B31             0293*  
046B31             0294*  
046B31             0295*  ; player_move:
046B31             0296*  ; ; begin setting player to active sprite
046B31             0297*  ;     ld hl,player
046B31             0298*  ;     ld (sprite_base_bufferId),hl
046B31             0299*  ;     ld hl,0 ; north
046B31             0300*  ;     ld (sprite_heading),hl
046B31             0301*  ;     ld a,#01 ; animation 1 is center,which we set here as a default
046B31             0302*  ;     ld (sprite_animation),a
046B31             0303*  ;     ; we set position here for the time being as a default
046B31             0304*  ;     ; in case the player doesn't move,or is flagged for deletion
046B31             0305*  ;     ld hl,(player_x)
046B31             0306*  ;     ld (sprite_x),hl
046B31             0307*  ;     ld hl,(player_y)
046B31             0308*  ;     ld (sprite_y),hl
046B31             0309*  ; ; did we just die?
046B31             0310*  ;     ld a,(player_collisions)
046B31             0311*  ;     and %00000010 ; zero flag will be set if not dead
046B31             0312*  ;     jr z,player_not_dead
046B31             0313*  ; ; yes we died
046B31             0314*  ;     call kill_player
046B31             0315*  ;     ret ; done
046B31             0316*  ; ; yay we didn't die
046B31             0317*  ; player_not_dead:
046B31             0318*  ; ; set player movements to zero by default
046B31             0319*  ;     ld hl,0
046B31             0320*  ;     ld (player_xvel),hl
046B31             0321*  ;     ld (player_yvel),hl
046B31             0322*  ; ; do we move it?
046B31             0323*  ;     in a,(#82) ; keyboard
046B31             0324*  ;     or a ; if zero,don't move
046B31             0325*  ;     jr z,player_draw
046B31             0326*  ; ; move it
046B31             0327*  ;     call player_move_calc
046B31             0328*  ; player_draw:
046B31             0329*  ;     call vdu_bmp_select
046B31             0330*  ;     call vdu_bmp_draw
046B31             0331*  ; player_move_done:
046B31             0332*  ;     ; write updated x,y coordinates back to player table
046B31             0333*  ;     ld hl,(sprite_x)
046B31             0334*  ;     ld (player_x),hl
046B31             0335*  ;     ld hl,(sprite_y)
046B31             0336*  ;     ld (player_y),hl
046B31             0337*  ;     ret
046B31             0064   	include "src/asm/tiles.inc"
046B31             0001*  ; ######### TILES #########
046B31             0002*  ; TODO: implement buffering of tiles here when there isn't other stuff to do
046B31             0003*  ; tiles_defs: ds 256*16 ; 256 rows of 16 tiles, each tile is a byte
046B31 00 00 00    0004*  tiles_row_defs: dl 0x000000 ; pointer to current row tiles definitions
046B34 00          0005*  tiles_row: db 0 ; decrements each time a row is drawn. level is over when hits zero
046B35             0006*                          ; initialize to zero for a maximum of 256 rows in a level
046B35 00          0007*  cur_level: db 0
046B36             0008*  num_levels: equ 2 ; number of levels,duh
046B36             0009*  
046B36             0010*  ; lookup table for level definitions
046B36 61 41 04 62 0011*  tiles_levels: dl tiles_level_00,tiles_level_01
       51 04       
046B3C             0012*  
046B3C             0013*  ; tiles_bufferId: dl 0
046B3C 00 00 00    0014*  tiles_x_plot: dl 0
046B3F F1 FF FF    0015*  tiles_y_plot: dl -15
046B42             0016*  
046B42             0017*  
046B42             0018*  tiles_plot:
046B42             0019*  ; ; NOTE: this is bugged. y1 should be zero to get a 1px-tall viewport
046B42             0020*  ; ;       as written it gves a 2px-tall window which is what we'd expect,
046B42             0021*  ; ;       but don't want
046B42             0022*  ; ; https://discord.com/channels/1158535358624039014/1158536809916149831/1209571014514712637
046B42             0023*  ; ; set gfx viewport to one scanline to optimise plotting tiles
046B42             0024*  ; 	ld bc,0 ; leftmost x-coord
046B42             0025*  ; 	ld de,0 ; topmost y-coord
046B42             0026*  ; 	ld ix,255 ; rightmost x-coord
046B42             0027*  ; 	ld iy,1 ; bottommost y-coord
046B42             0028*  ; 	call vdu_set_gfx_viewport
046B42             0029*  
046B42 21 00 00 00 0030*      ld hl,0 ; init plotting x-coordinate
046B46 22 3C 6B 04 0031*      ld (tiles_x_plot),hl
046B4A 2A 31 6B 04 0032*      ld hl,(tiles_row_defs)
046B4E 06 10       0033*  	ld b,16 ; loop counter
046B50             0034*  @loop:
046B50 C5          0035*  	push bc ; save the loop counter
046B51             0036*  ; read the tile defintion for the current column
046B51 7E          0037*      ld a,(hl) ; a has tile definition
046B52 E5          0038*      push hl  ; save pointer to tile definition
046B53 21 00 00 00 0039*      ld hl,0 ; hlu is non-zero
046B57 6F          0040*      ld l,a ; l is tile defintion
046B58 26 01       0041*      ld h,0x01 ; hl = 256 + tile index = the tile's bitmapId
046B5A CD 87 5B 04 0042*      call vdu_buff_select ; tile bitmap buffer is now active
046B5E             0043*  
046B5E             0044*  ; plot the active bitmap
046B5E ED 4B 3C 6B 0045*      ld bc,(tiles_x_plot)
       04          
046B63 ED 5B 3F 6B 0046*      ld de,(tiles_y_plot)
       04          
046B68 CD 58 5D 04 0047*      call vdu_plot_bmp
046B6C             0048*  
046B6C             0049*  ; bump x-coords the width of one tile and save it
046B6C 2A 3C 6B 04 0050*      ld hl,(tiles_x_plot)
046B70 01 10 00 00 0051*      ld bc,16
046B74 09          0052*      add hl,bc
046B75 22 3C 6B 04 0053*      ld (tiles_x_plot),hl
046B79             0054*  
046B79             0055*  ; prepare to loop to next column
046B79 E1          0056*      pop hl ; get back pointer to tile def
046B7A 23          0057*      inc hl ; bump it to the next column
046B7B C1          0058*  	pop bc ; snag our loop counter
046B7C 10 D2       0059*      djnz @loop
046B7E             0060*  
046B7E             0061*  ; increment tiles plotting y-coordinate
046B7E             0062*  ; when it hits zero, we go to next row of tiles in the map
046B7E             0063*  ; (we use ix b/c we want to preserve hl for the next step)
046B7E DD 21 3F 6B 0064*  	ld ix,tiles_y_plot
       04          
046B83 DD 34 00    0065*  	inc (ix)
046B86 C0          0066*  	ret nz
046B87             0067*  
046B87             0068*  ; time to bump tiles_row_defs to next row
046B87             0069*  ; (hl was already there at the end of the loop)
046B87 22 31 6B 04 0070*      ld (tiles_row_defs),hl
046B8B             0071*  
046B8B             0072*  ; reset coords to plot next row of tiles
046B8B 21 00 00 00 0073*      ld hl,0
046B8F 22 3C 6B 04 0074*      ld (tiles_x_plot),hl
046B93 21 F1 FF FF 0075*      ld hl,-15
046B97 22 3F 6B 04 0076*      ld (tiles_y_plot),hl
046B9B             0077*  
046B9B             0078*  ; decrement tiles row counter
046B9B 21 34 6B 04 0079*      ld hl,tiles_row
046B9F 35          0080*      dec (hl)
046BA0 C0          0081*      ret nz
046BA1             0082*  
046BA1             0083*  ; queue up next level
046BA1 3A 35 6B 04 0084*      ld a,(cur_level)
046BA5 FE 01       0085*      cp num_levels-1
046BA7 20 02       0086*      jr nz,@inc_level
046BA9 3E FF       0087*      ld a,-1 ; will wrap around to zero when we fall through
046BAB             0088*  
046BAB             0089*  @inc_level:
046BAB 3C          0090*      inc a
046BAC 32 35 6B 04 0091*      ld (cur_level),a
046BB0             0092*  
046BB0             0093*  ; increase the number of enemy sprites
046BB0 3A FF 6B 04 0094*      ld a,(max_enemy_sprites)
046BB4 3C          0095*      inc a
046BB5 FE 04       0096*      cp table_max_records ; if we're at the global limit,skip ahead at max level
046BB7 28 04       0097*      jr z,init_level
046BB9 32 FF 6B 04 0098*      ld (max_enemy_sprites),a ; otherwise save the updated number
046BBD             0099*  ; fall through to init_level
046BBD             0100*  
046BBD             0101*  init_level:
046BBD             0102*  ; look up address of level's tile defintion
046BBD 21 36 6B 04 0103*      ld hl,tiles_levels
046BC1 3A 35 6B 04 0104*      ld a,(cur_level)
046BC5 11 00 00 00 0105*      ld de,0 ; just in case deu is non-zero
046BC9 57          0106*      ld d,a
046BCA 1E 03       0107*      ld e,3
046BCC ED 5C       0108*      mlt de
046BCE 19          0109*      add hl,de
046BCF ED 37       0110*      ld ix,(hl)
046BD1 DD 22 31 6B 0111*      ld (tiles_row_defs),ix
       04          
046BD6             0112*  
046BD6             0113*  ; set tiles_row counter
046BD6 DD 7E 00    0114*      ld a,(ix)
046BD9 32 34 6B 04 0115*      ld (tiles_row),a
046BDD DD 23       0116*      inc ix ; now ix points first element of first row tile def
046BDF DD 22 31 6B 0117*      ld (tiles_row_defs),ix ; ... so we save it
       04          
046BE4 C9          0118*      ret
046BE5             0119*  
046BE5             0120*  
046BE5             0121*  ; ###### TODO: NEW CODE TO IMPLEMENT ######
046BE5             0122*  ; dt_is_active:
046BE5             0123*  ; ; a lands here containing a tile index in the low nibble
046BE5             0124*  ; ; we test the values for the tiles which are active
046BE5             0125*  ;     cp #07
046BE5             0126*  ;     call z,ld_act_landing_pad
046BE5             0127*  ;     cp #08
046BE5             0128*  ;     call z,ld_act_laser_turret
046BE5             0129*  ;     ; fall through
046BE5             0130*  ;     ret
046BE5             0131*  
046BE5             0132*  ; ; some tiles become active sprites,so we load those here
046BE5             0133*  ; ; sprite_x/y have already been loaded
046BE5             0134*  ; ; sprite_dim_x/y are loaded by table_add_record
046BE5             0135*  ; ; we don't want sprite drawn to background like other tiles
046BE5             0136*  ; ; so this routine only adds them to the sprite table
046BE5             0137*  ; dt_ld_act:
046BE5             0138*  ;     ld a,#48 ; top of screen + 1/2 tile height
046BE5             0139*  ;     ld (sprite_y+1),a ; just the integer part
046BE5             0140*  ;     ld (sprite_base_bufferId),hl
046BE5             0141*  ;     call vdu_bmp_select
046BE5             0142*  ;     call table_add_record
046BE5             0143*  ;     call sprite_variables_from_stack
046BE5             0144*  ;     ld a,#FF ; lets calling proc know we loaded an active tile
046BE5             0145*  ;     ret ; and back
046BE5             0146*  
046BE5             0147*  ; ld_act_landing_pad:
046BE5             0148*  ;     call sprite_variables_to_stack
046BE5             0149*  
046BE5             0150*  ;     ld hl,move_landing_pad
046BE5             0151*  ;     ld (sprite_move_program),hl
046BE5             0152*  
046BE5             0153*  ;     xor a
046BE5             0154*  ;     ld (sprite_animation),a ; animation 0
046BE5             0155*  
046BE5             0156*  ;     call rand_8     ; snag a random number
046BE5             0157*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
046BE5             0158*  ;     add a,64 ; range is now 64-127
046BE5             0159*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn an enemy
046BE5             0160*  
046BE5             0161*  ;     ld a,%10 ; collides with laser but not player
046BE5             0162*  ;     ld (iy+sprite_collisions),a
046BE5             0163*  
046BE5             0164*  ;     ld a,#05 ; BCD
046BE5             0165*  ;     ld (sprite_points),a
046BE5             0166*  ;     ld a,0 ; binary
046BE5             0167*  ;     ld (sprite_shield_damage),a
046BE5             0168*  
046BE5             0169*  ;     ld hl,landing_pad ; dt_ld_act loads this to sprite_base_bufferId
046BE5             0170*  ;     jr dt_ld_act
046BE5             0171*  
046BE5             0172*  ; ld_act_laser_turret:
046BE5             0173*  ;     call sprite_variables_to_stack
046BE5             0174*  
046BE5             0175*  ;     ld hl,move_laser_turret
046BE5             0176*  ;     ld (sprite_move_program),hl
046BE5             0177*  
046BE5             0178*  ;     xor a
046BE5             0179*  ;     ld (sprite_animation),a
046BE5             0180*  ;     ld (sprite_move_step),a
046BE5             0181*  
046BE5             0182*  ;     call rand_8     ; snag a random number
046BE5             0183*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
046BE5             0184*  ;     add a,64 ; range is now 64-127
046BE5             0185*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn a fireball
046BE5             0186*  
046BE5             0187*  ;     ld a,%10 ; collides with laser but not player
046BE5             0188*  ;     ld (iy+sprite_collisions),a
046BE5             0189*  
046BE5             0190*  ;     ld a,#10 ; BCD
046BE5             0191*  ;     ld (sprite_points),a
046BE5             0192*  ;     ld a,0 ; binary
046BE5             0193*  ;     ld (sprite_shield_damage),a
046BE5             0194*  
046BE5             0195*  ;     ld hl,laser_turret ; dt_ld_act loads this to sprite_base_bufferId
046BE5             0196*  ;     jp dt_ld_act
046BE5             0197*  
046BE5             0198*  
046BE5             0199*  ; moves active tile sprites down one pixel in sync with tiles movement
046BE5             0200*  ; deletes sprites from table when they wrap around to top of screen
046BE5             0201*  move_active_tiles:
046BE5             0202*  ; get current position
046BE5 3A 0F 00 00 0203*      ld a,(sprite_y+1) ; we only need the integer part
046BE9 3C          0204*      inc a
046BEA             0205*  ; are we at the bottom of the screen?
046BEA 20 06       0206*      jr nz,move_active_tiles_draw_sprite ; nope
046BEC             0207*  ; otherwise kill sprite
046BEC 3E 80       0208*      ld a,%10000000 ; any bit set in high nibble means sprite will die
046BEE FD 77 08    0209*      ld (iy+sprite_collisions),a
046BF1 C9          0210*      ret ; debug
046BF2             0211*  move_active_tiles_draw_sprite:
046BF2 32 0F 00 00 0212*      ld (sprite_y+1),a ; update tile y position integer part
046BF6 CD 74 5B 04 0213*      call vdu_bmp_select
046BFA CD BD 5B 04 0214*      call vdu_bmp_draw ; draw it
046BFE C9          0215*      ret ; and done
046BFF             0065   	include "src/asm/enemies.inc"
046BFF 10          0001*  max_enemy_sprites: db 16
046C00             0002*  
046C00             0003*  ; sprite_type
046C00             0004*  enemy_dead: equ 0
046C00             0005*  enemy_small: equ 1
046C00             0006*  enemy_medium: equ 2
046C00             0007*  enemy_large: equ 3
046C00             0008*  landing_pad: equ 4
046C00             0009*  laser_turret: equ 5
046C00             0010*  fireballs: equ 6
046C00             0011*  explosion: equ 7
046C00             0012*  
046C00             0013*  
046C00             0014*  respawn_countdown:
046C00 2A 21 6C 04 0015*      ld hl,(respawn_timer)
046C04 2B          0016*      dec hl
046C05 22 21 6C 04 0017*      ld (respawn_timer),hl
046C09             0018*  ; check hl for zero
046C09 19          0019*      add hl,de
046C0A B7          0020*      or a
046C0B ED 52       0021*      sbc hl,de
046C0D C0          0022*      ret nz
046C0E 06 04       0023*      ld b,table_max_records
046C10             0024*  @respawn_loop:
046C10 C5          0025*      push bc
046C11 CD 12 6D 04 0026*      call enemy_init_from_landing_pad
046C15 C1          0027*      pop bc
046C16 10 F8       0028*      djnz @respawn_loop
046C18 21 3C 00 00 0029*      ld hl,1*60 ; 1 second
046C1C 22 21 6C 04 0030*      ld (respawn_timer),hl
046C20 C9          0031*      ret
046C21 3C 00 00    0032*  respawn_timer: dl 1*60
046C24             0033*  
046C24             0034*  move_enemies:
046C24             0035*  ; are there any active enemies or explosions?
046C24 21 00 00 00 0036*      ld hl,0
046C28 3A FE 52 04 0037*      ld a,(table_active_sprites)
046C2C 6F          0038*      ld l,a
046C2D             0039*      ; call dumpRegistersHex
046C2D A7          0040*      and a ; will be zero if no alive enemies or explosions
046C2E             0041*      ; ret z ; so nothing to do but go back
046C2E             0042*      ; ld hl,(respawn_timer)
046C2E             0043*      ; call dumpRegistersHex
046C2E 20 05       0044*      jr nz,move_enemies_do
046C30 CD 00 6C 04 0045*      call respawn_countdown
046C34 C9          0046*      ret
046C35             0047*  move_enemies_do:
046C35             0048*  ; initialize pointers and loop counter
046C35 FD 21 63 52 0049*      ld iy,table_base ; set iy to first record in table
       04          
046C3A 06 04       0050*      ld b,table_max_records ; loop counter
046C3C             0051*  move_enemies_loop:
046C3C FD 22 FB 52 0052*      ld (table_pointer),iy ; update table pointer
       04          
046C41 C5          0053*      push bc ; backup loop counter
046C42             0054*  ; check sprite_type to see if sprite is active
046C42 FD 7E 01    0055*      ld a,(iy+sprite_type)
046C45 A7          0056*      and a ; if zero, sprite is dead
046C46 28 2E       0057*      jr z,move_enemies_next_record ; ... and we skip to next record
046C48             0058*  ; otherwise we prepare to move the sprite
046C48 FD 7E 00    0059*      ld a,(iy+sprite_id) ; get spriteId
046C4B CD F9 5D 04 0060*      call vdu_sprite_select ; select sprite
046C4F FD 27 05    0061*      ld hl,(iy+sprite_move_program) ; load the behavior subroutine address
046C52 E9          0062*      jp (hl)  ; ... and jump to it
046C53             0063*  ; we always jp back here from behavior subroutines
046C53             0064*  move_enemies_loop_return:
046C53 FD 2A FB 52 0065*      ld iy,(table_pointer) ; get back table pointer
       04          
046C58             0066*  ; now we check results of all the moves
046C58 FD 7E 08    0067*      ld a,(iy+sprite_collisions)
046C5B E6 F0       0068*      and %11110000 ; any bits set in high nibble means we died
046C5D FD 7E 00    0069*      ld a,(iy+sprite_id) ; get spriteId for the deactivate_sprite call if needed
046C60 28 0A       0070*      jr z,move_enemies_draw_sprite ; if not dead,draw sprite
046C62 CD 47 53 04 0071*      call table_deactivate_sprite ; otherwise we ded
046C66 AF          0072*      xor a ; zero a so that we can ...
046C67 FD 77 08    0073*      ld (iy+sprite_collisions),a ; ... clear collision flags
046C6A 18 0A       0074*      jr move_enemies_next_record ; and to the next record
046C6C             0075*  move_enemies_draw_sprite:
046C6C             0076*  ; if we got here sprite will have already been activated
046C6C             0077*  ; so all we need to do is set its coordinates and draw it
046C6C FD 07 0B    0078*      ld bc,(iy+sprite_x)
046C6F FD 17 0E    0079*      ld de,(iy+sprite_y)
046C72 CD C5 5E 04 0080*      call vdu_sprite_move_abs168
046C76             0081*  ; fall through to next record
046C76             0082*  move_enemies_next_record:
046C76 11 26 00 00 0083*      ld de,table_bytes_per_record
046C7A FD 19       0084*      add iy,de ; point to next record
046C7C AF          0085*      xor a ; clears carry flag
046C7D 32 FF 52 04 0086*      ld (sprite_screen_edge),a ; clear screen edge collision flag
046C81 C1          0087*      pop bc ; get back our loop counter
046C82 10 B8       0088*      djnz move_enemies_loop ; loop until we've checked all the records
046C84 C9          0089*      ret ; and we're out
046C85             0090*  
046C85             0091*  en_nav_zigzag_start:
046C85 FD 2A FB 52 0092*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
046C8A CD BB 61 04 0093*      call rand_8
046C8E E6 3F       0094*      and %00111111 ; limit it to 64
046C90 CB DF       0095*      set 3,a ; make sure it's at least 8
046C92 FD 77 22    0096*      ld (iy+sprite_move_timer),a ; store it
046C95             0097*      ; fall through to en_nav_zigzag
046C95             0098*  en_nav_zigzag:
046C95 FD 7E 22    0099*      ld a,(iy+sprite_move_timer)
046C98 3D          0100*      dec a
046C99 FD 77 22    0101*      ld (iy+sprite_move_timer),a
046C9C 20 1C       0102*      jr nz,en_nav_zigzag_no_switch
046C9E             0103*      ; otherwise flip direction and restart timer
046C9E FD 7E 23    0104*      ld a,(iy+sprite_move_step)
046CA1 EE 01       0105*      xor %1 ; flips bit one
046CA3 FD 77 23    0106*      ld (iy+sprite_move_step),a ; store it
046CA6 20 09       0107*      jr nz,en_nav_zigzag_right
046CA8             0108*  ;otherwise zag left
046CA8 21 00 A0 00 0109*      ld hl,0x00A000; southwest heading
046CAC FD 2F 1A    0110*      ld (iy+sprite_heading),hl ; save sprite heading
046CAF 18 D4       0111*      jr en_nav_zigzag_start
046CB1             0112*  en_nav_zigzag_right:
046CB1 21 00 60 00 0113*      ld hl,0x006000; southeast heading
046CB5 FD 2F 1A    0114*      ld (iy+sprite_heading),hl ; save sprite heading
046CB8 18 CB       0115*      jr en_nav_zigzag_start
046CBA             0116*  en_nav_zigzag_no_switch:
046CBA             0117*      ; ld a,(sprite_orientation)
046CBA FD 27 1A    0118*      ld hl,(iy+sprite_heading)
046CBD 18 13       0119*      jr en_nav_computevelocities
046CBF             0120*  
046CBF             0121*  ; contains the logic for how to move the enemy
046CBF             0122*  ; and then does the moving
046CBF             0123*  ; inputs: a fully-populated active sprite table
046CBF             0124*  ;         player position variables
046CBF             0125*  ; destroys: everything except index registers
046CBF             0126*  ; outputs: moving enemies
046CBF             0127*  en_nav:
046CBF             0128*  ; set velocity and orientation by player's relative location
046CBF             0129*  ; move enemies y-axis
046CBF             0130*  ; where is player relative to us?
046CBF CD 95 6D 04 0131*      call orientation_to_player
046CC3             0132*  ;    h.l 16.8 fixed angle256 to player
046CC3             0133*  ;    ub.c and ud.e as 16.8 signed fixed point numbers
046CC3             0134*  ; is player above or below us?
046CC3 ED 53 D6 58 0135*      ld (ude),de ; dy
       04          
046CC8 3A D8 58 04 0136*      ld a,(ude+2) ; deu
046CCC 17          0137*      rla ; shift sign bit into carry
046CCD 30 C6       0138*      jr nc,en_nav_zigzag ; player is below,evade
046CCF             0139*  ; player is even or above,so home in on current heading
046CCF FD 2F 1A    0140*      ld (iy+sprite_heading),hl ; save sprite heading
046CD2             0141*  
046CD2             0142*  ; we land here from zig-zag program so as not to
046CD2             0143*  ; redundantly save orientation and heading
046CD2             0144*  en_nav_computevelocities:
046CD2             0145*  ; set x/y component velocities based on bearing to player
046CD2 FD 2A FB 52 0146*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
046CD7 E5          0147*      push hl ; we need it back to set rotation frame
046CD8 FD 17 17    0148*      ld de,(iy+sprite_vel)
046CDB CD E7 61 04 0149*      call polar_to_cartesian
046CDF FD 0F 11    0150*      ld (iy+sprite_xvel),bc ; save x-velocity component
046CE2 FD 1F 14    0151*      ld (iy+sprite_yvel),de ; save y-velocity component
046CE5             0152*  ; change the animation frame to match heading
046CE5             0153*  ; by dividng the heading by 8
046CE5 E1          0154*      pop hl ; get back Heading
046CE6 7C          0155*      ld a,h
046CE7 CB 3F       0156*      srl a
046CE9 CB 3F       0157*      srl a
046CEB CB 3F       0158*      srl a
046CED CD 5C 5E 04 0159*      call vdu_sprite_select_frame
046CF1             0160*  ; update sprite position
046CF1             0161*  move_enemy_sprite:
046CF1 FD 27 0B    0162*      ld hl,(iy+sprite_x)
046CF4 FD 17 11    0163*      ld de,(iy+sprite_xvel)
046CF7 19          0164*      add hl,de
046CF8 FD 2F 0B    0165*      ld (iy+sprite_x),hl
046CFB             0166*  
046CFB FD 27 0E    0167*      ld hl,(iy+sprite_y)
046CFE FD 17 14    0168*      ld de,(iy+sprite_yvel)
046D01 19          0169*      add hl,de
046D02 FD 2F 0E    0170*      ld (iy+sprite_y),hl
046D05 C9          0171*      ret
046D06             0172*  
046D06             0173*  ; ; TODO: IMPLEMENT THIS PROPERLY
046D06             0174*  ; move_enemy_sprite:
046D06             0175*  ; ; x-axis movement first
046D06             0176*  ;     ld hl,(iy+sprite_x)
046D06             0177*  ;     push hl ; save pre-move position
046D06             0178*  ;     pop bc ; to detect screen edge collision
046D06             0179*  ;     ld de,(iy+sprite_xvel)
046D06             0180*  ;     add hl,de ;compute new x position
046D06             0181*  ;     ld (iy+sprite_x),hl ; store it
046D06             0182*  ;     and a ; clear the carry flag
046D06             0183*  ;     sbc hl,bc ; test which direction was our movement
046D06             0184*  ;     jr z,@move_y ; zero flag means no horizontal movement
046D06             0185*  ;     jp p,@move_right ; sign positive means moved right
046D06             0186*  ; @move_left: ; otherwise we moved left
046D06             0187*  ;     jr c,@move_y ; move left,no wraparound |C1 N1 PV1 H1 Z0 S1|A=00 HL=FF00 BC=0100 DE=FF00
046D06             0188*  ;     ld hl,0x000000   ; move left,with wraparound |C0 N1 PV0 H0 Z0 S1|A=00 HL=FF00 BC=0000 DE=FF00
046D06             0189*  ;     ld (iy+sprite_x),hl ; set x position to left edge of screen
046D06             0190*  ;     ld a,#20 ; west
046D06             0191*  ;     ld (sprite_screen_edge),a ; set screen edge collision flag
046D06             0192*  ;     jr @move_y
046D06             0193*  ; @move_right:
046D06             0194*  ;     jr nc,@move_y ; move right,no wraparound |C0 N1 PV1 H0 Z0 S0|A=00 HL=0100 BC=FE00 DE=0100
046D06             0195*  ;     ; move right,with wraparound |C1 N1 PV0 H1 Z0 S0|A=00 HL=0100 BC=FF00 DE=0100
046D06             0196*  ;     ld l,0x00
046D06             0197*  ;     ld a,(iy+sprite_dim_x)
046D06             0198*  ;     ld h,a
046D06             0199*  ;     ld a,0x00
046D06             0200*  ;     sub h
046D06             0201*  ;     ld h,a
046D06             0202*  ;     ld (iy+sprite_x),hl ; set x position to right edge of screen
046D06             0203*  ;     ld a,0x02 ; east
046D06             0204*  ;     ld (sprite_screen_edge),a ; set screen edge collision flag
046D06             0205*  ; @move_y:
046D06             0206*  ;     ld hl,(iy+sprite_y)
046D06             0207*  ;     ld b,h ; save pre-move position
046D06             0208*  ;     ld c,l ; to detect screen edge collision
046D06             0209*  ;     ld de,(iy+sprite_yvel)
046D06             0210*  ;     add hl,de ;compute new y position
046D06             0211*  ;     ld (iy+sprite_y),hl ; store it
046D06             0212*  ;     and a ; clear the carry flag
046D06             0213*  ;     sbc hl,bc ; test which direction was our movement
046D06             0214*  ;     jr z,@move_ret ; zero flag means no vertical movement
046D06             0215*  ;     jp p,@move_dn ; sign positive means moved down
046D06             0216*  ; @move_up:
046D06             0217*  ;     add hl,bc ; get back new y position
046D06             0218*  ;     ld de,0x5000 ; top edge of visible screen
046D06             0219*  ;     and a ; clear the carry flag
046D06             0220*  ;     sbc hl,de
046D06             0221*  ;     jr nc,@move_ret ; move up,no wraparound |C0 N1 PV0 H0 Z1 S0|A=00 HL=0000 BC=5100 DE=5000
046D06             0222*  ;     ; move up,with wraparound |C1 N1 PV1 H0 Z0 S1|A=00 HL=FF00 BC=5000 DE=5000
046D06             0223*  ;     ld (iy+sprite_y),de ; set y position flush with top of screen
046D06             0224*  ;     ld a,(sprite_screen_edge) ; load any vertical edge collision
046D06             0225*  ;     or 0x80 ; north
046D06             0226*  ;     ld (sprite_screen_edge),a ; set screen edge collision flag
046D06             0227*  ;     jr @move_ret
046D06             0228*  ; @move_dn:
046D06             0229*  ;     jr nc,@move_ret ; move down,no wraparound |C0 N1 PV0 H0 Z0 S0|A=00 HL=0100 BC=5100 DE=0100
046D06             0230*  ;     ; move down,with wraparound |C1 N1 PV0 H1 Z0 S0|A=00 HL=0100 BC=FF00 DE=0100
046D06             0231*  ;     ld l,0x00
046D06             0232*  ;     ld a,(iy+sprite_dim_y)
046D06             0233*  ;     ld h,a
046D06             0234*  ;     ld a,0x00
046D06             0235*  ;     sub h
046D06             0236*  ;     ld h,a
046D06             0237*  ;     ld (iy+sprite_y),hl ; set y position flush with bottom of screen
046D06             0238*  ;     ld a,(sprite_screen_edge) ; load any vertical edge collision
046D06             0239*  ;     or 0x08 ; south
046D06             0240*  ;     ld (sprite_screen_edge),a ; set screen edge collision flag
046D06             0241*  ; @move_ret:
046D06             0242*  ;     ret
046D06             0243*  
046D06             0244*  ; ; ######### SPRITE BEHAVIOR ROUTINES #########
046D06             0245*  ; ; each sprite in the table must have one of these defined
046D06             0246*  ; ; but they need not be unique to a particular sprite
046D06             0247*  ; ; these are jumped to from move_enemies_do_program,but could come from other places
046D06             0248*  ; ; and have the option but not obligation to go back to move_enemies_loop_return
046D06             0249*  ; ; but they can call anything they want between those two endpoints
046D06             0250*  ; move_programs: ; bookmark in case we want to know the first address of the first subroutine
046D06             0251*  
046D06             0252*  ; move_nop: ; does nothing but burn a few cycles changing the PC
046D06             0253*  ;     jp move_enemies_loop_return
046D06             0254*  
046D06             0255*  ; move_explosion:
046D06             0256*  ;     call animate_explosion
046D06             0257*  ;     jp move_enemies_loop_return
046D06             0258*  
046D06             0259*  move_enemy_small:
046D06 CD BF 6C 04 0260*      call en_nav
046D0A CD 31 6E 04 0261*      call check_collisions
046D0E C3 53 6C 04 0262*      jp move_enemies_loop_return
046D12             0263*  
046D12             0264*  ; move_enemy_medium:
046D12             0265*  ;     call en_nav
046D12             0266*  ;     call check_collisions
046D12             0267*  ;     jp move_enemies_loop_return
046D12             0268*  
046D12             0269*  ; move_enemy_large:
046D12             0270*  ;     call en_nav
046D12             0271*  ;     call check_collisions
046D12             0272*  ;     jp move_enemies_loop_return
046D12             0273*  
046D12             0274*  ; move_landing_pad:
046D12             0275*  ;     call move_active_tiles
046D12             0276*  ;     call check_collisions
046D12             0277*  ; ; is it time to launch an enemy?
046D12             0278*  ;     ld hl,sprite_move_timer
046D12             0279*  ;     dec (hl)
046D12             0280*  ;     jp nz,move_enemies_loop_return
046D12             0281*  ;     call enemy_init_from_landing_pad
046D12             0282*  ;     ; reset move timer so can spawn again if player doesn't take us out
046D12             0283*  ;     call rand_8     ; snag a random number
046D12             0284*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
046D12             0285*  ;     add a,64 ; range is now 64-127
046D12             0286*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn an enemy
046D12             0287*  ;     jp move_enemies_loop_return
046D12             0288*  
046D12             0289*  enemy_init_from_landing_pad:
046D12             0290*  ; get next available spriteId
046D12 CD 22 53 04 0291*      call table_get_next_id
046D16 D0          0292*      ret nc ; no carry means no free sprite slots, so we go home
046D17             0293*  ; ix comes back with the pointer to the new sprite variables
046D17 DD E5       0294*      push ix ; de picks it up when we're ready for the copy to the table
046D19             0295*  ; a comes back with the spriteId of the new sprite
046D19 32 6F 6D 04 0296*      ld (@id),a
046D1D             0297*  ; initialize the new sprite
046D1D CD F9 5D 04 0298*      call vdu_sprite_select
046D21 CD 0C 5E 04 0299*      call vdu_sprite_clear_frames
046D25 21 14 01 00 0300*      ld hl,BUF_SEEKER_000
046D29 06 20       0301*      ld b,32
046D2B             0302*  @load_frames:
046D2B C5          0303*      push bc
046D2C E5          0304*      push hl
046D2D CD 46 5F 04 0305*      call vdu_sprite_add_buff
046D31 E1          0306*      pop hl
046D32 23          0307*      inc hl
046D33 C1          0308*      pop bc
046D34 10 F5       0309*      djnz @load_frames
046D36             0310*  ; copy coordinates of active sprite to new sprite
046D36 FD 2A FB 52 0311*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
046D3B             0312*      ; ld hl,(iy+sprite_x)
046D3B             0313*  	; ld hl,0x008000 ; debug
046D3B             0314*  
046D3B CD BB 61 04 0315*      call rand_8
046D3F 21 00 00 00 0316*      ld hl,0
046D43 67          0317*      ld h,a
046D44             0318*  
046D44 22 7A 6D 04 0319*      ld (@x),hl
046D48             0320*      ; ld hl,(iy+sprite_y)
046D48             0321*      ; ld hl,0x002000 ; debug
046D48             0322*  
046D48 CD BB 61 04 0323*      call rand_8
046D4C 21 00 00 00 0324*      ld hl,0
046D50 67          0325*      ld h,a
046D51             0326*  
046D51 22 7D 6D 04 0327*      ld (@y),hl
046D55 CD BB 61 04 0328*      call rand_8
046D59 E6 01       0329*      and %00000001 ; 50/50 chance of moving left or right on spanw
046D5B 32 92 6D 04 0330*      ld (@move_step),a
046D5F             0331*  ; now copy to the table
046D5F 21 6F 6D 04 0332*      ld hl,@id ; address to copy from
046D63 D1          0333*      pop de ; address to copy to (was ix)
046D64 01 26 00 00 0334*      ld bc,table_bytes_per_record ; number of bytes to copy
046D68 ED B0       0335*      ldir ; copy the records from local scratch to sprite table
046D6A             0336*  ; finally, make the new sprite visible
046D6A CD 6F 5E 04 0337*      call vdu_sprite_show
046D6E C9          0338*      ret
046D6F 00          0339*  @id:               db     0x00 ; 1 bytes unique spriteId, zero-based
046D70 01          0340*  @type:             db enemy_small ; 1 bytes type of sprite as defined in enemies.inc
046D71 14 01 00    0341*  @base_bufferId:    dl BUF_SEEKER_000 ; 3 bytes bitmap bufferId
046D74 06 6D 04    0342*  @move_program:     dl move_enemy_small ; 3 bytes address of sprite's behavior subroutine
046D77 03          0343*  @collisions:       db %00000011 ; 3 bytes collides with enemy and laser
046D78 10          0344*  @dim_x:            db     0x10 ; 1 bytes sprite width in pixels
046D79 10          0345*  @dim_y:            db     0x10 ; 1 bytes sprite height in pixels
046D7A 00 00 00    0346*  @x:                dl 0x000000 ; 1 bytes 16.8 fractional x position in pixels
046D7D 00 00 00    0347*  @y:                dl 0x000000 ; 3 bytes 16.8 fractional y position in pixels
046D80 00 00 00    0348*  @xvel:             dl 0x000000 ; 3 bytes x-component velocity, 16.8 fixed, pixels
046D83 00 00 00    0349*  @yvel:             dl 0x000000 ; 3 bytes y-component velocity, 16.8 fixed, pixels
046D86 80 02 00    0350*  @vel:              dl speed_seeker ; 3 bytes velocity, 16.8 fixed, pixels
046D89 00 80 00    0351*  @heading:          dl 0x008000 ; 3 bytes sprite movement direction deg256 16.8 fixed
046D8C 00 80 00    0352*  @orientation:      dl 0x008000 ; 3 bytes orientation bits
046D8F 00          0353*  @animation:        db     0x00 ; 1 bytes current animation index, zero-based
046D90 00          0354*  @animation_timer:  db     0x00 ; 1 bytes when hits zero, draw next animation
046D91 01          0355*  @move_timer:       db     0x01 ; 1 bytes when zero, go to next move program, or step
046D92 00          0356*  @move_step:        db     0x00 ; 1 bytes stage in a move program sequence, varies
046D93 20          0357*  @points:           db     0x20 ; 1 bytes points awarded for killing this sprite type, BCD
046D94 02          0358*  @shield_damage:    db     0x02 ; 1 bytes shield points deducted for collision, binary
046D95             0359*  
046D95             0360*  ; move_laser_turret:
046D95             0361*  ; ; compute orientation to player
046D95             0362*  ;     call orientation_to_player
046D95             0363*  ; ; h.l 8.8 fixed angle256 to player
046D95             0364*  ; ; bc and de as signed 16-bit integers
046D95             0365*  ; ; representing delta-x/y *to* target respectively
046D95             0366*  ;     ld (Bearing_t),hl
046D95             0367*  ;     ld hl,0x0400
046D95             0368*  ;     ld (Vp),hl
046D95             0369*  ;     call targeting_computer
046D95             0370*  ;     ld (sprite_heading),hl ; store bearing to player
046D95             0371*  ; ; is it time to launch a fireball?
046D95             0372*  ;     ld hl,sprite_move_timer
046D95             0373*  ;     dec (hl)
046D95             0374*  ;     jp nz,move_laser_turret_boilerplate
046D95             0375*  ;     call fireballs_init
046D95             0376*  ;     ; reset move timer so can fire again if player doesn't take us out
046D95             0377*  ;     call rand_8     ; snag a random number
046D95             0378*  ;     and %00011111   ; keep only 5 lowest bits (max 31)
046D95             0379*  ;     add a,64 ; range is now 64-127
046D95             0380*  ;     ld (sprite_move_timer),a ; when this hits zero,will spawn a fireball
046D95             0381*  ; move_laser_turret_boilerplate:
046D95             0382*  ;     call move_active_tiles
046D95             0383*  ;     call check_collisions
046D95             0384*  ;     jp move_enemies_loop_return
046D95             0385*  
046D95             0386*  ; fireballs_init:
046D95             0387*  ;     call sprite_variables_to_stack
046D95             0388*  
046D95             0389*  ;     ld hl,fireballs
046D95             0390*  ;     ld (sprite_base_bufferId),hl
046D95             0391*  
046D95             0392*  ;     ld hl,move_fireballs
046D95             0393*  ;     ld (sprite_move_program),hl
046D95             0394*  
046D95             0395*  ;     ld a,%11 ; collides with laser and player
046D95             0396*  ;     ; ld a,%10 ; collides with laser DEBUG
046D95             0397*  ;     ld (iy+sprite_collisions),a
046D95             0398*  
046D95             0399*  ;     ld hl,(Vp)
046D95             0400*  ;     ld (sprite_vel),hl
046D95             0401*  ;     ld hl,(Vp_x)
046D95             0402*  ;     ld (sprite_xvel),hl
046D95             0403*  ;     ld hl,(Vp_y)
046D95             0404*  ;     inc h ; account for ground movement
046D95             0405*  ;     ld (sprite_yvel),hl
046D95             0406*  
046D95             0407*  ;     xor a ; zero a
046D95             0408*  ;     ld (sprite_animation),a
046D95             0409*  ;     ld (sprite_move_step),a
046D95             0410*  ;     ld (sprite_move_timer),a
046D95             0411*  
046D95             0412*  ;     ld a,6 ; 1/10th of a second timer
046D95             0413*  ;     ld (sprite_animation_timer),a
046D95             0414*  
046D95             0415*  ;     ld a,0x00 ; BCD
046D95             0416*  ;     ld (sprite_points),a
046D95             0417*  ;     ld a,1 ; binary
046D95             0418*  ;     ld (sprite_shield_damage),a
046D95             0419*  
046D95             0420*  ;     call table_add_record ; plops that on the sprite stack for later
046D95             0421*  ;     call sprite_variables_from_stack ; come back to where we started
046D95             0422*  ;     ret
046D95             0423*  
046D95             0424*  ; move_fireballs:
046D95             0425*  ;     call move_enemy_sprite ; move sprite
046D95             0426*  ;     ld a,(sprite_screen_edge) ; check for collision with screen edge
046D95             0427*  ;     and a ; if zero we're still within screen bounds
046D95             0428*  ;     jr z,move_fireballs_alive
046D95             0429*  ; ; otherwise kill sprite
046D95             0430*  ;     ld a,%10000000 ; any bit set in high nibble means sprite will die
046D95             0431*  ;     ld (iy+sprite_collisions),a
046D95             0432*  ;     jp move_enemies_loop_return
046D95             0433*  ; move_fireballs_alive:
046D95             0434*  ;     ld a,(sprite_animation_timer)
046D95             0435*  ;     dec a
046D95             0436*  ;     ld (sprite_animation_timer),a
046D95             0437*  ;     jr nz,move_fireballs_draw
046D95             0438*  ;     ld a,(sprite_animation)
046D95             0439*  ;     xor %1
046D95             0440*  ;     ld (sprite_animation),a
046D95             0441*  ;     ld a,6 ; 1/10th of a second timer
046D95             0442*  ;     ld (sprite_animation_timer),a
046D95             0443*  ;     ; fall through
046D95             0444*  
046D95             0445*  ; move_fireballs_draw:
046D95             0446*  ;     call vdu_bmp_select
046D95             0447*  ;     call vdu_bmp_draw
046D95             0448*  ;     call check_collisions
046D95             0449*  ;     jp move_enemies_loop_return
046D95             0450*  
046D95             0451*  ; compute orientation to player
046D95             0452*  ; based on relative positions
046D95             0453*  ; returns: h.l 16.8 fixed angle256 to player
046D95             0454*  ;    ub.c and ud.e as 16.8 signed fixed point numbers
046D95             0455*  ;    representing delta-x/y *to* target respectively
046D95             0456*  orientation_to_player:
046D95 FD 2A FB 52 0457*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
046D9A FD E5       0458*      push iy ; so we can send it back intact
046D9C FD 07 0B    0459*      ld bc,(iy+sprite_x)
046D9F FD 17 0E    0460*      ld de,(iy+sprite_y)
046DA2 DD 2A 44 6A 0461*      ld ix,(player_x)
       04          
046DA7 FD 2A 47 6A 0462*      ld iy,(player_y)
       04          
046DAC CD 31 62 04 0463*      call dxy168
046DB0 CD 98 62 04 0464*      call atan2_168game
046DB4 ED 4B 8C 62 0465*      ld bc,(dx168)
       04          
046DB9 ED 5B 92 62 0466*      ld de,(dy168)
       04          
046DBE FD E1       0467*      pop iy ; restore table pointer
046DC0 C9          0468*      ret
046DC1             0469*  
046DC1             0470*  
046DC1             0471*  ; targeting_computer scratch variables
046DC1 00 00       0472*  Bearing_t: dw #0000 ; 8.8 fixed
046DC3 00 00       0473*  Heading_t: dw #0000 ; 8.8 fixed
046DC5 00 00       0474*  Vp: dw #0000 ; 8.8 fixed
046DC7 00 00       0475*  Vp_x: dw #0000 ; 8.8 fixed
046DC9 00 00       0476*  Vp_y: dw #0000 ; 8.8 fixed
046DCB 00 00       0477*  Vt: dw #0000 ; 8.8 fixed
046DCD 00 00       0478*  Vt_x: dw #0000 ; 8.8 fixed
046DCF 00 00       0479*  Vt_y: dw #0000 ; 8.8 fixed
046DD1             0480*  
046DD1             0481*  
046DD1             0482*  ; ; Inputs:   see scratch variables
046DD1             0483*  ; ; Note:     a call to orientation_to_player provides these inputs
046DD1             0484*  ; ; Outputs:  h.l is the 16.8 fixed firing angle256
046DD1             0485*  ; ;           b.c and d.e are the 16.8 fixed x,y component projectile velocities
046DD1             0486*  ; ; https://old.robowiki.net/cgi-bin/robowiki?LinearTargeting
046DD1             0487*  ; targeting_computer:
046DD1             0488*  ; ; compute target velocity from x,y component velocities
046DD1             0489*  ;     ld bc,(player_xvel)
046DD1             0490*  ;     ld de,(player_yvel)
046DD1             0491*  ;     dec d ; account for vertical ground movement: b.c=player_xvel,d.e=player_yvel-1
046DD1             0492*  
046DD1             0493*  ;     call cartesian_to_polar ; b.c=Heading_t, d.e=Vt
046DD1             0494*  ;     ld (Heading_t),bc
046DD1             0495*  ;     ld (Vt),de
046DD1             0496*  
046DD1             0497*  ; ; compute Heading_t-Bearing_t
046DD1             0498*  ;     ld h,b
046DD1             0499*  ;     ld l,c
046DD1             0500*  ;     ld bc,(Bearing_t)
046DD1             0501*  ;     and a ; clear carry
046DD1             0502*  ;     sbc hl,bc ; h.l=Heading_t-Bearing_t
046DD1             0503*  
046DD1             0504*  ; ; compute sin(Heading_t-Bearing_t)
046DD1             0505*  ;     ld b,h
046DD1             0506*  ;     ld c,l
046DD1             0507*  ;     call sin_bc ; h.l=sin(Heading_t-Bearing_t)
046DD1             0508*  
046DD1             0509*  ; ; compute (Vt*sin(Heading_t-Bearing_t))
046DD1             0510*  ;     ex de,hl
046DD1             0511*  ;     ld bc,(Vt)
046DD1             0512*  ;     call BC_Mul_DE_88 ; h.l=(Vt*sin(Heading_t-Bearing_t))
046DD1             0513*  
046DD1             0514*  ; ; compute (Vt * sin(Heading_t-Bearing_t)) / Vp
046DD1             0515*  ;     ld b,h
046DD1             0516*  ;     ld c,l
046DD1             0517*  ;     ld de,(Vp)
046DD1             0518*  ;     call div_88 ; h.l=(Vt*sin(Heading_t-Bearing_t)) / Vp
046DD1             0519*  ; ; answer is in radians, convert to degrees256
046DD1             0520*  ;     ex de,hl
046DD1             0521*  ;     ld bc,#28BE ; 40.74=57.29578*256/360
046DD1             0522*  ;     call BC_Mul_DE_88
046DD1             0523*  
046DD1             0524*  ; ; add lead angle to target bearing
046DD1             0525*  ;     ld de,(Bearing_t)
046DD1             0526*  ;     add hl,de ; h.l=lead angle+target bearing
046DD1             0527*  ;     push hl
046DD1             0528*  
046DD1             0529*  ; ; compute component projectile velocities
046DD1             0530*  ;     ld b,h
046DD1             0531*  ;     ld c,l
046DD1             0532*  ;     ld de,(Vp)
046DD1             0533*  ;     call polar_to_cartesian ; b.c=Vp_x, d.e=Vp_y
046DD1             0534*  
046DD1             0535*  ;     ld (Vp_x),bc
046DD1             0536*  ;     ld (Vp_y),de
046DD1             0537*  ;     pop hl ; h.l=lead angle+target bearing
046DD1             0538*  ;     ret
046DD1             0539*  
046DD1             0540*  ; this routine vanquishes the enemy sprite
046DD1             0541*  ; and replaces it with an animated explosion
046DD1             0542*  ; we jump here instead of call because
046DD1             0543*  ; we want to return to differing locations in the loop
046DD1             0544*  ; depending on whether we're still sploding
046DD1             0545*  ; destroys: everything except index registers
046DD1             0546*  ; returns: an incandescent ball of debris and gas
046DD1             0547*  kill_nurple:
046DD1             0548*  ; ; tally up points
046DD1             0549*  ;     ld bc,0
046DD1             0550*  ;     ld a,(sprite_points)
046DD1             0551*  ;     ld e,a
046DD1             0552*  ;     ld d,0
046DD1             0553*  ;     ld hl,add_bcd_arg2
046DD1             0554*  ;     call set_bcd
046DD1             0555*  ;     ld hl,player_score
046DD1             0556*  ;     ld de,add_bcd_arg2
046DD1             0557*  ;     ld a,3 ; number of bytes to add
046DD1             0558*  ;     call add_bcd
046DD1             0559*  ; ; initialize explosion
046DD1             0560*  ; init_explosion:
046DD1             0561*  ;     ld hl,explosion
046DD1             0562*  ;     ld (sprite_base_bufferId),hl
046DD1             0563*  ;     ld hl,move_explosion
046DD1             0564*  ;     ld (sprite_move_program),hl
046DD1             0565*  ;     ld a,%00000000 ; collides with nothing
046DD1             0566*  ;     ld (iy+sprite_collisions),a
046DD1             0567*  ;     ld hl,0 ; north
046DD1             0568*  ;     ld (sprite_heading),hl
046DD1             0569*  ;     ld a,0x04 ; will decrement to 03
046DD1             0570*  ;     ld (sprite_animation),a
046DD1             0571*  ;     ld a,0x07 ; 7/60th of a second timer
046DD1             0572*  ;     ld (sprite_animation_timer),a
046DD1             0573*  ;     xor a
046DD1             0574*  ;     ld (sprite_move_timer),a
046DD1             0575*  ;     call vdu_bmp_select
046DD1             0576*  ; ; fall through to next_explosion
046DD1             0577*  ; next_explosion:
046DD1             0578*  ;     ld a,(sprite_animation)
046DD1             0579*  ;     dec a ; if rolled negative from zero,we're done sploding
046DD1             0580*  ;     jp m,done_explosion
046DD1             0581*  ;     ld (sprite_animation),a
046DD1             0582*  ;     ld a,0x7 ; 7/60th of a second timer
046DD1             0583*  ;     ld (sprite_animation_timer),a
046DD1             0584*  ; ; fall through to animate_explosion
046DD1             0585*  ; animate_explosion:
046DD1             0586*  ;     ld hl,sprite_y+1
046DD1             0587*  ;     inc (hl) ; move explosion down 1 pixel
046DD1             0588*  ;     jr z, done_explosion ; if wraparound to top of screen, kill explosion
046DD1             0589*  ;     ld hl,sprite_animation_timer
046DD1             0590*  ;     dec (hl) ; if timer is zero,we do next animation
046DD1             0591*  ;     jr z,next_explosion
046DD1             0592*  ;     ;otherwise we fall through to draw the current one
046DD1             0593*  ;     call vdu_bmp_select
046DD1             0594*  ;     call vdu_bmp_draw
046DD1             0595*  ;     ret ; now we go back to caller
046DD1             0596*  ; done_explosion:
046DD1 3E 80       0597*      ld a,%10000000 ; high bit set is non-specific kill-me flag
046DD3 FD 2A FB 52 0598*      ld iy,(table_pointer); TODO: see if we can get IY to land here with the proper value
       04          
046DD8 FD 77 08    0599*      ld (iy+sprite_collisions),a
046DDB C9          0600*      ret ; now we go back to caller
046DDC             0601*  
046DDC             0602*  ; game_over:
046DDC             0603*  ;     jp new_game
046DDC             0604*  
046DDC             0605*  ; it's presumed we've already checked that laser is alive
046DDC             0606*  collision_enemy_with_laser:
046DDC DD 2A 69 6E 0607*      ld ix,(laser_x)
       04          
046DE1 FD 2A 6C 6E 0608*      ld iy,(laser_y)
       04          
046DE6 3A 67 6E 04 0609*      ld a,(laser_dim_x)
046DEA CB 2F       0610*      sra a ; divide by 2
046DEC F5          0611*      push af ; we need this later
046DED             0612*      ; ld de,0
046DED             0613*      ; ld d,a
046DED             0614*      ; add ix,de
046DED             0615*      ; add iy,de
046DED 18 11       0616*      jr collision_enemy
046DEF             0617*  
046DEF             0618*  ; it's presumed we've already checked that player is alive
046DEF             0619*  collision_enemy_with_player:
046DEF DD 2A 44 6A 0620*      ld ix,(player_x)
       04          
046DF4 FD 2A 47 6A 0621*      ld iy,(player_y)
       04          
046DF9 3A 42 6A 04 0622*      ld a,(player_dim_x)
046DFD             0623*  
046DFD             0624*      ; call dumpRegistersHex
046DFD             0625*  
046DFD CB 2F       0626*      sra a ; divide by 2
046DFF F5          0627*      push af ; we need this later
046E00             0628*      ; ld de,0
046E00             0629*      ; ld d,a
046E00             0630*      ; add ix,de
046E00             0631*      ; add iy,de
046E00             0632*      ; fall through to collision_enemy
046E00             0633*  
046E00             0634*  ; compute the distance between the two sprites' centers
046E00             0635*  ; inputs: bc and de as y0,x0 and y1,x1 respectively
046E00             0636*  collision_enemy:
046E00             0637*  ; back up iy because we need it as the sprite table pointer
046E00 FD E5       0638*      push iy
046E02 FD 2A FB 52 0639*      ld iy,(table_pointer)
       04          
046E07 FD 27 0B    0640*      ld hl,(iy+sprite_x)
046E0A FD 7E 09    0641*      ld a,(iy+sprite_dim_x)
046E0D CB 2F       0642*      sra a
046E0F F5          0643*      push af ; we need this later
046E10             0644*      ; ld de,0
046E10             0645*      ; ld d,a
046E10             0646*      ; add hl,de
046E10 E5          0647*      push hl
046E11 C1          0648*      pop bc ; bc = x0
046E12 FD 27 0E    0649*      ld hl,(iy+sprite_y)
046E15 FD 7E 0A    0650*      ld a,(iy+sprite_dim_y)
046E18             0651*      ; sra a
046E18             0652*      ; ld de,0
046E18             0653*      ; ld d,a
046E18             0654*      ; add hl,de
046E18 EB          0655*      ex de,hl ; de = y0
046E19 F1          0656*      pop af ; TODO: srsly, this is the best way to do this?
046E1A FD E1       0657*      pop iy
046E1C F5          0658*      push af
046E1D             0659*  
046E1D             0660*      ; call dumpRegistersHex
046E1D             0661*  
046E1D CD 4C 62 04 0662*      call distance168
046E21             0663*      ; CALL dumpRegistersHex
046E21             0664*  ; ; subtract sum of radii from distance between centers
046E21             0665*  ;     ld de,0
046E21             0666*  ;     pop af ; radius of enemy sprite
046E21             0667*  ;     ld e,a
046E21             0668*  ;     pop af ; radius of player or laser sprite
046E21             0669*  ;     add a,e
046E21             0670*  ;     ld e,a
046E21             0671*  ;     and a ; clear carry
046E21             0672*  ;     sbc hl,de
046E21             0673*  ;     jr c,collision_enemy_is
046E21             0674*  ;     xor a
046E21             0675*  ;     ret
046E21             0676*  ; temp fix TODO: remove this
046E21 F1          0677*      pop af
046E22 F1          0678*      pop af
046E23 11 00 10 00 0679*      ld de,16*256
046E27 A7          0680*      and a
046E28 ED 52       0681*      sbc hl,de
046E2A 38 02       0682*      jr c,collision_enemy_is
046E2C AF          0683*      xor a
046E2D             0684*      ; call dumpRegistersHex
046E2D C9          0685*      ret
046E2E             0686*  collision_enemy_is:
046E2E AF          0687*      xor a
046E2F 3C          0688*      inc a
046E30             0689*      ; call dumpRegistersHex
046E30 C9          0690*      ret
046E31             0691*  
046E31             0692*  ; ; looks up what enemy sprite collides with
046E31             0693*  ; ; detects collisions
046E31             0694*  ; ; and sets things to sploding accordingly
046E31             0695*  ; check_collisions:
046E31             0696*  ;     ld a,(iy+sprite_collisions) ; snag what we collide with
046E31             0697*  ;     and a ; if this is zero,
046E31             0698*  ;     ret z ; there's nothing to do
046E31             0699*  ;     and %01 ; do we collide with player?
046E31             0700*  ;     jr z,move_enemies_laser ; if not,check laser collision
046E31             0701*  ;     call collision_enemy_with_player ; otherwise see if we hit player
046E31             0702*  ;     and a ; was there a collision?
046E31             0703*  ;     jr z,move_enemies_laser ; if not,see if laser smacked us
046E31             0704*  ; ; yes collision with player
046E31             0705*  ;     ; deduct shield damage
046E31             0706*  ;     ld hl,sprite_shield_damage
046E31             0707*  ;     ld a,(player_shields)
046E31             0708*  ;     sub (hl)
046E31             0709*  ;     ld (player_shields),a
046E31             0710*  ; ; if shields >= 0,player survives
046E31             0711*  ;     jp p,check_collisions_kill_nurple
046E31             0712*  ; ; otherwise update player status so it will die
046E31             0713*  ;     ld a,(player_collisions)
046E31             0714*  ;     or %10 ; sets bit 1,meaning player just died
046E31             0715*  ;     ld (player_collisions),a
046E31             0716*  ;     ; fall through
046E31             0717*  ; check_collisions_kill_nurple:
046E31             0718*  ; ; kill enemy and replace with explosion
046E31             0719*  ;     call kill_nurple
046E31             0720*  ;     ret ; and out
046E31             0721*  
046E31             0722*  check_collisions:
046E31 CD EF 6D 04 0723*      call collision_enemy_with_player ; did we hit the player?
046E35 A7          0724*      and a ; was there a collision?
046E36 C8          0725*      ret z ; if not,we're done
046E37 CD D1 6D 04 0726*      call kill_nurple ; otherwise kill enemy
046E3B C9          0727*      ret
046E3C             0728*  
046E3C             0729*  ; did we hit the laser?
046E3C             0730*  move_enemies_laser:
046E3C FD 7E 08    0731*      ld a,(iy+sprite_collisions) ; snag what we collide with again
046E3F E6 02       0732*      and %10 ; do we even collide with laser?
046E41 C8          0733*      ret z ; if not,we're out
046E42 3A 66 6E 04 0734*      ld a,(laser_collisions) ; is laser alive?
046E46 E6 01       0735*      and %1 ; if bit 0 is not set laser is dead
046E48 C8          0736*      ret z ; so we're out
046E49 CD DC 6D 04 0737*      call collision_enemy_with_laser ; otherwise check for collision
046E4D A7          0738*      and a ; was there a collision?
046E4E C8          0739*      ret z ; if not,we're done
046E4F             0740*  ; otherwise we mark laser for termination and kill enemy
046E4F             0741*  ; update laser status so it will die
046E4F 3A 66 6E 04 0742*      ld a,(laser_collisions)
046E53 F6 02       0743*      or %10 ; bit 1 set means laser just died
046E55 32 66 6E 04 0744*      ld (laser_collisions),a
046E59 CD D1 6D 04 0745*      call kill_nurple ; yes there was a collision,so kill enemy
046E5D C9          0746*      ret ; we're outta' here
046E5E             0066   	include "src/asm/laser.inc"
046E5E             0001*  ; ##### LASER SPRITE PARAMETERS #####
046E5E             0002*  ; uses the same offsets from its table base as the main sprite table:
046E5E             0003*  laser_start_variables: ; label marking beginning of table
046E5E 05          0004*  laser_id:               db table_max_records+1
046E5F 00          0005*  laser_type:             db     0x00 ; 1 bytes currently not used
046E60 11 01 00    0006*  laser_base_bufferId:    dl BUF_LASER_A ; 3 bytes bitmap bufferId
046E63 00 00 00    0007*  laser_move_program:     dl 0x000000 ; 3 bytes not currently used
046E66 00          0008*  laser_collisions:       db     0x00 ; 1 bytes bit 0 set=alive, otherwise dead, bit 1 set=just died
046E67 00          0009*  laser_dim_x:            db     0x00 ; 1 bytes sprite width in pixels
046E68 00          0010*  laser_dim_y:            db     0x00 ; 1 bytes sprite height in pixels
046E69 00 00 00    0011*  laser_x:                dl 0x000000 ; 3 bytes 16.8 fractional x position in pixels
046E6C 00 00 00    0012*  laser_y:                dl 0x000000 ; 3 bytes 16.8 fractional y position in pixels
046E6F 00 00 00    0013*  laser_xvel:             dl 0x000000 ; 3 bytes x-component velocity, 16.8 fixed, pixels
046E72 00 F8 FF    0014*  laser_yvel:             dl 0xFFF800 ; 3 bytes y-component velocity, 16.8 fixed, pixels
046E75 00 00 00    0015*  laser_vel:              dl 0x000000 ; 3 bytes not currently used
046E78 00 00 00    0016*  laser_heading:          dl 0x000000 ; 3 bytes sprite movement direction deg256 16.8 fixed
046E7B 00 00 00    0017*  laser_orientation:      dl 0x000000 ; 3 bytes not currently used
046E7E 00          0018*  laser_animation:        db     0x00 ; 1 bytes current sprite animation frame
046E7F 00          0019*  laser_animation_timer:  db     0x00 ; 1 bytes decremented every frame, when zero, advance animation
046E80 00          0020*  laser_move_timer:       db     0x00 ; 1 bytes not currently used
046E81 00          0021*  laser_move_step:        db     0x00 ; 1 bytes not currently used
046E82 00          0022*  laser_points:           db     0x00 ; 1 bytes not currently used
046E83 00          0023*  laser_shield_damage:    db     0x00 ; 1 bytes not currently used
046E84             0024*  laser_end_variables: ; for when we want to traverse this table in reverse
046E84             0025*  
046E84             0026*  ; laser_control:
046E84             0027*  ; ; is laser already active?
046E84             0028*  ;     ld a,(laser_collisions)
046E84             0029*  ;     and %00000001 ; bit zero is lit if laser is active
046E84             0030*  ;     jr nz,laser_move ; move laser if not zero
046E84             0031*  ; ; otherwise check if laser fired
046E84             0032*  ;     in a,(#82) ; keyboard
046E84             0033*  ;     and %00010000 ; bit 4 is lit if space bar pressed
046E84             0034*  ;     ret z ; go back if laser not fired
046E84             0035*  ; ; otherwise,FIRE ZEE LASER!!1111
046E84             0036*  ; ; set laser status to active (set bit 0)
046E84             0037*  ;     ld a,%1
046E84             0038*  ;     ld (laser_collisions),a
046E84             0039*  ; ; initialize laser position
046E84             0040*  ;     ld a,(player_x+1) ; we only need the integer part
046E84             0041*  ;     ; add a,6 ; horizontal center with player sprite
046E84             0042*  ;     ld (laser_x+1),a ; store laser x coordinate
046E84             0043*  ;     ld a,(player_y+1) ; we only need the integer part
046E84             0044*  ;     add a,-6 ; set laser y a few pixels above player
046E84             0045*  ;     ld (laser_y+1),a ; store laser y coordinate
046E84             0046*  ;     ; fall through to laser_move
046E84             0047*  
046E84             0048*  ; laser_move:
046E84             0049*  ; ; begin setting laser to active sprite
046E84             0050*  ;     ld hl,lasers
046E84             0051*  ;     ld (sprite_base_bufferId),hl
046E84             0052*  ;     ld hl,0 ; north
046E84             0053*  ;     ld (sprite_heading),hl
046E84             0054*  ;     xor a ; laser has no animations yet :-(
046E84             0055*  ;     ld (sprite_animation),a
046E84             0056*  ;     ; we set position here for the time being as a default
046E84             0057*  ;     ; in case the laser is flagged for deletion
046E84             0058*  ;     ; load sprite_x with laser x position (we do y further down)
046E84             0059*  ;     ld hl,(laser_x)
046E84             0060*  ;     ld (sprite_x),hl
046E84             0061*  ; ; did laser just die?
046E84             0062*  ;     ld a,(laser_collisions)
046E84             0063*  ;     bit 1,a ; z if laser didn't just die
046E84             0064*  ;     jr z,laser_not_dead_yet
046E84             0065*  ; ; yes laser died
046E84             0066*  ;     call kill_laser
046E84             0067*  ;     ret ; done
046E84             0068*  ; laser_not_dead_yet:
046E84             0069*  ; ; draw it
046E84             0070*  ; ; update laser y position
046E84             0071*  ;     ld hl,(laser_y) ; grab laser y position
046E84             0072*  ;     ld de,(laser_yvel) ; snag laser y velocity
046E84             0073*  ;     add hl,de ; add y velocity to y pos
046E84             0074*  ;     ld (sprite_y),hl ; update laser y position
046E84             0075*  ;     ld (laser_y),hl ; update laser y position
046E84             0076*  ; ; are we at top of screen?
046E84             0077*  ;     ld a,#51 ; top of visible screen plus a pixel
046E84             0078*  ;     sub h ; no carry if above threshold
046E84             0079*  ;     jr c,finally_draw_the_frikken_laser
046E84             0080*  ;     ; if at top of screen,laser dies
046E84             0081*  ;     call kill_laser
046E84             0082*  ;     ret
046E84             0083*  ; ; otherwise,finally draw the frikken laser
046E84             0084*  ; finally_draw_the_frikken_laser:
046E84             0085*  ;     call vdu_bmp_select
046E84             0086*  ;     call vdu_bmp_draw
046E84             0087*  ; ; all done
046E84             0088*  ;     ret
046E84             0089*  
046E84             0090*  ; kill_laser:
046E84             0091*  ; ; update status to inactive
046E84             0092*  ;     xor a ; zero out a
046E84             0093*  ;     ld (laser_collisions),a
046E84             0094*  ;     ret
046E84             0067   
046E84             0068   	include "src/asm/timer.inc"
046E84             0001*  ; Table 32. Timer Control Registers
046E84             0002*  ; this constant is the base address of the timer control registers
046E84             0003*  ; each timer takes three bytes:
046E84             0004*  ;   0: control register
046E84             0005*  ;   1: low byte of timer reset value
046E84             0006*  ;   2: high byte of timer reset value
046E84             0007*  ; note that the value is only 8-bits,so we use in0/out0 i/o calls,
046E84             0008*  ; which correctly force the high and upper bytes of the address bus to zero
046E84             0009*  TMR_CTL:     equ 80h
046E84             0010*  
046E84             0011*  ; Timer Control Register Bit Definitions
046E84             0012*  PRT_IRQ_0:    equ %00000000 ; The timer does not reach its end-of-count value.
046E84             0013*                              ; This bit is reset to 0 every time the TMRx_CTL register is read.
046E84             0014*  PRT_IRQ_1:    equ %10000000 ; The timer reaches its end-of-count value. If IRQ_EN is set to 1,
046E84             0015*                              ; an interrupt signal is sent to the CPU. This bit remains 1 until
046E84             0016*                              ; the TMRx_CTL register is read.
046E84             0017*  
046E84             0018*  IRQ_EN_0:     equ %00000000 ; Timer interrupt requests are disabled.
046E84             0019*  IRQ_EN_1:     equ %01000000 ; Timer interrupt requests are enabled.
046E84             0020*  
046E84             0021*  PRT_MODE_0:   equ %00000000 ; The timer operates in SINGLE PASS mode. PRT_EN (bit 0) is reset to
046E84             0022*                              ;  0,and counting stops when the end-of-count value is reached.
046E84             0023*  PRT_MODE_1:   equ %00010000 ; The timer operates in CONTINUOUS mode. The timer reload value is
046E84             0024*                              ; written to the counter when the end-of-count value is reached.
046E84             0025*  
046E84             0026*  ; CLK_DIV is a 2-bit mask that sets the timer input source clock divider
046E84             0027*  CLK_DIV_256:  equ %00001100 ;
046E84             0028*  CLK_DIV_64:   equ %00001000 ;
046E84             0029*  CLK_DIV_16:   equ %00000100 ;
046E84             0030*  CLK_DIV_4:    equ %00000000 ;
046E84             0031*  
046E84             0032*  RST_EN_0:     equ %00000000 ; The reload and restart function is disabled.
046E84             0033*  RST_EN_1:     equ %00000010 ; The reload and restart function is enabled.
046E84             0034*                              ; When a 1 is written to this bit,the values in the reload registers
046E84             0035*                              ;  are loaded into the downcounter when the timer restarts. The
046E84             0036*                              ; programmer must ensure that this bit is set to 1 each time
046E84             0037*                              ; SINGLE-PASS mode is used.
046E84             0038*  
046E84             0039*  ; disable/enable the programmable reload timer
046E84             0040*  PRT_EN_0:     equ %00000000 ;
046E84             0041*  PRT_EN_1:     equ %00000001 ;
046E84             0042*  
046E84             0043*  ; Table 37. Timer Input Source Select Register
046E84             0044*  ; Each of the 4 timers are allocated two bits of the 8-bit register
046E84             0045*  ; in little-endian order,with TMR0 using bits 0 and 1,TMR1 using bits 2 and 3,etc.
046E84             0046*  ;   00: System clock / CLK_DIV
046E84             0047*  ;   01: RTC / CLK_DIV
046E84             0048*  ;   NOTE: these are the values given in the manual,but it may be a typo
046E84             0049*  ;   10: GPIO port B pin 1.
046E84             0050*  ;   11: GPIO port B pin 1.
046E84             0051*  TMR_ISS:   equ 92h ; register address
046E84             0052*  
046E84             0053*  ; Table 51. Real-Time Clock Control Register
046E84             0054*  RTC_CTRL: equ EDh ; register address
046E84             0055*  
046E84             0056*  ; alarm interrupt disable/enable
046E84             0057*  RTC_ALARM_0:    equ %00000000
046E84             0058*  RTC_ALARM_1:    equ %10000000
046E84             0059*  
046E84             0060*  ; interrupt on alarm disable/enable
046E84             0061*  RTC_INT_ENT_0:  equ %00000000
046E84             0062*  RTC_INT_ENT_1:  equ %01000000
046E84             0063*  
046E84             0064*  RTC_BCD_EN_0:   equ %00000000   ; RTC count and alarm registers are binary
046E84             0065*  RTC_BCD_EN_1:   equ %00100000   ; RTC count and alarm registers are BCD
046E84             0066*  
046E84             0067*  RTC_CLK_SEL_0:  equ %00000000   ; RTC clock source is crystal oscillator output (32768 Hz).
046E84             0068*                                  ; On-chip 32768 Hz oscillator is enabled.
046E84             0069*  RTC_CLK_SEL_1:  equ %00010000   ; RTC clock source is power line frequency input as set by FREQ_SEL.
046E84             0070*                                  ; On-chip 32768 Hz oscillator is disabled.
046E84             0071*  
046E84             0072*  RTC_FREQ_SEL_0: equ %00000000   ; 60 Hz power line frequency.
046E84             0073*  RTC_FREQ_SEL_1: equ %00001000   ; 50 Hz power line frequency.
046E84             0074*  
046E84             0075*  RTC_SLP_WAKE_0: equ %00000000   ; RTC does not generate a sleep-mode recovery reset.
046E84             0076*  RTC_SLP_WAKE_1: equ %00000010   ; RTC generates a sleep-mode recovery reset.
046E84             0077*  
046E84             0078*  RTC_UNLOCK_0:   equ %00000000   ; RTC count registers are locked to prevent Write access.
046E84             0079*                                  ; RTC counter is enabled.
046E84             0080*  RTC_UNLOCK_1:   equ %00000001   ; RTC count registers are unlocked to allow Write access.
046E84             0081*                                  ; RTC counter is disabled.
046E84             0082*  
046E84             0083*  ; prt_reload_emulator: equ 11234 ; 1/102.4 seconds on emulator with 16 clock divider
046E84             0084*  
046E84             0085*  prt_reload_emulator: equ 11519 ; 1 centisecond on emulator with 16 clock divider
046E84             0086*  prt_reload_hardware: equ 11532 ; 1 centisecond on hardware with 16 clock divider
046E84 00 00 00    0087*  prt_reload: dl 0x000000
046E87             0088*  
046E87             0089*  ; returns: a = 0 if running on hardware,1 if running on emulator
046E87             0090*  ;          de = number PRT interrupts during test interval
046E87             0091*  prt_calibrate:
046E87 CD 78 5C 04 0092*      call vdu_vblank
046E8B             0093*  ; set a MOS timer
046E8B 21 78 00 00 0094*      ld hl,120*1 ; 1 second
046E8F FD 21 E2 6F 0095*      ld iy,tmr_test
       04          
046E94 CD C0 6F 04 0096*      call tmr_set
046E98             0097*  ; set a PRT timer
046E98             0098*      ; ld hl,prt_reload_hardware
046E98             0099*      ; ld hl,prt_reload_emulator
046E98 21 05 2D 00 0100*      ld hl,prt_reload_emulator + prt_reload_hardware / 2
046E9C 22 84 6E 04 0101*      ld (prt_reload),hl
046EA0 CD FB 6E 04 0102*      call prt_set
046EA4             0103*  @loop:
046EA4             0104*  ; check time remaining on MOS timer
046EA4 CD CE 6F 04 0105*      call tmr_get
046EA8 CA B2 6E 04 0106*      jp z,@done ; time expired,so quit
046EAC FA B2 6E 04 0107*      jp m,@done ; time past expiration (negative),so quit
046EB0 18 F2       0108*      jr @loop
046EB2             0109*  @done:
046EB2 ED 5B 49 6F 0110*      ld de,(prt_irq_counter)
       04          
046EB7 01 0C 2D 00 0111*      ld bc,prt_reload_hardware ; default value for running on hardware
046EBB ED 43 84 6E 0112*      ld (prt_reload),bc
       04          
046EC0 21 64 00 00 0113*      ld hl,100 ; halfway between 101 for real hardware and 99 for emulator
046EC4 AF          0114*      xor a ; clear carry,zero is default value for running on hardware
046EC5 32 7A 70 04 0115*      ld (is_emulator),a
046EC9 ED 52       0116*      sbc hl,de
046ECB 21 92 70 04 0117*      ld hl,on_hardware ; default message for running on hardware
046ECF CA 87 6E 04 0118*      jp z,prt_calibrate ; zero result is indeterminate so we try again
046ED3 F8          0119*      ret m ; negative result means we're on hardware
046ED4 3C          0120*      inc a ; we're on emulator
046ED5 32 7A 70 04 0121*      ld (is_emulator),a
046ED9 01 FF 2C 00 0122*      ld bc,prt_reload_emulator
046EDD ED 43 84 6E 0123*      ld (prt_reload),bc
       04          
046EE2 21 7B 70 04 0124*      ld hl,on_emulator
046EE6 C9          0125*      ret
046EE7             0126*  
046EE7 43 61 6C 69 0127*  calibrating_timer: defb "Calibrating timer\r\n",0
       62 72 61 74 
       69 6E 67 20 
       74 69 6D 65 
       72 0D 0A 00 
046EFB             0128*  
046EFB             0129*  ; set PRT timer
046EFB             0130*  prt_set:
046EFB 21 00 00 00 0131*      ld hl,0
046EFF 22 49 6F 04 0132*      ld (prt_irq_counter),hl
046F03 2A 84 6E 04 0133*      ld hl,(prt_reload)
046F07 ED 29 84    0134*      out0 ($84),l
046F0A ED 21 85    0135*  	out0 ($85),h
046F0D             0136*  ; disable timer
046F0D 3E 06       0137*      ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_16 | RST_EN_1 | PRT_EN_0
046F0F ED 39 83    0138*  	out0 ($83),a
046F12             0139*  ; enable timer,with interrupt and CONTINUOUS mode,clock divider 16
046F12 3E 57       0140*      ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_16 | RST_EN_1 | PRT_EN_1
046F14 ED 39 83    0141*  	out0 ($83),a
046F17 C9          0142*      ret
046F18             0143*  
046F18             0144*  ; ===============================================
046F18             0145*  ; PRT Timer Interrupt Handling
046F18             0146*  ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.inc
046F18             0147*  ; -----------------------------------------------
046F18             0148*  prt_irq_init:
046F18             0149*      ; set up interrupt vector table 2
046F18 21 00 00 00 0150*  	ld hl,0
046F1C 3A 0C 01 00 0151*  	ld a,($10c)
046F20 6F          0152*  	ld l,a
046F21 3A 0D 01 00 0153*  	ld a,($10d)
046F25 67          0154*  	ld h,a
046F26             0155*  
046F26             0156*  	; skip over CALL ($c3)
046F26 23          0157*  	inc hl
046F27             0158*  	; load address of jump into vector table 2 (in ram)
046F27 ED 27       0159*  	ld hl,(hl)
046F29             0160*  
046F29             0161*  	; write CALL prt_irq_handler to vector table 2
046F29 3E C3       0162*  	ld a,$c3
046F2B 77          0163*  	ld (hl),a
046F2C 23          0164*  	inc hl
046F2D 11 34 6F 04 0165*  	ld de,prt_irq_handler
046F31 ED 1F       0166*  	ld (hl),de
046F33             0167*  
046F33 C9          0168*      ret
046F34             0169*  
046F34             0170*  prt_irq_handler:
046F34 F3          0171*  	di
046F35 F5          0172*  	push af
046F36 E5          0173*      push hl
046F37 ED 38 83    0174*  	in0 a,($83)
046F3A 2A 49 6F 04 0175*  	ld hl,(prt_irq_counter)
046F3E 23          0176*  	inc hl
046F3F 22 49 6F 04 0177*  	ld (prt_irq_counter),hl
046F43 E1          0178*      pop hl
046F44 F1          0179*  	pop af
046F45 FB          0180*  	ei
046F46 5B ED 4D    0181*  	reti.l
046F49             0182*  
046F49             0183*  prt_irq_counter:
046F49 00 00 00    0184*  	.dl 0
046F4C             0185*  prt_irq_counter_saved:
046F4C 00 00 00    0186*      .dl 0
046F4F             0187*  
046F4F             0188*  prt_loop_reset:
046F4F E5          0189*      push hl
046F50 21 00 00 00 0190*  	ld hl,0
046F54 22 49 6F 04 0191*  	ld (prt_irq_counter),hl
046F58 22 BA 6F 04 0192*      ld (prt_loop_counter),hl
046F5C 22 BD 6F 04 0193*      ld (prt_loops),hl
046F60 CD FB 6E 04 0194*      call prt_set
046F64 E1          0195*      pop hl
046F65 C9          0196*      ret
046F66             0197*  
046F66             0198*  prt_loop_start:
046F66 E5          0199*      push hl
046F67 21 00 00 00 0200*  	ld hl,0
046F6B 22 49 6F 04 0201*  	ld (prt_irq_counter),hl
046F6F E1          0202*      pop hl
046F70 C9          0203*      ret
046F71             0204*  
046F71             0205*  prt_loop_stop:
046F71 E5          0206*      push hl
046F72 D5          0207*      push de
046F73 2A 49 6F 04 0208*      ld hl,(prt_irq_counter)
046F77 ED 5B BA 6F 0209*      ld de,(prt_loop_counter)
       04          
046F7C 19          0210*      add hl,de
046F7D 22 BA 6F 04 0211*      ld (prt_loop_counter),hl
046F81 21 00 00 00 0212*      ld hl,0
046F85 22 49 6F 04 0213*      ld (prt_irq_counter),hl
046F89 2A BD 6F 04 0214*      ld hl,(prt_loops)
046F8D 23          0215*      inc hl
046F8E 22 BD 6F 04 0216*      ld (prt_loops),hl
046F92 D1          0217*      pop de
046F93 E1          0218*      pop hl
046F94 C9          0219*      ret
046F95             0220*  
046F95             0221*  ; inputs: bc = y,x text coordinates to print
046F95             0222*  prt_loop_print:
046F95 F5          0223*      push af
046F96 E5          0224*      push hl
046F97 C5          0225*      push bc
046F98 D5          0226*      push de
046F99 DD E5       0227*      push ix
046F9B FD E5       0228*      push iy
046F9D CD 5B 5B 04 0229*      call vdu_move_cursor
046FA1             0230*  
046FA1 2A BA 6F 04 0231*      ld hl,(prt_loop_counter)
046FA5 CD A7 54 04 0232*      call printDec
046FA9             0233*  
046FA9 2A BD 6F 04 0234*      ld hl,(prt_loops)
046FAD CD A7 54 04 0235*      call printDec
046FB1             0236*  
046FB1 FD E1       0237*      pop iy
046FB3 DD E1       0238*      pop ix
046FB5 D1          0239*      pop de
046FB6 C1          0240*      pop bc
046FB7 E1          0241*      pop hl
046FB8 F1          0242*      pop af
046FB9 C9          0243*      ret
046FBA             0244*  
046FBA             0245*  prt_loop_counter:
046FBA 00 00 00    0246*      .dl 0
046FBD             0247*  prt_loops:
046FBD 00 00 00    0248*      .dl 0
046FC0             0249*  
046FC0             0250*  ; ===============================================
046FC0             0251*  ; Timer functions
046FC0             0252*  ; -----------------------------------------------
046FC0             0253*  ; set a countdown timer
046FC0             0254*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
046FC0             0255*  ; returns: hl = current time
046FC0             0256*  tmr_set:
046FC0 FD 2F 03    0257*      ld (iy+3),hl            ; set time remaining
046FC3             0258*      MOSCALL mos_sysvars     ; ix points to syvars table
046FC3 3E 08       0001*M 			LD	A, function
046FC5 5B CF       0002*M 			RST.LIL	08h
046FC7 DD 27 00    0259*      ld hl,(ix+sysvar_time)  ; get current time
046FCA FD 2F 00    0260*      ld (iy+0),hl            ; set start time
046FCD C9          0261*      ret
046FCE             0262*  
046FCE             0263*  ; gets time remaining on a countdown timer
046FCE             0264*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
046FCE             0265*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
046FCE             0266*  ;          sign flags: pos = time not expired,zero or neg = time expired
046FCE             0267*  tmr_get:
046FCE             0268*      MOSCALL mos_sysvars     ; ix points to syvars table
046FCE 3E 08       0001*M 			LD	A, function
046FD0 5B CF       0002*M 			RST.LIL	08h
046FD2 DD 17 00    0269*      ld de,(ix+sysvar_time)  ; get current time
046FD5 FD 27 00    0270*      ld hl,(iy+0)            ; get start time
046FD8 AF          0271*      xor a                   ; clear carry
046FD9 ED 52       0272*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
046FDB FD 17 03    0273*      ld de,(iy+3)            ; get timer set value
046FDE AF          0274*      xor a                   ; clear carry
046FDF ED 5A       0275*      adc hl,de               ; hl = time remaining
046FE1             0276*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
046FE1 C9          0277*      ret
046FE2             0278*  
046FE2             0279*  tmr_test: ds 6 ; example of a buffer to hold timer data
046FE8             0280*  
046FE8 00 00 00    0281*  timestamp_now: dl 0
046FEB 00 00 00    0282*  timestamp_old: dl 0
046FEE 00 00 00    0283*  timestamp_chg: dl 0
046FF1             0284*  
046FF1             0285*  ; update the global timestamp from the system clock
046FF1             0286*  ; inputs: none
046FF1             0287*  ; returns: hl = time elapsed in 1/120ths of a second
046FF1             0288*  ;          de = current time
046FF1             0289*  ;          ix = pointer to syvars table
046FF1             0290*  ; destroys: af,hl,de,ix
046FF1             0291*  timestamp_tick:
046FF1 ED 5B E8 6F 0292*      ld de,(timestamp_now)   ; get previous time
       04          
046FF6 ED 53 EB 6F 0293*      ld (timestamp_old),de   ; save previous time
       04          
046FFB             0294*      MOSCALL mos_sysvars     ; ix points to syvars table
046FFB 3E 08       0001*M 			LD	A, function
046FFD 5B CF       0002*M 			RST.LIL	08h
046FFF DD 27 00    0295*      ld hl,(ix+sysvar_time)  ; get current time
047002 22 E8 6F 04 0296*      ld (timestamp_now),hl   ; save current time
047006 AF          0297*      xor a                   ; clear carry
047007 ED 52       0298*      sbc hl,de               ; hl = time elapsed
047009 22 EE 6F 04 0299*      ld (timestamp_chg),hl   ; save elapsed time
04700D C9          0300*      ret
04700E             0301*  
04700E             0302*  ; set a countdown timer
04700E             0303*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
04700E             0304*  ; requires: timestamp_tick to be called at least once before this function
04700E             0305*  ; returns: hl = current time
04700E             0306*  ; destroys: hl
04700E             0307*  timestamp_tmr_set:
04700E FD 2F 03    0308*      ld (iy+3),hl            ; set time remaining
047011 2A E8 6F 04 0309*      ld hl,(timestamp_now)   ; get current timestamp
047015 FD 2F 00    0310*      ld (iy+0),hl            ; set start time
047018 C9          0311*      ret
047019             0312*  
047019             0313*  ; gets time remaining on a countdown timer following the global timestamp
047019             0314*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
047019             0315*  ; requires: timestamp_tick to be called at least once before this function
047019             0316*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
047019             0317*  ;          sign flags: pos = time not expired,zero or neg = time expired
047019             0318*  ; destroys: af,hl,de
047019             0319*  timestamp_tmr_get:
047019 ED 5B E8 6F 0320*      ld de,(timestamp_now)   ; get current timestamp
       04          
04701E FD 27 00    0321*      ld hl,(iy+0)            ; get start time
047021 AF          0322*      xor a                   ; clear carry
047022 ED 52       0323*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
047024 FD 17 03    0324*      ld de,(iy+3)            ; get timer set value
047027 AF          0325*      xor a                   ; clear carry
047028 ED 5A       0326*      adc hl,de               ; hl = time remaining
04702A             0327*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
04702A C9          0328*      ret
04702B             0329*  
04702B             0330*  ; set a stopwatch
04702B             0331*  ; returns: hl = start time
04702B             0332*  ; destroys: hl,ix
04702B             0333*  stopwatch_set:
04702B             0334*      MOSCALL mos_sysvars     ; ix points to syvars table
04702B 3E 08       0001*M 			LD	A, function
04702D 5B CF       0002*M 			RST.LIL	08h
04702F DD 27 00    0335*      ld hl,(ix+sysvar_time)  ; get current time
047032 22 47 70 04 0336*      ld (stopwatch_started),hl            ; set start time
047036 C9          0337*      ret
047037             0338*  
047037             0339*  ; gets time elapsed on a stopwatch
047037             0340*  ; returns: hl = time elapsed in 1/120ths of a second
047037             0341*  ; destroys: af,hl,de,ix
047037             0342*  stopwatch_get:
047037             0343*      MOSCALL mos_sysvars     ; ix points to syvars table
047037 3E 08       0001*M 			LD	A, function
047039 5B CF       0002*M 			RST.LIL	08h
04703B DD 27 00    0344*      ld hl,(ix+sysvar_time)  ; get current time
04703E ED 5B 47 70 0345*      ld de,(stopwatch_started)            ; get start time
       04          
047043 AF          0346*      xor a                   ; clear carry
047044 ED 52       0347*      sbc hl,de               ; hl = time elapsed (will always be zero or positive)
047046 C9          0348*      ret
047047             0349*  
047047             0350*  stopwatch_started: ds 3 ; buffer to hold stopwatch start time
04704A             0351*  
04704A             0352*  ; ------------------
04704A             0353*  ; delay routine
04704A             0354*  ; Author: Richard Turrnidge
04704A             0355*  ; https://github.com/richardturnnidge/lessons/blob/main/slowdown.inc
04704A             0356*  ; routine waits a fixed time,then returns
04704A             0357*  ; arrive with A =  the delay byte. One bit to be set only.
04704A             0358*  ; eg. ld A,00000100b
04704A             0359*  
04704A             0360*  multiPurposeDelay:
04704A F5          0361*      push af
04704B C5          0362*      push bc
04704C DD E5       0363*      push ix
04704E 47          0364*      ld b,a
04704F 3E 08       0365*      ld a,$08
047051 5B CF       0366*      RST.LIL	08h                 ; get IX pointer to sysvars
047053             0367*  
047053             0368*  waitLoop:
047053             0369*  
047053 DD 7E 00    0370*      ld a,(ix + 0)              ; ix+0h is lowest byte of clock timer
047056             0371*  
047056             0372*                                  ;   we check if bit set is same as last time we checked.
047056             0373*                                  ;   bit 0 - don't use
047056             0374*                                  ;   bit 1 - changes 64 times per second
047056             0375*                                  ;   bit 2 - changes 32 times per second
047056             0376*                                  ;   bit 3 - changes 16 times per second
047056             0377*  
047056             0378*                                  ;   bit 4 - changes 8 times per second
047056             0379*                                  ;   bit 5 - changes 4 times per second
047056             0380*                                  ;   bit 6 - changes 2 times per second
047056             0381*                                  ;   bit 7 - changes 1 times per second
047056 A0          0382*      and b
047057 4F          0383*      ld c,a
047058 3A 69 70 04 0384*      ld a,(oldTimeStamp)
04705C B9          0385*      cp c                        ; is A same as last value?
04705D 28 F4       0386*      jr z,waitLoop              ; loop here if it is
04705F 79          0387*      ld a,c
047060 32 69 70 04 0388*      ld (oldTimeStamp),a        ; set new value
047064             0389*  
047064 DD E1       0390*      pop ix
047066 C1          0391*      pop bc
047067 F1          0392*      pop af
047068 C9          0393*      ret
047069             0394*  
047069 00          0395*  oldTimeStamp:   .db 00h
04706A             0069   
04706A 48 65 6C 6C 0070   hello_world: defb "Hello, World!\n\r",0
       6F 2C 20 57 
       6F 72 6C 64 
       21 0A 0D 00 
04707A 00          0071   is_emulator: defb 0
04707B 52 75 6E 6E 0072   on_emulator: defb "Running on emulator.\r\n",0
       69 6E 67 20 
       6F 6E 20 65 
       6D 75 6C 61 
       74 6F 72 2E 
       0D 0A 00    
047092 52 75 6E 6E 0073   on_hardware: defb "Running on hardware.\r\n",0
       69 6E 67 20 
       6F 6E 20 68 
       61 72 64 77 
       61 72 65 2E 
       0D 0A 00    
0470A9             0074   
0470A9             0075   init:
0470A9             0076   ; ; set fonts
0470A9             0077   ; 	ld hl,font_nurples
0470A9             0078   ; 	ld b,144 ; loop counter for 96 chars
0470A9             0079   ; 	ld a,32 ; first char to define (space)
0470A9             0080   ; @loop:
0470A9             0081   ; 	push bc
0470A9             0082   ; 	push hl
0470A9             0083   ; 	push af
0470A9             0084   ; 	call vdu_define_character
0470A9             0085   ; 	pop af
0470A9             0086   ; 	inc a
0470A9             0087   ; 	pop hl
0470A9             0088   ; 	ld de,8
0470A9             0089   ; 	add hl,de
0470A9             0090   ; 	pop bc
0470A9             0091   ; 	djnz @loop
0470A9             0092   
0470A9             0093   ; set up the display
0470A9 3E 08       0094       ld a,8
0470AB CD AB 5A 04 0095       call vdu_set_screen_mode
0470AF AF          0096       xor a
0470B0 CD DA 5B 04 0097       call vdu_set_scaling
0470B4 01 20 00 00 0098   	ld bc,32
0470B8 11 10 00 00 0099   	ld de,16
0470BC CD 3B 5B 04 0100   	call vdu_set_gfx_origin
0470C0             0101   
0470C0             0102   	; call vdu_init ; grab a bunch of sysvars and stuff ; TODO: DEPRECATE
0470C0 CD 6A 5C 04 0103   	call cursor_off
0470C4             0104   
0470C4             0105   ; ; TESTING SOME MATHS
0470C4             0106   ; 	ld bc,0x00A000 ; 160
0470C4             0107   ; 	ld de,0x007800 ; 120
0470C4             0108   ; 	ld ix,0x011F80 ; 287.5
0470C4             0109   ; 	ld iy,0xFF9B2A ; -100.836
0470C4             0110   ; 	;  hl=0x00FF00 255
0470C4             0111   ; 	call distance168
0470C4             0112   ; 	call dumpRegistersHex
0470C4             0113   ; 	halt
0470C4             0114   ; ; END TESTING SOME MATHS
0470C4             0115   
0470C4             0116   ; ; print a hello message
0470C4             0117   ; 	ld hl,hello_world
0470C4             0118   ; 	call printString
0470C4             0119   
0470C4             0120   ; load the bitmaps
0470C4 CD 60 00 04 0121   	call bmp2_init
0470C8             0122   
0470C8             0123   ; initialize the first level
0470C8 AF          0124   	xor a
0470C9 32 35 6B 04 0125   	ld (cur_level),a
0470CD CD BD 6B 04 0126   	call init_level
0470D1             0127   
0470D1             0128   ; set gfx viewport to scrolling window
0470D1 01 00 00 00 0129   	ld bc,0
0470D5 11 00 00 00 0130   	ld de,0
0470D9 DD 21 FF 00 0131   	ld ix,255
       00          
0470DE FD 21 DF 00 0132   	ld iy,239-16
       00          
0470E3 CD E1 5A 04 0133   	call vdu_set_gfx_viewport
0470E7             0134   
0470E7             0135   ; initialize sprites
0470E7 CD 25 5F 04 0136   	call vdu_sprite_reset ; out of an abundance of caution (copilot: and paranoia)
0470EB AF          0137   	xor a
0470EC             0138   @sprite_loop:
0470EC F5          0139   	push af
0470ED CD F9 5D 04 0140   	call vdu_sprite_select
0470F1 21 00 01 00 0141   	ld hl,BUF_0TILE_EMPTY ; can be anything, but why not blank?
0470F5 CD 46 5F 04 0142   	call vdu_sprite_add_buff
0470F9 F1          0143   	pop af
0470FA 3C          0144   	inc a
0470FB FE 05       0145   	cp table_max_records+1 ; tack on sprites for player and laser
0470FD 20 ED       0146   	jr nz,@sprite_loop
0470FF 3C          0147   	inc a
047100 CD 2D 5E 04 0148   	call vdu_sprite_activate
047104             0149   
047104             0150   ; define player sprite
047104 3E 10       0151   	ld a,16
047106 CD F9 5D 04 0152   	call vdu_sprite_select
04710A CD 0C 5E 04 0153   	call vdu_sprite_clear_frames
04710E 21 34 01 00 0154   	ld hl,BUF_SHIP_0L
047112 01 03 00 00 0155   	ld bc,3 ; three bitmaps for player ship
047116             0156   @sprite_player_loop:
047116 C5          0157   	push bc
047117 E5          0158   	push hl
047118 CD 46 5F 04 0159   	call vdu_sprite_add_buff
04711C E1          0160   	pop hl
04711D 23          0161   	inc hl
04711E C1          0162   	pop bc
04711F 10 F5       0163   	djnz @sprite_player_loop
047121 CD 6F 5E 04 0164   	call vdu_sprite_show
047125             0165   
047125             0166   ; initialize player
047125 CD 5F 6A 04 0167   	call player_init
047129             0168   
047129             0169   ; spawn an enemy sprite
047129 06 04       0170   	ld b,table_max_records
04712B             0171   @spawn_enemy_loop:
04712B C5          0172   	push bc
04712C CD 12 6D 04 0173   	call enemy_init_from_landing_pad
047130 C1          0174   	pop bc
047131 10 F8       0175   	djnz @spawn_enemy_loop
047133             0176   
047133 C9          0177   	ret
047134             0178   
047134             0179   ; new_game:
047134             0180   ; ; ###### INITIALIZE GAME #######
047134             0181   ; ; clear the screen
047134             0182   ;     ld a,3
047134             0183   ;     out (81h),a
047134             0184   
047134             0185   ; ; reset the sprite table
047134             0186   ;     xor a
047134             0187   ;     ld (table_active_sprites),a
047134             0188   ;     ld hl,table_limit
047134             0189   ;     ld (table_base),hl
047134             0190   ;     ld (table_pointer),hl
047134             0191   
047134             0192   ; ; draw a starfield over the entire screen
047134             0193   ;     ld b,#50 ; first row of visible screen
047134             0194   ; new_game_draw_stars_loop:
047134             0195   ;     push bc
047134             0196   ;     call draw_stars
047134             0197   ;     pop bc
047134             0198   ;     ld a,#10
047134             0199   ;     add a,b
047134             0200   ;     ld b,a
047134             0201   ;     jr nz,new_game_draw_stars_loop
047134             0202   
047134             0203   ; ; ; print a welcome message
047134             0204   ; ;     ld de,msg_welcome
047134             0205   ; ;     ld hl,#581C
047134             0206   ; ;     ld c,218 ; a bright pastel purple d677e3
047134             0207   ; ;     call print_string
047134             0208   
047134             0209   ; ; push all that to frame buffer
047134             0210   ;     ld a,#01 ; send video to frame buffer
047134             0211   ;     out (81h),a
047134             0212   
047134             0213   ; ; reset score, lives, shields
047134             0214   ;     xor a
047134             0215   ;     ld hl,player_score
047134             0216   ;     ld (hl),a ; player_score 0
047134             0217   ;     inc hl
047134             0218   ;     ld (hl),a ; player_score 1
047134             0219   ;     inc hl
047134             0220   ;     ld (hl),a ; player_score 3
047134             0221   ;     inc hl
047134             0222   ;     ld a,16
047134             0223   ;     ld (hl),a ; player_shields
047134             0224   ;     inc hl
047134             0225   ;     ld (hl),a ; player_max_shields
047134             0226   ;     inc hl
047134             0227   ;     ld a,3
047134             0228   ;     ld (hl),a ; player_ships
047134             0229   ;     inc hl
047134             0230   
047134             0231   ; ; initialize first level
047134             0232   ;     ld a,1 ; levels are zero-based, so this will wrap around
047134             0233   ;     ld (cur_level),a
047134             0234   ;     ld a,3 ; set max enemy sprites to easy street
047134             0235   ;     ; ld a,64 ; DEBUG: BRING IT
047134             0236   ;     ld (max_enemy_sprites),a
047134             0237   ;     call dt_next_level
047134             0238   ;     call dt
047134             0239   
047134             0240   ; ; spawn our intrepid hero
047134             0241   ;     call player_init
047134             0242   
047134             0243   ; ; #### BEGIN GAME VARIABLES ####
047134             0244   speed_seeker: equ 0x000280 ; 2.5 pixels per frame
047134             0245   speed_player: equ 0x000300 ; 3 pixels per frame
047134             0246   
047134             0247   main:
047134             0248   ; move the background down one pixel
047134 3E 02       0249   	ld a,2 ; current gfx viewport
047136 2E 02       0250   	ld l,2 ; direction=down
047138 26 01       0251   	ld h,1 ; speed=1 px
04713A CD 43 5C 04 0252   	call vdu_scroll_down
04713E             0253   
04713E             0254   ; scroll tiles
04713E CD 42 6B 04 0255   	call tiles_plot
047142             0256   
047142             0257   ; get player input and update sprite position
047142 CD 9C 6A 04 0258   	call player_input
047146             0259   
047146             0260   ; move enemies
047146 CD 24 6C 04 0261   	call move_enemies
04714A             0262   
04714A             0263   ; wait for the next vsync
04714A CD 78 5C 04 0264   	call vdu_vblank
04714E             0265   
04714E             0266   ; poll keyboard
04714E 3E 08       0267       ld a, $08                           ; code to send to MOS
047150 5B CF       0268       rst.lil $08                         ; get IX pointer to System Variables
047152             0269   
047152 DD 7E 05    0270       ld a, (ix + $05)                    ; get ASCII code of key pressed
047155 FE 1B       0271       cp 27                               ; check if 27 (ascii code for ESC)
047157 CA 5F 71 04 0272       jp z, main_end                     ; if pressed, jump to exit
04715B             0273   
04715B C3 34 71 04 0274       jp main
04715F             0275   
04715F             0276   main_end:
04715F CD 5C 5C 04 0277       call cursor_on
047163 C9          0278   	ret
047164             0279   
047164             0280   
047164             0281   ; ; #### BEGIN GAME MAIN LOOP ####
047164             0282   ; main_loop:
047164             0283   ; ; ; debug: start execution counter
047164             0284   ; ;     ld a,1
047164             0285   ; ;     out (#e0),a ; start counting instructions
047164             0286   
047164             0287   ; ; refresh background from frame buffer
047164             0288   ;     ld a,#02
047164             0289   ;     out (81h),a
047164             0290   ;     call move_background ; now move it
047164             0291   ;     ld a,#01
047164             0292   ;     out (81h),a ; save it back to buffer
047164             0293   ; ; do all the things
047164             0294   ;     call move_enemies
047164             0295   ;     call player_move
047164             0296   ;     call laser_control
047164             0297   ;     call print_score
047164             0298   ;     call draw_shields
047164             0299   ;     call draw_lives
047164             0300   ; ; ; debug: stop execution counter and print results
047164             0301   ; ;     ld a,0
047164             0302   ; ;     out (#e0),a ; stop counting instructions
047164             0303   
047164             0304   ; ; ; debug: start execution counter
047164             0305   ; ;     ld a,1
047164             0306   ; ;     out (#e0),a ; start counting instructions
047164             0307   
047164             0308   ;     call vdu_vblank
047164             0309   ; ; ; debug: stop execution counter and print results
047164             0310   ; ;     ld a,0
047164             0311   ; ;     out (#e0),a ; stop counting instructions
047164             0312   
047164             0313   ;     jr main_loop
047164             0314   ; #### END GAME MAIN LOOP ####
047164             0315   
047164             0316   ; draws the player's shields level
047164             0317   ; draw_shields:
047164             0318   ; TODO: Agonize this routine
047164             0319   ; ; prep the loop to draw the bars
047164             0320   ;     ld a,(player_shields) ; snag shields
047164             0321   ;     and a
047164             0322   ;     ret z ; don't draw if zero shields
047164             0323   ; ; set loop counter and drawing position
047164             0324   ;     ld b,a ; loop counter
047164             0325   ;     ld hl,#5300+48+12
047164             0326   ; ; set color based on bars remaining
047164             0327   ;     ld c,103 ; bright green 28fe0a
047164             0328   ;     cp 9
047164             0329   ;     jp p,draw_shields_loop
047164             0330   ;     ld c,74 ; bright yellow eafe5b
047164             0331   ;     cp 3
047164             0332   ;     jp p,draw_shields_loop
047164             0333   ;     ld c,28 ; bright red fe0a0a
047164             0334   ; draw_shields_loop:
047164             0335   ;     push bc ; yup,outta
047164             0336   ;     push hl ; registers again
047164             0337   ;     ; ld a,#A8 ; ▀,168
047164             0338   ;     ld a,10 ; ▀,168 ; we renumber because we don't use the full charset
047164             0339   ;     ; call draw_char
047164             0340   ;     call draw_num ; we nuked draw_char for the time being
047164             0341   ;     pop hl
047164             0342   ;     ld a,8
047164             0343   ;     add a,l
047164             0344   ;     ld l,a
047164             0345   ;     pop bc
047164             0346   ;     djnz draw_shields_loop
047164             0347       ; ret
047164             0348   
047164             0349   ; prints the player's score
047164             0350   ; print_score:
047164             0351   ; TODO: Agonize this
047164             0352   ; ; draw score (we do it twice for a totally unecessary drop-shadow effect)
047164             0353   ;     ld c,42 ; dark orange b74400
047164             0354   ;     ld hl,#5200+1+8+6*6
047164             0355   ;     ld a,3 ; print 6 bdc digits
047164             0356   ;     ld de,player_score
047164             0357   ;     call print_num
047164             0358   
047164             0359   ;     ld c,58 ; golden yellow fec10a
047164             0360   ;     ld hl,#5100+8+6*6
047164             0361   ;     ld a,3 ; print 6 bdc digits
047164             0362   ;     ld de,player_score
047164             0363   ;     call print_num
047164             0364       ; ret
047164             0365   
047164             0366   ; draw_lives:
047164             0367   ;     ld hl,player_small ; make small yellow ship the active sprite
047164             0368   ;     ld (sprite_base_bufferId),hl
047164             0369   ;     ; ld a,#80 ; northern orientation
047164             0370   ;     ; ld (sprite_orientation),a
047164             0371   ;     ld hl,0 ; north
047164             0372   ;     ld (sprite_heading),hl
047164             0373   ;     xor a
047164             0374   ;     ld (sprite_animation),a
047164             0375   ;     ld a,#56 ; top of visible screen
047164             0376   ;     ld (sprite_y+1),a
047164             0377   ;     call vdu_bmp_select
047164             0378   ;     ld a,(player_ships)
047164             0379   ;     dec a ; we draw one fewer ships than lives
047164             0380   ;     ret z ; nothing to draw here, move along
047164             0381   ;     ld b,a ; loop counter
047164             0382   ;     ld a,256-16 ; initial x position
047164             0383   ; draw_lives_loop:
047164             0384   ;     ld (sprite_x+1),a
047164             0385   ;     push af
047164             0386   ;     push bc
047164             0387   ;     call vdu_bmp_draw
047164             0388   ;     pop bc
047164             0389   ;     pop af
047164             0390   ;     sub 10
047164             0391   ;     djnz draw_lives_loop
047164             0392   ;     ret
